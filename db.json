{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/avatar.jpeg","path":"img/avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/main.min.js","path":"js/main.min.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/search.min.js","path":"js/search.min.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"d0901d2a70d22610473e5b7e5717740c76320dd9","modified":1521807856665},{"_id":"themes/indigo/.editorconfig","hash":"9b0445427777519defe360ea38c61729d847b3d3","modified":1521264527130},{"_id":"themes/indigo/LICENSE","hash":"24944bf7920108f5a4790e6071c32e9102760c37","modified":1521264527130},{"_id":"themes/indigo/.DS_Store","hash":"ba26a66b64bae42ca909c9947a2cee835b3fd051","modified":1521269236045},{"_id":"themes/indigo/README.md","hash":"b188fb95a9c16eb188eeffa6caa0895a14676338","modified":1521264527130},{"_id":"themes/indigo/_config.yml","hash":"f9a64b77c2f6cca2bba76eb2fa728b8c556a99bb","modified":1521270290403},{"_id":"themes/indigo/package.json","hash":"c795e3100ae3655bfa8b39adcca7333a7925b47f","modified":1521264527145},{"_id":"source/_posts/Android消息机制-Handler.md","hash":"db012f56964eb255471a417a50479a049b755fa6","modified":1521808238360},{"_id":"source/_posts/hello-world.md","hash":"1f80c362aacf4e6dc46d89b839cfda7928289fd8","modified":1521272668868},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1521808144194},{"_id":"source/categories/index.md","hash":"ded90db7ec7f50da93f579aab0d52ae91ff4b5d2","modified":1521264671949},{"_id":"themes/indigo/languages/en.yml","hash":"1957d2bfc3a4cef299f4f169b431e9b1128ba162","modified":1521264527131},{"_id":"themes/indigo/languages/ja.yml","hash":"74fd480874bf5e773ba7f9d2a94697cda979091f","modified":1521264527131},{"_id":"themes/indigo/languages/zh-CN.yml","hash":"7dc6ae434dde390b6768d244132e23cc78c33817","modified":1521264527132},{"_id":"themes/indigo/languages/nl-NL","hash":"9085c04491f93066f2369911cc2175b59ae596ad","modified":1521264527131},{"_id":"themes/indigo/languages/zh-TW.yml","hash":"6a9e820be66eb12ae746f2527e0dc1adf927c685","modified":1521264527132},{"_id":"themes/indigo/layout/archive.ejs","hash":"d039719e21f6a6fa2925b00aaa623a180a78c818","modified":1521264527143},{"_id":"themes/indigo/layout/categories.ejs","hash":"41783d2069d5080566a99e6312aa2113105f8b41","modified":1521264527143},{"_id":"themes/indigo/layout/layout.ejs","hash":"d52f43fa9572d70cae834e4887c8897b43744805","modified":1521264527144},{"_id":"themes/indigo/layout/page.ejs","hash":"afb98face24d39a21ebbbde6592a9afc98572aa4","modified":1521264527144},{"_id":"themes/indigo/layout/index.ejs","hash":"39477807b98b2d2df78f3b82498a11e90be8222c","modified":1521264527144},{"_id":"themes/indigo/layout/category.ejs","hash":"7ea26a8a935886963eda82f41c7bd5270cf780d9","modified":1521264527143},{"_id":"themes/indigo/scripts/plugins.js","hash":"e439d717513616bedeed37ba9b05117470809b21","modified":1521264527146},{"_id":"themes/indigo/layout/tag.ejs","hash":"36786a3de7f6cad58209603f7d84ba23addea174","modified":1521264527145},{"_id":"themes/indigo/layout/tags.ejs","hash":"20466446c41409d14a3d42ccaec24a65a045efef","modified":1521264527145},{"_id":"themes/indigo/layout/post.ejs","hash":"afbf8532dc8d148ca4dff2ca127a3382907cf2f5","modified":1521264527144},{"_id":"themes/indigo/source/.DS_Store","hash":"3695ffa4c31aedd2b87700a4c72612e4110a08f7","modified":1521269211116},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"9ac30b9439fab69973cf4722dbf2945a18fd3804","modified":1521264527132},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"55cd81ef9183426d6d99fd91550fce0a9cc92aa0","modified":1521264527132},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"e1a71a30a1c7a664ddf3ba3e7eb3a5b90bc4b33c","modified":1521264527133},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"6156bf20791e46fc1c5872113276c1c1f5c13773","modified":1521264527133},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"b197b87b120b09b68aa3d79954ed039816a88664","modified":1521264527133},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1521264527134},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"ec7b3ec79bbbead9c7e43e2e6c6b5c8bef509410","modified":1521264527134},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"d39afaad6b0dd2a3ae27e6db3e9a6cd6014622fa","modified":1521264527134},{"_id":"themes/indigo/layout/_partial/paginator.ejs","hash":"dc27242927890f130a64400596b9b7ad5fca8972","modified":1521264527134},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"a87d9b0485b3bf4cdfdad890e5974c43dbaa8240","modified":1521264527137},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"439d6315a1b16e32b77a68c3f0cb2961d581086a","modified":1521264527142},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"c2091c621b5480ef1e69d72027028cec8e929892","modified":1521264527142},{"_id":"themes/indigo/layout/_partial/tags-bar.ejs","hash":"19eff4876d31080a427644f7a43fe172d0c008c6","modified":1521264527142},{"_id":"themes/indigo/source/css/style.less","hash":"f22d4146e0bdb4485d33f20080c67ba05724afea","modified":1521264527188},{"_id":"themes/indigo/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1521269201806},{"_id":"themes/indigo/source/img/avatar.jpeg","hash":"abe5306efb6e8039f009cec213a3dcad2691a191","modified":1521269147966},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1521264527189},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1521264527190},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1521264527190},{"_id":"themes/indigo/source/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1521264527191},{"_id":"themes/indigo/source/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1521264527192},{"_id":"themes/indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1521264527192},{"_id":"themes/indigo/source/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1521264527191},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1521264527189},{"_id":"themes/indigo/layout/_partial/plugins/baidu.ejs","hash":"e44d526029f122e9c2c74f3a647c35002c818cbe","modified":1521264527135},{"_id":"themes/indigo/layout/_partial/plugins/disqus.ejs","hash":"4a0c01e4195f685f9825fcd016d01249dbdd52ca","modified":1521264527135},{"_id":"themes/indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"23c101d45911eb0846533aaa2d409c43aa5e899a","modified":1521264527135},{"_id":"themes/indigo/layout/_partial/plugins/gitment.ejs","hash":"5723d507eca4390e8e5d18c0770e7953b8c22f5a","modified":1521264527135},{"_id":"themes/indigo/layout/_partial/plugins/mathjax.ejs","hash":"ea603a057196de53bd6afab1fddb93d11f27eb81","modified":1521264527136},{"_id":"themes/indigo/layout/_partial/plugins/google-analytics.ejs","hash":"a947f4076b54b48d4df5baf2d5b3c39b632c7576","modified":1521264527136},{"_id":"themes/indigo/layout/_partial/plugins/page-visit.ejs","hash":"2decb77bf3c1a064ea6ce1d4e78892c434d9c884","modified":1521264527136},{"_id":"themes/indigo/layout/_partial/plugins/site-visit.ejs","hash":"8fbd0910828f1ab6eba728bdecc9811d623baae2","modified":1521264527136},{"_id":"themes/indigo/layout/_partial/plugins/tajs.ejs","hash":"97b48fe10be1c71d4ff25ccec3bd92d97466c9c5","modified":1521264527136},{"_id":"themes/indigo/layout/_partial/plugins/uyan.ejs","hash":"e370bd04ea5cf1c83e0c20516aff7ba3ca8b2d0b","modified":1521264527137},{"_id":"themes/indigo/layout/_partial/plugins/valine.ejs","hash":"a976ca36bd09aeb2902bf94fcc7a59975ea25148","modified":1521264527137},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c7476165721a3a5e34d00d8c5c07e1e5474cd800","modified":1521264527138},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"f2c6a55a88ce694b44c46c8322293172afc00255","modified":1521264527138},{"_id":"themes/indigo/layout/_partial/post/copyright.ejs","hash":"5305ed30ee35cf50f87656737d0ffe85f5bfc16b","modified":1521264527138},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"b0c680ce5b8aaf461a6731b1ff1287bd140c168a","modified":1521264527139},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"ea85b46e12d3b9c3612eef7aa76289a663fbc096","modified":1521264527138},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"11e7d504f7c7a3c4c052da13cfa8ea4862c9383e","modified":1521264527139},{"_id":"themes/indigo/layout/_partial/post/reward-btn.ejs","hash":"41c242fe3159dc68cec8dd00ab6d2663f5a51179","modified":1521264527139},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"23719e09689b3afbb19214c6603eb02f896cb9ba","modified":1521264527139},{"_id":"themes/indigo/layout/_partial/post/share-fab.ejs","hash":"93482ad7d1e01b966f5ee1c5d12b88564e02b349","modified":1521264527140},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"8df0d7bf6f8e106cdbdac2dd10a97367aa0695f8","modified":1521264527140},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"062d56cb88ae2be3a6616b911d4ebeffcbfe3cff","modified":1521264527141},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"b3dc38652c4a018a37418136478dcd522fc49f79","modified":1521264527140},{"_id":"themes/indigo/layout/_partial/post/toc.ejs","hash":"ad287a70724eb7cd8cd2a03a45b68032ee99973d","modified":1521264527141},{"_id":"themes/indigo/layout/_partial/post/updated.ejs","hash":"5caa71745aa340ce57938a930f3b898ee7518d74","modified":1521264527141},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"7d2a6886265386c640e94ffca3f042675f701a35","modified":1521264527146},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"d476cd3537bcd8a02d055cc223f5c805b8638cc2","modified":1521264527147},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1521264527148},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"58492b7cdb45fe09b026b2f34e8ae69c2ddb8228","modified":1521264527149},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"90f0948a9182c14b1dac1e9dbed3c883543266f9","modified":1521264527148},{"_id":"themes/indigo/source/css/_partial/lightbox.less","hash":"9b961eb1d70e7658f42cf2ca895fa5e35a6b6541","modified":1521264527149},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"f9d06a1e24fb4857fd18d7a0bfbb3a0ab2d1c742","modified":1521264527150},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"1c041bf91106808e5480c60d9ece45431bb503b3","modified":1521264527150},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"4390ed22abad59c8b28ed1a479a52f15b5f9cf4a","modified":1521264527149},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"4857f90bb57fc22ca3f942d8934d86d5e9e82c1e","modified":1521264527151},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1521264527151},{"_id":"themes/indigo/source/css/_partial/page.less","hash":"e92ccb53e6ac73a51498c6a9672db9d0d2bc7f1a","modified":1521264527150},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"1d6641ae7568a0153d24beba9fd9704d2b155f6c","modified":1521264527151},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"27d80bcc96a53dd1e7eaa9a7d746e4b212357302","modified":1521264527152},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"959f4373fda6e45f6a4041a995ed3ea8a05a5170","modified":1521264527152},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"082896b966ed25b39c74e7b007b4f54c235685a4","modified":1521264527152},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"77bfd0b373b0469eb0176167fb076ccda4edf2a7","modified":1521264527153},{"_id":"themes/indigo/source/css/_plugin/valine.less","hash":"ddbb7647d83f732f9b0d5d817d40a748006949cc","modified":1521264527153},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"ca30b732d2efbb0cd55a272ecdabc97f895aee78","modified":1521264527148},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1521264527171},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1521264527173},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1521264527174},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1521264527173},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1521264527176},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1521264527177},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1521264527177},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1521264527180},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1521264527181},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1521264527180},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1521264527183},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1521264527184},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1521264527184},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1521264527187},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1521264527187},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1521264527170},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1521264527172},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1521264527175},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1521264527183},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1521264527179},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1521264527186},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1521264527169},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1521264527168},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1521264527159},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1521264527157},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1521264527165},{"_id":"public/atom.xml","hash":"bd0782fb40b9c48a7e9b2358e707868eaef233a5","modified":1521808273292},{"_id":"public/content.json","hash":"3ba87dafd8051a4d479e2499e3b0701228b302a9","modified":1521808273523},{"_id":"public/categories/index.html","hash":"b4f3977457eab02fd036a0f10723c7b33d318b19","modified":1521808273532},{"_id":"public/2018/03/17/hello-world/index.html","hash":"c228c186e607352f1e3886dac5348edcb2a884a2","modified":1521808273532},{"_id":"public/archives/index.html","hash":"863790d538393306db962d6ee5bd442ffe75ea1f","modified":1521808273532},{"_id":"public/archives/2018/index.html","hash":"85af559e3a3876d0635e5f1494cfbd17df8b7f3e","modified":1521808273532},{"_id":"public/archives/2018/03/index.html","hash":"6d3c3fa78ac0ea4735f3da2caebe960bf2ae7369","modified":1521808273532},{"_id":"public/index.html","hash":"8cd61450b11b00eef284e1f699a63816e2d7a6b9","modified":1521808273532},{"_id":"public/2018/03/23/Android消息机制-Handler/index.html","hash":"bc0f52129f21181511639028f7195d331a76ec24","modified":1521808273532},{"_id":"public/img/avatar.jpeg","hash":"abe5306efb6e8039f009cec213a3dcad2691a191","modified":1521808273561},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1521808273561},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1521808273562},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1521808273562},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1521808273562},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1521808273562},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1521808273563},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1521808273563},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1521808273564},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1521808273564},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1521808273564},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1521808273564},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1521808273564},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1521808273564},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1521808273564},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1521808273565},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1521808273565},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1521808273565},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1521808273565},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1521808273565},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1521808273637},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1521808273639},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1521808273650},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1521808273651},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1521808273651},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1521808273653},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1521808273654},{"_id":"public/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1521808273662},{"_id":"public/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1521808273662},{"_id":"public/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1521808273663},{"_id":"public/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1521808273663},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1521808273663},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1521808273663},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1521808273663},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1521808273683},{"_id":"public/css/style.css","hash":"27f88e278b738328b5acd28e88b5cb20daa490e6","modified":1521808274086}],"Category":[],"Data":[],"Page":[{"title":"categories","date":"2018-03-17T05:30:37.000Z","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-03-17 13:30:37\nlayout: categories\ncomments: false\n---\n","updated":"2018-03-17T05:31:11.949Z","path":"categories/index.html","_id":"cjf3xcq930002fa9h0vwgit0k","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"## 面朝大海，春暖花开\n\n从明天起，做一个幸福的人\n\n喂马、劈柴、周游世界\n\n从明天起，关心粮食和蔬菜\n\n我有一所房子，面朝大海，春暖花开\n\n\n\n从明天起，和每一个亲人通信\n\n告诉他们我的幸福\n\n那幸福的闪电告诉我的\n\n我将告诉每一个人\n\n\n\n给每一条河每一座山取一个温暖的名字\n\n陌生人，我也为你祝福\n\n愿你有一个灿烂的前程\n\n愿你有情人总成眷属\n\n愿你在尘世获得幸福\n\n我只愿面朝大海，春暖花开\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\n## 面朝大海，春暖花开\n\n从明天起，做一个幸福的人\n\n喂马、劈柴、周游世界\n\n从明天起，关心粮食和蔬菜\n\n我有一所房子，面朝大海，春暖花开\n\n\n\n从明天起，和每一个亲人通信\n\n告诉他们我的幸福\n\n那幸福的闪电告诉我的\n\n我将告诉每一个人\n\n\n\n给每一条河每一座山取一个温暖的名字\n\n陌生人，我也为你祝福\n\n愿你有一个灿烂的前程\n\n愿你有情人总成眷属\n\n愿你在尘世获得幸福\n\n我只愿面朝大海，春暖花开\n","slug":"hello-world","published":1,"date":"2018-03-17T05:24:16.197Z","updated":"2018-03-17T07:44:28.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf3xcq8e0000fa9h62nf6lrg","content":"<h2 id=\"面朝大海，春暖花开\"><a href=\"#面朝大海，春暖花开\" class=\"headerlink\" title=\"面朝大海，春暖花开\"></a>面朝大海，春暖花开</h2><p>从明天起，做一个幸福的人</p>\n<p>喂马、劈柴、周游世界</p>\n<p>从明天起，关心粮食和蔬菜</p>\n<p>我有一所房子，面朝大海，春暖花开</p>\n<p>从明天起，和每一个亲人通信</p>\n<p>告诉他们我的幸福</p>\n<p>那幸福的闪电告诉我的</p>\n<p>我将告诉每一个人</p>\n<p>给每一条河每一座山取一个温暖的名字</p>\n<p>陌生人，我也为你祝福</p>\n<p>愿你有一个灿烂的前程</p>\n<p>愿你有情人总成眷属</p>\n<p>愿你在尘世获得幸福</p>\n<p>我只愿面朝大海，春暖花开</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"面朝大海，春暖花开\"><a href=\"#面朝大海，春暖花开\" class=\"headerlink\" title=\"面朝大海，春暖花开\"></a>面朝大海，春暖花开</h2><p>从明天起，做一个幸福的人</p>\n<p>喂马、劈柴、周游世界</p>\n<p>从明天起，关心粮食和蔬菜</p>\n<p>我有一所房子，面朝大海，春暖花开</p>\n<p>从明天起，和每一个亲人通信</p>\n<p>告诉他们我的幸福</p>\n<p>那幸福的闪电告诉我的</p>\n<p>我将告诉每一个人</p>\n<p>给每一条河每一座山取一个温暖的名字</p>\n<p>陌生人，我也为你祝福</p>\n<p>愿你有一个灿烂的前程</p>\n<p>愿你有情人总成眷属</p>\n<p>愿你在尘世获得幸福</p>\n<p>我只愿面朝大海，春暖花开</p>\n"},{"title":"Android消息机制-Handler","date":"2018-03-23T12:29:21.000Z","_content":"\n### 参考\n\n[Android消息机制1-Handler(Java层)](http://gityuan.com/2015/12/26/handler-message-framework/)\n\n[Android消息机制2-Handler(Native层)](http://gityuan.com/2015/12/27/handler-message-native/)\n\n[Android应用程序消息处理机制（Looper、Handler）分析](http://blog.csdn.net/luoshengyang/article/details/6817933)\n\n[管道(Unix)](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix))\n\n[Epoll](https://zh.wikipedia.org/zh-hans/Epoll)\n\n[文件描述符](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)\n\nHandler 机制主要由四个部分组成：\n\n* Looper\n* MessageQueue\n* Message\n* Handler\n\n### 典型用法\n\n``` java\nclass LooperThread extends Thread {\n    public Handler mHandler;\n    \n    public void run() {\n        Looper.prepare();\n        \n        mHandler = new Handler() {\n            public void handleMessage(Message msg) {\n                // process incoming messages here\n            }\n        };\n        \n        Looper.loop();\n    }\n}\n```\n\n### Looper\n\n不断循环执行 `Looper.loop`，按分发机制将消息分发给目标处理者\n\n``` java\nprivate static void prepare(boolean quitAllowed) {\n    if(sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    // 构建 Looper 存储到 ThreadLocal\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n`sThreadLocal` 是一个 ThreadLocal 类型的静态变量\n\n> ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域\n\n``` java\nprivate Looper(boolean quitAllowed) {\n    // Looper 中创建 MessageQueue\n    mQueue = new MessageQueue(quitAllowed);\n    mThread = Thread.currentThread();\n}\n```\n\n``` java\npublic static void loop() {                                                                     \n    final Looper me = myLooper();                                                               \n    if (me == null) {                                                                           \n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }                                                                                           \n    final MessageQueue queue = me.mQueue;                                                       \n                                                                                                \n    // Make sure the identity of this thread is that of the local process,                      \n    // and keep track of what that identity token actually is.                                  \n    Binder.clearCallingIdentity();                                                              \n    final long ident = Binder.clearCallingIdentity();                                           \n                                                                                                \n    for (;;) {                                                                                  \n        Message msg = queue.next(); // 获取下一条 Message，可能会阻塞                                              \n        if (msg == null) {                                                                      \n            // No message indicates that the message queue is quitting.                         \n            return;                                                                             \n        }                                                                                       \n                                                                                                \n        // This must be in a local variable, in case a UI event sets the logger                 \n        final Printer logging = me.mLogging;                                                    \n        if (logging != null) {                                                                  \n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +                        \n                    msg.callback + \": \" + msg.what);                                            \n        }                                                                                       \n                                                                                                \n        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       \n                                                                                                \n        //省略\n        \n        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();     \n        final long end;                                                                         \n        try {\n            // 分发 Message\n            msg.target.dispatchMessage(msg);                                                    \n            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();              \n        } finally {                                                                             \n            if (traceTag != 0) {                                                                \n                Trace.traceEnd(traceTag);                                                       \n            }                                                                                   \n        }                                                                                       \n        if (slowDispatchThresholdMs > 0) {                                                      \n            final long time = end - start;                                                      \n            if (time > slowDispatchThresholdMs) {                                               \n                Slog.w(TAG, \"Dispatch took \" + time + \"ms on \"                                  \n                        + Thread.currentThread().getName() + \", h=\" +                           \n                        msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what);               \n            }                                                                                   \n        }                                                                                       \n                                                                                                \n        if (logging != null) {                                                                  \n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);            \n        }                                                                                       \n                                                                                                \n        // Make sure that during the course of dispatching the                                  \n        // identity of the thread wasn't corrupted.                                             \n        final long newIdent = Binder.clearCallingIdentity();                                    \n        if (ident != newIdent) {                                                                \n            Log.wtf(TAG, \"Thread identity changed from 0x\"                                      \n                    + Long.toHexString(ident) + \" to 0x\"                                        \n                    + Long.toHexString(newIdent) + \" while dispatching to \"                     \n                    + msg.target.getClass().getName() + \" \"                                     \n                    + msg.callback + \" what=\" + msg.what);                                      \n        }                                                                                       \n         \n        // 释放 Message\n        msg.recycleUnchecked();                                                                 \n    }                                                                                           \n}                                                                                               \n```\n\n``` java\n// Looper.quit 最终调用的都是 MessageQueue.quit\npublic void quit() {\n    mQueue.quit(false); // 移除消息\n}\n\npublic void quitSafely() {\n    mQueue.quit(true); // 安全移除消息\n}\n```\n\nMessageQueue 在构造方法中，会调用 native 方法 `nativeInit` 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper\n\n``` cpp\n// frameworks/base/libs\nLooper::Looper(bool allowNonCallbacks) :  \n    mAllowNonCallbacks(allowNonCallbacks),  \n    mResponseIndex(0) {\n    // 管道机制\n    int wakeFds[2];  \n    int result = pipe(wakeFds);  \n    ......  \n  \n    mWakeReadPipeFd = wakeFds[0];  \n    mWakeWritePipeFd = wakeFds[1];  \n  \t\n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    // 分配新的 epoll 实例同时注册唤醒管道\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  \n    ......  \n  \n    struct epoll_event eventItem;  \n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    // 观察 EPOLLIN 事件\n    eventItem.events = EPOLLIN;  \n    eventItem.data.fd = mWakeReadPipeFd;  \n    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem);  \n    ......  \n#else  \n    ......  \n#endif  \n  \n    ......  \n}  \n```\n\n> 管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。\n>\n> epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。\n\npipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。\n\n以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。\n\n### Handler\n\n``` java\npublic Handler(Callback callback, boolean async) {                                                  \n    if (FIND_POTENTIAL_LEAKS) {                                                                     \n        final Class<? extends Handler> klass = getClass();                                          \n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&          \n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            // 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +      \n                klass.getCanonicalName());                                                          \n        }                                                                                           \n    }                                                                                               \n    // 默认使用当前线程的 Looper                                                                                                \n    mLooper = Looper.myLooper();                                                                    \n    if (mLooper == null) {                                                                          \n        throw new RuntimeException(                                                                 \n            \"Can't create handler inside thread that has not called Looper.prepare()\");             \n    }                                                                                               \n    mQueue = mLooper.mQueue;                                                                        \n    mCallback = callback;\n    // 是否为异步处理\n    mAsynchronous = async;                                                                          \n}                                                                                                   \n```\n\n在 `Looper.loop` 中，当存在 Message 需要处理时，会调用 `dispatchMessage` 来进行分发：\n\n``` java\npublic void dispatchMessage(Message msg) {      \n    if (msg.callback != null) {\n        // 先调用 callback\n        handleCallback(msg);                    \n    } else {                                    \n        if (mCallback != null) {\n            // 接着检查通过构造方法传进来的 Callback\n            if (mCallback.handleMessage(msg)) { \n                return;                         \n            }                                   \n        }\n        // 最后调用 handleMessage\n        handleMessage(msg);                     \n    }                                           \n}                                               \n```\n\n通过 Handler 发送消息：\n\n![发送消息调用链](http://gityuan.com/images/handler/java_sendmessage.png)\n\n最终所有的方法都会调用到 `MessageQueue.enqueueMessage`\n\n### MessageQueue\n\n> 消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理\n\n``` java\nMessageQueue(boolean quitAllowed) { \n    mQuitAllowed = quitAllowed;\n    // used by native code\n    mPtr = nativeInit();            \n}                                   \n```\n\nMessageQueue 的初始化工作主要由 native 方法来执行\n\n``` cpp\n//frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {\n    // 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();  \n    if (! nativeMessageQueue) {  \n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");  \n        return;  \n    }  \n  \t\n    // 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量\n    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  \n}  \n```\n\n`nativeInit` 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 `mPtr`，关联了 NativeMessageQueue 和 MessageQueue\n\n``` java\nMessage next() {                                                                              \n    // messsage loop has already quit                                                              \n    final long ptr = mPtr;                                                                    \n    if (ptr == 0) {                                                                           \n        return null;                                                                          \n    }                                                                                         \n                                                                                              \n    int pendingIdleHandlerCount = -1; // -1 only during first iteration                       \n    int nextPollTimeoutMillis = 0;                                                            \n    for (;;) {                                                                                \n        if (nextPollTimeoutMillis != 0) {                                                     \n            Binder.flushPendingCommands();                                                    \n        }                                                                                     \n        // 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回\n        // ptr 是在 JNI 层创建的 NativeMessageQueue\n        nativePollOnce(ptr, nextPollTimeoutMillis);                                           \n        \n        // 当前 nativePollOnce 返回后，查看消息队列中是否存在消息\n        synchronized (this) {                                                                 \n            // 尝试检索下一条消息，如果找到则返回                            \n            final long now = SystemClock.uptimeMillis();                                      \n            Message prevMsg = null;                                                           \n            Message msg = mMessages;                                                          \n            if (msg != null && msg.target == null) {                                          \n                // 找到下一条异步消息或者没有消息了，则退出循环\n                do {                                                                          \n                    prevMsg = msg;                                                            \n                    msg = msg.next;                                                           \n                } while (msg != null && !msg.isAsynchronous());                               \n            }                                                                                 \n            if (msg != null) {                                                                \n                if (now < msg.when) {                                                         \n                    // 下一个消息还没准备好，重新设置唤醒超时时间\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {                                                                      \n                    // 获取一条消息                                                         \n                    mBlocked = false;\n                    if (prevMsg != null) {                                                    \n                        prevMsg.next = msg.next;                                              \n                    } else {                                                                  \n                        mMessages = msg.next;                                                 \n                    }                                                                         \n                    msg.next = null;                                                          \n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    // 标记当前消息已使用\n                    msg.markInUse();                                                          \n                    return msg;                                                               \n                }                                                                             \n            } else {                                                                          \n                // 当前还没有消息，设置为 -1，无限等待中                                                     \n                nextPollTimeoutMillis = -1;                                                   \n            }                                                                                 \n                                                                                              \n            // Process the quit message now that all pending messages have been handled.      \n            if (mQuitting) {                                                                  \n                dispose();                                                                    \n                return null;                                                                  \n            }                                                                                 \n                                                                                              \n            // queue is empty or if the first message\n            // get pending idle handler count\n            if (pendingIdleHandlerCount < 0                                                   \n                    && (mMessages == null || now < mMessages.when)) {                         \n                pendingIdleHandlerCount = mIdleHandlers.size();                               \n            }                                                                                 \n            if (pendingIdleHandlerCount <= 0) {                                               \n                // 没有 idle handlers 需要运行，循环继续等待                        \n                mBlocked = true;                                                              \n                continue;                                                                     \n            }                                                                                 \n                                                                                              \n            if (mPendingIdleHandlers == null) {                                               \n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; \n            }                                                                                 \n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               \n        }                                                                                     \n                                                                                              \n        // Run the idle handlers.                                                        \n        // We only ever reach this code block during the first iteration                    \n        for (int i = 0; i < pendingIdleHandlerCount; i++) {                                   \n            final IdleHandler idler = mPendingIdleHandlers[i];                                \n            mPendingIdleHandlers[i] = null;           \n                                                                                              \n            boolean keep = false;                                                             \n            try {                                                                             \n                keep = idler.queueIdle();                                                     \n            } catch (Throwable t) {                                                           \n                Log.wtf(TAG, \"IdleHandler threw exception\", t);                               \n            }                                                                                 \n                                                                                              \n            if (!keep) {                                                                      \n                synchronized (this) {\n                    mIdleHandlers.remove(idler);                                              \n                }                                                                             \n            }                                                                                 \n        }                                                                                     \n                                                                                              \n        // Reset the idle handler count to 0 so we do not run them again.                     \n        pendingIdleHandlerCount = 0;                                                          \n                                                                                              \n        //不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                \n        nextPollTimeoutMillis = 0;                                                            \n    }                                                                                         \n}                                                                                             \n```\n\n在 `next` 方法中，`nativePollOnce` 是阻塞操作，其中 `nextPollTimeoutMillis` 代表下一个消息到来之前，还需要等待的时长；`nextPollTimeoutMillis == -1` 表示当前没有更多消息。`nativePollOnce` 调用结束后，从 `mMessages` 中提取一个消息\n\n当处于空闲时，执行 `IdleHandler` 中的回调方法。\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,  \n        jint ptr, jint timeoutMillis) {\n    // 通过前面设置的 mPrt 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr); \n    // 调用 NativeMessageQueue.pollOnce 进行轮询\n    nativeMessageQueue->pollOnce(timeoutMillis);  \n}  \n```\n\n``` cpp\nvoid NativeMessageQueue::pollOnce(int timeoutMillis) {\n    // 将调用转发给了 JNI 层的 Looper\n    mLooper->pollOnce(timeoutMillis);  \n} \n```\n\n`pollOnce` 会调用 `pollnner` 来进一步操作，如果 `pollnner` 返回值不等于 0，则返回\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nint Looper::pollInner(int timeoutMillis) {  \n    ......  \n  \n    int result = ALOOPER_POLL_WAKE;  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis\n    // 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件\n    // 如果检查成功或者超时，则结束等待\n    // 处于 Idle 状态\n    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    bool acquiredLock = false;  \n#else  \n    ......  \n#endif  \n    \n    // eventCount < 0 可能出错了\n    if (eventCount < 0) {  \n        if (errno == EINTR) {  \n            goto Done;  \n        }  \n  \n        LOGW(\"Poll failed with an unexpected error, errno=%d\", errno);  \n        result = ALOOPER_POLL_ERROR;  \n        goto Done;  \n    }  \n  \t\n    // eventCount == 0 超时\n    if (eventCount == 0) {  \n        ......  \n        result = ALOOPER_POLL_TIMEOUT;  \n        goto Done;  \n    }  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL\n    // eventCount > 0 存在事件\n    for (int i = 0; i < eventCount; i++) {  \n        int fd = eventItems[i].data.fd;  \n        uint32_t epollEvents = eventItems[i].events;  \n        if (fd == mWakeReadPipeFd) {  \n            if (epollEvents & EPOLLIN) {\n                // Looper 中使用 epoll 监听的 EPOLLIN 事件\n                awoken();  \n            } else {  \n                LOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents);  \n            }  \n        } else {  \n            ......  \n        }  \n    }  \n    if (acquiredLock) {  \n        mLock.unlock();  \n    }  \nDone: ;  \n#else  \n    ......  \n#endif  \n  \n    ......  \n  \n    return result;  \n} \n```\n\n``` cpp\nvoid Looper::awoken() {  \n    ......  \n  \n    char buffer[16];  \n    ssize_t nRead;  \n    do {  \n        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));  \n    } while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));  \n}  \n```\n\n总结上面的代码，Looper 通过 `loop` 调用 MessageQueue 的 `next`，`next` 中又会调用到 native 方法 `nativePollOnce`，在这个方法中，会调用到 NativeMessageQueue 的 `pollInner`，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 `awoken`，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。\n\n``` java\nboolean enqueueMessage(Message msg, long when) {                                         \n    if (msg.target == null) {                                                            \n        throw new IllegalArgumentException(\"Message must have a target.\");               \n    }                                                                                    \n    if (msg.isInUse()) {                                                                 \n        throw new IllegalStateException(msg + \" This message is already in use.\");       \n    }                                                                                    \n                                                                                         \n    synchronized (this) {                                                                \n        if (mQuitting) {                                                                 \n            IllegalStateException e = new IllegalStateException(                         \n                    msg.target + \" sending message to a Handler on a dead thread\");      \n            Log.w(TAG, e.getMessage(), e);                                               \n            msg.recycle();                                                               \n            return false;                                                                \n        }                                                                                \n                                                                                         \n        msg.markInUse();                                                                 \n        msg.when = when;                                                                 \n        Message p = mMessages;                                                           \n        boolean needWake;                                                                \n        if (p == null || when == 0 || when < p.when) {                                   \n            // 不存在头部消息或立即执行或执行时机快于头部消息\n            // 将处理的消息作为新的头部消息\n            msg.next = p;                                                                \n            mMessages = msg;                                                             \n            needWake = mBlocked;                                                         \n        } else {                                                                         \n            // 将处理的消息插入到队列的尾部\n            // 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();             \n            Message prev;                                                                \n            for (;;) {                                                                   \n                prev = p;                                                                \n                p = p.next;                                                              \n                if (p == null || when < p.when) {                                        \n                    break;                                                               \n                }                                                                        \n                if (needWake && p.isAsynchronous()) {                                    \n                    needWake = false;                                                    \n                }                                                                        \n            }                                                                            \n            msg.next = p; // invariant: p == prev.next                                   \n            prev.next = msg;                                                             \n        }                                                                                \n                                                                                         \n        // We can assume mPtr != 0 because mQuitting is false.                           \n        if (needWake) {                                                                  \n            nativeWake(mPtr);                                                            \n        }                                                                                \n    }                                                                                    \n    return true;                                                                         \n}                                                                                        \n```\n\n`MessageQueue` 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。\n\n如果当前线程处于空闲等待状态，那么还需要调用 `nativeWake` 来唤醒：\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj, jint ptr) {\n    // ptr 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);  \n    return nativeMessageQueue->wake();  \n}  \n```\n\n这里将唤醒请求转发到 Looper `wake`：\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nvoid Looper::wake() {  \n    ......  \n  \n    ssize_t nWrite;  \n    do {\n        // 先管道中写入 \"W\n        nWrite = write(mWakeWritePipeFd, \"W\", 1);  \n    } while (nWrite == -1 && errno == EINTR);  \n  \n    .......  \n}  \n```\n\n往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 `polllnner` 中调用 `epoll_wait` 进入\n\n``` java\nvoid removeMessages(Handler h, int what, Object object) {     \n    if (h == null) {                                          \n        return;                                               \n    }                                                         \n                                                              \n    synchronized (this) {                                     \n        Message p = mMessages;                                \n                                                              \n        // 从队列头部开始，移除连续的所有符合条件的消息                     \n        while (p != null && p.target == h && p.what == what   \n               && (object == null || p.obj == object)) {      \n            Message n = p.next;                               \n            mMessages = n;\n            // 找到对应的消息，释放它\n            p.recycleUnchecked();                             \n            p = n;                                            \n        }                                                     \n                                                              \n        //  从新的队列头部开始，移除全部符合条件的消息                  \n        while (p != null) {                                   \n            Message n = p.next;                               \n            if (n != null) {                                  \n                if (n.target == h && n.what == what           \n                    && (object == null || n.obj == object)) { \n                    Message nn = n.next;                      \n                    n.recycleUnchecked();                     \n                    p.next = nn;                              \n                    continue;                                 \n                }                                             \n            }                                                 \n            p = n;                                            \n        }                                                     \n    }                                                         \n}                                                             \n```\n\n`postSyncBarrier` 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 `removeSyncBarrier`\n\n当 MessageQueue 退出时，需要 `dispose`：\n\n``` java\n// Disposes of the underlying message queue.                 \n// Must only be called on the looper thread or the finalizer.\nprivate void dispose() {                                     \n    if (mPtr != 0) {\n        // native 方法\n        nativeDestroy(mPtr);\n        // mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量\n        mPtr = 0;                                            \n    }                                                        \n}                                                            \n```\n\n`nativeDestroy` 最终会调用 RefBase 的 `decStrong`：\n\n``` cpp\nvoid RefBase::decStrong(const void* id) const\n{\n    weakref_impl* const refs = mRefs;\n    refs->removeStrongRef(id); //移除强引用\n    const int32_t c = android_atomic_dec(&refs->mStrong);\n    if (c == 1) {\n        refs->mBase->onLastStrongRef(id);\n        if ((refs->mFlags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {\n            delete this;\n        }\n    }\n    refs->decWeak(id); // 移除弱引用\n}\n```\n\n### Message\n\n``` java\nvoid recycleUnchecked() {                 \n    // 标记为使用状态，清除其他状态     \n    flags = FLAG_IN_USE;                  \n    what = 0;                             \n    arg1 = 0;                             \n    arg2 = 0;                             \n    obj = null;                           \n    replyTo = null;                       \n    sendingUid = -1;                      \n    when = 0;                             \n    target = null;                        \n    callback = null;                      \n    data = null;                          \n                                          \n    synchronized (sPoolSync) {\n        // 消息缓存\n        if (sPoolSize < MAX_POOL_SIZE) {  \n            next = sPool;                 \n            sPool = this;                 \n            sPoolSize++;                  \n        }                                 \n    }                                     \n}                                         \n```\n\n``` java\npublic static Message obtain() {             \n    synchronized (sPoolSync) {               \n        if (sPool != null) {\n            // 从缓存中获取\n            Message m = sPool;               \n            sPool = m.next;                  \n            m.next = null;                   \n            m.flags = 0; // clear in-use flag\n            sPoolSize--;                     \n            return m;                        \n        }                                    \n    }                                        \n    return new Message();                    \n}                                            \n```\n\n### 总结\n\n![消息机制](http://gityuan.com/images/handler/handler_java.jpg)\n\nJava 层：\n\n* Handler 通过 `sendMessage`，将 Message 通过 `MessageQueue.enqueueMessage` 添加到队列中\n* Looper 通过 `loop` 提取需要执行的 Message，并交与 `Message.target` 的 Handler 进行 `dispatchMessage` 分发\n*  将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler \n\nJNI 层：\n\n* 线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态\n* 通过 epoll 机制监听 `EPOLLIN` 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程\n\n消息分发的优先级：\n\n1. `Message.callback.run()`\n2. `Handler.mCallback.handleMessage()`\n3. `Handler.handleMessage()`\n\n> EPOLL：Linux 内核的可扩展 I/O 事件通知机制\n>\n> PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入\n>\n> 文件描述符(File descriptor)：用于表述指向[文件](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6)的引用的抽象化概念","source":"_posts/Android消息机制-Handler.md","raw":"---\ntitle: Android消息机制-Handler\ndate: 2018-03-23 20:29:21\ntags:\n---\n\n### 参考\n\n[Android消息机制1-Handler(Java层)](http://gityuan.com/2015/12/26/handler-message-framework/)\n\n[Android消息机制2-Handler(Native层)](http://gityuan.com/2015/12/27/handler-message-native/)\n\n[Android应用程序消息处理机制（Looper、Handler）分析](http://blog.csdn.net/luoshengyang/article/details/6817933)\n\n[管道(Unix)](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix))\n\n[Epoll](https://zh.wikipedia.org/zh-hans/Epoll)\n\n[文件描述符](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)\n\nHandler 机制主要由四个部分组成：\n\n* Looper\n* MessageQueue\n* Message\n* Handler\n\n### 典型用法\n\n``` java\nclass LooperThread extends Thread {\n    public Handler mHandler;\n    \n    public void run() {\n        Looper.prepare();\n        \n        mHandler = new Handler() {\n            public void handleMessage(Message msg) {\n                // process incoming messages here\n            }\n        };\n        \n        Looper.loop();\n    }\n}\n```\n\n### Looper\n\n不断循环执行 `Looper.loop`，按分发机制将消息分发给目标处理者\n\n``` java\nprivate static void prepare(boolean quitAllowed) {\n    if(sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    // 构建 Looper 存储到 ThreadLocal\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n`sThreadLocal` 是一个 ThreadLocal 类型的静态变量\n\n> ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域\n\n``` java\nprivate Looper(boolean quitAllowed) {\n    // Looper 中创建 MessageQueue\n    mQueue = new MessageQueue(quitAllowed);\n    mThread = Thread.currentThread();\n}\n```\n\n``` java\npublic static void loop() {                                                                     \n    final Looper me = myLooper();                                                               \n    if (me == null) {                                                                           \n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }                                                                                           \n    final MessageQueue queue = me.mQueue;                                                       \n                                                                                                \n    // Make sure the identity of this thread is that of the local process,                      \n    // and keep track of what that identity token actually is.                                  \n    Binder.clearCallingIdentity();                                                              \n    final long ident = Binder.clearCallingIdentity();                                           \n                                                                                                \n    for (;;) {                                                                                  \n        Message msg = queue.next(); // 获取下一条 Message，可能会阻塞                                              \n        if (msg == null) {                                                                      \n            // No message indicates that the message queue is quitting.                         \n            return;                                                                             \n        }                                                                                       \n                                                                                                \n        // This must be in a local variable, in case a UI event sets the logger                 \n        final Printer logging = me.mLogging;                                                    \n        if (logging != null) {                                                                  \n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +                        \n                    msg.callback + \": \" + msg.what);                                            \n        }                                                                                       \n                                                                                                \n        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       \n                                                                                                \n        //省略\n        \n        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();     \n        final long end;                                                                         \n        try {\n            // 分发 Message\n            msg.target.dispatchMessage(msg);                                                    \n            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();              \n        } finally {                                                                             \n            if (traceTag != 0) {                                                                \n                Trace.traceEnd(traceTag);                                                       \n            }                                                                                   \n        }                                                                                       \n        if (slowDispatchThresholdMs > 0) {                                                      \n            final long time = end - start;                                                      \n            if (time > slowDispatchThresholdMs) {                                               \n                Slog.w(TAG, \"Dispatch took \" + time + \"ms on \"                                  \n                        + Thread.currentThread().getName() + \", h=\" +                           \n                        msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what);               \n            }                                                                                   \n        }                                                                                       \n                                                                                                \n        if (logging != null) {                                                                  \n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);            \n        }                                                                                       \n                                                                                                \n        // Make sure that during the course of dispatching the                                  \n        // identity of the thread wasn't corrupted.                                             \n        final long newIdent = Binder.clearCallingIdentity();                                    \n        if (ident != newIdent) {                                                                \n            Log.wtf(TAG, \"Thread identity changed from 0x\"                                      \n                    + Long.toHexString(ident) + \" to 0x\"                                        \n                    + Long.toHexString(newIdent) + \" while dispatching to \"                     \n                    + msg.target.getClass().getName() + \" \"                                     \n                    + msg.callback + \" what=\" + msg.what);                                      \n        }                                                                                       \n         \n        // 释放 Message\n        msg.recycleUnchecked();                                                                 \n    }                                                                                           \n}                                                                                               \n```\n\n``` java\n// Looper.quit 最终调用的都是 MessageQueue.quit\npublic void quit() {\n    mQueue.quit(false); // 移除消息\n}\n\npublic void quitSafely() {\n    mQueue.quit(true); // 安全移除消息\n}\n```\n\nMessageQueue 在构造方法中，会调用 native 方法 `nativeInit` 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper\n\n``` cpp\n// frameworks/base/libs\nLooper::Looper(bool allowNonCallbacks) :  \n    mAllowNonCallbacks(allowNonCallbacks),  \n    mResponseIndex(0) {\n    // 管道机制\n    int wakeFds[2];  \n    int result = pipe(wakeFds);  \n    ......  \n  \n    mWakeReadPipeFd = wakeFds[0];  \n    mWakeWritePipeFd = wakeFds[1];  \n  \t\n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    // 分配新的 epoll 实例同时注册唤醒管道\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  \n    ......  \n  \n    struct epoll_event eventItem;  \n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    // 观察 EPOLLIN 事件\n    eventItem.events = EPOLLIN;  \n    eventItem.data.fd = mWakeReadPipeFd;  \n    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem);  \n    ......  \n#else  \n    ......  \n#endif  \n  \n    ......  \n}  \n```\n\n> 管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。\n>\n> epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。\n\npipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。\n\n以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。\n\n### Handler\n\n``` java\npublic Handler(Callback callback, boolean async) {                                                  \n    if (FIND_POTENTIAL_LEAKS) {                                                                     \n        final Class<? extends Handler> klass = getClass();                                          \n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&          \n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            // 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +      \n                klass.getCanonicalName());                                                          \n        }                                                                                           \n    }                                                                                               \n    // 默认使用当前线程的 Looper                                                                                                \n    mLooper = Looper.myLooper();                                                                    \n    if (mLooper == null) {                                                                          \n        throw new RuntimeException(                                                                 \n            \"Can't create handler inside thread that has not called Looper.prepare()\");             \n    }                                                                                               \n    mQueue = mLooper.mQueue;                                                                        \n    mCallback = callback;\n    // 是否为异步处理\n    mAsynchronous = async;                                                                          \n}                                                                                                   \n```\n\n在 `Looper.loop` 中，当存在 Message 需要处理时，会调用 `dispatchMessage` 来进行分发：\n\n``` java\npublic void dispatchMessage(Message msg) {      \n    if (msg.callback != null) {\n        // 先调用 callback\n        handleCallback(msg);                    \n    } else {                                    \n        if (mCallback != null) {\n            // 接着检查通过构造方法传进来的 Callback\n            if (mCallback.handleMessage(msg)) { \n                return;                         \n            }                                   \n        }\n        // 最后调用 handleMessage\n        handleMessage(msg);                     \n    }                                           \n}                                               \n```\n\n通过 Handler 发送消息：\n\n![发送消息调用链](http://gityuan.com/images/handler/java_sendmessage.png)\n\n最终所有的方法都会调用到 `MessageQueue.enqueueMessage`\n\n### MessageQueue\n\n> 消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理\n\n``` java\nMessageQueue(boolean quitAllowed) { \n    mQuitAllowed = quitAllowed;\n    // used by native code\n    mPtr = nativeInit();            \n}                                   \n```\n\nMessageQueue 的初始化工作主要由 native 方法来执行\n\n``` cpp\n//frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {\n    // 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();  \n    if (! nativeMessageQueue) {  \n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");  \n        return;  \n    }  \n  \t\n    // 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量\n    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  \n}  \n```\n\n`nativeInit` 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 `mPtr`，关联了 NativeMessageQueue 和 MessageQueue\n\n``` java\nMessage next() {                                                                              \n    // messsage loop has already quit                                                              \n    final long ptr = mPtr;                                                                    \n    if (ptr == 0) {                                                                           \n        return null;                                                                          \n    }                                                                                         \n                                                                                              \n    int pendingIdleHandlerCount = -1; // -1 only during first iteration                       \n    int nextPollTimeoutMillis = 0;                                                            \n    for (;;) {                                                                                \n        if (nextPollTimeoutMillis != 0) {                                                     \n            Binder.flushPendingCommands();                                                    \n        }                                                                                     \n        // 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回\n        // ptr 是在 JNI 层创建的 NativeMessageQueue\n        nativePollOnce(ptr, nextPollTimeoutMillis);                                           \n        \n        // 当前 nativePollOnce 返回后，查看消息队列中是否存在消息\n        synchronized (this) {                                                                 \n            // 尝试检索下一条消息，如果找到则返回                            \n            final long now = SystemClock.uptimeMillis();                                      \n            Message prevMsg = null;                                                           \n            Message msg = mMessages;                                                          \n            if (msg != null && msg.target == null) {                                          \n                // 找到下一条异步消息或者没有消息了，则退出循环\n                do {                                                                          \n                    prevMsg = msg;                                                            \n                    msg = msg.next;                                                           \n                } while (msg != null && !msg.isAsynchronous());                               \n            }                                                                                 \n            if (msg != null) {                                                                \n                if (now < msg.when) {                                                         \n                    // 下一个消息还没准备好，重新设置唤醒超时时间\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {                                                                      \n                    // 获取一条消息                                                         \n                    mBlocked = false;\n                    if (prevMsg != null) {                                                    \n                        prevMsg.next = msg.next;                                              \n                    } else {                                                                  \n                        mMessages = msg.next;                                                 \n                    }                                                                         \n                    msg.next = null;                                                          \n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    // 标记当前消息已使用\n                    msg.markInUse();                                                          \n                    return msg;                                                               \n                }                                                                             \n            } else {                                                                          \n                // 当前还没有消息，设置为 -1，无限等待中                                                     \n                nextPollTimeoutMillis = -1;                                                   \n            }                                                                                 \n                                                                                              \n            // Process the quit message now that all pending messages have been handled.      \n            if (mQuitting) {                                                                  \n                dispose();                                                                    \n                return null;                                                                  \n            }                                                                                 \n                                                                                              \n            // queue is empty or if the first message\n            // get pending idle handler count\n            if (pendingIdleHandlerCount < 0                                                   \n                    && (mMessages == null || now < mMessages.when)) {                         \n                pendingIdleHandlerCount = mIdleHandlers.size();                               \n            }                                                                                 \n            if (pendingIdleHandlerCount <= 0) {                                               \n                // 没有 idle handlers 需要运行，循环继续等待                        \n                mBlocked = true;                                                              \n                continue;                                                                     \n            }                                                                                 \n                                                                                              \n            if (mPendingIdleHandlers == null) {                                               \n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; \n            }                                                                                 \n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               \n        }                                                                                     \n                                                                                              \n        // Run the idle handlers.                                                        \n        // We only ever reach this code block during the first iteration                    \n        for (int i = 0; i < pendingIdleHandlerCount; i++) {                                   \n            final IdleHandler idler = mPendingIdleHandlers[i];                                \n            mPendingIdleHandlers[i] = null;           \n                                                                                              \n            boolean keep = false;                                                             \n            try {                                                                             \n                keep = idler.queueIdle();                                                     \n            } catch (Throwable t) {                                                           \n                Log.wtf(TAG, \"IdleHandler threw exception\", t);                               \n            }                                                                                 \n                                                                                              \n            if (!keep) {                                                                      \n                synchronized (this) {\n                    mIdleHandlers.remove(idler);                                              \n                }                                                                             \n            }                                                                                 \n        }                                                                                     \n                                                                                              \n        // Reset the idle handler count to 0 so we do not run them again.                     \n        pendingIdleHandlerCount = 0;                                                          \n                                                                                              \n        //不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                \n        nextPollTimeoutMillis = 0;                                                            \n    }                                                                                         \n}                                                                                             \n```\n\n在 `next` 方法中，`nativePollOnce` 是阻塞操作，其中 `nextPollTimeoutMillis` 代表下一个消息到来之前，还需要等待的时长；`nextPollTimeoutMillis == -1` 表示当前没有更多消息。`nativePollOnce` 调用结束后，从 `mMessages` 中提取一个消息\n\n当处于空闲时，执行 `IdleHandler` 中的回调方法。\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,  \n        jint ptr, jint timeoutMillis) {\n    // 通过前面设置的 mPrt 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr); \n    // 调用 NativeMessageQueue.pollOnce 进行轮询\n    nativeMessageQueue->pollOnce(timeoutMillis);  \n}  \n```\n\n``` cpp\nvoid NativeMessageQueue::pollOnce(int timeoutMillis) {\n    // 将调用转发给了 JNI 层的 Looper\n    mLooper->pollOnce(timeoutMillis);  \n} \n```\n\n`pollOnce` 会调用 `pollnner` 来进一步操作，如果 `pollnner` 返回值不等于 0，则返回\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nint Looper::pollInner(int timeoutMillis) {  \n    ......  \n  \n    int result = ALOOPER_POLL_WAKE;  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis\n    // 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件\n    // 如果检查成功或者超时，则结束等待\n    // 处于 Idle 状态\n    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    bool acquiredLock = false;  \n#else  \n    ......  \n#endif  \n    \n    // eventCount < 0 可能出错了\n    if (eventCount < 0) {  \n        if (errno == EINTR) {  \n            goto Done;  \n        }  \n  \n        LOGW(\"Poll failed with an unexpected error, errno=%d\", errno);  \n        result = ALOOPER_POLL_ERROR;  \n        goto Done;  \n    }  \n  \t\n    // eventCount == 0 超时\n    if (eventCount == 0) {  \n        ......  \n        result = ALOOPER_POLL_TIMEOUT;  \n        goto Done;  \n    }  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL\n    // eventCount > 0 存在事件\n    for (int i = 0; i < eventCount; i++) {  \n        int fd = eventItems[i].data.fd;  \n        uint32_t epollEvents = eventItems[i].events;  \n        if (fd == mWakeReadPipeFd) {  \n            if (epollEvents & EPOLLIN) {\n                // Looper 中使用 epoll 监听的 EPOLLIN 事件\n                awoken();  \n            } else {  \n                LOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents);  \n            }  \n        } else {  \n            ......  \n        }  \n    }  \n    if (acquiredLock) {  \n        mLock.unlock();  \n    }  \nDone: ;  \n#else  \n    ......  \n#endif  \n  \n    ......  \n  \n    return result;  \n} \n```\n\n``` cpp\nvoid Looper::awoken() {  \n    ......  \n  \n    char buffer[16];  \n    ssize_t nRead;  \n    do {  \n        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));  \n    } while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));  \n}  \n```\n\n总结上面的代码，Looper 通过 `loop` 调用 MessageQueue 的 `next`，`next` 中又会调用到 native 方法 `nativePollOnce`，在这个方法中，会调用到 NativeMessageQueue 的 `pollInner`，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 `awoken`，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。\n\n``` java\nboolean enqueueMessage(Message msg, long when) {                                         \n    if (msg.target == null) {                                                            \n        throw new IllegalArgumentException(\"Message must have a target.\");               \n    }                                                                                    \n    if (msg.isInUse()) {                                                                 \n        throw new IllegalStateException(msg + \" This message is already in use.\");       \n    }                                                                                    \n                                                                                         \n    synchronized (this) {                                                                \n        if (mQuitting) {                                                                 \n            IllegalStateException e = new IllegalStateException(                         \n                    msg.target + \" sending message to a Handler on a dead thread\");      \n            Log.w(TAG, e.getMessage(), e);                                               \n            msg.recycle();                                                               \n            return false;                                                                \n        }                                                                                \n                                                                                         \n        msg.markInUse();                                                                 \n        msg.when = when;                                                                 \n        Message p = mMessages;                                                           \n        boolean needWake;                                                                \n        if (p == null || when == 0 || when < p.when) {                                   \n            // 不存在头部消息或立即执行或执行时机快于头部消息\n            // 将处理的消息作为新的头部消息\n            msg.next = p;                                                                \n            mMessages = msg;                                                             \n            needWake = mBlocked;                                                         \n        } else {                                                                         \n            // 将处理的消息插入到队列的尾部\n            // 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();             \n            Message prev;                                                                \n            for (;;) {                                                                   \n                prev = p;                                                                \n                p = p.next;                                                              \n                if (p == null || when < p.when) {                                        \n                    break;                                                               \n                }                                                                        \n                if (needWake && p.isAsynchronous()) {                                    \n                    needWake = false;                                                    \n                }                                                                        \n            }                                                                            \n            msg.next = p; // invariant: p == prev.next                                   \n            prev.next = msg;                                                             \n        }                                                                                \n                                                                                         \n        // We can assume mPtr != 0 because mQuitting is false.                           \n        if (needWake) {                                                                  \n            nativeWake(mPtr);                                                            \n        }                                                                                \n    }                                                                                    \n    return true;                                                                         \n}                                                                                        \n```\n\n`MessageQueue` 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。\n\n如果当前线程处于空闲等待状态，那么还需要调用 `nativeWake` 来唤醒：\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj, jint ptr) {\n    // ptr 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);  \n    return nativeMessageQueue->wake();  \n}  \n```\n\n这里将唤醒请求转发到 Looper `wake`：\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nvoid Looper::wake() {  \n    ......  \n  \n    ssize_t nWrite;  \n    do {\n        // 先管道中写入 \"W\n        nWrite = write(mWakeWritePipeFd, \"W\", 1);  \n    } while (nWrite == -1 && errno == EINTR);  \n  \n    .......  \n}  \n```\n\n往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 `polllnner` 中调用 `epoll_wait` 进入\n\n``` java\nvoid removeMessages(Handler h, int what, Object object) {     \n    if (h == null) {                                          \n        return;                                               \n    }                                                         \n                                                              \n    synchronized (this) {                                     \n        Message p = mMessages;                                \n                                                              \n        // 从队列头部开始，移除连续的所有符合条件的消息                     \n        while (p != null && p.target == h && p.what == what   \n               && (object == null || p.obj == object)) {      \n            Message n = p.next;                               \n            mMessages = n;\n            // 找到对应的消息，释放它\n            p.recycleUnchecked();                             \n            p = n;                                            \n        }                                                     \n                                                              \n        //  从新的队列头部开始，移除全部符合条件的消息                  \n        while (p != null) {                                   \n            Message n = p.next;                               \n            if (n != null) {                                  \n                if (n.target == h && n.what == what           \n                    && (object == null || n.obj == object)) { \n                    Message nn = n.next;                      \n                    n.recycleUnchecked();                     \n                    p.next = nn;                              \n                    continue;                                 \n                }                                             \n            }                                                 \n            p = n;                                            \n        }                                                     \n    }                                                         \n}                                                             \n```\n\n`postSyncBarrier` 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 `removeSyncBarrier`\n\n当 MessageQueue 退出时，需要 `dispose`：\n\n``` java\n// Disposes of the underlying message queue.                 \n// Must only be called on the looper thread or the finalizer.\nprivate void dispose() {                                     \n    if (mPtr != 0) {\n        // native 方法\n        nativeDestroy(mPtr);\n        // mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量\n        mPtr = 0;                                            \n    }                                                        \n}                                                            \n```\n\n`nativeDestroy` 最终会调用 RefBase 的 `decStrong`：\n\n``` cpp\nvoid RefBase::decStrong(const void* id) const\n{\n    weakref_impl* const refs = mRefs;\n    refs->removeStrongRef(id); //移除强引用\n    const int32_t c = android_atomic_dec(&refs->mStrong);\n    if (c == 1) {\n        refs->mBase->onLastStrongRef(id);\n        if ((refs->mFlags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {\n            delete this;\n        }\n    }\n    refs->decWeak(id); // 移除弱引用\n}\n```\n\n### Message\n\n``` java\nvoid recycleUnchecked() {                 \n    // 标记为使用状态，清除其他状态     \n    flags = FLAG_IN_USE;                  \n    what = 0;                             \n    arg1 = 0;                             \n    arg2 = 0;                             \n    obj = null;                           \n    replyTo = null;                       \n    sendingUid = -1;                      \n    when = 0;                             \n    target = null;                        \n    callback = null;                      \n    data = null;                          \n                                          \n    synchronized (sPoolSync) {\n        // 消息缓存\n        if (sPoolSize < MAX_POOL_SIZE) {  \n            next = sPool;                 \n            sPool = this;                 \n            sPoolSize++;                  \n        }                                 \n    }                                     \n}                                         \n```\n\n``` java\npublic static Message obtain() {             \n    synchronized (sPoolSync) {               \n        if (sPool != null) {\n            // 从缓存中获取\n            Message m = sPool;               \n            sPool = m.next;                  \n            m.next = null;                   \n            m.flags = 0; // clear in-use flag\n            sPoolSize--;                     \n            return m;                        \n        }                                    \n    }                                        \n    return new Message();                    \n}                                            \n```\n\n### 总结\n\n![消息机制](http://gityuan.com/images/handler/handler_java.jpg)\n\nJava 层：\n\n* Handler 通过 `sendMessage`，将 Message 通过 `MessageQueue.enqueueMessage` 添加到队列中\n* Looper 通过 `loop` 提取需要执行的 Message，并交与 `Message.target` 的 Handler 进行 `dispatchMessage` 分发\n*  将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler \n\nJNI 层：\n\n* 线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态\n* 通过 epoll 机制监听 `EPOLLIN` 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程\n\n消息分发的优先级：\n\n1. `Message.callback.run()`\n2. `Handler.mCallback.handleMessage()`\n3. `Handler.handleMessage()`\n\n> EPOLL：Linux 内核的可扩展 I/O 事件通知机制\n>\n> PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入\n>\n> 文件描述符(File descriptor)：用于表述指向[文件](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6)的引用的抽象化概念","slug":"Android消息机制-Handler","published":1,"updated":"2018-03-23T12:30:38.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf3xcq8k0001fa9hkubkv0c1","content":"<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://gityuan.com/2015/12/26/handler-message-framework/\" target=\"_blank\" rel=\"noopener\">Android消息机制1-Handler(Java层)</a></p>\n<p><a href=\"http://gityuan.com/2015/12/27/handler-message-native/\" target=\"_blank\" rel=\"noopener\">Android消息机制2-Handler(Native层)</a></p>\n<p><a href=\"http://blog.csdn.net/luoshengyang/article/details/6817933\" target=\"_blank\" rel=\"noopener\">Android应用程序消息处理机制（Looper、Handler）分析</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix\" target=\"_blank\" rel=\"noopener\">管道(Unix)</a>)</p>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/Epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">文件描述符</a></p>\n<p>Handler 机制主要由四个部分组成：</p>\n<ul>\n<li>Looper</li>\n<li>MessageQueue</li>\n<li>Message</li>\n<li>Handler</li>\n</ul>\n<h3 id=\"典型用法\"><a href=\"#典型用法\" class=\"headerlink\" title=\"典型用法\"></a>典型用法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        </span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>不断循环执行 <code>Looper.loop</code>，按分发机制将消息分发给目标处理者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构建 Looper 存储到 ThreadLocal</span></span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>sThreadLocal</code> 是一个 ThreadLocal 类型的静态变量</p>\n<blockquote>\n<p>ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Looper 中创建 MessageQueue</span></span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,                      </span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.                                  </span></span><br><span class=\"line\">    Binder.clearCallingIdentity();                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();                                           </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                  </span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// 获取下一条 Message，可能会阻塞                                              </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;                                                                      </span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.                         </span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger                 </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Printer logging = me.mLogging;                                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +                        </span><br><span class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);                                            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">//省略</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> end;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 分发 Message</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);                                                    </span><br><span class=\"line\">            end = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();              </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;                                                                             </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;                                                                </span><br><span class=\"line\">                Trace.traceEnd(traceTag);                                                       </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>) &#123;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> time = end - start;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; slowDispatchThresholdMs) &#123;                                               </span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Dispatch took \"</span> + time + <span class=\"string\">\"ms on \"</span>                                  </span><br><span class=\"line\">                        + Thread.currentThread().getName() + <span class=\"string\">\", h=\"</span> +                           </span><br><span class=\"line\">                        msg.target + <span class=\"string\">\" cb=\"</span> + msg.callback + <span class=\"string\">\" msg=\"</span> + msg.what);               </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the                                  </span></span><br><span class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.                                             </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;                                                                </span><br><span class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span>                                      </span><br><span class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span>                                        </span><br><span class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span>                     </span><br><span class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span>                                     </span><br><span class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);                                      </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"comment\">// 释放 Message</span></span><br><span class=\"line\">        msg.recycleUnchecked();                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Looper.quit 最终调用的都是 MessageQueue.quit</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">false</span>); <span class=\"comment\">// 移除消息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quitSafely</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">true</span>); <span class=\"comment\">// 安全移除消息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 在构造方法中，会调用 native 方法 <code>nativeInit</code> 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs</span></span><br><span class=\"line\">Looper::Looper(<span class=\"keyword\">bool</span> allowNonCallbacks) :  </span><br><span class=\"line\">    mAllowNonCallbacks(allowNonCallbacks),  </span><br><span class=\"line\">    mResponseIndex(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 管道机制</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> wakeFds[<span class=\"number\">2</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = pipe(wakeFds);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    mWakeReadPipeFd = wakeFds[<span class=\"number\">0</span>];  </span><br><span class=\"line\">    mWakeWritePipeFd = wakeFds[<span class=\"number\">1</span>];  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"comment\">// 分配新的 epoll 实例同时注册唤醒管道</span></span><br><span class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItem</span>;</span>  </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp; eventItem, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(epoll_event)); <span class=\"comment\">// zero out unused members of data field union</span></span><br><span class=\"line\">    <span class=\"comment\">// 观察 EPOLLIN 事件</span></span><br><span class=\"line\">    eventItem.events = EPOLLIN;  </span><br><span class=\"line\">    eventItem.data.fd = mWakeReadPipeFd;  </span><br><span class=\"line\">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。</p>\n<p>epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p>\n</blockquote>\n<p>pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。</p>\n<p>以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;                                                                     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();                                          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;          </span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏</span></span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +      </span><br><span class=\"line\">                klass.getCanonicalName());                                                          </span><br><span class=\"line\">        &#125;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    <span class=\"comment\">// 默认使用当前线程的 Looper                                                                                                </span></span><br><span class=\"line\">    mLooper = Looper.myLooper();                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(                                                                 </span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread that has not called Looper.prepare()\"</span>);             </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    mQueue = mLooper.mQueue;                                                                        </span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    <span class=\"comment\">// 是否为异步处理</span></span><br><span class=\"line\">    mAsynchronous = async;                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>Looper.loop</code> 中，当存在 Message 需要处理时，会调用 <code>dispatchMessage</code> 来进行分发：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用 callback</span></span><br><span class=\"line\">        handleCallback(msg);                    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接着检查通过构造方法传进来的 Callback</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123; </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;                         </span><br><span class=\"line\">            &#125;                                   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 最后调用 handleMessage</span></span><br><span class=\"line\">        handleMessage(msg);                     </span><br><span class=\"line\">    &#125;                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 Handler 发送消息：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://gityuan.com/images/handler/java_sendmessage.png\" alt=\"发送消息调用链\" title=\"\">\n                </div>\n                <div class=\"image-caption\">发送消息调用链</div>\n            </figure>\n<p>最终所有的方法都会调用到 <code>MessageQueue.enqueueMessage</code></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><blockquote>\n<p>消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123; </span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    <span class=\"comment\">// used by native code</span></span><br><span class=\"line\">    mPtr = nativeInit();            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 的初始化工作主要由 native 方法来执行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> NativeMessageQueue();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! nativeMessageQueue) &#123;  </span><br><span class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Unable to allocate native queue\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量</span></span><br><span class=\"line\">    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeInit</code> 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 <code>mPtr</code>，关联了 NativeMessageQueue 和 MessageQueue</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// messsage loop has already quit                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                          </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration                       </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;                                                     </span><br><span class=\"line\">            Binder.flushPendingCommands();                                                    </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class=\"line\">        <span class=\"comment\">// ptr 是在 JNI 层创建的 NativeMessageQueue</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);                                           </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 当前 nativePollOnce 返回后，查看消息队列中是否存在消息</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                 </span><br><span class=\"line\">            <span class=\"comment\">// 尝试检索下一条消息，如果找到则返回                            </span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();                                      </span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">            Message msg = mMessages;                                                          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">                <span class=\"comment\">// 找到下一条异步消息或者没有消息了，则退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;                                                                          </span><br><span class=\"line\">                    prevMsg = msg;                                                            </span><br><span class=\"line\">                    msg = msg.next;                                                           </span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;                                                                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;                                                         </span><br><span class=\"line\">                    <span class=\"comment\">// 下一个消息还没准备好，重新设置唤醒超时时间</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;                                                                      </span><br><span class=\"line\">                    <span class=\"comment\">// 获取一条消息                                                         </span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;                                                    </span><br><span class=\"line\">                        prevMsg.next = msg.next;                                              </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;                                                                  </span><br><span class=\"line\">                        mMessages = msg.next;                                                 </span><br><span class=\"line\">                    &#125;                                                                         </span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"Returning message: \"</span> + msg);</span><br><span class=\"line\">                    <span class=\"comment\">// 标记当前消息已使用</span></span><br><span class=\"line\">                    msg.markInUse();                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;                                                               </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;                                                                          </span><br><span class=\"line\">                <span class=\"comment\">// 当前还没有消息，设置为 -1，无限等待中                                                     </span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;                                                   </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.      </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                  </span><br><span class=\"line\">                dispose();                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                  </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// get pending idle handler count</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span>                                                   </span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;                         </span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">                <span class=\"comment\">// 没有 idle handlers 需要运行，循环继续等待                        </span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                                                                     </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;                                               </span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)]; </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.                                                        </span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration                    </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;                                   </span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];                                </span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>;           </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;                                                             </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;                                                                             </span><br><span class=\"line\">                keep = idler.queueIdle();                                                     </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;                                                           </span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;                                                                      </span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);                                              </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.                     </span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;                                                          </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">//不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                </span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>next</code> 方法中，<code>nativePollOnce</code> 是阻塞操作，其中 <code>nextPollTimeoutMillis</code> 代表下一个消息到来之前，还需要等待的时长；<code>nextPollTimeoutMillis == -1</code> 表示当前没有更多消息。<code>nativePollOnce</code> 调用结束后，从 <code>mMessages</code> 中提取一个消息</p>\n<p>当处于空闲时，执行 <code>IdleHandler</code> 中的回调方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jint ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过前面设置的 mPrt 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr); </span><br><span class=\"line\">    <span class=\"comment\">// 调用 NativeMessageQueue.pollOnce 进行轮询</span></span><br><span class=\"line\">    nativeMessageQueue-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> NativeMessageQueue::pollOnce(<span class=\"keyword\">int</span> timeoutMillis) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将调用转发给了 JNI 层的 Looper</span></span><br><span class=\"line\">    mLooper-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>pollOnce</code> 会调用 <code>pollnner</code> 来进一步操作，如果 <code>pollnner</code> 返回值不等于 0，则返回</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Looper::pollInner(<span class=\"keyword\">int</span> timeoutMillis) &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = ALOOPER_POLL_WAKE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItems</span>[<span class=\"title\">EPOLL_MAX_EVENTS</span>];</span></span><br><span class=\"line\">    <span class=\"comment\">// 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis</span></span><br><span class=\"line\">    <span class=\"comment\">// 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果检查成功或者超时，则结束等待</span></span><br><span class=\"line\">    <span class=\"comment\">// 处于 Idle 状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> acquiredLock = <span class=\"literal\">false</span>;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// eventCount &lt; 0 可能出错了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        LOGW(<span class=\"string\">\"Poll failed with an unexpected error, errno=%d\"</span>, errno);  </span><br><span class=\"line\">        result = ALOOPER_POLL_ERROR;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// eventCount == 0 超时</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        ......  </span><br><span class=\"line\">        result = ALOOPER_POLL_TIMEOUT;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL</span></span><br><span class=\"line\">    <span class=\"comment\">// eventCount &gt; 0 存在事件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd = eventItems[i].data.fd;  </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Looper 中使用 epoll 监听的 EPOLLIN 事件</span></span><br><span class=\"line\">                awoken();  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                LOGW(<span class=\"string\">\"Ignoring unexpected epoll events 0x%x on wake read pipe.\"</span>, epollEvents);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            ......  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquiredLock) &#123;  </span><br><span class=\"line\">        mLock.unlock();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">Done: ;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::awoken() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">16</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nRead;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">        nRead = read(mWakeReadPipeFd, buffer, <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((nRead == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结上面的代码，Looper 通过 <code>loop</code> 调用 MessageQueue 的 <code>next</code>，<code>next</code> 中又会调用到 native 方法 <code>nativePollOnce</code>，在这个方法中，会调用到 NativeMessageQueue 的 <code>pollInner</code>，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 <code>awoken</code>，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;                                                            </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Message must have a target.\"</span>);               </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">\" This message is already in use.\"</span>);       </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                 </span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(                         </span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);      </span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);                                               </span><br><span class=\"line\">            msg.recycle();                                                               </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        msg.markInUse();                                                                 </span><br><span class=\"line\">        msg.when = when;                                                                 </span><br><span class=\"line\">        Message p = mMessages;                                                           </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;                                   </span><br><span class=\"line\">            <span class=\"comment\">// 不存在头部消息或立即执行或执行时机快于头部消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息作为新的头部消息</span></span><br><span class=\"line\">            msg.next = p;                                                                </span><br><span class=\"line\">            mMessages = msg;                                                             </span><br><span class=\"line\">            needWake = mBlocked;                                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                                         </span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息插入到队列的尾部</span></span><br><span class=\"line\">            <span class=\"comment\">// 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();             </span><br><span class=\"line\">            Message prev;                                                                </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;                                                                   </span><br><span class=\"line\">                prev = p;                                                                </span><br><span class=\"line\">                p = p.next;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;                                        </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                               </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;                                    </span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;                                                    </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">            &#125;                                                                            </span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next                                   </span></span><br><span class=\"line\">            prev.next = msg;                                                             </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.                           </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;                                                                  </span><br><span class=\"line\">            nativeWake(mPtr);                                                            </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MessageQueue</code> 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。</p>\n<p>如果当前线程处于空闲等待状态，那么还需要调用 <code>nativeWake</code> 来唤醒：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jobject obj, jint ptr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ptr 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nativeMessageQueue-&gt;wake();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将唤醒请求转发到 Looper <code>wake</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Looper::wake() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nWrite;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先管道中写入 \"W</span></span><br><span class=\"line\">        nWrite = write(mWakeWritePipeFd, <span class=\"string\">\"W\"</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (nWrite == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    .......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 <code>polllnner</code> 中调用 <code>epoll_wait</code> 进入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, <span class=\"keyword\">int</span> what, Object object)</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                               </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                     </span><br><span class=\"line\">        Message p = mMessages;                                </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">// 从队列头部开始，移除连续的所有符合条件的消息                     </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what   </span><br><span class=\"line\">               &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;      </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            <span class=\"comment\">// 找到对应的消息，释放它</span></span><br><span class=\"line\">            p.recycleUnchecked();                             </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">//  从新的队列头部开始，移除全部符合条件的消息                  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;                                   </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;                                  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.what == what           </span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123; </span><br><span class=\"line\">                    Message nn = n.next;                      </span><br><span class=\"line\">                    n.recycleUnchecked();                     </span><br><span class=\"line\">                    p.next = nn;                              </span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;                                 </span><br><span class=\"line\">                &#125;                                             </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSyncBarrier</code> 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 <code>removeSyncBarrier</code></p>\n<p>当 MessageQueue 退出时，需要 <code>dispose</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposes of the underlying message queue.                 </span></span><br><span class=\"line\"><span class=\"comment\">// Must only be called on the looper thread or the finalizer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPtr != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// native 方法</span></span><br><span class=\"line\">        nativeDestroy(mPtr);</span><br><span class=\"line\">        <span class=\"comment\">// mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量</span></span><br><span class=\"line\">        mPtr = <span class=\"number\">0</span>;                                            </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeDestroy</code> 最终会调用 RefBase 的 <code>decStrong</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> RefBase::decStrong(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* id) <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weakref_impl* <span class=\"keyword\">const</span> refs = mRefs;</span><br><span class=\"line\">    refs-&gt;removeStrongRef(id); <span class=\"comment\">//移除强引用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs-&gt;decWeak(id); <span class=\"comment\">// 移除弱引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycleUnchecked</span><span class=\"params\">()</span> </span>&#123;                 </span><br><span class=\"line\">    <span class=\"comment\">// 标记为使用状态，清除其他状态     </span></span><br><span class=\"line\">    flags = FLAG_IN_USE;                  </span><br><span class=\"line\">    what = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg1 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg2 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    obj = <span class=\"keyword\">null</span>;                           </span><br><span class=\"line\">    replyTo = <span class=\"keyword\">null</span>;                       </span><br><span class=\"line\">    sendingUid = -<span class=\"number\">1</span>;                      </span><br><span class=\"line\">    when = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    target = <span class=\"keyword\">null</span>;                        </span><br><span class=\"line\">    callback = <span class=\"keyword\">null</span>;                      </span><br><span class=\"line\">    data = <span class=\"keyword\">null</span>;                          </span><br><span class=\"line\">                                          </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;  </span><br><span class=\"line\">            next = sPool;                 </span><br><span class=\"line\">            sPool = <span class=\"keyword\">this</span>;                 </span><br><span class=\"line\">            sPoolSize++;                  </span><br><span class=\"line\">        &#125;                                 </span><br><span class=\"line\">    &#125;                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;             </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从缓存中获取</span></span><br><span class=\"line\">            Message m = sPool;               </span><br><span class=\"line\">            sPool = m.next;                  </span><br><span class=\"line\">            m.next = <span class=\"keyword\">null</span>;                   </span><br><span class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></span><br><span class=\"line\">            sPoolSize--;                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;                        </span><br><span class=\"line\">        &#125;                                    </span><br><span class=\"line\">    &#125;                                        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://gityuan.com/images/handler/handler_java.jpg\" alt=\"消息机制\" title=\"\">\n                </div>\n                <div class=\"image-caption\">消息机制</div>\n            </figure>\n<p>Java 层：</p>\n<ul>\n<li>Handler 通过 <code>sendMessage</code>，将 Message 通过 <code>MessageQueue.enqueueMessage</code> 添加到队列中</li>\n<li>Looper 通过 <code>loop</code> 提取需要执行的 Message，并交与 <code>Message.target</code> 的 Handler 进行 <code>dispatchMessage</code> 分发</li>\n<li>将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler </li>\n</ul>\n<p>JNI 层：</p>\n<ul>\n<li>线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态</li>\n<li>通过 epoll 机制监听 <code>EPOLLIN</code> 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程</li>\n</ul>\n<p>消息分发的优先级：</p>\n<ol>\n<li><code>Message.callback.run()</code></li>\n<li><code>Handler.mCallback.handleMessage()</code></li>\n<li><code>Handler.handleMessage()</code></li>\n</ol>\n<blockquote>\n<p>EPOLL：Linux 内核的可扩展 I/O 事件通知机制</p>\n<p>PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入</p>\n<p>文件描述符(File descriptor)：用于表述指向<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">文件</a>的引用的抽象化概念</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://gityuan.com/2015/12/26/handler-message-framework/\" target=\"_blank\" rel=\"noopener\">Android消息机制1-Handler(Java层)</a></p>\n<p><a href=\"http://gityuan.com/2015/12/27/handler-message-native/\" target=\"_blank\" rel=\"noopener\">Android消息机制2-Handler(Native层)</a></p>\n<p><a href=\"http://blog.csdn.net/luoshengyang/article/details/6817933\" target=\"_blank\" rel=\"noopener\">Android应用程序消息处理机制（Looper、Handler）分析</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix\" target=\"_blank\" rel=\"noopener\">管道(Unix)</a>)</p>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/Epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">文件描述符</a></p>\n<p>Handler 机制主要由四个部分组成：</p>\n<ul>\n<li>Looper</li>\n<li>MessageQueue</li>\n<li>Message</li>\n<li>Handler</li>\n</ul>\n<h3 id=\"典型用法\"><a href=\"#典型用法\" class=\"headerlink\" title=\"典型用法\"></a>典型用法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        </span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>不断循环执行 <code>Looper.loop</code>，按分发机制将消息分发给目标处理者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构建 Looper 存储到 ThreadLocal</span></span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>sThreadLocal</code> 是一个 ThreadLocal 类型的静态变量</p>\n<blockquote>\n<p>ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Looper 中创建 MessageQueue</span></span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,                      </span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.                                  </span></span><br><span class=\"line\">    Binder.clearCallingIdentity();                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();                                           </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                  </span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// 获取下一条 Message，可能会阻塞                                              </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;                                                                      </span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.                         </span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger                 </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Printer logging = me.mLogging;                                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +                        </span><br><span class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);                                            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">//省略</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> end;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 分发 Message</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);                                                    </span><br><span class=\"line\">            end = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();              </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;                                                                             </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;                                                                </span><br><span class=\"line\">                Trace.traceEnd(traceTag);                                                       </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>) &#123;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> time = end - start;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; slowDispatchThresholdMs) &#123;                                               </span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Dispatch took \"</span> + time + <span class=\"string\">\"ms on \"</span>                                  </span><br><span class=\"line\">                        + Thread.currentThread().getName() + <span class=\"string\">\", h=\"</span> +                           </span><br><span class=\"line\">                        msg.target + <span class=\"string\">\" cb=\"</span> + msg.callback + <span class=\"string\">\" msg=\"</span> + msg.what);               </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the                                  </span></span><br><span class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.                                             </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;                                                                </span><br><span class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span>                                      </span><br><span class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span>                                        </span><br><span class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span>                     </span><br><span class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span>                                     </span><br><span class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);                                      </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"comment\">// 释放 Message</span></span><br><span class=\"line\">        msg.recycleUnchecked();                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Looper.quit 最终调用的都是 MessageQueue.quit</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">false</span>); <span class=\"comment\">// 移除消息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quitSafely</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">true</span>); <span class=\"comment\">// 安全移除消息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 在构造方法中，会调用 native 方法 <code>nativeInit</code> 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs</span></span><br><span class=\"line\">Looper::Looper(<span class=\"keyword\">bool</span> allowNonCallbacks) :  </span><br><span class=\"line\">    mAllowNonCallbacks(allowNonCallbacks),  </span><br><span class=\"line\">    mResponseIndex(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 管道机制</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> wakeFds[<span class=\"number\">2</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = pipe(wakeFds);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    mWakeReadPipeFd = wakeFds[<span class=\"number\">0</span>];  </span><br><span class=\"line\">    mWakeWritePipeFd = wakeFds[<span class=\"number\">1</span>];  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"comment\">// 分配新的 epoll 实例同时注册唤醒管道</span></span><br><span class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItem</span>;</span>  </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp; eventItem, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(epoll_event)); <span class=\"comment\">// zero out unused members of data field union</span></span><br><span class=\"line\">    <span class=\"comment\">// 观察 EPOLLIN 事件</span></span><br><span class=\"line\">    eventItem.events = EPOLLIN;  </span><br><span class=\"line\">    eventItem.data.fd = mWakeReadPipeFd;  </span><br><span class=\"line\">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。</p>\n<p>epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p>\n</blockquote>\n<p>pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。</p>\n<p>以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;                                                                     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();                                          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;          </span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏</span></span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +      </span><br><span class=\"line\">                klass.getCanonicalName());                                                          </span><br><span class=\"line\">        &#125;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    <span class=\"comment\">// 默认使用当前线程的 Looper                                                                                                </span></span><br><span class=\"line\">    mLooper = Looper.myLooper();                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(                                                                 </span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread that has not called Looper.prepare()\"</span>);             </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    mQueue = mLooper.mQueue;                                                                        </span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    <span class=\"comment\">// 是否为异步处理</span></span><br><span class=\"line\">    mAsynchronous = async;                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>Looper.loop</code> 中，当存在 Message 需要处理时，会调用 <code>dispatchMessage</code> 来进行分发：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用 callback</span></span><br><span class=\"line\">        handleCallback(msg);                    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接着检查通过构造方法传进来的 Callback</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123; </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;                         </span><br><span class=\"line\">            &#125;                                   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 最后调用 handleMessage</span></span><br><span class=\"line\">        handleMessage(msg);                     </span><br><span class=\"line\">    &#125;                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 Handler 发送消息：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://gityuan.com/images/handler/java_sendmessage.png\" alt=\"发送消息调用链\" title=\"\">\n                </div>\n                <div class=\"image-caption\">发送消息调用链</div>\n            </figure>\n<p>最终所有的方法都会调用到 <code>MessageQueue.enqueueMessage</code></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><blockquote>\n<p>消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123; </span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    <span class=\"comment\">// used by native code</span></span><br><span class=\"line\">    mPtr = nativeInit();            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 的初始化工作主要由 native 方法来执行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> NativeMessageQueue();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! nativeMessageQueue) &#123;  </span><br><span class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Unable to allocate native queue\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量</span></span><br><span class=\"line\">    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeInit</code> 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 <code>mPtr</code>，关联了 NativeMessageQueue 和 MessageQueue</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// messsage loop has already quit                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                          </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration                       </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;                                                     </span><br><span class=\"line\">            Binder.flushPendingCommands();                                                    </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class=\"line\">        <span class=\"comment\">// ptr 是在 JNI 层创建的 NativeMessageQueue</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);                                           </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 当前 nativePollOnce 返回后，查看消息队列中是否存在消息</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                 </span><br><span class=\"line\">            <span class=\"comment\">// 尝试检索下一条消息，如果找到则返回                            </span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();                                      </span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">            Message msg = mMessages;                                                          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">                <span class=\"comment\">// 找到下一条异步消息或者没有消息了，则退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;                                                                          </span><br><span class=\"line\">                    prevMsg = msg;                                                            </span><br><span class=\"line\">                    msg = msg.next;                                                           </span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;                                                                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;                                                         </span><br><span class=\"line\">                    <span class=\"comment\">// 下一个消息还没准备好，重新设置唤醒超时时间</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;                                                                      </span><br><span class=\"line\">                    <span class=\"comment\">// 获取一条消息                                                         </span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;                                                    </span><br><span class=\"line\">                        prevMsg.next = msg.next;                                              </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;                                                                  </span><br><span class=\"line\">                        mMessages = msg.next;                                                 </span><br><span class=\"line\">                    &#125;                                                                         </span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"Returning message: \"</span> + msg);</span><br><span class=\"line\">                    <span class=\"comment\">// 标记当前消息已使用</span></span><br><span class=\"line\">                    msg.markInUse();                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;                                                               </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;                                                                          </span><br><span class=\"line\">                <span class=\"comment\">// 当前还没有消息，设置为 -1，无限等待中                                                     </span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;                                                   </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.      </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                  </span><br><span class=\"line\">                dispose();                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                  </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// get pending idle handler count</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span>                                                   </span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;                         </span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">                <span class=\"comment\">// 没有 idle handlers 需要运行，循环继续等待                        </span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                                                                     </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;                                               </span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)]; </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.                                                        </span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration                    </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;                                   </span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];                                </span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>;           </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;                                                             </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;                                                                             </span><br><span class=\"line\">                keep = idler.queueIdle();                                                     </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;                                                           </span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;                                                                      </span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);                                              </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.                     </span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;                                                          </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">//不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                </span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>next</code> 方法中，<code>nativePollOnce</code> 是阻塞操作，其中 <code>nextPollTimeoutMillis</code> 代表下一个消息到来之前，还需要等待的时长；<code>nextPollTimeoutMillis == -1</code> 表示当前没有更多消息。<code>nativePollOnce</code> 调用结束后，从 <code>mMessages</code> 中提取一个消息</p>\n<p>当处于空闲时，执行 <code>IdleHandler</code> 中的回调方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jint ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过前面设置的 mPrt 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr); </span><br><span class=\"line\">    <span class=\"comment\">// 调用 NativeMessageQueue.pollOnce 进行轮询</span></span><br><span class=\"line\">    nativeMessageQueue-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> NativeMessageQueue::pollOnce(<span class=\"keyword\">int</span> timeoutMillis) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将调用转发给了 JNI 层的 Looper</span></span><br><span class=\"line\">    mLooper-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>pollOnce</code> 会调用 <code>pollnner</code> 来进一步操作，如果 <code>pollnner</code> 返回值不等于 0，则返回</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Looper::pollInner(<span class=\"keyword\">int</span> timeoutMillis) &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = ALOOPER_POLL_WAKE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItems</span>[<span class=\"title\">EPOLL_MAX_EVENTS</span>];</span></span><br><span class=\"line\">    <span class=\"comment\">// 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis</span></span><br><span class=\"line\">    <span class=\"comment\">// 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果检查成功或者超时，则结束等待</span></span><br><span class=\"line\">    <span class=\"comment\">// 处于 Idle 状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> acquiredLock = <span class=\"literal\">false</span>;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// eventCount &lt; 0 可能出错了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        LOGW(<span class=\"string\">\"Poll failed with an unexpected error, errno=%d\"</span>, errno);  </span><br><span class=\"line\">        result = ALOOPER_POLL_ERROR;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// eventCount == 0 超时</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        ......  </span><br><span class=\"line\">        result = ALOOPER_POLL_TIMEOUT;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL</span></span><br><span class=\"line\">    <span class=\"comment\">// eventCount &gt; 0 存在事件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd = eventItems[i].data.fd;  </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Looper 中使用 epoll 监听的 EPOLLIN 事件</span></span><br><span class=\"line\">                awoken();  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                LOGW(<span class=\"string\">\"Ignoring unexpected epoll events 0x%x on wake read pipe.\"</span>, epollEvents);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            ......  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquiredLock) &#123;  </span><br><span class=\"line\">        mLock.unlock();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">Done: ;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::awoken() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">16</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nRead;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">        nRead = read(mWakeReadPipeFd, buffer, <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((nRead == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结上面的代码，Looper 通过 <code>loop</code> 调用 MessageQueue 的 <code>next</code>，<code>next</code> 中又会调用到 native 方法 <code>nativePollOnce</code>，在这个方法中，会调用到 NativeMessageQueue 的 <code>pollInner</code>，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 <code>awoken</code>，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;                                                            </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Message must have a target.\"</span>);               </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">\" This message is already in use.\"</span>);       </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                 </span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(                         </span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);      </span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);                                               </span><br><span class=\"line\">            msg.recycle();                                                               </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        msg.markInUse();                                                                 </span><br><span class=\"line\">        msg.when = when;                                                                 </span><br><span class=\"line\">        Message p = mMessages;                                                           </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;                                   </span><br><span class=\"line\">            <span class=\"comment\">// 不存在头部消息或立即执行或执行时机快于头部消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息作为新的头部消息</span></span><br><span class=\"line\">            msg.next = p;                                                                </span><br><span class=\"line\">            mMessages = msg;                                                             </span><br><span class=\"line\">            needWake = mBlocked;                                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                                         </span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息插入到队列的尾部</span></span><br><span class=\"line\">            <span class=\"comment\">// 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();             </span><br><span class=\"line\">            Message prev;                                                                </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;                                                                   </span><br><span class=\"line\">                prev = p;                                                                </span><br><span class=\"line\">                p = p.next;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;                                        </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                               </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;                                    </span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;                                                    </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">            &#125;                                                                            </span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next                                   </span></span><br><span class=\"line\">            prev.next = msg;                                                             </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.                           </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;                                                                  </span><br><span class=\"line\">            nativeWake(mPtr);                                                            </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MessageQueue</code> 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。</p>\n<p>如果当前线程处于空闲等待状态，那么还需要调用 <code>nativeWake</code> 来唤醒：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jobject obj, jint ptr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ptr 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nativeMessageQueue-&gt;wake();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将唤醒请求转发到 Looper <code>wake</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Looper::wake() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nWrite;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先管道中写入 \"W</span></span><br><span class=\"line\">        nWrite = write(mWakeWritePipeFd, <span class=\"string\">\"W\"</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (nWrite == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    .......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 <code>polllnner</code> 中调用 <code>epoll_wait</code> 进入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, <span class=\"keyword\">int</span> what, Object object)</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                               </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                     </span><br><span class=\"line\">        Message p = mMessages;                                </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">// 从队列头部开始，移除连续的所有符合条件的消息                     </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what   </span><br><span class=\"line\">               &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;      </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            <span class=\"comment\">// 找到对应的消息，释放它</span></span><br><span class=\"line\">            p.recycleUnchecked();                             </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">//  从新的队列头部开始，移除全部符合条件的消息                  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;                                   </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;                                  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.what == what           </span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123; </span><br><span class=\"line\">                    Message nn = n.next;                      </span><br><span class=\"line\">                    n.recycleUnchecked();                     </span><br><span class=\"line\">                    p.next = nn;                              </span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;                                 </span><br><span class=\"line\">                &#125;                                             </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSyncBarrier</code> 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 <code>removeSyncBarrier</code></p>\n<p>当 MessageQueue 退出时，需要 <code>dispose</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposes of the underlying message queue.                 </span></span><br><span class=\"line\"><span class=\"comment\">// Must only be called on the looper thread or the finalizer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPtr != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// native 方法</span></span><br><span class=\"line\">        nativeDestroy(mPtr);</span><br><span class=\"line\">        <span class=\"comment\">// mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量</span></span><br><span class=\"line\">        mPtr = <span class=\"number\">0</span>;                                            </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeDestroy</code> 最终会调用 RefBase 的 <code>decStrong</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> RefBase::decStrong(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* id) <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weakref_impl* <span class=\"keyword\">const</span> refs = mRefs;</span><br><span class=\"line\">    refs-&gt;removeStrongRef(id); <span class=\"comment\">//移除强引用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs-&gt;decWeak(id); <span class=\"comment\">// 移除弱引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycleUnchecked</span><span class=\"params\">()</span> </span>&#123;                 </span><br><span class=\"line\">    <span class=\"comment\">// 标记为使用状态，清除其他状态     </span></span><br><span class=\"line\">    flags = FLAG_IN_USE;                  </span><br><span class=\"line\">    what = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg1 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg2 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    obj = <span class=\"keyword\">null</span>;                           </span><br><span class=\"line\">    replyTo = <span class=\"keyword\">null</span>;                       </span><br><span class=\"line\">    sendingUid = -<span class=\"number\">1</span>;                      </span><br><span class=\"line\">    when = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    target = <span class=\"keyword\">null</span>;                        </span><br><span class=\"line\">    callback = <span class=\"keyword\">null</span>;                      </span><br><span class=\"line\">    data = <span class=\"keyword\">null</span>;                          </span><br><span class=\"line\">                                          </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;  </span><br><span class=\"line\">            next = sPool;                 </span><br><span class=\"line\">            sPool = <span class=\"keyword\">this</span>;                 </span><br><span class=\"line\">            sPoolSize++;                  </span><br><span class=\"line\">        &#125;                                 </span><br><span class=\"line\">    &#125;                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;             </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从缓存中获取</span></span><br><span class=\"line\">            Message m = sPool;               </span><br><span class=\"line\">            sPool = m.next;                  </span><br><span class=\"line\">            m.next = <span class=\"keyword\">null</span>;                   </span><br><span class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></span><br><span class=\"line\">            sPoolSize--;                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;                        </span><br><span class=\"line\">        &#125;                                    </span><br><span class=\"line\">    &#125;                                        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://gityuan.com/images/handler/handler_java.jpg\" alt=\"消息机制\" title=\"\">\n                </div>\n                <div class=\"image-caption\">消息机制</div>\n            </figure>\n<p>Java 层：</p>\n<ul>\n<li>Handler 通过 <code>sendMessage</code>，将 Message 通过 <code>MessageQueue.enqueueMessage</code> 添加到队列中</li>\n<li>Looper 通过 <code>loop</code> 提取需要执行的 Message，并交与 <code>Message.target</code> 的 Handler 进行 <code>dispatchMessage</code> 分发</li>\n<li>将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler </li>\n</ul>\n<p>JNI 层：</p>\n<ul>\n<li>线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态</li>\n<li>通过 epoll 机制监听 <code>EPOLLIN</code> 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程</li>\n</ul>\n<p>消息分发的优先级：</p>\n<ol>\n<li><code>Message.callback.run()</code></li>\n<li><code>Handler.mCallback.handleMessage()</code></li>\n<li><code>Handler.handleMessage()</code></li>\n</ol>\n<blockquote>\n<p>EPOLL：Linux 内核的可扩展 I/O 事件通知机制</p>\n<p>PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入</p>\n<p>文件描述符(File descriptor)：用于表述指向<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">文件</a>的引用的抽象化概念</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}