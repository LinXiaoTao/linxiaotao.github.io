{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/main.min.js","path":"js/main.min.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/search.min.js","path":"js/search.min.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/avatar.jpeg","path":"img/avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/indigo/.git","hash":"147fdd26473c66cbc35538ab4fcaa2856afdf230","modified":1523842563769},{"_id":"themes/indigo/.editorconfig","hash":"9b0445427777519defe360ea38c61729d847b3d3","modified":1523842563781},{"_id":"source/.DS_Store","hash":"dfe3c19144aee33a3fcab8091b0eab325ba41612","modified":1525681161108},{"_id":"themes/indigo/LICENSE","hash":"24944bf7920108f5a4790e6071c32e9102760c37","modified":1523842563781},{"_id":"themes/indigo/package.json","hash":"c795e3100ae3655bfa8b39adcca7333a7925b47f","modified":1523842563794},{"_id":"themes/indigo/README.md","hash":"b188fb95a9c16eb188eeffa6caa0895a14676338","modified":1523842563781},{"_id":"themes/indigo/_config.yml","hash":"f505204d970431009405204aaf548490c97598c8","modified":1523842563781},{"_id":"source/_posts/Gradle多项目构建.md","hash":"635bb4c68fd958ca3836824c4165a2d875250599","modified":1525617798140},{"_id":"source/_posts/Gradle多项目实践.md","hash":"0cca966a802c440fa49d60f4af5f850fdf2c1dbd","modified":1525868877414},{"_id":"source/_posts/Activity启动流程-基于Android26.md","hash":"9f2b191ddc0e4be48b2a37a3a7ec567bfb973aa6","modified":1523455530095},{"_id":"source/_posts/可拖拽的网格布局.md","hash":"6a28780e56e4c938cb78d9e5e289745a3724dee2","modified":1531971853674},{"_id":"source/_posts/Android消息机制-Handler.md","hash":"9d208a44a9bedbeca071851197d362ed52e1d594","modified":1523455530096},{"_id":"source/_posts/Gradle插件-基础篇.md","hash":"10b1ab2b68227036421e21e7520651fa4889f8a9","modified":1526720889447},{"_id":"source/_posts/熟悉又陌生的Context.md","hash":"c36ebec0ad795cf51aebba2e77403d9dfe45a48f","modified":1523801531237},{"_id":"source/_posts/hello-world.md","hash":"7d143ea20eb8fe54463dd464d7fe7f6856e9d616","modified":1523455530096},{"_id":"source/_posts/Gradle插件-提高篇.md","hash":"0ac087efbca9e9d94a1754041e1beddb7dafa021","modified":1527396116275},{"_id":"source/_posts/性能优化第一步.md","hash":"21b1e30287fd38be61ef086b412e43a55a3160e0","modified":1524372328967},{"_id":"source/categories/index.md","hash":"01aaad46196103db69d1d2545e486453d0c4cafb","modified":1523782008143},{"_id":"source/_posts/触摸事件实践之路.md","hash":"6617b8ffa54e16f1d9c2c4209ac7a3643fbf041a","modified":1523455530096},{"_id":"source/categories/.DS_Store","hash":"45673a8ec47535550c1655fb6f129816c4bf94f9","modified":1523782076525},{"_id":"source/tags/index.md","hash":"758576e3a3061215a1c02f147bd5e8572df4f3a5","modified":1523781921246},{"_id":"themes/indigo/languages/en.yml","hash":"1957d2bfc3a4cef299f4f169b431e9b1128ba162","modified":1523842563782},{"_id":"themes/indigo/languages/nl-NL","hash":"9085c04491f93066f2369911cc2175b59ae596ad","modified":1523842563782},{"_id":"themes/indigo/languages/zh-TW.yml","hash":"6a9e820be66eb12ae746f2527e0dc1adf927c685","modified":1523842563782},{"_id":"themes/indigo/languages/ja.yml","hash":"74fd480874bf5e773ba7f9d2a94697cda979091f","modified":1523842563782},{"_id":"themes/indigo/languages/zh-CN.yml","hash":"7dc6ae434dde390b6768d244132e23cc78c33817","modified":1523842563782},{"_id":"themes/indigo/layout/categories.ejs","hash":"41783d2069d5080566a99e6312aa2113105f8b41","modified":1523842563792},{"_id":"themes/indigo/layout/archive.ejs","hash":"d039719e21f6a6fa2925b00aaa623a180a78c818","modified":1523842563791},{"_id":"themes/indigo/layout/index.ejs","hash":"39477807b98b2d2df78f3b82498a11e90be8222c","modified":1523842563792},{"_id":"themes/indigo/layout/category.ejs","hash":"7ea26a8a935886963eda82f41c7bd5270cf780d9","modified":1523842563792},{"_id":"themes/indigo/layout/layout.ejs","hash":"d52f43fa9572d70cae834e4887c8897b43744805","modified":1523842563792},{"_id":"themes/indigo/layout/post.ejs","hash":"afbf8532dc8d148ca4dff2ca127a3382907cf2f5","modified":1523842563793},{"_id":"themes/indigo/layout/page.ejs","hash":"afb98face24d39a21ebbbde6592a9afc98572aa4","modified":1523842563793},{"_id":"themes/indigo/layout/tag.ejs","hash":"36786a3de7f6cad58209603f7d84ba23addea174","modified":1523842563793},{"_id":"themes/indigo/layout/tags.ejs","hash":"20466446c41409d14a3d42ccaec24a65a045efef","modified":1523842563793},{"_id":"themes/indigo/scripts/plugins.js","hash":"e439d717513616bedeed37ba9b05117470809b21","modified":1523842563794},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"9ac30b9439fab69973cf4722dbf2945a18fd3804","modified":1523842563782},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"e1a71a30a1c7a664ddf3ba3e7eb3a5b90bc4b33c","modified":1523842563783},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"55cd81ef9183426d6d99fd91550fce0a9cc92aa0","modified":1523842563783},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"02a95a88774cc50dbcc32242b6c8ac7e9d9028bb","modified":1523842563783},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"6156bf20791e46fc1c5872113276c1c1f5c13773","modified":1523842563783},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"ec7b3ec79bbbead9c7e43e2e6c6b5c8bef509410","modified":1523842563783},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1523842563784},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"d39afaad6b0dd2a3ae27e6db3e9a6cd6014622fa","modified":1523842563784},{"_id":"themes/indigo/layout/_partial/paginator.ejs","hash":"dc27242927890f130a64400596b9b7ad5fca8972","modified":1523842563784},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"a87d9b0485b3bf4cdfdad890e5974c43dbaa8240","modified":1523842563787},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"c2091c621b5480ef1e69d72027028cec8e929892","modified":1523842563791},{"_id":"themes/indigo/layout/_partial/tags-bar.ejs","hash":"19eff4876d31080a427644f7a43fe172d0c008c6","modified":1523842563791},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"439d6315a1b16e32b77a68c3f0cb2961d581086a","modified":1523842563791},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1523842563830},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1523842563831},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1523842563831},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1523842563831},{"_id":"themes/indigo/source/css/style.less","hash":"f22d4146e0bdb4485d33f20080c67ba05724afea","modified":1523842563829},{"_id":"themes/indigo/source/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1523842563832},{"_id":"themes/indigo/source/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1523842563832},{"_id":"themes/indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1523842563832},{"_id":"themes/indigo/source/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1523842563832},{"_id":"themes/indigo/source/img/avatar.jpeg","hash":"77063730fe1097a71fa19fcaf6da54ee9c0aad9f","modified":1523842563830},{"_id":"themes/indigo/layout/_partial/post/copyright.ejs","hash":"5305ed30ee35cf50f87656737d0ffe85f5bfc16b","modified":1523842563788},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"bcc3bd7a9023d71778f15e98c88552335ae69a69","modified":1523842563787},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"ea85b46e12d3b9c3612eef7aa76289a663fbc096","modified":1523842563788},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c7476165721a3a5e34d00d8c5c07e1e5474cd800","modified":1523842563787},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"b0c680ce5b8aaf461a6731b1ff1287bd140c168a","modified":1523842563788},{"_id":"themes/indigo/layout/_partial/post/reward-btn.ejs","hash":"41c242fe3159dc68cec8dd00ab6d2663f5a51179","modified":1523842563789},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"11e7d504f7c7a3c4c052da13cfa8ea4862c9383e","modified":1523842563788},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"23719e09689b3afbb19214c6603eb02f896cb9ba","modified":1523842563789},{"_id":"themes/indigo/layout/_partial/post/share-fab.ejs","hash":"93482ad7d1e01b966f5ee1c5d12b88564e02b349","modified":1523842563789},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"8df0d7bf6f8e106cdbdac2dd10a97367aa0695f8","modified":1523842563789},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"b3dc38652c4a018a37418136478dcd522fc49f79","modified":1523842563790},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"062d56cb88ae2be3a6616b911d4ebeffcbfe3cff","modified":1523842563790},{"_id":"themes/indigo/layout/_partial/post/toc.ejs","hash":"ad287a70724eb7cd8cd2a03a45b68032ee99973d","modified":1523842563790},{"_id":"themes/indigo/layout/_partial/post/updated.ejs","hash":"5caa71745aa340ce57938a930f3b898ee7518d74","modified":1523842563790},{"_id":"themes/indigo/layout/_partial/plugins/baidu.ejs","hash":"e44d526029f122e9c2c74f3a647c35002c818cbe","modified":1523842563784},{"_id":"themes/indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"23c101d45911eb0846533aaa2d409c43aa5e899a","modified":1523842563785},{"_id":"themes/indigo/layout/_partial/plugins/disqus.ejs","hash":"4a0c01e4195f685f9825fcd016d01249dbdd52ca","modified":1523842563784},{"_id":"themes/indigo/layout/_partial/plugins/gitment.ejs","hash":"5723d507eca4390e8e5d18c0770e7953b8c22f5a","modified":1523842563785},{"_id":"themes/indigo/layout/_partial/plugins/google-analytics.ejs","hash":"a947f4076b54b48d4df5baf2d5b3c39b632c7576","modified":1523842563785},{"_id":"themes/indigo/layout/_partial/plugins/hyper-comments.ejs","hash":"e5a83acc7c2e385b0c9abf428e86e8fdfd3a5202","modified":1523842563785},{"_id":"themes/indigo/layout/_partial/plugins/mathjax.ejs","hash":"ea603a057196de53bd6afab1fddb93d11f27eb81","modified":1523842563785},{"_id":"themes/indigo/layout/_partial/plugins/page-visit.ejs","hash":"2decb77bf3c1a064ea6ce1d4e78892c434d9c884","modified":1523842563786},{"_id":"themes/indigo/layout/_partial/plugins/site-visit.ejs","hash":"8fbd0910828f1ab6eba728bdecc9811d623baae2","modified":1523842563786},{"_id":"themes/indigo/layout/_partial/plugins/tajs.ejs","hash":"97b48fe10be1c71d4ff25ccec3bd92d97466c9c5","modified":1523842563786},{"_id":"themes/indigo/layout/_partial/plugins/uyan.ejs","hash":"e370bd04ea5cf1c83e0c20516aff7ba3ca8b2d0b","modified":1523842563786},{"_id":"themes/indigo/layout/_partial/plugins/valine.ejs","hash":"a976ca36bd09aeb2902bf94fcc7a59975ea25148","modified":1523842563787},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"d476cd3537bcd8a02d055cc223f5c805b8638cc2","modified":1523842563795},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"7d2a6886265386c640e94ffca3f042675f701a35","modified":1523842563794},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1523842563796},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"90f0948a9182c14b1dac1e9dbed3c883543266f9","modified":1523842563796},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"58492b7cdb45fe09b026b2f34e8ae69c2ddb8228","modified":1523842563796},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"4390ed22abad59c8b28ed1a479a52f15b5f9cf4a","modified":1523842563797},{"_id":"themes/indigo/source/css/_partial/lightbox.less","hash":"9b961eb1d70e7658f42cf2ca895fa5e35a6b6541","modified":1523842563797},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"f9d06a1e24fb4857fd18d7a0bfbb3a0ab2d1c742","modified":1523842563797},{"_id":"themes/indigo/source/css/_partial/page.less","hash":"e92ccb53e6ac73a51498c6a9672db9d0d2bc7f1a","modified":1523842563797},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"1c041bf91106808e5480c60d9ece45431bb503b3","modified":1523842563798},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"4857f90bb57fc22ca3f942d8934d86d5e9e82c1e","modified":1523842563798},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1523842563798},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"1d6641ae7568a0153d24beba9fd9704d2b155f6c","modified":1523842563798},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"27d80bcc96a53dd1e7eaa9a7d746e4b212357302","modified":1523842563799},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"959f4373fda6e45f6a4041a995ed3ea8a05a5170","modified":1523842563799},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"082896b966ed25b39c74e7b007b4f54c235685a4","modified":1523842563799},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"77bfd0b373b0469eb0176167fb076ccda4edf2a7","modified":1523842563799},{"_id":"themes/indigo/source/css/_plugin/valine.less","hash":"ddbb7647d83f732f9b0d5d817d40a748006949cc","modified":1523842563800},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"ca30b732d2efbb0cd55a272ecdabc97f895aee78","modified":1523842563796},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1523842563814},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1523842563817},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1523842563816},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1523842563816},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1523842563819},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1523842563820},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1523842563819},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1523842563822},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1523842563823},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1523842563822},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1523842563826},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1523842563825},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1523842563825},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1523842563828},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1523842563828},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1523842563813},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1523842563813},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1523842563815},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1523842563818},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1523842563821},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1523842563824},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1523842563827},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1523842563802},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1523842563804},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1523842563812},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1523842563809},{"_id":"public/atom.xml","hash":"ecabad726c2bd8b7fb4c31b9c7b8266f8296e7cb","modified":1531971867329},{"_id":"public/content.json","hash":"e13a9495c05e902c7c64a487943d9613d1cff48c","modified":1531971867535},{"_id":"public/tags/index.html","hash":"5ade26cf0c28208fed8fd1ee5f496ad36979eca1","modified":1531971867546},{"_id":"public/archives/index.html","hash":"42973cecc9eb95ccc23c89c39286882579c31556","modified":1531971867546},{"_id":"public/archives/2018/index.html","hash":"2650582639b426242930a1a626a04652ca14b2d4","modified":1531971867547},{"_id":"public/archives/2018/03/index.html","hash":"085e4b4cf3c5b1ba8c73bb6af8327c57109ee132","modified":1531971867547},{"_id":"public/archives/2018/05/index.html","hash":"e40e02e0211af7b3bf615c6633372c07e6b33213","modified":1531971867547},{"_id":"public/categories/Gradle/index.html","hash":"ba9d362817b87c9ce4747f39a6f478020a3df803","modified":1531971867547},{"_id":"public/categories/Android-Framework/index.html","hash":"f1241ee1d7ceaa57eec7e4364b0a97e142f9beec","modified":1531971867547},{"_id":"public/archives/2018/04/index.html","hash":"6314ef4eaaa5d5d5a37f89d755dd52e0307d991d","modified":1531971867547},{"_id":"public/categories/Android-Application/index.html","hash":"b7191da6299c99b9e83d23d8855235756c7344f8","modified":1531971867547},{"_id":"public/categories/随笔/index.html","hash":"527f5d5c65810d50228be2adea52f6c168275e4e","modified":1531971867547},{"_id":"public/categories/index.html","hash":"b9241d23e13b3d924423a7060f5369f4361f6ac2","modified":1531971867547},{"_id":"public/2018/05/08/Gradle多项目实践/index.html","hash":"15e5360de916295cf51a7c3a31060f69c9545661","modified":1531971867547},{"_id":"public/2018/04/19/性能优化第一步/index.html","hash":"467e7fe85483321409ea3111d27cdece585ed7c3","modified":1531971867547},{"_id":"public/2018/04/12/熟悉又陌生的Context/index.html","hash":"51cc01d99b8966c3ca4b47443b46065996db0f46","modified":1531971867548},{"_id":"public/2018/05/21/Gradle插件-提高篇/index.html","hash":"975b2f33cd66ce8ccf0401f3d1662da2a4b093e7","modified":1531971867548},{"_id":"public/2018/04/11/hello-world/index.html","hash":"1b459801a228c2736298a57f68145da10769b05c","modified":1531971867548},{"_id":"public/2018/04/03/触摸事件实践之路/index.html","hash":"0ed1260ef834c07d3e1350e3fc99be3cdf69e078","modified":1531971867548},{"_id":"public/2018/05/16/Gradle插件-基础篇/index.html","hash":"d8433c04bf3d09bb6b5c5ef2ff69c32ac0d0ffc7","modified":1531971867548},{"_id":"public/2018/03/27/Activity启动流程-基于Android26/index.html","hash":"57c12f385a78e6edac4ad8257aa143a16a2f70e6","modified":1531971867548},{"_id":"public/2018/03/23/Android消息机制-Handler/index.html","hash":"afe368d8fb26073ccec99a3bfd0cc644f2f52e65","modified":1531971867548},{"_id":"public/2018/04/29/Gradle多项目构建/index.html","hash":"280324a4bbf58ef64cb701b3b3cab727e4a0b6ad","modified":1531971867548},{"_id":"public/index.html","hash":"70a58079f49b4bedbf4a48f25fdc73424f730fc0","modified":1531971867549},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1531971867554},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1531971867554},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1531971867555},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1531971867555},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1531971867578},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1531971867578},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1531971867579},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1531971867579},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1531971867579},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1531971867579},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1531971867579},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1531971867579},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1531971867579},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1531971867579},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1531971867579},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1531971867579},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1531971867579},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1531971867580},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1531971867580},{"_id":"public/img/avatar.jpeg","hash":"77063730fe1097a71fa19fcaf6da54ee9c0aad9f","modified":1531971867580},{"_id":"public/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1531971867585},{"_id":"public/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1531971867585},{"_id":"public/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1531971867585},{"_id":"public/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1531971867585},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1531971867585},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1531971867585},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1531971867586},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1531971867586},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1531971867586},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1531971867586},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1531971867586},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1531971867591},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1531971867591},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1531971867591},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1531971867599},{"_id":"public/css/style.css","hash":"27f88e278b738328b5acd28e88b5cb20daa490e6","modified":1531971867937}],"Category":[{"name":"Gradle","_id":"cjjs0ht9d0002ero64c26r5k6"},{"name":"Android Framework","_id":"cjjs0ht9i0005ero6gy1ou4tn"},{"name":"随笔","_id":"cjjs0hta4000eero634axbl3t"},{"name":"Android Application","_id":"cjjs0htac000mero68lp7s40t"}],"Data":[],"Page":[{"title":"categories","date":"2018-04-15T08:45:33.000Z","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-04-15 16:45:33\nlayout: categories\ncomments: false\n---\n","updated":"2018-04-15T08:46:48.143Z","path":"categories/index.html","_id":"cjjs0ht9z000aero6fhrisri0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","layout":"tags","comments":0,"date":"2018-04-15T08:44:13.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\nlayout: tags\ncomments: false\ndate: 2018-04-15 16:44:13\n---\n","updated":"2018-04-15T08:45:21.246Z","path":"tags/index.html","_id":"cjjs0hta2000cero6dgg4k8o8","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Gradle多项目构建","date":"2018-04-29T01:57:51.000Z","_content":"\n## 参考\n\n[multi_project_builds](https://docs.gradle.org/current/userguide/multi_project_builds.html)\n\n## 概述\n\n在使用 Android Studio 作为 IDE 之后，Android 项目就开始使用 Gradle 作为构建脚本，Gradle 的优点就不用我多说了，使用 Groovy 作为开发语言，配合各种 Gradle 插件和 DSL 可以实现多样化的构建过程。\n\nGradle 能讲的知识点很多，本文主要讲的是 Gradle 在多项目构建上提供的一些便捷的功能，希望能给大家一些启发。\n\n## 名词解释\n\n* 构建脚本：本文所说的构建脚本指的是 Gradle 文件，以 `.gradle` 为后缀的文件\n* 项目：在多项目构建中，有根项目和子项目。根项目的称呼是相对的，以执行 gradle 命令的目录为根项目，当前目录的子目录称为子项目\n\n## Gradle 多项目构建\n\n首先我们对 Gradle 多项目构建先做下了解，这里所涉及的知识点大部分来源于参考文档。\n\n### 跨项目配置\n\nGradle 提供了在任何构建脚本中访问任何项目，比如可以使用 `allprojects` 来对所有项目进行配置：\n\n``` groovy\nallprojects {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n这个例子我们对所有项目都创建了一个叫 \"hello\" 的 task，如果你只是想对当前项目的子项目进行配置：\n\n``` groovy\nsubprojects {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n当然你也可以针对单个项目进行配置：\n\n``` groovy\nproject (':project') {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n上面所说的操作可以在任何一个构建脚本上执行，所以你可以选择统一写到单独的构建脚本上，再通过 `apply from: \"xxx.gradle\"` 应用进来。\n\n### 边读取边解释\n\n可能有的同学会问，为什么上面要用 doLast，可以不用 doLast，直接写可以吗？\n\n当前可以，但是执行的时机就不一样了，doLast 从字面意思来看，表示在最后执行，那么这个最后指的是什么之后呢。答案就是项目配置评测(evaluation)之后，简单来讲，当 Gradle 开始执行时，会先从根目录的 `settings.gradle` 中读取参与构建的项目，即只有将子项目 `include` 才能参与构建，接着 Gradle 会在每个项目的根目录下读取 `build.gradle` 如果存在的话，即 `build.gradle` 并不是必须的。默认情况下，Gradle 会先读取根项目的配置，即当你执行 Gradle 命令时所在目录的项目。接着按字母排序，读取子项目的配置，当项目配置评测完成之后，再执行对应的 task.doLast。\n\n那有的同学又会问了，那如果直接写，执行的顺序是什么呢？是在评测之后，doLast 之前吗？这可能是写习惯应用程序的同学最常见的误区了，之前博主也是这么想的，后来经过同事的点拨，**Gradle 是边读取边解释**，有点口语化，但确实如此，回到上面的问题，如果直接写在 task 的代码，会在 Gradle 读取到这一行的时候执行，即可能先于其他还没评测的项目执行，我们可以通过一个例子来看下：\n\n这是项目的目录结构：\n\n```\n├── build.gradle\n├── config.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradle.properties\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n├── sub1\n│   └── build.gradle\n└── sub2\n    └── build.gradle\n```\n\n这里我们包含了两个子项目，分别是 `sub1` 和 `sub2`，在每个项目的 `build.gradle` 我们都加上 Log 打印：\n\n``` groovy\nprintln \"$project.name init\"\n\nprintln \"$project.name  end\"\n```\n\n接着我们在根项目的 `build.gradle` 即最外层目录下，添加一个 task：\n\n``` groovy\ntask hello {\n    println \"我直接运行\"\n    doLast {\n        println \"我运行在 doLast\"\n    }\n}\n```\n\n记得在根目录下执行 `./gradlew -q hello`，参数 `-q` 只打印我们的 log，结果如下：\n\n```\nMyApplication init\n我直接运行\nMyApplication  end\nsub1 init\nsub1 end\nsub2 init\nsub2  end\n我运行在 doLast\n```\n\n结果是不是和我们想的一样。接着我们在 sub1 的 `build.gradle` 中增加以下代码：\n\n``` groovy\nprintln \"当前 sub2 是否存在 username 属性：\" + rootProject.project(\":sub2\").findProperty('username')\n\nrootProject.project(\":sub2\") {\n    ext {\n        username = \"Leo\"\n    }\n}\n\nprintln \"当前 sub2 是否存在 username 属性：\" + rootProject.project(\":sub2\").findProperty('username')\n```\n\n上面我们说到，在任何一个构建脚本中，都可以去配置其他项目，所以我们在 sub1 中往 sub2 添加一个变量，然后在 sub2 中将它打印出来：\n\n``` groovy\nprintln \"我的名字是 $project.ext.username\"\n```\n\n执行下：\n\n``` \nMyApplication init\n我直接运行\nMyApplication  end\nsub1 init\n当前 sub2 是否存在 username 属性：null\n当前 sub2 是否存在 username 属性：Leo\nsub1  end\nsub2 init\n我的名字是 Leo\nsub2  end\n我运行在 doLast\n```\n\n是不是非常有意思，要记住：**Gradle 边读取边解释，先评测项目配置，再执行相应的 Task.doLast**\n\n### 执行规则\n\nGradle 执行时，从当前执行的目录开始查看项目结构，即当前目录为根项目，根据目录下的 `setting.gradle` 去评估子项目的配置，执行相应的 Task，我们同样来看个例子：\n\n```\n.\n├── build.gradle\n├── config.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradle.properties\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n├── sub1\n│   └── build.gradle\n└── sub2\n    ├── build.gradle\n    ├── settings.gradle\n    └── sub3\n        └── build.gradle\n```\n\n我们在 sub2 目录下创建一个新的目录 sub3，其中的 `build.gradle` 如下：\n\n``` groovy\nprintln \"rootProject is $rootProject.name\"\n```\n\n代码非常简单，就是输出当前根项目的名称。我们先在最外层的目录下，执行 `./gradlew` 输出如下：\n\n```\nrootProject is MyApplication\n```\n\n记得将 sub3 `include` 到 `settings.gradle` 可以看到当前的根项目名称即为当前运行的目录，接着我们切换到 sub2 目录下执行同样的命令，输出如下：\n\n```\nrootProject is sub2\n```\n\n### 执行顺序\n\n这里我们所说的执行顺序，包括两个方面，第一是项目的评测顺序，第二是各个项目 Task 的执行顺序。\n\n上面我们提到了项目评测顺序是，先评测根项目，接着按字母顺序评测子项目。那我们如果想改变默认顺序，又不想修改名称呢。Gradle 提供了 `evaluationDependsOn` 用于声明某个项目的评测依赖于其他项目的评测，所以会在依赖项目评测完成之后进行。在上面的例子中，sub1 默认会在 sub2 之前执行，但是如果我们在 sub1 项目中增加如下配置：\n\n``` groovy\nprintln \"$project.name init\"\n\nevaluationDependsOn(':sub2')\n\nprintln \"$project.name  end\"\n```\n\n执行 `./gradlew -q` 输出如下：\n\n``` \nsub1 init\nsub2 init\nsub2  end\nsub1  end\n```\n\n结合我们之前说到的，Gradle 是边读取边解释的，那么 `sub1 end` 在最后输出就不难理解了。\n\nGradle 还提供了 `evaluationDependsOnChildren` 声明子项目先于根项目进行评测。\n\nTask 也是类似的，Gradle 提供了 `dependsOn` 去声明某个 Task 依赖于其他 Task，所以会在依赖 Task 执行后执行。使用例子如下：\n\n``` groovy\ntask hello(dependsOn: ':project:task') {\n    \n}\n```\n\n### 项目解耦\n\nGradle 允许任何项目去访问当前多项目构建中其他项目，虽然这很灵活，但使用不当却会导致项目耦合程度高。\n\n例如，我们通过会在根项目中使用 `allprojects` 或者 `subprojects` 进行项目配置注入，但如果我们在子项目中去对其他项目进行配置注入，就会导致项目耦合。同时如果在子项目构建时，去更改其他项目的配置，这同样也会导致项目耦合，并且这两个操作都可能会影响到 **并行模式** 和 **按需配置** 的正确性。\n\n为了更好的使用配置注入和其他优化选项，我们应该：\n\n* 避免在子项目 `build.gradle` 引用其他子项目，更适合在根项目中进行配置注入\n* 避免在构建时更改其他的项目的配置\n\n### 多项目编译和测试\n\n在 Java 插件的 `build` task 通常是用于对单个项目进行编译、测试和应用代码格式化检查等等。在多项目中构建中你可能想要将 task 作用于指定范围内的项目，那么 `buildNeeded` 和 `buildDependents` task 可以帮助你。\n\n> 接下来的例子都是从官方文档中翻译而来的\n\n比如在这个[例子](https://docs.gradle.org/current/userguide/multi_project_builds.html#javadependencies_2)中，`:services:personservice` 项目依赖于 `:api` 和 `:shared` 项目，同时 `:api` 项目也依赖于 `:shared`。\n\n当我们执行 `./gradlew :api:build` 时，输出可能如下：\n\n``` \n> gradle :api:build\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n\nBUILD SUCCESSFUL in 0s\n9 actionable tasks: 9 executed\n```\n\n可以看到，当我们只执行 `:api` 项目的 `build` task，同时也会执行其依赖项目 `:shared` 部分的 task，如果我们确定对 `:api` 项目的修改不会影响 `:share` 项目，可以使用 `-a` 选项参数，这个参数可以让 Gradle 去缓存依赖项目生成的 jars，不重新去编译依赖项目，现在我们增加 `-a` 参数，`./gradlew -a :api:build`，输出可能如下：\n\n```\n> gradle -a :api:build\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n\nBUILD SUCCESSFUL in 0s\n6 actionable tasks: 6 executed\n```\n\n可以看到 `-a` 选项起作用了。\n\n如果你刚刚从版本控制工具中更新了 `:api` 项目依赖的项目，你可能不仅仅想要只执行编译，可能想要去测试它们，那么 `buildNeeded` task 将测试所有依赖项目测试运行时的配置。执行 `./gradlew :api:buildNeeded`，可能输出如下：\n\n```\n> gradle :api:buildNeeded\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n> Task :shared:assemble\n> Task :shared:compileTestJava\n> Task :shared:processTestResources\n> Task :shared:testClasses\n> Task :shared:test\n> Task :shared:check\n> Task :shared:build\n> Task :shared:buildNeeded\n> Task :api:buildNeeded\n\nBUILD SUCCESSFUL in 0s\n12 actionable tasks: 12 executed\n```\n\n有时候你重构了 `:api` 的某些代码，想要测试依赖于 `:api` 项目的其他项目，那么可以使用 `buildDependents`，它可以测试编译依赖指定的项目的所有项目，运行 `./gradlew :api:buildDependents` 输出如下：\n\n``` \n> gradle :api:buildDependents\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n> Task :services:personService:compileJava\n> Task :services:personService:processResources\n> Task :services:personService:classes\n> Task :services:personService:jar\n> Task :services:personService:assemble\n> Task :services:personService:compileTestJava\n> Task :services:personService:processTestResources\n> Task :services:personService:testClasses\n> Task :services:personService:test\n> Task :services:personService:check\n> Task :services:personService:build\n> Task :services:personService:buildDependents\n> Task :api:buildDependents\n\nBUILD SUCCESSFUL in 0s\n17 actionable tasks: 17 executed\n```\n\n最后，如果你在根项目执行的任何 task 都会导致所有项目中存在同名的 task 的执行。\n\n### 属性和方法的继承\n\n在根项目中声明的属性和方法都会继承到子项目中，这是配置注入的替代方式。而配置注入不支持方法，\n\n### 其他选项\n\n#### 并行模式\n\n可以使用 `—parallel` 开启并行模式，这可以减少项目构建时间\n\n#### 按需配置\n\n可以使用 `--configure-on-demand` 开启按需配置，这同样可以减少构建配置时间\n\n## 总结\n\n在上面的篇幅我们着重讲解了 Gradle 对多项目构建的支持，包括跨项目配置，多项目的执行规则和执行顺序，配置注入等等。但理论知识毕竟只是纸上谈兵，下一篇文章会通过具体的项目配置，来讲解实际的使用。","source":"_posts/Gradle多项目构建.md","raw":"---\ntitle: Gradle多项目构建\ndate: 2018-04-29 09:57:51\ncategories: Gradle\ntags:\n---\n\n## 参考\n\n[multi_project_builds](https://docs.gradle.org/current/userguide/multi_project_builds.html)\n\n## 概述\n\n在使用 Android Studio 作为 IDE 之后，Android 项目就开始使用 Gradle 作为构建脚本，Gradle 的优点就不用我多说了，使用 Groovy 作为开发语言，配合各种 Gradle 插件和 DSL 可以实现多样化的构建过程。\n\nGradle 能讲的知识点很多，本文主要讲的是 Gradle 在多项目构建上提供的一些便捷的功能，希望能给大家一些启发。\n\n## 名词解释\n\n* 构建脚本：本文所说的构建脚本指的是 Gradle 文件，以 `.gradle` 为后缀的文件\n* 项目：在多项目构建中，有根项目和子项目。根项目的称呼是相对的，以执行 gradle 命令的目录为根项目，当前目录的子目录称为子项目\n\n## Gradle 多项目构建\n\n首先我们对 Gradle 多项目构建先做下了解，这里所涉及的知识点大部分来源于参考文档。\n\n### 跨项目配置\n\nGradle 提供了在任何构建脚本中访问任何项目，比如可以使用 `allprojects` 来对所有项目进行配置：\n\n``` groovy\nallprojects {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n这个例子我们对所有项目都创建了一个叫 \"hello\" 的 task，如果你只是想对当前项目的子项目进行配置：\n\n``` groovy\nsubprojects {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n当然你也可以针对单个项目进行配置：\n\n``` groovy\nproject (':project') {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n上面所说的操作可以在任何一个构建脚本上执行，所以你可以选择统一写到单独的构建脚本上，再通过 `apply from: \"xxx.gradle\"` 应用进来。\n\n### 边读取边解释\n\n可能有的同学会问，为什么上面要用 doLast，可以不用 doLast，直接写可以吗？\n\n当前可以，但是执行的时机就不一样了，doLast 从字面意思来看，表示在最后执行，那么这个最后指的是什么之后呢。答案就是项目配置评测(evaluation)之后，简单来讲，当 Gradle 开始执行时，会先从根目录的 `settings.gradle` 中读取参与构建的项目，即只有将子项目 `include` 才能参与构建，接着 Gradle 会在每个项目的根目录下读取 `build.gradle` 如果存在的话，即 `build.gradle` 并不是必须的。默认情况下，Gradle 会先读取根项目的配置，即当你执行 Gradle 命令时所在目录的项目。接着按字母排序，读取子项目的配置，当项目配置评测完成之后，再执行对应的 task.doLast。\n\n那有的同学又会问了，那如果直接写，执行的顺序是什么呢？是在评测之后，doLast 之前吗？这可能是写习惯应用程序的同学最常见的误区了，之前博主也是这么想的，后来经过同事的点拨，**Gradle 是边读取边解释**，有点口语化，但确实如此，回到上面的问题，如果直接写在 task 的代码，会在 Gradle 读取到这一行的时候执行，即可能先于其他还没评测的项目执行，我们可以通过一个例子来看下：\n\n这是项目的目录结构：\n\n```\n├── build.gradle\n├── config.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradle.properties\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n├── sub1\n│   └── build.gradle\n└── sub2\n    └── build.gradle\n```\n\n这里我们包含了两个子项目，分别是 `sub1` 和 `sub2`，在每个项目的 `build.gradle` 我们都加上 Log 打印：\n\n``` groovy\nprintln \"$project.name init\"\n\nprintln \"$project.name  end\"\n```\n\n接着我们在根项目的 `build.gradle` 即最外层目录下，添加一个 task：\n\n``` groovy\ntask hello {\n    println \"我直接运行\"\n    doLast {\n        println \"我运行在 doLast\"\n    }\n}\n```\n\n记得在根目录下执行 `./gradlew -q hello`，参数 `-q` 只打印我们的 log，结果如下：\n\n```\nMyApplication init\n我直接运行\nMyApplication  end\nsub1 init\nsub1 end\nsub2 init\nsub2  end\n我运行在 doLast\n```\n\n结果是不是和我们想的一样。接着我们在 sub1 的 `build.gradle` 中增加以下代码：\n\n``` groovy\nprintln \"当前 sub2 是否存在 username 属性：\" + rootProject.project(\":sub2\").findProperty('username')\n\nrootProject.project(\":sub2\") {\n    ext {\n        username = \"Leo\"\n    }\n}\n\nprintln \"当前 sub2 是否存在 username 属性：\" + rootProject.project(\":sub2\").findProperty('username')\n```\n\n上面我们说到，在任何一个构建脚本中，都可以去配置其他项目，所以我们在 sub1 中往 sub2 添加一个变量，然后在 sub2 中将它打印出来：\n\n``` groovy\nprintln \"我的名字是 $project.ext.username\"\n```\n\n执行下：\n\n``` \nMyApplication init\n我直接运行\nMyApplication  end\nsub1 init\n当前 sub2 是否存在 username 属性：null\n当前 sub2 是否存在 username 属性：Leo\nsub1  end\nsub2 init\n我的名字是 Leo\nsub2  end\n我运行在 doLast\n```\n\n是不是非常有意思，要记住：**Gradle 边读取边解释，先评测项目配置，再执行相应的 Task.doLast**\n\n### 执行规则\n\nGradle 执行时，从当前执行的目录开始查看项目结构，即当前目录为根项目，根据目录下的 `setting.gradle` 去评估子项目的配置，执行相应的 Task，我们同样来看个例子：\n\n```\n.\n├── build.gradle\n├── config.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradle.properties\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n├── sub1\n│   └── build.gradle\n└── sub2\n    ├── build.gradle\n    ├── settings.gradle\n    └── sub3\n        └── build.gradle\n```\n\n我们在 sub2 目录下创建一个新的目录 sub3，其中的 `build.gradle` 如下：\n\n``` groovy\nprintln \"rootProject is $rootProject.name\"\n```\n\n代码非常简单，就是输出当前根项目的名称。我们先在最外层的目录下，执行 `./gradlew` 输出如下：\n\n```\nrootProject is MyApplication\n```\n\n记得将 sub3 `include` 到 `settings.gradle` 可以看到当前的根项目名称即为当前运行的目录，接着我们切换到 sub2 目录下执行同样的命令，输出如下：\n\n```\nrootProject is sub2\n```\n\n### 执行顺序\n\n这里我们所说的执行顺序，包括两个方面，第一是项目的评测顺序，第二是各个项目 Task 的执行顺序。\n\n上面我们提到了项目评测顺序是，先评测根项目，接着按字母顺序评测子项目。那我们如果想改变默认顺序，又不想修改名称呢。Gradle 提供了 `evaluationDependsOn` 用于声明某个项目的评测依赖于其他项目的评测，所以会在依赖项目评测完成之后进行。在上面的例子中，sub1 默认会在 sub2 之前执行，但是如果我们在 sub1 项目中增加如下配置：\n\n``` groovy\nprintln \"$project.name init\"\n\nevaluationDependsOn(':sub2')\n\nprintln \"$project.name  end\"\n```\n\n执行 `./gradlew -q` 输出如下：\n\n``` \nsub1 init\nsub2 init\nsub2  end\nsub1  end\n```\n\n结合我们之前说到的，Gradle 是边读取边解释的，那么 `sub1 end` 在最后输出就不难理解了。\n\nGradle 还提供了 `evaluationDependsOnChildren` 声明子项目先于根项目进行评测。\n\nTask 也是类似的，Gradle 提供了 `dependsOn` 去声明某个 Task 依赖于其他 Task，所以会在依赖 Task 执行后执行。使用例子如下：\n\n``` groovy\ntask hello(dependsOn: ':project:task') {\n    \n}\n```\n\n### 项目解耦\n\nGradle 允许任何项目去访问当前多项目构建中其他项目，虽然这很灵活，但使用不当却会导致项目耦合程度高。\n\n例如，我们通过会在根项目中使用 `allprojects` 或者 `subprojects` 进行项目配置注入，但如果我们在子项目中去对其他项目进行配置注入，就会导致项目耦合。同时如果在子项目构建时，去更改其他项目的配置，这同样也会导致项目耦合，并且这两个操作都可能会影响到 **并行模式** 和 **按需配置** 的正确性。\n\n为了更好的使用配置注入和其他优化选项，我们应该：\n\n* 避免在子项目 `build.gradle` 引用其他子项目，更适合在根项目中进行配置注入\n* 避免在构建时更改其他的项目的配置\n\n### 多项目编译和测试\n\n在 Java 插件的 `build` task 通常是用于对单个项目进行编译、测试和应用代码格式化检查等等。在多项目中构建中你可能想要将 task 作用于指定范围内的项目，那么 `buildNeeded` 和 `buildDependents` task 可以帮助你。\n\n> 接下来的例子都是从官方文档中翻译而来的\n\n比如在这个[例子](https://docs.gradle.org/current/userguide/multi_project_builds.html#javadependencies_2)中，`:services:personservice` 项目依赖于 `:api` 和 `:shared` 项目，同时 `:api` 项目也依赖于 `:shared`。\n\n当我们执行 `./gradlew :api:build` 时，输出可能如下：\n\n``` \n> gradle :api:build\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n\nBUILD SUCCESSFUL in 0s\n9 actionable tasks: 9 executed\n```\n\n可以看到，当我们只执行 `:api` 项目的 `build` task，同时也会执行其依赖项目 `:shared` 部分的 task，如果我们确定对 `:api` 项目的修改不会影响 `:share` 项目，可以使用 `-a` 选项参数，这个参数可以让 Gradle 去缓存依赖项目生成的 jars，不重新去编译依赖项目，现在我们增加 `-a` 参数，`./gradlew -a :api:build`，输出可能如下：\n\n```\n> gradle -a :api:build\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n\nBUILD SUCCESSFUL in 0s\n6 actionable tasks: 6 executed\n```\n\n可以看到 `-a` 选项起作用了。\n\n如果你刚刚从版本控制工具中更新了 `:api` 项目依赖的项目，你可能不仅仅想要只执行编译，可能想要去测试它们，那么 `buildNeeded` task 将测试所有依赖项目测试运行时的配置。执行 `./gradlew :api:buildNeeded`，可能输出如下：\n\n```\n> gradle :api:buildNeeded\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n> Task :shared:assemble\n> Task :shared:compileTestJava\n> Task :shared:processTestResources\n> Task :shared:testClasses\n> Task :shared:test\n> Task :shared:check\n> Task :shared:build\n> Task :shared:buildNeeded\n> Task :api:buildNeeded\n\nBUILD SUCCESSFUL in 0s\n12 actionable tasks: 12 executed\n```\n\n有时候你重构了 `:api` 的某些代码，想要测试依赖于 `:api` 项目的其他项目，那么可以使用 `buildDependents`，它可以测试编译依赖指定的项目的所有项目，运行 `./gradlew :api:buildDependents` 输出如下：\n\n``` \n> gradle :api:buildDependents\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n> Task :services:personService:compileJava\n> Task :services:personService:processResources\n> Task :services:personService:classes\n> Task :services:personService:jar\n> Task :services:personService:assemble\n> Task :services:personService:compileTestJava\n> Task :services:personService:processTestResources\n> Task :services:personService:testClasses\n> Task :services:personService:test\n> Task :services:personService:check\n> Task :services:personService:build\n> Task :services:personService:buildDependents\n> Task :api:buildDependents\n\nBUILD SUCCESSFUL in 0s\n17 actionable tasks: 17 executed\n```\n\n最后，如果你在根项目执行的任何 task 都会导致所有项目中存在同名的 task 的执行。\n\n### 属性和方法的继承\n\n在根项目中声明的属性和方法都会继承到子项目中，这是配置注入的替代方式。而配置注入不支持方法，\n\n### 其他选项\n\n#### 并行模式\n\n可以使用 `—parallel` 开启并行模式，这可以减少项目构建时间\n\n#### 按需配置\n\n可以使用 `--configure-on-demand` 开启按需配置，这同样可以减少构建配置时间\n\n## 总结\n\n在上面的篇幅我们着重讲解了 Gradle 对多项目构建的支持，包括跨项目配置，多项目的执行规则和执行顺序，配置注入等等。但理论知识毕竟只是纸上谈兵，下一篇文章会通过具体的项目配置，来讲解实际的使用。","slug":"Gradle多项目构建","published":1,"updated":"2018-05-06T14:43:18.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjs0ht980000ero6nhxg55hz","content":"<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://docs.gradle.org/current/userguide/multi_project_builds.html\" target=\"_blank\" rel=\"noopener\">multi_project_builds</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>在使用 Android Studio 作为 IDE 之后，Android 项目就开始使用 Gradle 作为构建脚本，Gradle 的优点就不用我多说了，使用 Groovy 作为开发语言，配合各种 Gradle 插件和 DSL 可以实现多样化的构建过程。</p>\n<p>Gradle 能讲的知识点很多，本文主要讲的是 Gradle 在多项目构建上提供的一些便捷的功能，希望能给大家一些启发。</p>\n<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><ul>\n<li>构建脚本：本文所说的构建脚本指的是 Gradle 文件，以 <code>.gradle</code> 为后缀的文件</li>\n<li>项目：在多项目构建中，有根项目和子项目。根项目的称呼是相对的，以执行 gradle 命令的目录为根项目，当前目录的子目录称为子项目</li>\n</ul>\n<h2 id=\"Gradle-多项目构建\"><a href=\"#Gradle-多项目构建\" class=\"headerlink\" title=\"Gradle 多项目构建\"></a>Gradle 多项目构建</h2><p>首先我们对 Gradle 多项目构建先做下了解，这里所涉及的知识点大部分来源于参考文档。</p>\n<h3 id=\"跨项目配置\"><a href=\"#跨项目配置\" class=\"headerlink\" title=\"跨项目配置\"></a>跨项目配置</h3><p>Gradle 提供了在任何构建脚本中访问任何项目，比如可以使用 <code>allprojects</code> 来对所有项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子我们对所有项目都创建了一个叫 “hello” 的 task，如果你只是想对当前项目的子项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然你也可以针对单个项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project (<span class=\"string\">':project'</span>) &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面所说的操作可以在任何一个构建脚本上执行，所以你可以选择统一写到单独的构建脚本上，再通过 <code>apply from: &quot;xxx.gradle&quot;</code> 应用进来。</p>\n<h3 id=\"边读取边解释\"><a href=\"#边读取边解释\" class=\"headerlink\" title=\"边读取边解释\"></a>边读取边解释</h3><p>可能有的同学会问，为什么上面要用 doLast，可以不用 doLast，直接写可以吗？</p>\n<p>当前可以，但是执行的时机就不一样了，doLast 从字面意思来看，表示在最后执行，那么这个最后指的是什么之后呢。答案就是项目配置评测(evaluation)之后，简单来讲，当 Gradle 开始执行时，会先从根目录的 <code>settings.gradle</code> 中读取参与构建的项目，即只有将子项目 <code>include</code> 才能参与构建，接着 Gradle 会在每个项目的根目录下读取 <code>build.gradle</code> 如果存在的话，即 <code>build.gradle</code> 并不是必须的。默认情况下，Gradle 会先读取根项目的配置，即当你执行 Gradle 命令时所在目录的项目。接着按字母排序，读取子项目的配置，当项目配置评测完成之后，再执行对应的 task.doLast。</p>\n<p>那有的同学又会问了，那如果直接写，执行的顺序是什么呢？是在评测之后，doLast 之前吗？这可能是写习惯应用程序的同学最常见的误区了，之前博主也是这么想的，后来经过同事的点拨，<strong>Gradle 是边读取边解释</strong>，有点口语化，但确实如此，回到上面的问题，如果直接写在 task 的代码，会在 Gradle 读取到这一行的时候执行，即可能先于其他还没评测的项目执行，我们可以通过一个例子来看下：</p>\n<p>这是项目的目录结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── config.gradle</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradle.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">├── settings.gradle</span><br><span class=\"line\">├── sub1</span><br><span class=\"line\">│   └── build.gradle</span><br><span class=\"line\">└── sub2</span><br><span class=\"line\">    └── build.gradle</span><br></pre></td></tr></table></figure>\n<p>这里我们包含了两个子项目，分别是 <code>sub1</code> 和 <code>sub2</code>，在每个项目的 <code>build.gradle</code> 我们都加上 Log 打印：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"$project.name init\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"$project.name  end\"</span></span><br></pre></td></tr></table></figure>\n<p>接着我们在根项目的 <code>build.gradle</code> 即最外层目录下，添加一个 task：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task hello &#123;</span><br><span class=\"line\">    println <span class=\"string\">\"我直接运行\"</span></span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        println <span class=\"string\">\"我运行在 doLast\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记得在根目录下执行 <code>./gradlew -q hello</code>，参数 <code>-q</code> 只打印我们的 log，结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyApplication init</span><br><span class=\"line\">我直接运行</span><br><span class=\"line\">MyApplication  end</span><br><span class=\"line\">sub1 init</span><br><span class=\"line\">sub1 end</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">我运行在 doLast</span><br></pre></td></tr></table></figure>\n<p>结果是不是和我们想的一样。接着我们在 sub1 的 <code>build.gradle</code> 中增加以下代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"当前 sub2 是否存在 username 属性：\"</span> + rootProject.project(<span class=\"string\">\":sub2\"</span>).findProperty(<span class=\"string\">'username'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">rootProject.project(<span class=\"string\">\":sub2\"</span>) &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"Leo\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"当前 sub2 是否存在 username 属性：\"</span> + rootProject.project(<span class=\"string\">\":sub2\"</span>).findProperty(<span class=\"string\">'username'</span>)</span><br></pre></td></tr></table></figure>\n<p>上面我们说到，在任何一个构建脚本中，都可以去配置其他项目，所以我们在 sub1 中往 sub2 添加一个变量，然后在 sub2 中将它打印出来：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"我的名字是 $project.ext.username\"</span></span><br></pre></td></tr></table></figure>\n<p>执行下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyApplication init</span><br><span class=\"line\">我直接运行</span><br><span class=\"line\">MyApplication  end</span><br><span class=\"line\">sub1 init</span><br><span class=\"line\">当前 sub2 是否存在 username 属性：null</span><br><span class=\"line\">当前 sub2 是否存在 username 属性：Leo</span><br><span class=\"line\">sub1  end</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">我的名字是 Leo</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">我运行在 doLast</span><br></pre></td></tr></table></figure>\n<p>是不是非常有意思，要记住：<strong>Gradle 边读取边解释，先评测项目配置，再执行相应的 Task.doLast</strong></p>\n<h3 id=\"执行规则\"><a href=\"#执行规则\" class=\"headerlink\" title=\"执行规则\"></a>执行规则</h3><p>Gradle 执行时，从当前执行的目录开始查看项目结构，即当前目录为根项目，根据目录下的 <code>setting.gradle</code> 去评估子项目的配置，执行相应的 Task，我们同样来看个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── config.gradle</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradle.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">├── settings.gradle</span><br><span class=\"line\">├── sub1</span><br><span class=\"line\">│   └── build.gradle</span><br><span class=\"line\">└── sub2</span><br><span class=\"line\">    ├── build.gradle</span><br><span class=\"line\">    ├── settings.gradle</span><br><span class=\"line\">    └── sub3</span><br><span class=\"line\">        └── build.gradle</span><br></pre></td></tr></table></figure>\n<p>我们在 sub2 目录下创建一个新的目录 sub3，其中的 <code>build.gradle</code> 如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"rootProject is $rootProject.name\"</span></span><br></pre></td></tr></table></figure>\n<p>代码非常简单，就是输出当前根项目的名称。我们先在最外层的目录下，执行 <code>./gradlew</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject is MyApplication</span><br></pre></td></tr></table></figure>\n<p>记得将 sub3 <code>include</code> 到 <code>settings.gradle</code> 可以看到当前的根项目名称即为当前运行的目录，接着我们切换到 sub2 目录下执行同样的命令，输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject is sub2</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><p>这里我们所说的执行顺序，包括两个方面，第一是项目的评测顺序，第二是各个项目 Task 的执行顺序。</p>\n<p>上面我们提到了项目评测顺序是，先评测根项目，接着按字母顺序评测子项目。那我们如果想改变默认顺序，又不想修改名称呢。Gradle 提供了 <code>evaluationDependsOn</code> 用于声明某个项目的评测依赖于其他项目的评测，所以会在依赖项目评测完成之后进行。在上面的例子中，sub1 默认会在 sub2 之前执行，但是如果我们在 sub1 项目中增加如下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"$project.name init\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">evaluationDependsOn(<span class=\"string\">':sub2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"$project.name  end\"</span></span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew -q</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sub1 init</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">sub1  end</span><br></pre></td></tr></table></figure>\n<p>结合我们之前说到的，Gradle 是边读取边解释的，那么 <code>sub1 end</code> 在最后输出就不难理解了。</p>\n<p>Gradle 还提供了 <code>evaluationDependsOnChildren</code> 声明子项目先于根项目进行评测。</p>\n<p>Task 也是类似的，Gradle 提供了 <code>dependsOn</code> 去声明某个 Task 依赖于其他 Task，所以会在依赖 Task 执行后执行。使用例子如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task hello(<span class=\"string\">dependsOn:</span> <span class=\"string\">':project:task'</span>) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"项目解耦\"><a href=\"#项目解耦\" class=\"headerlink\" title=\"项目解耦\"></a>项目解耦</h3><p>Gradle 允许任何项目去访问当前多项目构建中其他项目，虽然这很灵活，但使用不当却会导致项目耦合程度高。</p>\n<p>例如，我们通过会在根项目中使用 <code>allprojects</code> 或者 <code>subprojects</code> 进行项目配置注入，但如果我们在子项目中去对其他项目进行配置注入，就会导致项目耦合。同时如果在子项目构建时，去更改其他项目的配置，这同样也会导致项目耦合，并且这两个操作都可能会影响到 <strong>并行模式</strong> 和 <strong>按需配置</strong> 的正确性。</p>\n<p>为了更好的使用配置注入和其他优化选项，我们应该：</p>\n<ul>\n<li>避免在子项目 <code>build.gradle</code> 引用其他子项目，更适合在根项目中进行配置注入</li>\n<li>避免在构建时更改其他的项目的配置</li>\n</ul>\n<h3 id=\"多项目编译和测试\"><a href=\"#多项目编译和测试\" class=\"headerlink\" title=\"多项目编译和测试\"></a>多项目编译和测试</h3><p>在 Java 插件的 <code>build</code> task 通常是用于对单个项目进行编译、测试和应用代码格式化检查等等。在多项目中构建中你可能想要将 task 作用于指定范围内的项目，那么 <code>buildNeeded</code> 和 <code>buildDependents</code> task 可以帮助你。</p>\n<blockquote>\n<p>接下来的例子都是从官方文档中翻译而来的</p>\n</blockquote>\n<p>比如在这个<a href=\"https://docs.gradle.org/current/userguide/multi_project_builds.html#javadependencies_2\" target=\"_blank\" rel=\"noopener\">例子</a>中，<code>:services:personservice</code> 项目依赖于 <code>:api</code> 和 <code>:shared</code> 项目，同时 <code>:api</code> 项目也依赖于 <code>:shared</code>。</p>\n<p>当我们执行 <code>./gradlew :api:build</code> 时，输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:build</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">9 actionable tasks: 9 executed</span><br></pre></td></tr></table></figure>\n<p>可以看到，当我们只执行 <code>:api</code> 项目的 <code>build</code> task，同时也会执行其依赖项目 <code>:shared</code> 部分的 task，如果我们确定对 <code>:api</code> 项目的修改不会影响 <code>:share</code> 项目，可以使用 <code>-a</code> 选项参数，这个参数可以让 Gradle 去缓存依赖项目生成的 jars，不重新去编译依赖项目，现在我们增加 <code>-a</code> 参数，<code>./gradlew -a :api:build</code>，输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle -a :api:build</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">6 actionable tasks: 6 executed</span><br></pre></td></tr></table></figure>\n<p>可以看到 <code>-a</code> 选项起作用了。</p>\n<p>如果你刚刚从版本控制工具中更新了 <code>:api</code> 项目依赖的项目，你可能不仅仅想要只执行编译，可能想要去测试它们，那么 <code>buildNeeded</code> task 将测试所有依赖项目测试运行时的配置。执行 <code>./gradlew :api:buildNeeded</code>，可能输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:buildNeeded</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\">&gt; Task :shared:assemble</span><br><span class=\"line\">&gt; Task :shared:compileTestJava</span><br><span class=\"line\">&gt; Task :shared:processTestResources</span><br><span class=\"line\">&gt; Task :shared:testClasses</span><br><span class=\"line\">&gt; Task :shared:test</span><br><span class=\"line\">&gt; Task :shared:check</span><br><span class=\"line\">&gt; Task :shared:build</span><br><span class=\"line\">&gt; Task :shared:buildNeeded</span><br><span class=\"line\">&gt; Task :api:buildNeeded</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">12 actionable tasks: 12 executed</span><br></pre></td></tr></table></figure>\n<p>有时候你重构了 <code>:api</code> 的某些代码，想要测试依赖于 <code>:api</code> 项目的其他项目，那么可以使用 <code>buildDependents</code>，它可以测试编译依赖指定的项目的所有项目，运行 <code>./gradlew :api:buildDependents</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:buildDependents</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\">&gt; Task :services:personService:compileJava</span><br><span class=\"line\">&gt; Task :services:personService:processResources</span><br><span class=\"line\">&gt; Task :services:personService:classes</span><br><span class=\"line\">&gt; Task :services:personService:jar</span><br><span class=\"line\">&gt; Task :services:personService:assemble</span><br><span class=\"line\">&gt; Task :services:personService:compileTestJava</span><br><span class=\"line\">&gt; Task :services:personService:processTestResources</span><br><span class=\"line\">&gt; Task :services:personService:testClasses</span><br><span class=\"line\">&gt; Task :services:personService:test</span><br><span class=\"line\">&gt; Task :services:personService:check</span><br><span class=\"line\">&gt; Task :services:personService:build</span><br><span class=\"line\">&gt; Task :services:personService:buildDependents</span><br><span class=\"line\">&gt; Task :api:buildDependents</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">17 actionable tasks: 17 executed</span><br></pre></td></tr></table></figure>\n<p>最后，如果你在根项目执行的任何 task 都会导致所有项目中存在同名的 task 的执行。</p>\n<h3 id=\"属性和方法的继承\"><a href=\"#属性和方法的继承\" class=\"headerlink\" title=\"属性和方法的继承\"></a>属性和方法的继承</h3><p>在根项目中声明的属性和方法都会继承到子项目中，这是配置注入的替代方式。而配置注入不支持方法，</p>\n<h3 id=\"其他选项\"><a href=\"#其他选项\" class=\"headerlink\" title=\"其他选项\"></a>其他选项</h3><h4 id=\"并行模式\"><a href=\"#并行模式\" class=\"headerlink\" title=\"并行模式\"></a>并行模式</h4><p>可以使用 <code>—parallel</code> 开启并行模式，这可以减少项目构建时间</p>\n<h4 id=\"按需配置\"><a href=\"#按需配置\" class=\"headerlink\" title=\"按需配置\"></a>按需配置</h4><p>可以使用 <code>--configure-on-demand</code> 开启按需配置，这同样可以减少构建配置时间</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在上面的篇幅我们着重讲解了 Gradle 对多项目构建的支持，包括跨项目配置，多项目的执行规则和执行顺序，配置注入等等。但理论知识毕竟只是纸上谈兵，下一篇文章会通过具体的项目配置，来讲解实际的使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://docs.gradle.org/current/userguide/multi_project_builds.html\" target=\"_blank\" rel=\"noopener\">multi_project_builds</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>在使用 Android Studio 作为 IDE 之后，Android 项目就开始使用 Gradle 作为构建脚本，Gradle 的优点就不用我多说了，使用 Groovy 作为开发语言，配合各种 Gradle 插件和 DSL 可以实现多样化的构建过程。</p>\n<p>Gradle 能讲的知识点很多，本文主要讲的是 Gradle 在多项目构建上提供的一些便捷的功能，希望能给大家一些启发。</p>\n<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><ul>\n<li>构建脚本：本文所说的构建脚本指的是 Gradle 文件，以 <code>.gradle</code> 为后缀的文件</li>\n<li>项目：在多项目构建中，有根项目和子项目。根项目的称呼是相对的，以执行 gradle 命令的目录为根项目，当前目录的子目录称为子项目</li>\n</ul>\n<h2 id=\"Gradle-多项目构建\"><a href=\"#Gradle-多项目构建\" class=\"headerlink\" title=\"Gradle 多项目构建\"></a>Gradle 多项目构建</h2><p>首先我们对 Gradle 多项目构建先做下了解，这里所涉及的知识点大部分来源于参考文档。</p>\n<h3 id=\"跨项目配置\"><a href=\"#跨项目配置\" class=\"headerlink\" title=\"跨项目配置\"></a>跨项目配置</h3><p>Gradle 提供了在任何构建脚本中访问任何项目，比如可以使用 <code>allprojects</code> 来对所有项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子我们对所有项目都创建了一个叫 “hello” 的 task，如果你只是想对当前项目的子项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然你也可以针对单个项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project (<span class=\"string\">':project'</span>) &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面所说的操作可以在任何一个构建脚本上执行，所以你可以选择统一写到单独的构建脚本上，再通过 <code>apply from: &quot;xxx.gradle&quot;</code> 应用进来。</p>\n<h3 id=\"边读取边解释\"><a href=\"#边读取边解释\" class=\"headerlink\" title=\"边读取边解释\"></a>边读取边解释</h3><p>可能有的同学会问，为什么上面要用 doLast，可以不用 doLast，直接写可以吗？</p>\n<p>当前可以，但是执行的时机就不一样了，doLast 从字面意思来看，表示在最后执行，那么这个最后指的是什么之后呢。答案就是项目配置评测(evaluation)之后，简单来讲，当 Gradle 开始执行时，会先从根目录的 <code>settings.gradle</code> 中读取参与构建的项目，即只有将子项目 <code>include</code> 才能参与构建，接着 Gradle 会在每个项目的根目录下读取 <code>build.gradle</code> 如果存在的话，即 <code>build.gradle</code> 并不是必须的。默认情况下，Gradle 会先读取根项目的配置，即当你执行 Gradle 命令时所在目录的项目。接着按字母排序，读取子项目的配置，当项目配置评测完成之后，再执行对应的 task.doLast。</p>\n<p>那有的同学又会问了，那如果直接写，执行的顺序是什么呢？是在评测之后，doLast 之前吗？这可能是写习惯应用程序的同学最常见的误区了，之前博主也是这么想的，后来经过同事的点拨，<strong>Gradle 是边读取边解释</strong>，有点口语化，但确实如此，回到上面的问题，如果直接写在 task 的代码，会在 Gradle 读取到这一行的时候执行，即可能先于其他还没评测的项目执行，我们可以通过一个例子来看下：</p>\n<p>这是项目的目录结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── config.gradle</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradle.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">├── settings.gradle</span><br><span class=\"line\">├── sub1</span><br><span class=\"line\">│   └── build.gradle</span><br><span class=\"line\">└── sub2</span><br><span class=\"line\">    └── build.gradle</span><br></pre></td></tr></table></figure>\n<p>这里我们包含了两个子项目，分别是 <code>sub1</code> 和 <code>sub2</code>，在每个项目的 <code>build.gradle</code> 我们都加上 Log 打印：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"$project.name init\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"$project.name  end\"</span></span><br></pre></td></tr></table></figure>\n<p>接着我们在根项目的 <code>build.gradle</code> 即最外层目录下，添加一个 task：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task hello &#123;</span><br><span class=\"line\">    println <span class=\"string\">\"我直接运行\"</span></span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        println <span class=\"string\">\"我运行在 doLast\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记得在根目录下执行 <code>./gradlew -q hello</code>，参数 <code>-q</code> 只打印我们的 log，结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyApplication init</span><br><span class=\"line\">我直接运行</span><br><span class=\"line\">MyApplication  end</span><br><span class=\"line\">sub1 init</span><br><span class=\"line\">sub1 end</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">我运行在 doLast</span><br></pre></td></tr></table></figure>\n<p>结果是不是和我们想的一样。接着我们在 sub1 的 <code>build.gradle</code> 中增加以下代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"当前 sub2 是否存在 username 属性：\"</span> + rootProject.project(<span class=\"string\">\":sub2\"</span>).findProperty(<span class=\"string\">'username'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">rootProject.project(<span class=\"string\">\":sub2\"</span>) &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"Leo\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"当前 sub2 是否存在 username 属性：\"</span> + rootProject.project(<span class=\"string\">\":sub2\"</span>).findProperty(<span class=\"string\">'username'</span>)</span><br></pre></td></tr></table></figure>\n<p>上面我们说到，在任何一个构建脚本中，都可以去配置其他项目，所以我们在 sub1 中往 sub2 添加一个变量，然后在 sub2 中将它打印出来：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"我的名字是 $project.ext.username\"</span></span><br></pre></td></tr></table></figure>\n<p>执行下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyApplication init</span><br><span class=\"line\">我直接运行</span><br><span class=\"line\">MyApplication  end</span><br><span class=\"line\">sub1 init</span><br><span class=\"line\">当前 sub2 是否存在 username 属性：null</span><br><span class=\"line\">当前 sub2 是否存在 username 属性：Leo</span><br><span class=\"line\">sub1  end</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">我的名字是 Leo</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">我运行在 doLast</span><br></pre></td></tr></table></figure>\n<p>是不是非常有意思，要记住：<strong>Gradle 边读取边解释，先评测项目配置，再执行相应的 Task.doLast</strong></p>\n<h3 id=\"执行规则\"><a href=\"#执行规则\" class=\"headerlink\" title=\"执行规则\"></a>执行规则</h3><p>Gradle 执行时，从当前执行的目录开始查看项目结构，即当前目录为根项目，根据目录下的 <code>setting.gradle</code> 去评估子项目的配置，执行相应的 Task，我们同样来看个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── config.gradle</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradle.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">├── settings.gradle</span><br><span class=\"line\">├── sub1</span><br><span class=\"line\">│   └── build.gradle</span><br><span class=\"line\">└── sub2</span><br><span class=\"line\">    ├── build.gradle</span><br><span class=\"line\">    ├── settings.gradle</span><br><span class=\"line\">    └── sub3</span><br><span class=\"line\">        └── build.gradle</span><br></pre></td></tr></table></figure>\n<p>我们在 sub2 目录下创建一个新的目录 sub3，其中的 <code>build.gradle</code> 如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"rootProject is $rootProject.name\"</span></span><br></pre></td></tr></table></figure>\n<p>代码非常简单，就是输出当前根项目的名称。我们先在最外层的目录下，执行 <code>./gradlew</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject is MyApplication</span><br></pre></td></tr></table></figure>\n<p>记得将 sub3 <code>include</code> 到 <code>settings.gradle</code> 可以看到当前的根项目名称即为当前运行的目录，接着我们切换到 sub2 目录下执行同样的命令，输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject is sub2</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><p>这里我们所说的执行顺序，包括两个方面，第一是项目的评测顺序，第二是各个项目 Task 的执行顺序。</p>\n<p>上面我们提到了项目评测顺序是，先评测根项目，接着按字母顺序评测子项目。那我们如果想改变默认顺序，又不想修改名称呢。Gradle 提供了 <code>evaluationDependsOn</code> 用于声明某个项目的评测依赖于其他项目的评测，所以会在依赖项目评测完成之后进行。在上面的例子中，sub1 默认会在 sub2 之前执行，但是如果我们在 sub1 项目中增加如下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"$project.name init\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">evaluationDependsOn(<span class=\"string\">':sub2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"$project.name  end\"</span></span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew -q</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sub1 init</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">sub1  end</span><br></pre></td></tr></table></figure>\n<p>结合我们之前说到的，Gradle 是边读取边解释的，那么 <code>sub1 end</code> 在最后输出就不难理解了。</p>\n<p>Gradle 还提供了 <code>evaluationDependsOnChildren</code> 声明子项目先于根项目进行评测。</p>\n<p>Task 也是类似的，Gradle 提供了 <code>dependsOn</code> 去声明某个 Task 依赖于其他 Task，所以会在依赖 Task 执行后执行。使用例子如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task hello(<span class=\"string\">dependsOn:</span> <span class=\"string\">':project:task'</span>) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"项目解耦\"><a href=\"#项目解耦\" class=\"headerlink\" title=\"项目解耦\"></a>项目解耦</h3><p>Gradle 允许任何项目去访问当前多项目构建中其他项目，虽然这很灵活，但使用不当却会导致项目耦合程度高。</p>\n<p>例如，我们通过会在根项目中使用 <code>allprojects</code> 或者 <code>subprojects</code> 进行项目配置注入，但如果我们在子项目中去对其他项目进行配置注入，就会导致项目耦合。同时如果在子项目构建时，去更改其他项目的配置，这同样也会导致项目耦合，并且这两个操作都可能会影响到 <strong>并行模式</strong> 和 <strong>按需配置</strong> 的正确性。</p>\n<p>为了更好的使用配置注入和其他优化选项，我们应该：</p>\n<ul>\n<li>避免在子项目 <code>build.gradle</code> 引用其他子项目，更适合在根项目中进行配置注入</li>\n<li>避免在构建时更改其他的项目的配置</li>\n</ul>\n<h3 id=\"多项目编译和测试\"><a href=\"#多项目编译和测试\" class=\"headerlink\" title=\"多项目编译和测试\"></a>多项目编译和测试</h3><p>在 Java 插件的 <code>build</code> task 通常是用于对单个项目进行编译、测试和应用代码格式化检查等等。在多项目中构建中你可能想要将 task 作用于指定范围内的项目，那么 <code>buildNeeded</code> 和 <code>buildDependents</code> task 可以帮助你。</p>\n<blockquote>\n<p>接下来的例子都是从官方文档中翻译而来的</p>\n</blockquote>\n<p>比如在这个<a href=\"https://docs.gradle.org/current/userguide/multi_project_builds.html#javadependencies_2\" target=\"_blank\" rel=\"noopener\">例子</a>中，<code>:services:personservice</code> 项目依赖于 <code>:api</code> 和 <code>:shared</code> 项目，同时 <code>:api</code> 项目也依赖于 <code>:shared</code>。</p>\n<p>当我们执行 <code>./gradlew :api:build</code> 时，输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:build</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">9 actionable tasks: 9 executed</span><br></pre></td></tr></table></figure>\n<p>可以看到，当我们只执行 <code>:api</code> 项目的 <code>build</code> task，同时也会执行其依赖项目 <code>:shared</code> 部分的 task，如果我们确定对 <code>:api</code> 项目的修改不会影响 <code>:share</code> 项目，可以使用 <code>-a</code> 选项参数，这个参数可以让 Gradle 去缓存依赖项目生成的 jars，不重新去编译依赖项目，现在我们增加 <code>-a</code> 参数，<code>./gradlew -a :api:build</code>，输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle -a :api:build</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">6 actionable tasks: 6 executed</span><br></pre></td></tr></table></figure>\n<p>可以看到 <code>-a</code> 选项起作用了。</p>\n<p>如果你刚刚从版本控制工具中更新了 <code>:api</code> 项目依赖的项目，你可能不仅仅想要只执行编译，可能想要去测试它们，那么 <code>buildNeeded</code> task 将测试所有依赖项目测试运行时的配置。执行 <code>./gradlew :api:buildNeeded</code>，可能输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:buildNeeded</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\">&gt; Task :shared:assemble</span><br><span class=\"line\">&gt; Task :shared:compileTestJava</span><br><span class=\"line\">&gt; Task :shared:processTestResources</span><br><span class=\"line\">&gt; Task :shared:testClasses</span><br><span class=\"line\">&gt; Task :shared:test</span><br><span class=\"line\">&gt; Task :shared:check</span><br><span class=\"line\">&gt; Task :shared:build</span><br><span class=\"line\">&gt; Task :shared:buildNeeded</span><br><span class=\"line\">&gt; Task :api:buildNeeded</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">12 actionable tasks: 12 executed</span><br></pre></td></tr></table></figure>\n<p>有时候你重构了 <code>:api</code> 的某些代码，想要测试依赖于 <code>:api</code> 项目的其他项目，那么可以使用 <code>buildDependents</code>，它可以测试编译依赖指定的项目的所有项目，运行 <code>./gradlew :api:buildDependents</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:buildDependents</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\">&gt; Task :services:personService:compileJava</span><br><span class=\"line\">&gt; Task :services:personService:processResources</span><br><span class=\"line\">&gt; Task :services:personService:classes</span><br><span class=\"line\">&gt; Task :services:personService:jar</span><br><span class=\"line\">&gt; Task :services:personService:assemble</span><br><span class=\"line\">&gt; Task :services:personService:compileTestJava</span><br><span class=\"line\">&gt; Task :services:personService:processTestResources</span><br><span class=\"line\">&gt; Task :services:personService:testClasses</span><br><span class=\"line\">&gt; Task :services:personService:test</span><br><span class=\"line\">&gt; Task :services:personService:check</span><br><span class=\"line\">&gt; Task :services:personService:build</span><br><span class=\"line\">&gt; Task :services:personService:buildDependents</span><br><span class=\"line\">&gt; Task :api:buildDependents</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">17 actionable tasks: 17 executed</span><br></pre></td></tr></table></figure>\n<p>最后，如果你在根项目执行的任何 task 都会导致所有项目中存在同名的 task 的执行。</p>\n<h3 id=\"属性和方法的继承\"><a href=\"#属性和方法的继承\" class=\"headerlink\" title=\"属性和方法的继承\"></a>属性和方法的继承</h3><p>在根项目中声明的属性和方法都会继承到子项目中，这是配置注入的替代方式。而配置注入不支持方法，</p>\n<h3 id=\"其他选项\"><a href=\"#其他选项\" class=\"headerlink\" title=\"其他选项\"></a>其他选项</h3><h4 id=\"并行模式\"><a href=\"#并行模式\" class=\"headerlink\" title=\"并行模式\"></a>并行模式</h4><p>可以使用 <code>—parallel</code> 开启并行模式，这可以减少项目构建时间</p>\n<h4 id=\"按需配置\"><a href=\"#按需配置\" class=\"headerlink\" title=\"按需配置\"></a>按需配置</h4><p>可以使用 <code>--configure-on-demand</code> 开启按需配置，这同样可以减少构建配置时间</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在上面的篇幅我们着重讲解了 Gradle 对多项目构建的支持，包括跨项目配置，多项目的执行规则和执行顺序，配置注入等等。但理论知识毕竟只是纸上谈兵，下一篇文章会通过具体的项目配置，来讲解实际的使用。</p>\n"},{"title":"Gradle多项目实践","date":"2018-05-08T10:58:17.000Z","_content":"\n## 前言\n\n上篇文章中，我们说到了 [Gradle多项目构建](https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/) 的一些知识点，但这些总归只是纸上谈兵，今天我们在实际项目中通过之前学到的知识去改造下项目的 Gradle 构建脚本，充分利用 Gradle 带来的好处。\n\n虽然使用 Gradle 作为构建工具已经有一段时间了，但很多同学对它还是很陌生的，基本都是沿用 Android Studio 默认生成的配置，用的比较多的可能也只是 `dependencies` 配置，从不同的 `repositories` 去下载依赖，可能在需要实现一些自定义配置的时候，就去 google 后照搬代码，对其配置参数也是似懂非懂，出了问题不知道如何下手解决，所以这篇文章的主要目的是，实践 Gradle 在 Android 上的运用，对 Gradle 的使用有基本认识。\n\n[项目源码](https://github.com/LinXiaoTao/GradleCaseProject)\n\n## 改造开始\n\n### Gradle 知识\n\n我们先看下 Android Studio 默认帮我们生成的配置代码：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    // android 构建配置\n}\n\ndependencies {\n \t// 依赖配置\n}\n\n```\n\n先简单讲下上面各部分的配置含义，首先我们知道如果不先 `apply plugin: 'com.android.application'` 就不会有 `android` 配置选项，那么这个配置选项具体是什么内容呢？我们可以通过源码了解下，`com.android.application` 这个插件就是我们在根目录下的 *build.gradle* 中导入的：\n\n``` groovy\nbuildscript {\n    repositories {\n        // 构建脚本依赖源地址\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.1.2'\n    }\n}\n```\n\n对 Gradle Plugin 有点了解的同学都知道，Gradle Plugin 需要定义到 *META-INF* 中，浏览 *gradle-3.1.2.jar*，*META-INF* 目录如下：\n\n```\n├── MANIFEST.MF\n├── gradle-plugins\n│   ├── android-library.properties\n│   ├── android-reporting.properties\n│   ├── android.properties\n│   ├── com.android.application.properties\n│   ├── com.android.atom.properties\n│   ├── com.android.bundle.properties\n│   ├── com.android.debug.structure.properties\n│   ├── com.android.feature.properties\n│   ├── com.android.instantapp.properties\n│   ├── com.android.library.properties\n│   ├── com.android.lint.properties\n│   └── com.android.test.properties\n```\n\n这里对应的是提供的各个插件的配置，比如 *com.android.application.properties* 就表示 `com.android.application` 插件，其他也是一样，properties 的名称表示插件的名称。*com.android.application.properties* 的内容如下：\n\n```\nimplementation-class=com.android.build.gradle.AppPlugin\n```\n\n`com.android.build.gradle.AppPlugin` 这个类就是 Application Plugin 的源码。阅读 AppPlugin 源码，我们可以看到这一段：\n\n``` groovy\n\t@NonNull\n    @Override\n    protected BaseExtension createExtension(\n            @NonNull Project project,\n            @NonNull ProjectOptions projectOptions,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull SdkHandler sdkHandler,\n            @NonNull NamedDomainObjectContainer<BuildType> buildTypeContainer,\n            @NonNull NamedDomainObjectContainer<ProductFlavor> productFlavorContainer,\n            @NonNull NamedDomainObjectContainer<SigningConfig> signingConfigContainer,\n            @NonNull NamedDomainObjectContainer<BaseVariantOutput> buildOutputs,\n            @NonNull SourceSetManager sourceSetManager,\n            @NonNull ExtraModelInfo extraModelInfo) {\n        return project.getExtensions()\n                .create(\n                        \"android\",\n                        AppExtension.class,\n                        project,\n                        projectOptions,\n                        androidBuilder,\n                        sdkHandler,\n                        buildTypeContainer,\n                        productFlavorContainer,\n                        signingConfigContainer,\n                        buildOutputs,\n                        sourceSetManager,\n                        extraModelInfo);\n    }\n```\n\n首先我们先通过 API 文档了解下 [project.extensions](https://docs.gradle.org/current/dsl/org.gradle.api.Project.html) 的定义：\n\n```\n定义：\n\tExtensionContainer extensions (read-only)\n说明：\n\tAllows adding DSL extensions to the project. Useful for plugin authors.\n\t允许向项目添加 DSL 扩展，对插件作者很有用\n```\n\n接着我们看下 [`ExtensionContainer.create`](https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/ExtensionContainer.html#create-java.lang.String-java.lang.Class-java.lang.Object...-) 方法的定义：\n\n```\n定义：\n\t<T> T create(String name,Class<T> type,Object... constructionArguments)\n说明：\n\tCreates and adds a new extension to this container. A new instance of the given type will be created using the given constructionArguments. The extension will be exposed as type unless the extension itself declares a preferred public type via the HasPublicType protocol. The new instance will have been dynamically made ExtensionAware, which means that you can cast it to ExtensionAware.\n\t向项目创建并且添加一个新的扩展。通过给定的 type 创建一个新的实例，使用给定的 constructionArguments 构造函数参数。可以通过 HasPublicType 接口声明对外开放的类型，否则整个扩展将对外开放。新的实例将动态生成为 \nExtensionAware，这意味着你可以将它转换成 ExtensionAware\n```\n\n现在我们可以知道，为什么在引入 `com.android.application` 之后才能使用 `android` 配置块，这也意味着，`android` 所能提供的配置依赖于 `AppExtension` 这个类。\n\n这里我们简单就 `defaultConfig` 这个做下分析，先看下这个类在 `AppExtension` 中的配置，因为 `AppExtension` 直接调用超类 `TestedExtension` 的构造方法，而 `TestedExtension` 又会调用超类 `BaseExtension` 所以我们直接看到 `BaseExtension`：\n\n``` java\nprivate final DefaultConfig defaultConfig;\n\ndefaultConfig = objectFactory.newInstance(\n                        DefaultConfig.class,\n                        BuilderConstants.MAIN,\n                        project,\n                        objectFactory,\n                        extraModelInfo.getDeprecationReporter(),\n                        project.getLogger());\n```\n\n这里我们先不关心 `objectFactory.newInstance` 只需要知道，当我们在 `android` 配置块中，配置 `defaultConfig` 实质上也是，对 `DefaultConfig` 的配置，而 `DefaultConfig` 又继承于 `DefaultProductFlavor`，相关的配置同时也是 `DefaultProductFlavor` 的成员属性：\n\n> DefaultProductFlavor 位于 `builder-3.1.2.jar`\n>\n> Android Gradle Plugin 相关代码分别位于 `gradle-3.1.2.jar`、`gradle-api-3.1.2.jar`、`gradle-core-3.1.2.jar`\n>\n> 如果想查看源码，则下载 sources 包，比如 [builder-3.1.2-sources.jar](https://dl.google.com/dl/android/maven2/com/android/tools/build/builder/3.1.2/builder-3.1.2-sources.jar)，其他 jar 下载方法类似\n>\n> 心好累，各种继承。。。\n\n``` java\npublic class DefaultProductFlavor extends BaseConfigImpl implements ProductFlavor {\n    private static final long serialVersionUID = 1L;\n\n    @NonNull\n    private final String mName;\n    @Nullable\n    private String mDimension;\n    @Nullable\n    private ApiVersion mMinSdkVersion;\n    @Nullable\n    private ApiVersion mTargetSdkVersion;\n    @Nullable\n    private Integer mMaxSdkVersion;\n    @Nullable\n    private Integer mRenderscriptTargetApi;\n    @Nullable\n    private Boolean mRenderscriptSupportModeEnabled;\n    @Nullable\n    private Boolean mRenderscriptSupportModeBlasEnabled;\n    @Nullable\n    private Boolean mRenderscriptNdkModeEnabled;\n    @Nullable\n    private Integer mVersionCode;\n    @Nullable\n    private String mVersionName;\n    @Nullable\n    private String mApplicationId;\n    @Nullable\n    private String mTestApplicationId;\n    @Nullable\n    private String mTestInstrumentationRunner;\n    @NonNull\n    private Map<String, String> mTestInstrumentationRunnerArguments = Maps.newHashMap();\n    @Nullable\n    private Boolean mTestHandleProfiling;\n    @Nullable\n    private Boolean mTestFunctionalTest;\n    @Nullable\n    private SigningConfig mSigningConfig;\n    @Nullable\n    private Set<String> mResourceConfiguration;\n    @NonNull\n    private DefaultVectorDrawablesOptions mVectorDrawablesOptions;\n    @Nullable\n    private Boolean mWearAppUnbundled;\n}\n```\n\n### 重复配置处理\n\n当我们项目不止只有一个 app module 时，那么在其他 module 中，例如下面这些配置都需要去配置下：\n\n``` groovy\ndefaultConfig {\n        minSdkVersion 21\n        targetSdkVersion 27\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\n    }\n```\n\n这样就显得很繁琐又不灵活，比如现在很多项目都开始进行组件化，有的 module 有时候是 `com.android.application`，有的时候又是  `com.android.library` 这样又得根据条件写两套配置，如果其中一个更改了，还得去挨个 module 中更改。\n\n而利用 Gradle 多项目构建，我们可以将这些重复配置都统一处理，还可以根据属性自动导入不同的 plugin。首先为了统一管理各种版本号，我们先新建一个 *constants.gradle* 将一些常量写入到 ext 中：\n\n``` groovy\nproject.ext {\n    compileSdkVersion = 27\n    \n    minSdkVersion = 21\n    \n    targetSdkVersion = 27\n    \n    versionCode = 1\n    \n    versionName = \"1.0\"\n}\n```\n\n>  ext 实际上是 [ExtraPropertiesExtension](https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html) 类型，它类似 map，可以存储 key/value 键值对。ext 也是扩展的一种，可以通过 `project.extensions.getByName('ext')` 获取实例，所有的 [`ExtensionAware`](https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtensionAware.html) 都拥有一个 `ext`，而 Project 又是继承于  `ExtensionAware`\n\n接着我们在各个 module 中创建一个 `gradle.properties` ，这个文件默认会被读取，在其中定义一个属性 `isApplication`，根据这个属性导入不同的 plugin：\n\n``` groovy\n// library module\nisApplication=false\n\n// application module\nisApplication=true\n```\n\n接着创建 *init.gradle*，在 `subprojects` 中配置，这里的配置对所有的子项目都会生效：\n\n``` groovy\nsubprojects {\n    if (project.isApplication.toBoolean()) {\n        // 当前 module 导入 application plugin\n        project.plugins.apply(\"com.android.application\")\n    } else {\n        project.plugins.apply(\"com.android.library\")\n    }\n}\n```\n\n> 这里有点地方需要注意下，因为属性的获取都是通过 String 类型，所以我们需要明确使用 `toBoolean()` 去转化成布尔值\n\n最后要想使得这些 gradle 文件生效，需要将它们 apply 进去，因为 Gradle 默认只会识别 `build.gradle`，还记得我们在 [Gradle多项目构建](https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/) 中说到，*Gradle 是边读取边执行的* ，这意味着你需要在使用到 `android` 构建块之前，将 plugin apply 进去，所以我们将这些 gradle 文件在根目录的 *build.gradle* 中 apply，因为默认根目录的优先级最高：\n\n``` groovy\n// constants.gradle 需要在 init.gradle，因为 init.gradle 后面会使用到 constants.gradle 中定义的值，理由如上\napply from: 'gradle/constants.gradle'\napply from: 'gradle/init.gradle'\n```\n\n我们将 module 下 *build.gradle* 中的 apply 代码删除，重新同步下，可以发现 `android` 配置块依然生效，这意味着，我们 apply plugin 操作成功了。\n\n在处理完 plugin 之后，我们可以将 `android` 配置块中的重复配置也在 *init.gradle* 中去配置：\n\n``` groovy\nsubprojects {\n    if (project.isApplication.toBoolean()) {\n        // 当前 module 导入 application plugin\n        project.plugins.apply(\"com.android.application\")\n    } else {\n        project.plugins.apply(\"com.android.library\")\n    }\n    android {\n        compileSdkVersion rootProject.ext['compileSdkVersion']\n        defaultConfig {\n            minSdkVersion rootProject.ext['minSdkVersion']\n            targetSdkVersion rootProject.ext['targetSdkVersion']\n            versionCode rootProject.ext['versionCode']\n            versionName rootProject.ext['versionName']\n            testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n        }\n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            }\n        }\n    }\n\n}\n```\n\n是不是非常方便，这样统一的配置你只需要写一次，不只是 `android` 配置块可以这么处理，其他的配置也可以这么处理。\n\n### 依赖管理\n\n一般情况下，我们会在各个 module 下去编写所需的依赖配置，比如通过 `implementation 'com.android.support:appcompat-v7:27.1.1'` 去从 maven 中心仓库或者 jcenter 中下载依赖，但这样有个不好的地方就是依赖配置太分散了，只能到每个 module 目录中的 *build.gradle* 去管理，如果我们将这个写到统一的 Gradle 构建脚本中，是不是会更好点，我们同样创建个 *dependencies.gradle*，将共同的依赖写到 `subprojects` ，特有的依赖写到单独的项目配置中，同样这个文件需要在根目录的 *build.gradle* 中 apply：\n\n``` groovy\nsubprojects {\n    dependencies {\n        testImplementation rootProject.ext.dependencies['junit']\n        androidTestImplementation rootProject.ext.dependencies['runner']\n        androidTestImplementation rootProject.ext.dependencies['espresso-core']\n    }\n}\n\nproject(':mylibrary') {\n    dependencies {\n        api fileTree(dir: 'libs', include: ['*.jar'])\n        api rootProject.ext.dependencies['appcompat-v7']\n        api rootProject.ext.dependencies['constraint-layout']\n    }\n}\n\nproject(':app') {\n    dependencies {\n        implementation fileTree(dir: 'libs', include: ['*.jar'])\n        implementation project(\":mylibrary\")\n    }\n}\n```\n\n我们可以将共同的依赖写到 `subprojects` 块，单独项目的配置写到各自的配置块下。\n\n现在我们再来解决另外一个常见的问题：依赖冲突，比如不同的依赖项各自又依赖于同一个库的不同版本，默认 [Gradle 会用这个重复库的最高版本](https://docs.gradle.org/current/userguide/troubleshooting_dependency_resolution.html#sub:version_conflicts)，但如果你配置了 `resolutionStrategy.failOnVersionConflict()` 即当出现版本冲突则失败，或者版本选择不合适，等等，就会出现依赖冲突问题。\n\n我们通过个例子来证实默认的处理策略，我们在 app 模块中去依赖  `com.android.support:design:27.1.1` 和 `com.android.support:recyclerview-v7:26.1.0` ，而 `design` 会自动去依赖 `com.android.support:recyclerview-v7:27.1.1`，依赖关系我们可以通过 `./gradlew :app:dependencies` 这个 Task 去查看，这里我们只查看 *releaseCompileClasspath* 依赖配置中 `design` 和 `recyclerview` 的情况：\n\n```\n+--- project :mylibrary\n|    \\--- com.android.support:design:27.1.1\n|         +--- com.android.support:support-v4:27.1.1\n|         |    +--- com.android.support:support-compat:27.1.1 (*)\n|         |    +--- com.android.support:support-media-compat:27.1.1\n|         |    |    +--- com.android.support:support-annotations:27.1.1\n|         |    |    \\--- com.android.support:support-compat:27.1.1 (*)\n|         |    +--- com.android.support:support-core-utils:27.1.1 (*)\n|         |    +--- com.android.support:support-core-ui:27.1.1 (*)\n|         |    \\--- com.android.support:support-fragment:27.1.1 (*)\n|         +--- com.android.support:appcompat-v7:27.1.1 (*)\n|         +--- com.android.support:recyclerview-v7:27.1.1\n|         |    +--- com.android.support:support-annotations:27.1.1\n|         |    +--- com.android.support:support-compat:27.1.1 (*)\n|         |    \\--- com.android.support:support-core-ui:27.1.1 (*)\n|         \\--- com.android.support:transition:27.1.1\n|              +--- com.android.support:support-annotations:27.1.1\n|              \\--- com.android.support:support-compat:27.1.1 (*)\n\\--- com.android.support:recyclerview-v7:26.1.0 -> 27.1.1 (*)\n```\n\n可以看到我们依赖的 26.1.0 已经被替换成 27.1.1，如果这是我们想要的结果，那就很理想，但是如果我们想要去定义依赖冲突的策略呢？同样的，Gradle 也提供了相应的 API。\n\n还是上面的例子，如果我们不想要使用 `design` 中的 `recyclerview` 而想要我们单独依赖的 `recyclerview-v7:26.1.1` 这里我们有几种方式解决：\n\n1. 不传递依赖\n\n   ``` groovy\n   api(rootProject.ext.dependencies['design']) {\n               transitive = false\n   }\n   ```\n\n2. 强制使用当前版本\n\n   ``` groovy\n   implementation(rootProject.ext.dependencies['recyclerview']) {\n               force = true\n   }\n   ```\n\n其他的解决方案可以参考[官方文档](https://docs.gradle.org/current/userguide/introduction_dependency_management.html)\n\n这里我们使用 Gradle 提供的 [resolutionStrategy](https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html) 方案： \n\n``` groovy\nsubprojects {\n    configurations.all {\n        resolutionStrategy {\n            force rootProject.ext.dependencies['recyclerview']\n        }\n    }\n}\n```\n\n`configurations` 表示当前项目的依赖配置容器，`configurations.all` 表示当前项目的所有依赖配置，上面的配置表示，遍历当前项目的所有依赖配置，设置其依赖解决策略为 **强制使用指定的版本**\n\n## 改造结束\n\n现在我们再来对比下，默认生成的构建配置和改造后的构建配置：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 27\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n        minSdkVersion 21\n        targetSdkVersion 27\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.android.support:appcompat-v7:27.1.1'\n    implementation 'com.android.support.constraint:constraint-layout:1.1.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n}\n\n```\n\n``` groovy\nandroid {\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n    }\n}\n```\n\n是不是简洁了不少，重复的配置项我们交给统一的配置文件去做，依赖配置也是如此，包括依赖冲突的解决策略，但是 Gradle 能实现的不仅仅如此，还有强大的自定义 Gradle Plugin 我们还没讲到。\n\n## 总结\n\n通过这篇文章，不仅仅是教会大家如何去编写简单的 Gradle 构建脚本，更重要的想让大家对 Gradle 有个初步的认识，知道 Gradle 的配置块是如何生成的，更多知识可以通过[官方文档](https://docs.gradle.org/current/userguide/userguide.html)去获取。","source":"_posts/Gradle多项目实践.md","raw":"---\ntitle: Gradle多项目实践\ndate: 2018-05-08 18:58:17\ncategories: Gradle\ntags:\n---\n\n## 前言\n\n上篇文章中，我们说到了 [Gradle多项目构建](https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/) 的一些知识点，但这些总归只是纸上谈兵，今天我们在实际项目中通过之前学到的知识去改造下项目的 Gradle 构建脚本，充分利用 Gradle 带来的好处。\n\n虽然使用 Gradle 作为构建工具已经有一段时间了，但很多同学对它还是很陌生的，基本都是沿用 Android Studio 默认生成的配置，用的比较多的可能也只是 `dependencies` 配置，从不同的 `repositories` 去下载依赖，可能在需要实现一些自定义配置的时候，就去 google 后照搬代码，对其配置参数也是似懂非懂，出了问题不知道如何下手解决，所以这篇文章的主要目的是，实践 Gradle 在 Android 上的运用，对 Gradle 的使用有基本认识。\n\n[项目源码](https://github.com/LinXiaoTao/GradleCaseProject)\n\n## 改造开始\n\n### Gradle 知识\n\n我们先看下 Android Studio 默认帮我们生成的配置代码：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    // android 构建配置\n}\n\ndependencies {\n \t// 依赖配置\n}\n\n```\n\n先简单讲下上面各部分的配置含义，首先我们知道如果不先 `apply plugin: 'com.android.application'` 就不会有 `android` 配置选项，那么这个配置选项具体是什么内容呢？我们可以通过源码了解下，`com.android.application` 这个插件就是我们在根目录下的 *build.gradle* 中导入的：\n\n``` groovy\nbuildscript {\n    repositories {\n        // 构建脚本依赖源地址\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.1.2'\n    }\n}\n```\n\n对 Gradle Plugin 有点了解的同学都知道，Gradle Plugin 需要定义到 *META-INF* 中，浏览 *gradle-3.1.2.jar*，*META-INF* 目录如下：\n\n```\n├── MANIFEST.MF\n├── gradle-plugins\n│   ├── android-library.properties\n│   ├── android-reporting.properties\n│   ├── android.properties\n│   ├── com.android.application.properties\n│   ├── com.android.atom.properties\n│   ├── com.android.bundle.properties\n│   ├── com.android.debug.structure.properties\n│   ├── com.android.feature.properties\n│   ├── com.android.instantapp.properties\n│   ├── com.android.library.properties\n│   ├── com.android.lint.properties\n│   └── com.android.test.properties\n```\n\n这里对应的是提供的各个插件的配置，比如 *com.android.application.properties* 就表示 `com.android.application` 插件，其他也是一样，properties 的名称表示插件的名称。*com.android.application.properties* 的内容如下：\n\n```\nimplementation-class=com.android.build.gradle.AppPlugin\n```\n\n`com.android.build.gradle.AppPlugin` 这个类就是 Application Plugin 的源码。阅读 AppPlugin 源码，我们可以看到这一段：\n\n``` groovy\n\t@NonNull\n    @Override\n    protected BaseExtension createExtension(\n            @NonNull Project project,\n            @NonNull ProjectOptions projectOptions,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull SdkHandler sdkHandler,\n            @NonNull NamedDomainObjectContainer<BuildType> buildTypeContainer,\n            @NonNull NamedDomainObjectContainer<ProductFlavor> productFlavorContainer,\n            @NonNull NamedDomainObjectContainer<SigningConfig> signingConfigContainer,\n            @NonNull NamedDomainObjectContainer<BaseVariantOutput> buildOutputs,\n            @NonNull SourceSetManager sourceSetManager,\n            @NonNull ExtraModelInfo extraModelInfo) {\n        return project.getExtensions()\n                .create(\n                        \"android\",\n                        AppExtension.class,\n                        project,\n                        projectOptions,\n                        androidBuilder,\n                        sdkHandler,\n                        buildTypeContainer,\n                        productFlavorContainer,\n                        signingConfigContainer,\n                        buildOutputs,\n                        sourceSetManager,\n                        extraModelInfo);\n    }\n```\n\n首先我们先通过 API 文档了解下 [project.extensions](https://docs.gradle.org/current/dsl/org.gradle.api.Project.html) 的定义：\n\n```\n定义：\n\tExtensionContainer extensions (read-only)\n说明：\n\tAllows adding DSL extensions to the project. Useful for plugin authors.\n\t允许向项目添加 DSL 扩展，对插件作者很有用\n```\n\n接着我们看下 [`ExtensionContainer.create`](https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/ExtensionContainer.html#create-java.lang.String-java.lang.Class-java.lang.Object...-) 方法的定义：\n\n```\n定义：\n\t<T> T create(String name,Class<T> type,Object... constructionArguments)\n说明：\n\tCreates and adds a new extension to this container. A new instance of the given type will be created using the given constructionArguments. The extension will be exposed as type unless the extension itself declares a preferred public type via the HasPublicType protocol. The new instance will have been dynamically made ExtensionAware, which means that you can cast it to ExtensionAware.\n\t向项目创建并且添加一个新的扩展。通过给定的 type 创建一个新的实例，使用给定的 constructionArguments 构造函数参数。可以通过 HasPublicType 接口声明对外开放的类型，否则整个扩展将对外开放。新的实例将动态生成为 \nExtensionAware，这意味着你可以将它转换成 ExtensionAware\n```\n\n现在我们可以知道，为什么在引入 `com.android.application` 之后才能使用 `android` 配置块，这也意味着，`android` 所能提供的配置依赖于 `AppExtension` 这个类。\n\n这里我们简单就 `defaultConfig` 这个做下分析，先看下这个类在 `AppExtension` 中的配置，因为 `AppExtension` 直接调用超类 `TestedExtension` 的构造方法，而 `TestedExtension` 又会调用超类 `BaseExtension` 所以我们直接看到 `BaseExtension`：\n\n``` java\nprivate final DefaultConfig defaultConfig;\n\ndefaultConfig = objectFactory.newInstance(\n                        DefaultConfig.class,\n                        BuilderConstants.MAIN,\n                        project,\n                        objectFactory,\n                        extraModelInfo.getDeprecationReporter(),\n                        project.getLogger());\n```\n\n这里我们先不关心 `objectFactory.newInstance` 只需要知道，当我们在 `android` 配置块中，配置 `defaultConfig` 实质上也是，对 `DefaultConfig` 的配置，而 `DefaultConfig` 又继承于 `DefaultProductFlavor`，相关的配置同时也是 `DefaultProductFlavor` 的成员属性：\n\n> DefaultProductFlavor 位于 `builder-3.1.2.jar`\n>\n> Android Gradle Plugin 相关代码分别位于 `gradle-3.1.2.jar`、`gradle-api-3.1.2.jar`、`gradle-core-3.1.2.jar`\n>\n> 如果想查看源码，则下载 sources 包，比如 [builder-3.1.2-sources.jar](https://dl.google.com/dl/android/maven2/com/android/tools/build/builder/3.1.2/builder-3.1.2-sources.jar)，其他 jar 下载方法类似\n>\n> 心好累，各种继承。。。\n\n``` java\npublic class DefaultProductFlavor extends BaseConfigImpl implements ProductFlavor {\n    private static final long serialVersionUID = 1L;\n\n    @NonNull\n    private final String mName;\n    @Nullable\n    private String mDimension;\n    @Nullable\n    private ApiVersion mMinSdkVersion;\n    @Nullable\n    private ApiVersion mTargetSdkVersion;\n    @Nullable\n    private Integer mMaxSdkVersion;\n    @Nullable\n    private Integer mRenderscriptTargetApi;\n    @Nullable\n    private Boolean mRenderscriptSupportModeEnabled;\n    @Nullable\n    private Boolean mRenderscriptSupportModeBlasEnabled;\n    @Nullable\n    private Boolean mRenderscriptNdkModeEnabled;\n    @Nullable\n    private Integer mVersionCode;\n    @Nullable\n    private String mVersionName;\n    @Nullable\n    private String mApplicationId;\n    @Nullable\n    private String mTestApplicationId;\n    @Nullable\n    private String mTestInstrumentationRunner;\n    @NonNull\n    private Map<String, String> mTestInstrumentationRunnerArguments = Maps.newHashMap();\n    @Nullable\n    private Boolean mTestHandleProfiling;\n    @Nullable\n    private Boolean mTestFunctionalTest;\n    @Nullable\n    private SigningConfig mSigningConfig;\n    @Nullable\n    private Set<String> mResourceConfiguration;\n    @NonNull\n    private DefaultVectorDrawablesOptions mVectorDrawablesOptions;\n    @Nullable\n    private Boolean mWearAppUnbundled;\n}\n```\n\n### 重复配置处理\n\n当我们项目不止只有一个 app module 时，那么在其他 module 中，例如下面这些配置都需要去配置下：\n\n``` groovy\ndefaultConfig {\n        minSdkVersion 21\n        targetSdkVersion 27\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\n    }\n```\n\n这样就显得很繁琐又不灵活，比如现在很多项目都开始进行组件化，有的 module 有时候是 `com.android.application`，有的时候又是  `com.android.library` 这样又得根据条件写两套配置，如果其中一个更改了，还得去挨个 module 中更改。\n\n而利用 Gradle 多项目构建，我们可以将这些重复配置都统一处理，还可以根据属性自动导入不同的 plugin。首先为了统一管理各种版本号，我们先新建一个 *constants.gradle* 将一些常量写入到 ext 中：\n\n``` groovy\nproject.ext {\n    compileSdkVersion = 27\n    \n    minSdkVersion = 21\n    \n    targetSdkVersion = 27\n    \n    versionCode = 1\n    \n    versionName = \"1.0\"\n}\n```\n\n>  ext 实际上是 [ExtraPropertiesExtension](https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html) 类型，它类似 map，可以存储 key/value 键值对。ext 也是扩展的一种，可以通过 `project.extensions.getByName('ext')` 获取实例，所有的 [`ExtensionAware`](https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtensionAware.html) 都拥有一个 `ext`，而 Project 又是继承于  `ExtensionAware`\n\n接着我们在各个 module 中创建一个 `gradle.properties` ，这个文件默认会被读取，在其中定义一个属性 `isApplication`，根据这个属性导入不同的 plugin：\n\n``` groovy\n// library module\nisApplication=false\n\n// application module\nisApplication=true\n```\n\n接着创建 *init.gradle*，在 `subprojects` 中配置，这里的配置对所有的子项目都会生效：\n\n``` groovy\nsubprojects {\n    if (project.isApplication.toBoolean()) {\n        // 当前 module 导入 application plugin\n        project.plugins.apply(\"com.android.application\")\n    } else {\n        project.plugins.apply(\"com.android.library\")\n    }\n}\n```\n\n> 这里有点地方需要注意下，因为属性的获取都是通过 String 类型，所以我们需要明确使用 `toBoolean()` 去转化成布尔值\n\n最后要想使得这些 gradle 文件生效，需要将它们 apply 进去，因为 Gradle 默认只会识别 `build.gradle`，还记得我们在 [Gradle多项目构建](https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/) 中说到，*Gradle 是边读取边执行的* ，这意味着你需要在使用到 `android` 构建块之前，将 plugin apply 进去，所以我们将这些 gradle 文件在根目录的 *build.gradle* 中 apply，因为默认根目录的优先级最高：\n\n``` groovy\n// constants.gradle 需要在 init.gradle，因为 init.gradle 后面会使用到 constants.gradle 中定义的值，理由如上\napply from: 'gradle/constants.gradle'\napply from: 'gradle/init.gradle'\n```\n\n我们将 module 下 *build.gradle* 中的 apply 代码删除，重新同步下，可以发现 `android` 配置块依然生效，这意味着，我们 apply plugin 操作成功了。\n\n在处理完 plugin 之后，我们可以将 `android` 配置块中的重复配置也在 *init.gradle* 中去配置：\n\n``` groovy\nsubprojects {\n    if (project.isApplication.toBoolean()) {\n        // 当前 module 导入 application plugin\n        project.plugins.apply(\"com.android.application\")\n    } else {\n        project.plugins.apply(\"com.android.library\")\n    }\n    android {\n        compileSdkVersion rootProject.ext['compileSdkVersion']\n        defaultConfig {\n            minSdkVersion rootProject.ext['minSdkVersion']\n            targetSdkVersion rootProject.ext['targetSdkVersion']\n            versionCode rootProject.ext['versionCode']\n            versionName rootProject.ext['versionName']\n            testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n        }\n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            }\n        }\n    }\n\n}\n```\n\n是不是非常方便，这样统一的配置你只需要写一次，不只是 `android` 配置块可以这么处理，其他的配置也可以这么处理。\n\n### 依赖管理\n\n一般情况下，我们会在各个 module 下去编写所需的依赖配置，比如通过 `implementation 'com.android.support:appcompat-v7:27.1.1'` 去从 maven 中心仓库或者 jcenter 中下载依赖，但这样有个不好的地方就是依赖配置太分散了，只能到每个 module 目录中的 *build.gradle* 去管理，如果我们将这个写到统一的 Gradle 构建脚本中，是不是会更好点，我们同样创建个 *dependencies.gradle*，将共同的依赖写到 `subprojects` ，特有的依赖写到单独的项目配置中，同样这个文件需要在根目录的 *build.gradle* 中 apply：\n\n``` groovy\nsubprojects {\n    dependencies {\n        testImplementation rootProject.ext.dependencies['junit']\n        androidTestImplementation rootProject.ext.dependencies['runner']\n        androidTestImplementation rootProject.ext.dependencies['espresso-core']\n    }\n}\n\nproject(':mylibrary') {\n    dependencies {\n        api fileTree(dir: 'libs', include: ['*.jar'])\n        api rootProject.ext.dependencies['appcompat-v7']\n        api rootProject.ext.dependencies['constraint-layout']\n    }\n}\n\nproject(':app') {\n    dependencies {\n        implementation fileTree(dir: 'libs', include: ['*.jar'])\n        implementation project(\":mylibrary\")\n    }\n}\n```\n\n我们可以将共同的依赖写到 `subprojects` 块，单独项目的配置写到各自的配置块下。\n\n现在我们再来解决另外一个常见的问题：依赖冲突，比如不同的依赖项各自又依赖于同一个库的不同版本，默认 [Gradle 会用这个重复库的最高版本](https://docs.gradle.org/current/userguide/troubleshooting_dependency_resolution.html#sub:version_conflicts)，但如果你配置了 `resolutionStrategy.failOnVersionConflict()` 即当出现版本冲突则失败，或者版本选择不合适，等等，就会出现依赖冲突问题。\n\n我们通过个例子来证实默认的处理策略，我们在 app 模块中去依赖  `com.android.support:design:27.1.1` 和 `com.android.support:recyclerview-v7:26.1.0` ，而 `design` 会自动去依赖 `com.android.support:recyclerview-v7:27.1.1`，依赖关系我们可以通过 `./gradlew :app:dependencies` 这个 Task 去查看，这里我们只查看 *releaseCompileClasspath* 依赖配置中 `design` 和 `recyclerview` 的情况：\n\n```\n+--- project :mylibrary\n|    \\--- com.android.support:design:27.1.1\n|         +--- com.android.support:support-v4:27.1.1\n|         |    +--- com.android.support:support-compat:27.1.1 (*)\n|         |    +--- com.android.support:support-media-compat:27.1.1\n|         |    |    +--- com.android.support:support-annotations:27.1.1\n|         |    |    \\--- com.android.support:support-compat:27.1.1 (*)\n|         |    +--- com.android.support:support-core-utils:27.1.1 (*)\n|         |    +--- com.android.support:support-core-ui:27.1.1 (*)\n|         |    \\--- com.android.support:support-fragment:27.1.1 (*)\n|         +--- com.android.support:appcompat-v7:27.1.1 (*)\n|         +--- com.android.support:recyclerview-v7:27.1.1\n|         |    +--- com.android.support:support-annotations:27.1.1\n|         |    +--- com.android.support:support-compat:27.1.1 (*)\n|         |    \\--- com.android.support:support-core-ui:27.1.1 (*)\n|         \\--- com.android.support:transition:27.1.1\n|              +--- com.android.support:support-annotations:27.1.1\n|              \\--- com.android.support:support-compat:27.1.1 (*)\n\\--- com.android.support:recyclerview-v7:26.1.0 -> 27.1.1 (*)\n```\n\n可以看到我们依赖的 26.1.0 已经被替换成 27.1.1，如果这是我们想要的结果，那就很理想，但是如果我们想要去定义依赖冲突的策略呢？同样的，Gradle 也提供了相应的 API。\n\n还是上面的例子，如果我们不想要使用 `design` 中的 `recyclerview` 而想要我们单独依赖的 `recyclerview-v7:26.1.1` 这里我们有几种方式解决：\n\n1. 不传递依赖\n\n   ``` groovy\n   api(rootProject.ext.dependencies['design']) {\n               transitive = false\n   }\n   ```\n\n2. 强制使用当前版本\n\n   ``` groovy\n   implementation(rootProject.ext.dependencies['recyclerview']) {\n               force = true\n   }\n   ```\n\n其他的解决方案可以参考[官方文档](https://docs.gradle.org/current/userguide/introduction_dependency_management.html)\n\n这里我们使用 Gradle 提供的 [resolutionStrategy](https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html) 方案： \n\n``` groovy\nsubprojects {\n    configurations.all {\n        resolutionStrategy {\n            force rootProject.ext.dependencies['recyclerview']\n        }\n    }\n}\n```\n\n`configurations` 表示当前项目的依赖配置容器，`configurations.all` 表示当前项目的所有依赖配置，上面的配置表示，遍历当前项目的所有依赖配置，设置其依赖解决策略为 **强制使用指定的版本**\n\n## 改造结束\n\n现在我们再来对比下，默认生成的构建配置和改造后的构建配置：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 27\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n        minSdkVersion 21\n        targetSdkVersion 27\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.android.support:appcompat-v7:27.1.1'\n    implementation 'com.android.support.constraint:constraint-layout:1.1.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n}\n\n```\n\n``` groovy\nandroid {\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n    }\n}\n```\n\n是不是简洁了不少，重复的配置项我们交给统一的配置文件去做，依赖配置也是如此，包括依赖冲突的解决策略，但是 Gradle 能实现的不仅仅如此，还有强大的自定义 Gradle Plugin 我们还没讲到。\n\n## 总结\n\n通过这篇文章，不仅仅是教会大家如何去编写简单的 Gradle 构建脚本，更重要的想让大家对 Gradle 有个初步的认识，知道 Gradle 的配置块是如何生成的，更多知识可以通过[官方文档](https://docs.gradle.org/current/userguide/userguide.html)去获取。","slug":"Gradle多项目实践","published":1,"updated":"2018-05-09T12:27:57.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjs0ht9b0001ero6132qybb4","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上篇文章中，我们说到了 <a href=\"https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/\">Gradle多项目构建</a> 的一些知识点，但这些总归只是纸上谈兵，今天我们在实际项目中通过之前学到的知识去改造下项目的 Gradle 构建脚本，充分利用 Gradle 带来的好处。</p>\n<p>虽然使用 Gradle 作为构建工具已经有一段时间了，但很多同学对它还是很陌生的，基本都是沿用 Android Studio 默认生成的配置，用的比较多的可能也只是 <code>dependencies</code> 配置，从不同的 <code>repositories</code> 去下载依赖，可能在需要实现一些自定义配置的时候，就去 google 后照搬代码，对其配置参数也是似懂非懂，出了问题不知道如何下手解决，所以这篇文章的主要目的是，实践 Gradle 在 Android 上的运用，对 Gradle 的使用有基本认识。</p>\n<p><a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">项目源码</a></p>\n<h2 id=\"改造开始\"><a href=\"#改造开始\" class=\"headerlink\" title=\"改造开始\"></a>改造开始</h2><h3 id=\"Gradle-知识\"><a href=\"#Gradle-知识\" class=\"headerlink\" title=\"Gradle 知识\"></a>Gradle 知识</h3><p>我们先看下 Android Studio 默认帮我们生成的配置代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    <span class=\"comment\">// android 构建配置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\"> \t<span class=\"comment\">// 依赖配置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先简单讲下上面各部分的配置含义，首先我们知道如果不先 <code>apply plugin: &#39;com.android.application&#39;</code> 就不会有 <code>android</code> 配置选项，那么这个配置选项具体是什么内容呢？我们可以通过源码了解下，<code>com.android.application</code> 这个插件就是我们在根目录下的 <em>build.gradle</em> 中导入的：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 构建脚本依赖源地址</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:3.1.2'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对 Gradle Plugin 有点了解的同学都知道，Gradle Plugin 需要定义到 <em>META-INF</em> 中，浏览 <em>gradle-3.1.2.jar</em>，<em>META-INF</em> 目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── MANIFEST.MF</span><br><span class=\"line\">├── gradle-plugins</span><br><span class=\"line\">│   ├── android-library.properties</span><br><span class=\"line\">│   ├── android-reporting.properties</span><br><span class=\"line\">│   ├── android.properties</span><br><span class=\"line\">│   ├── com.android.application.properties</span><br><span class=\"line\">│   ├── com.android.atom.properties</span><br><span class=\"line\">│   ├── com.android.bundle.properties</span><br><span class=\"line\">│   ├── com.android.debug.structure.properties</span><br><span class=\"line\">│   ├── com.android.feature.properties</span><br><span class=\"line\">│   ├── com.android.instantapp.properties</span><br><span class=\"line\">│   ├── com.android.library.properties</span><br><span class=\"line\">│   ├── com.android.lint.properties</span><br><span class=\"line\">│   └── com.android.test.properties</span><br></pre></td></tr></table></figure>\n<p>这里对应的是提供的各个插件的配置，比如 <em>com.android.application.properties</em> 就表示 <code>com.android.application</code> 插件，其他也是一样，properties 的名称表示插件的名称。<em>com.android.application.properties</em> 的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation-class=com.android.build.gradle.AppPlugin</span><br></pre></td></tr></table></figure>\n<p><code>com.android.build.gradle.AppPlugin</code> 这个类就是 Application Plugin 的源码。阅读 AppPlugin 源码，我们可以看到这一段：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">protected</span> BaseExtension createExtension(</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> Project project,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> ProjectOptions projectOptions,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> AndroidBuilder androidBuilder,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> SdkHandler sdkHandler,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> SourceSetManager sourceSetManager,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> ExtraModelInfo extraModelInfo) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> project.getExtensions()</span><br><span class=\"line\">               .create(</span><br><span class=\"line\">                       <span class=\"string\">\"android\"</span>,</span><br><span class=\"line\">                       AppExtension.<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                       project,</span><br><span class=\"line\">                       projectOptions,</span><br><span class=\"line\">                       androidBuilder,</span><br><span class=\"line\">                       sdkHandler,</span><br><span class=\"line\">                       buildTypeContainer,</span><br><span class=\"line\">                       productFlavorContainer,</span><br><span class=\"line\">                       signingConfigContainer,</span><br><span class=\"line\">                       buildOutputs,</span><br><span class=\"line\">                       sourceSetManager,</span><br><span class=\"line\">                       extraModelInfo);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们先通过 API 文档了解下 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.Project.html\" target=\"_blank\" rel=\"noopener\">project.extensions</a> 的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义：</span><br><span class=\"line\">\tExtensionContainer extensions (read-only)</span><br><span class=\"line\">说明：</span><br><span class=\"line\">\tAllows adding DSL extensions to the project. Useful for plugin authors.</span><br><span class=\"line\">\t允许向项目添加 DSL 扩展，对插件作者很有用</span><br></pre></td></tr></table></figure>\n<p>接着我们看下 <a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/ExtensionContainer.html#create-java.lang.String-java.lang.Class-java.lang.Object...-\" target=\"_blank\" rel=\"noopener\"><code>ExtensionContainer.create</code></a> 方法的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义：</span><br><span class=\"line\">\t&lt;T&gt; T create(String name,Class&lt;T&gt; type,Object... constructionArguments)</span><br><span class=\"line\">说明：</span><br><span class=\"line\">\tCreates and adds a new extension to this container. A new instance of the given type will be created using the given constructionArguments. The extension will be exposed as type unless the extension itself declares a preferred public type via the HasPublicType protocol. The new instance will have been dynamically made ExtensionAware, which means that you can cast it to ExtensionAware.</span><br><span class=\"line\">\t向项目创建并且添加一个新的扩展。通过给定的 type 创建一个新的实例，使用给定的 constructionArguments 构造函数参数。可以通过 HasPublicType 接口声明对外开放的类型，否则整个扩展将对外开放。新的实例将动态生成为 </span><br><span class=\"line\">ExtensionAware，这意味着你可以将它转换成 ExtensionAware</span><br></pre></td></tr></table></figure>\n<p>现在我们可以知道，为什么在引入 <code>com.android.application</code> 之后才能使用 <code>android</code> 配置块，这也意味着，<code>android</code> 所能提供的配置依赖于 <code>AppExtension</code> 这个类。</p>\n<p>这里我们简单就 <code>defaultConfig</code> 这个做下分析，先看下这个类在 <code>AppExtension</code> 中的配置，因为 <code>AppExtension</code> 直接调用超类 <code>TestedExtension</code> 的构造方法，而 <code>TestedExtension</code> 又会调用超类 <code>BaseExtension</code> 所以我们直接看到 <code>BaseExtension</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DefaultConfig defaultConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">defaultConfig = objectFactory.newInstance(</span><br><span class=\"line\">                        DefaultConfig.class,</span><br><span class=\"line\">                        BuilderConstants.MAIN,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        objectFactory,</span><br><span class=\"line\">                        extraModelInfo.getDeprecationReporter(),</span><br><span class=\"line\">                        project.getLogger());</span><br></pre></td></tr></table></figure>\n<p>这里我们先不关心 <code>objectFactory.newInstance</code> 只需要知道，当我们在 <code>android</code> 配置块中，配置 <code>defaultConfig</code> 实质上也是，对 <code>DefaultConfig</code> 的配置，而 <code>DefaultConfig</code> 又继承于 <code>DefaultProductFlavor</code>，相关的配置同时也是 <code>DefaultProductFlavor</code> 的成员属性：</p>\n<blockquote>\n<p>DefaultProductFlavor 位于 <code>builder-3.1.2.jar</code></p>\n<p>Android Gradle Plugin 相关代码分别位于 <code>gradle-3.1.2.jar</code>、<code>gradle-api-3.1.2.jar</code>、<code>gradle-core-3.1.2.jar</code></p>\n<p>如果想查看源码，则下载 sources 包，比如 <a href=\"https://dl.google.com/dl/android/maven2/com/android/tools/build/builder/3.1.2/builder-3.1.2-sources.jar\" target=\"_blank\" rel=\"noopener\">builder-3.1.2-sources.jar</a>，其他 jar 下载方法类似</p>\n<p>心好累，各种继承。。。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultProductFlavor</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseConfigImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProductFlavor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String mName;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mDimension;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiVersion mMinSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiVersion mTargetSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mMaxSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mRenderscriptTargetApi;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptSupportModeEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptSupportModeBlasEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptNdkModeEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mVersionCode;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mVersionName;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mApplicationId;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mTestApplicationId;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mTestInstrumentationRunner;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, String&gt; mTestInstrumentationRunnerArguments = Maps.newHashMap();</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mTestHandleProfiling;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mTestFunctionalTest;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SigningConfig mSigningConfig;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;String&gt; mResourceConfiguration;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DefaultVectorDrawablesOptions mVectorDrawablesOptions;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mWearAppUnbundled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重复配置处理\"><a href=\"#重复配置处理\" class=\"headerlink\" title=\"重复配置处理\"></a>重复配置处理</h3><p>当我们项目不止只有一个 app module 时，那么在其他 module 中，例如下面这些配置都需要去配置下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这样就显得很繁琐又不灵活，比如现在很多项目都开始进行组件化，有的 module 有时候是 <code>com.android.application</code>，有的时候又是  <code>com.android.library</code> 这样又得根据条件写两套配置，如果其中一个更改了，还得去挨个 module 中更改。</p>\n<p>而利用 Gradle 多项目构建，我们可以将这些重复配置都统一处理，还可以根据属性自动导入不同的 plugin。首先为了统一管理各种版本号，我们先新建一个 <em>constants.gradle</em> 将一些常量写入到 ext 中：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.ext &#123;</span><br><span class=\"line\">    compileSdkVersion = <span class=\"number\">27</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    minSdkVersion = <span class=\"number\">21</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    targetSdkVersion = <span class=\"number\">27</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    versionCode = <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    versionName = <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p> ext 实际上是 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html\" target=\"_blank\" rel=\"noopener\">ExtraPropertiesExtension</a> 类型，它类似 map，可以存储 key/value 键值对。ext 也是扩展的一种，可以通过 <code>project.extensions.getByName(&#39;ext&#39;)</code> 获取实例，所有的 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtensionAware.html\" target=\"_blank\" rel=\"noopener\"><code>ExtensionAware</code></a> 都拥有一个 <code>ext</code>，而 Project 又是继承于  <code>ExtensionAware</code></p>\n</blockquote>\n<p>接着我们在各个 module 中创建一个 <code>gradle.properties</code> ，这个文件默认会被读取，在其中定义一个属性 <code>isApplication</code>，根据这个属性导入不同的 plugin：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// library module</span></span><br><span class=\"line\">isApplication=<span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// application module</span></span><br><span class=\"line\">isApplication=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>接着创建 <em>init.gradle</em>，在 <code>subprojects</code> 中配置，这里的配置对所有的子项目都会生效：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (project.isApplication.toBoolean()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 module 导入 application plugin</span></span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.application\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.library\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里有点地方需要注意下，因为属性的获取都是通过 String 类型，所以我们需要明确使用 <code>toBoolean()</code> 去转化成布尔值</p>\n</blockquote>\n<p>最后要想使得这些 gradle 文件生效，需要将它们 apply 进去，因为 Gradle 默认只会识别 <code>build.gradle</code>，还记得我们在 <a href=\"https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/\">Gradle多项目构建</a> 中说到，<em>Gradle 是边读取边执行的</em> ，这意味着你需要在使用到 <code>android</code> 构建块之前，将 plugin apply 进去，所以我们将这些 gradle 文件在根目录的 <em>build.gradle</em> 中 apply，因为默认根目录的优先级最高：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// constants.gradle 需要在 init.gradle，因为 init.gradle 后面会使用到 constants.gradle 中定义的值，理由如上</span></span><br><span class=\"line\">apply <span class=\"string\">from:</span> <span class=\"string\">'gradle/constants.gradle'</span></span><br><span class=\"line\">apply <span class=\"string\">from:</span> <span class=\"string\">'gradle/init.gradle'</span></span><br></pre></td></tr></table></figure>\n<p>我们将 module 下 <em>build.gradle</em> 中的 apply 代码删除，重新同步下，可以发现 <code>android</code> 配置块依然生效，这意味着，我们 apply plugin 操作成功了。</p>\n<p>在处理完 plugin 之后，我们可以将 <code>android</code> 配置块中的重复配置也在 <em>init.gradle</em> 中去配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (project.isApplication.toBoolean()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 module 导入 application plugin</span></span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.application\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.library\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    android &#123;</span><br><span class=\"line\">        compileSdkVersion rootProject.ext[<span class=\"string\">'compileSdkVersion'</span>]</span><br><span class=\"line\">        defaultConfig &#123;</span><br><span class=\"line\">            minSdkVersion rootProject.ext[<span class=\"string\">'minSdkVersion'</span>]</span><br><span class=\"line\">            targetSdkVersion rootProject.ext[<span class=\"string\">'targetSdkVersion'</span>]</span><br><span class=\"line\">            versionCode rootProject.ext[<span class=\"string\">'versionCode'</span>]</span><br><span class=\"line\">            versionName rootProject.ext[<span class=\"string\">'versionName'</span>]</span><br><span class=\"line\">            testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        buildTypes &#123;</span><br><span class=\"line\">            release &#123;</span><br><span class=\"line\">                minifyEnabled <span class=\"literal\">false</span></span><br><span class=\"line\">                proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是不是非常方便，这样统一的配置你只需要写一次，不只是 <code>android</code> 配置块可以这么处理，其他的配置也可以这么处理。</p>\n<h3 id=\"依赖管理\"><a href=\"#依赖管理\" class=\"headerlink\" title=\"依赖管理\"></a>依赖管理</h3><p>一般情况下，我们会在各个 module 下去编写所需的依赖配置，比如通过 <code>implementation &#39;com.android.support:appcompat-v7:27.1.1&#39;</code> 去从 maven 中心仓库或者 jcenter 中下载依赖，但这样有个不好的地方就是依赖配置太分散了，只能到每个 module 目录中的 <em>build.gradle</em> 去管理，如果我们将这个写到统一的 Gradle 构建脚本中，是不是会更好点，我们同样创建个 <em>dependencies.gradle</em>，将共同的依赖写到 <code>subprojects</code> ，特有的依赖写到单独的项目配置中，同样这个文件需要在根目录的 <em>build.gradle</em> 中 apply：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        testImplementation rootProject.ext.dependencies[<span class=\"string\">'junit'</span>]</span><br><span class=\"line\">        androidTestImplementation rootProject.ext.dependencies[<span class=\"string\">'runner'</span>]</span><br><span class=\"line\">        androidTestImplementation rootProject.ext.dependencies[<span class=\"string\">'espresso-core'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">project(<span class=\"string\">':mylibrary'</span>) &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        api fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">        api rootProject.ext.dependencies[<span class=\"string\">'appcompat-v7'</span>]</span><br><span class=\"line\">        api rootProject.ext.dependencies[<span class=\"string\">'constraint-layout'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">project(<span class=\"string\">':app'</span>) &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">        implementation project(<span class=\"string\">\":mylibrary\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以将共同的依赖写到 <code>subprojects</code> 块，单独项目的配置写到各自的配置块下。</p>\n<p>现在我们再来解决另外一个常见的问题：依赖冲突，比如不同的依赖项各自又依赖于同一个库的不同版本，默认 <a href=\"https://docs.gradle.org/current/userguide/troubleshooting_dependency_resolution.html#sub:version_conflicts\" target=\"_blank\" rel=\"noopener\">Gradle 会用这个重复库的最高版本</a>，但如果你配置了 <code>resolutionStrategy.failOnVersionConflict()</code> 即当出现版本冲突则失败，或者版本选择不合适，等等，就会出现依赖冲突问题。</p>\n<p>我们通过个例子来证实默认的处理策略，我们在 app 模块中去依赖  <code>com.android.support:design:27.1.1</code> 和 <code>com.android.support:recyclerview-v7:26.1.0</code> ，而 <code>design</code> 会自动去依赖 <code>com.android.support:recyclerview-v7:27.1.1</code>，依赖关系我们可以通过 <code>./gradlew :app:dependencies</code> 这个 Task 去查看，这里我们只查看 <em>releaseCompileClasspath</em> 依赖配置中 <code>design</code> 和 <code>recyclerview</code> 的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--- project :mylibrary</span><br><span class=\"line\">|    \\--- com.android.support:design:27.1.1</span><br><span class=\"line\">|         +--- com.android.support:support-v4:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-media-compat:27.1.1</span><br><span class=\"line\">|         |    |    +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|         |    |    \\--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-core-utils:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-core-ui:27.1.1 (*)</span><br><span class=\"line\">|         |    \\--- com.android.support:support-fragment:27.1.1 (*)</span><br><span class=\"line\">|         +--- com.android.support:appcompat-v7:27.1.1 (*)</span><br><span class=\"line\">|         +--- com.android.support:recyclerview-v7:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    \\--- com.android.support:support-core-ui:27.1.1 (*)</span><br><span class=\"line\">|         \\--- com.android.support:transition:27.1.1</span><br><span class=\"line\">|              +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|              \\--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">\\--- com.android.support:recyclerview-v7:26.1.0 -&gt; 27.1.1 (*)</span><br></pre></td></tr></table></figure>\n<p>可以看到我们依赖的 26.1.0 已经被替换成 27.1.1，如果这是我们想要的结果，那就很理想，但是如果我们想要去定义依赖冲突的策略呢？同样的，Gradle 也提供了相应的 API。</p>\n<p>还是上面的例子，如果我们不想要使用 <code>design</code> 中的 <code>recyclerview</code> 而想要我们单独依赖的 <code>recyclerview-v7:26.1.1</code> 这里我们有几种方式解决：</p>\n<ol>\n<li><p>不传递依赖</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">api(rootProject.ext.dependencies[<span class=\"string\">'design'</span>]) &#123;</span><br><span class=\"line\">            transitive = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>强制使用当前版本</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation(rootProject.ext.dependencies[<span class=\"string\">'recyclerview'</span>]) &#123;</span><br><span class=\"line\">            force = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其他的解决方案可以参考<a href=\"https://docs.gradle.org/current/userguide/introduction_dependency_management.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p>这里我们使用 Gradle 提供的 <a href=\"https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html\" target=\"_blank\" rel=\"noopener\">resolutionStrategy</a> 方案： </p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    configurations.all &#123;</span><br><span class=\"line\">        resolutionStrategy &#123;</span><br><span class=\"line\">            force rootProject.ext.dependencies[<span class=\"string\">'recyclerview'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>configurations</code> 表示当前项目的依赖配置容器，<code>configurations.all</code> 表示当前项目的所有依赖配置，上面的配置表示，遍历当前项目的所有依赖配置，设置其依赖解决策略为 <strong>强制使用指定的版本</strong></p>\n<h2 id=\"改造结束\"><a href=\"#改造结束\" class=\"headerlink\" title=\"改造结束\"></a>改造结束</h2><p>现在我们再来对比下，默认生成的构建配置和改造后的构建配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">        minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"literal\">false</span></span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support:appcompat-v7:27.1.1'</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support.constraint:constraint-layout:1.1.0'</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">'junit:junit:4.12'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test:runner:1.0.2'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test.espresso:espresso-core:3.0.2'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是不是简洁了不少，重复的配置项我们交给统一的配置文件去做，依赖配置也是如此，包括依赖冲突的解决策略，但是 Gradle 能实现的不仅仅如此，还有强大的自定义 Gradle Plugin 我们还没讲到。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这篇文章，不仅仅是教会大家如何去编写简单的 Gradle 构建脚本，更重要的想让大家对 Gradle 有个初步的认识，知道 Gradle 的配置块是如何生成的，更多知识可以通过<a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>去获取。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上篇文章中，我们说到了 <a href=\"https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/\">Gradle多项目构建</a> 的一些知识点，但这些总归只是纸上谈兵，今天我们在实际项目中通过之前学到的知识去改造下项目的 Gradle 构建脚本，充分利用 Gradle 带来的好处。</p>\n<p>虽然使用 Gradle 作为构建工具已经有一段时间了，但很多同学对它还是很陌生的，基本都是沿用 Android Studio 默认生成的配置，用的比较多的可能也只是 <code>dependencies</code> 配置，从不同的 <code>repositories</code> 去下载依赖，可能在需要实现一些自定义配置的时候，就去 google 后照搬代码，对其配置参数也是似懂非懂，出了问题不知道如何下手解决，所以这篇文章的主要目的是，实践 Gradle 在 Android 上的运用，对 Gradle 的使用有基本认识。</p>\n<p><a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">项目源码</a></p>\n<h2 id=\"改造开始\"><a href=\"#改造开始\" class=\"headerlink\" title=\"改造开始\"></a>改造开始</h2><h3 id=\"Gradle-知识\"><a href=\"#Gradle-知识\" class=\"headerlink\" title=\"Gradle 知识\"></a>Gradle 知识</h3><p>我们先看下 Android Studio 默认帮我们生成的配置代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    <span class=\"comment\">// android 构建配置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\"> \t<span class=\"comment\">// 依赖配置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先简单讲下上面各部分的配置含义，首先我们知道如果不先 <code>apply plugin: &#39;com.android.application&#39;</code> 就不会有 <code>android</code> 配置选项，那么这个配置选项具体是什么内容呢？我们可以通过源码了解下，<code>com.android.application</code> 这个插件就是我们在根目录下的 <em>build.gradle</em> 中导入的：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 构建脚本依赖源地址</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:3.1.2'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对 Gradle Plugin 有点了解的同学都知道，Gradle Plugin 需要定义到 <em>META-INF</em> 中，浏览 <em>gradle-3.1.2.jar</em>，<em>META-INF</em> 目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── MANIFEST.MF</span><br><span class=\"line\">├── gradle-plugins</span><br><span class=\"line\">│   ├── android-library.properties</span><br><span class=\"line\">│   ├── android-reporting.properties</span><br><span class=\"line\">│   ├── android.properties</span><br><span class=\"line\">│   ├── com.android.application.properties</span><br><span class=\"line\">│   ├── com.android.atom.properties</span><br><span class=\"line\">│   ├── com.android.bundle.properties</span><br><span class=\"line\">│   ├── com.android.debug.structure.properties</span><br><span class=\"line\">│   ├── com.android.feature.properties</span><br><span class=\"line\">│   ├── com.android.instantapp.properties</span><br><span class=\"line\">│   ├── com.android.library.properties</span><br><span class=\"line\">│   ├── com.android.lint.properties</span><br><span class=\"line\">│   └── com.android.test.properties</span><br></pre></td></tr></table></figure>\n<p>这里对应的是提供的各个插件的配置，比如 <em>com.android.application.properties</em> 就表示 <code>com.android.application</code> 插件，其他也是一样，properties 的名称表示插件的名称。<em>com.android.application.properties</em> 的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation-class=com.android.build.gradle.AppPlugin</span><br></pre></td></tr></table></figure>\n<p><code>com.android.build.gradle.AppPlugin</code> 这个类就是 Application Plugin 的源码。阅读 AppPlugin 源码，我们可以看到这一段：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">protected</span> BaseExtension createExtension(</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> Project project,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> ProjectOptions projectOptions,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> AndroidBuilder androidBuilder,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> SdkHandler sdkHandler,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> SourceSetManager sourceSetManager,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> ExtraModelInfo extraModelInfo) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> project.getExtensions()</span><br><span class=\"line\">               .create(</span><br><span class=\"line\">                       <span class=\"string\">\"android\"</span>,</span><br><span class=\"line\">                       AppExtension.<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                       project,</span><br><span class=\"line\">                       projectOptions,</span><br><span class=\"line\">                       androidBuilder,</span><br><span class=\"line\">                       sdkHandler,</span><br><span class=\"line\">                       buildTypeContainer,</span><br><span class=\"line\">                       productFlavorContainer,</span><br><span class=\"line\">                       signingConfigContainer,</span><br><span class=\"line\">                       buildOutputs,</span><br><span class=\"line\">                       sourceSetManager,</span><br><span class=\"line\">                       extraModelInfo);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们先通过 API 文档了解下 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.Project.html\" target=\"_blank\" rel=\"noopener\">project.extensions</a> 的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义：</span><br><span class=\"line\">\tExtensionContainer extensions (read-only)</span><br><span class=\"line\">说明：</span><br><span class=\"line\">\tAllows adding DSL extensions to the project. Useful for plugin authors.</span><br><span class=\"line\">\t允许向项目添加 DSL 扩展，对插件作者很有用</span><br></pre></td></tr></table></figure>\n<p>接着我们看下 <a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/ExtensionContainer.html#create-java.lang.String-java.lang.Class-java.lang.Object...-\" target=\"_blank\" rel=\"noopener\"><code>ExtensionContainer.create</code></a> 方法的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义：</span><br><span class=\"line\">\t&lt;T&gt; T create(String name,Class&lt;T&gt; type,Object... constructionArguments)</span><br><span class=\"line\">说明：</span><br><span class=\"line\">\tCreates and adds a new extension to this container. A new instance of the given type will be created using the given constructionArguments. The extension will be exposed as type unless the extension itself declares a preferred public type via the HasPublicType protocol. The new instance will have been dynamically made ExtensionAware, which means that you can cast it to ExtensionAware.</span><br><span class=\"line\">\t向项目创建并且添加一个新的扩展。通过给定的 type 创建一个新的实例，使用给定的 constructionArguments 构造函数参数。可以通过 HasPublicType 接口声明对外开放的类型，否则整个扩展将对外开放。新的实例将动态生成为 </span><br><span class=\"line\">ExtensionAware，这意味着你可以将它转换成 ExtensionAware</span><br></pre></td></tr></table></figure>\n<p>现在我们可以知道，为什么在引入 <code>com.android.application</code> 之后才能使用 <code>android</code> 配置块，这也意味着，<code>android</code> 所能提供的配置依赖于 <code>AppExtension</code> 这个类。</p>\n<p>这里我们简单就 <code>defaultConfig</code> 这个做下分析，先看下这个类在 <code>AppExtension</code> 中的配置，因为 <code>AppExtension</code> 直接调用超类 <code>TestedExtension</code> 的构造方法，而 <code>TestedExtension</code> 又会调用超类 <code>BaseExtension</code> 所以我们直接看到 <code>BaseExtension</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DefaultConfig defaultConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">defaultConfig = objectFactory.newInstance(</span><br><span class=\"line\">                        DefaultConfig.class,</span><br><span class=\"line\">                        BuilderConstants.MAIN,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        objectFactory,</span><br><span class=\"line\">                        extraModelInfo.getDeprecationReporter(),</span><br><span class=\"line\">                        project.getLogger());</span><br></pre></td></tr></table></figure>\n<p>这里我们先不关心 <code>objectFactory.newInstance</code> 只需要知道，当我们在 <code>android</code> 配置块中，配置 <code>defaultConfig</code> 实质上也是，对 <code>DefaultConfig</code> 的配置，而 <code>DefaultConfig</code> 又继承于 <code>DefaultProductFlavor</code>，相关的配置同时也是 <code>DefaultProductFlavor</code> 的成员属性：</p>\n<blockquote>\n<p>DefaultProductFlavor 位于 <code>builder-3.1.2.jar</code></p>\n<p>Android Gradle Plugin 相关代码分别位于 <code>gradle-3.1.2.jar</code>、<code>gradle-api-3.1.2.jar</code>、<code>gradle-core-3.1.2.jar</code></p>\n<p>如果想查看源码，则下载 sources 包，比如 <a href=\"https://dl.google.com/dl/android/maven2/com/android/tools/build/builder/3.1.2/builder-3.1.2-sources.jar\" target=\"_blank\" rel=\"noopener\">builder-3.1.2-sources.jar</a>，其他 jar 下载方法类似</p>\n<p>心好累，各种继承。。。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultProductFlavor</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseConfigImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProductFlavor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String mName;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mDimension;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiVersion mMinSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiVersion mTargetSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mMaxSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mRenderscriptTargetApi;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptSupportModeEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptSupportModeBlasEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptNdkModeEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mVersionCode;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mVersionName;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mApplicationId;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mTestApplicationId;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mTestInstrumentationRunner;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, String&gt; mTestInstrumentationRunnerArguments = Maps.newHashMap();</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mTestHandleProfiling;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mTestFunctionalTest;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SigningConfig mSigningConfig;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;String&gt; mResourceConfiguration;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DefaultVectorDrawablesOptions mVectorDrawablesOptions;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mWearAppUnbundled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重复配置处理\"><a href=\"#重复配置处理\" class=\"headerlink\" title=\"重复配置处理\"></a>重复配置处理</h3><p>当我们项目不止只有一个 app module 时，那么在其他 module 中，例如下面这些配置都需要去配置下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这样就显得很繁琐又不灵活，比如现在很多项目都开始进行组件化，有的 module 有时候是 <code>com.android.application</code>，有的时候又是  <code>com.android.library</code> 这样又得根据条件写两套配置，如果其中一个更改了，还得去挨个 module 中更改。</p>\n<p>而利用 Gradle 多项目构建，我们可以将这些重复配置都统一处理，还可以根据属性自动导入不同的 plugin。首先为了统一管理各种版本号，我们先新建一个 <em>constants.gradle</em> 将一些常量写入到 ext 中：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.ext &#123;</span><br><span class=\"line\">    compileSdkVersion = <span class=\"number\">27</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    minSdkVersion = <span class=\"number\">21</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    targetSdkVersion = <span class=\"number\">27</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    versionCode = <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    versionName = <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p> ext 实际上是 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html\" target=\"_blank\" rel=\"noopener\">ExtraPropertiesExtension</a> 类型，它类似 map，可以存储 key/value 键值对。ext 也是扩展的一种，可以通过 <code>project.extensions.getByName(&#39;ext&#39;)</code> 获取实例，所有的 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtensionAware.html\" target=\"_blank\" rel=\"noopener\"><code>ExtensionAware</code></a> 都拥有一个 <code>ext</code>，而 Project 又是继承于  <code>ExtensionAware</code></p>\n</blockquote>\n<p>接着我们在各个 module 中创建一个 <code>gradle.properties</code> ，这个文件默认会被读取，在其中定义一个属性 <code>isApplication</code>，根据这个属性导入不同的 plugin：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// library module</span></span><br><span class=\"line\">isApplication=<span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// application module</span></span><br><span class=\"line\">isApplication=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>接着创建 <em>init.gradle</em>，在 <code>subprojects</code> 中配置，这里的配置对所有的子项目都会生效：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (project.isApplication.toBoolean()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 module 导入 application plugin</span></span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.application\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.library\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里有点地方需要注意下，因为属性的获取都是通过 String 类型，所以我们需要明确使用 <code>toBoolean()</code> 去转化成布尔值</p>\n</blockquote>\n<p>最后要想使得这些 gradle 文件生效，需要将它们 apply 进去，因为 Gradle 默认只会识别 <code>build.gradle</code>，还记得我们在 <a href=\"https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/\">Gradle多项目构建</a> 中说到，<em>Gradle 是边读取边执行的</em> ，这意味着你需要在使用到 <code>android</code> 构建块之前，将 plugin apply 进去，所以我们将这些 gradle 文件在根目录的 <em>build.gradle</em> 中 apply，因为默认根目录的优先级最高：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// constants.gradle 需要在 init.gradle，因为 init.gradle 后面会使用到 constants.gradle 中定义的值，理由如上</span></span><br><span class=\"line\">apply <span class=\"string\">from:</span> <span class=\"string\">'gradle/constants.gradle'</span></span><br><span class=\"line\">apply <span class=\"string\">from:</span> <span class=\"string\">'gradle/init.gradle'</span></span><br></pre></td></tr></table></figure>\n<p>我们将 module 下 <em>build.gradle</em> 中的 apply 代码删除，重新同步下，可以发现 <code>android</code> 配置块依然生效，这意味着，我们 apply plugin 操作成功了。</p>\n<p>在处理完 plugin 之后，我们可以将 <code>android</code> 配置块中的重复配置也在 <em>init.gradle</em> 中去配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (project.isApplication.toBoolean()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 module 导入 application plugin</span></span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.application\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.library\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    android &#123;</span><br><span class=\"line\">        compileSdkVersion rootProject.ext[<span class=\"string\">'compileSdkVersion'</span>]</span><br><span class=\"line\">        defaultConfig &#123;</span><br><span class=\"line\">            minSdkVersion rootProject.ext[<span class=\"string\">'minSdkVersion'</span>]</span><br><span class=\"line\">            targetSdkVersion rootProject.ext[<span class=\"string\">'targetSdkVersion'</span>]</span><br><span class=\"line\">            versionCode rootProject.ext[<span class=\"string\">'versionCode'</span>]</span><br><span class=\"line\">            versionName rootProject.ext[<span class=\"string\">'versionName'</span>]</span><br><span class=\"line\">            testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        buildTypes &#123;</span><br><span class=\"line\">            release &#123;</span><br><span class=\"line\">                minifyEnabled <span class=\"literal\">false</span></span><br><span class=\"line\">                proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是不是非常方便，这样统一的配置你只需要写一次，不只是 <code>android</code> 配置块可以这么处理，其他的配置也可以这么处理。</p>\n<h3 id=\"依赖管理\"><a href=\"#依赖管理\" class=\"headerlink\" title=\"依赖管理\"></a>依赖管理</h3><p>一般情况下，我们会在各个 module 下去编写所需的依赖配置，比如通过 <code>implementation &#39;com.android.support:appcompat-v7:27.1.1&#39;</code> 去从 maven 中心仓库或者 jcenter 中下载依赖，但这样有个不好的地方就是依赖配置太分散了，只能到每个 module 目录中的 <em>build.gradle</em> 去管理，如果我们将这个写到统一的 Gradle 构建脚本中，是不是会更好点，我们同样创建个 <em>dependencies.gradle</em>，将共同的依赖写到 <code>subprojects</code> ，特有的依赖写到单独的项目配置中，同样这个文件需要在根目录的 <em>build.gradle</em> 中 apply：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        testImplementation rootProject.ext.dependencies[<span class=\"string\">'junit'</span>]</span><br><span class=\"line\">        androidTestImplementation rootProject.ext.dependencies[<span class=\"string\">'runner'</span>]</span><br><span class=\"line\">        androidTestImplementation rootProject.ext.dependencies[<span class=\"string\">'espresso-core'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">project(<span class=\"string\">':mylibrary'</span>) &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        api fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">        api rootProject.ext.dependencies[<span class=\"string\">'appcompat-v7'</span>]</span><br><span class=\"line\">        api rootProject.ext.dependencies[<span class=\"string\">'constraint-layout'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">project(<span class=\"string\">':app'</span>) &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">        implementation project(<span class=\"string\">\":mylibrary\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以将共同的依赖写到 <code>subprojects</code> 块，单独项目的配置写到各自的配置块下。</p>\n<p>现在我们再来解决另外一个常见的问题：依赖冲突，比如不同的依赖项各自又依赖于同一个库的不同版本，默认 <a href=\"https://docs.gradle.org/current/userguide/troubleshooting_dependency_resolution.html#sub:version_conflicts\" target=\"_blank\" rel=\"noopener\">Gradle 会用这个重复库的最高版本</a>，但如果你配置了 <code>resolutionStrategy.failOnVersionConflict()</code> 即当出现版本冲突则失败，或者版本选择不合适，等等，就会出现依赖冲突问题。</p>\n<p>我们通过个例子来证实默认的处理策略，我们在 app 模块中去依赖  <code>com.android.support:design:27.1.1</code> 和 <code>com.android.support:recyclerview-v7:26.1.0</code> ，而 <code>design</code> 会自动去依赖 <code>com.android.support:recyclerview-v7:27.1.1</code>，依赖关系我们可以通过 <code>./gradlew :app:dependencies</code> 这个 Task 去查看，这里我们只查看 <em>releaseCompileClasspath</em> 依赖配置中 <code>design</code> 和 <code>recyclerview</code> 的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--- project :mylibrary</span><br><span class=\"line\">|    \\--- com.android.support:design:27.1.1</span><br><span class=\"line\">|         +--- com.android.support:support-v4:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-media-compat:27.1.1</span><br><span class=\"line\">|         |    |    +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|         |    |    \\--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-core-utils:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-core-ui:27.1.1 (*)</span><br><span class=\"line\">|         |    \\--- com.android.support:support-fragment:27.1.1 (*)</span><br><span class=\"line\">|         +--- com.android.support:appcompat-v7:27.1.1 (*)</span><br><span class=\"line\">|         +--- com.android.support:recyclerview-v7:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    \\--- com.android.support:support-core-ui:27.1.1 (*)</span><br><span class=\"line\">|         \\--- com.android.support:transition:27.1.1</span><br><span class=\"line\">|              +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|              \\--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">\\--- com.android.support:recyclerview-v7:26.1.0 -&gt; 27.1.1 (*)</span><br></pre></td></tr></table></figure>\n<p>可以看到我们依赖的 26.1.0 已经被替换成 27.1.1，如果这是我们想要的结果，那就很理想，但是如果我们想要去定义依赖冲突的策略呢？同样的，Gradle 也提供了相应的 API。</p>\n<p>还是上面的例子，如果我们不想要使用 <code>design</code> 中的 <code>recyclerview</code> 而想要我们单独依赖的 <code>recyclerview-v7:26.1.1</code> 这里我们有几种方式解决：</p>\n<ol>\n<li><p>不传递依赖</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">api(rootProject.ext.dependencies[<span class=\"string\">'design'</span>]) &#123;</span><br><span class=\"line\">            transitive = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>强制使用当前版本</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation(rootProject.ext.dependencies[<span class=\"string\">'recyclerview'</span>]) &#123;</span><br><span class=\"line\">            force = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其他的解决方案可以参考<a href=\"https://docs.gradle.org/current/userguide/introduction_dependency_management.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p>这里我们使用 Gradle 提供的 <a href=\"https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html\" target=\"_blank\" rel=\"noopener\">resolutionStrategy</a> 方案： </p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    configurations.all &#123;</span><br><span class=\"line\">        resolutionStrategy &#123;</span><br><span class=\"line\">            force rootProject.ext.dependencies[<span class=\"string\">'recyclerview'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>configurations</code> 表示当前项目的依赖配置容器，<code>configurations.all</code> 表示当前项目的所有依赖配置，上面的配置表示，遍历当前项目的所有依赖配置，设置其依赖解决策略为 <strong>强制使用指定的版本</strong></p>\n<h2 id=\"改造结束\"><a href=\"#改造结束\" class=\"headerlink\" title=\"改造结束\"></a>改造结束</h2><p>现在我们再来对比下，默认生成的构建配置和改造后的构建配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">        minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"literal\">false</span></span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support:appcompat-v7:27.1.1'</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support.constraint:constraint-layout:1.1.0'</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">'junit:junit:4.12'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test:runner:1.0.2'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test.espresso:espresso-core:3.0.2'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是不是简洁了不少，重复的配置项我们交给统一的配置文件去做，依赖配置也是如此，包括依赖冲突的解决策略，但是 Gradle 能实现的不仅仅如此，还有强大的自定义 Gradle Plugin 我们还没讲到。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这篇文章，不仅仅是教会大家如何去编写简单的 Gradle 构建脚本，更重要的想让大家对 Gradle 有个初步的认识，知道 Gradle 的配置块是如何生成的，更多知识可以通过<a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>去获取。</p>\n"},{"title":"Activity启动流程(基于Android26)","date":"2018-03-27T01:54:17.000Z","_content":"\n> 基于 Android 26，分析 Android Activity 启动流程\n\n## 参考\n\n[startActivity启动过程分析](http://gityuan.com/2016/03/12/start-activity/)\n\n## 源码\n\n**源码篇幅可能过长，所以会省略一下不必要的代码和注释**\n\n### Activity\n\n``` java\n@Override                                    \npublic void startActivity() {   \n    this.startActivity(intent, null);        \n}\n\n@Override                                                           \npublic void startActivity() {\n    if (options != null) {                                          \n        startActivityForResult(intent, -1, options);                \n    } else {                                                        \n        startActivityForResult(intent, -1);                         \n    }                                                               \n}                                                                   \n```\n\n最终都会调用到 `startActivityForResult`：\n\n``` java\npublic void startActivityForResult() {                                                             \n    if (mParent == null) {\n        // 转场动画的处理\n        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      \n        if (ar != null) {                                                                       \n            mMainThread.sendActivityResult();                                                                                                             \n        }                                                                                       \n        if (requestCode >= 0) {                                                                                        \n            mStartedActivity = true;                                                            \n        }                                                                                                                                                                             \n    } else {                                                                                    \n        // 如果存在 Parent Activity 则交由它处理                                                                                    \n    }                                                                                           \n}                                                                                               \n```\n\n可以知道 Activity 启动委托给了 Instrumentation 进行实现\n\n### Instrumentation\n\n``` java\npublic ActivityResult execStartActivity() {\n    // 由 ActivityThread.getApplicationThread 提供的 ApplicationThread\n    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                \n    if (mActivityMonitors != null) {                                       \n        synchronized (mSync) {                                             \n            final int N = mActivityMonitors.size();                        \n            for (int i=0; i<N; i++) {                                      \n                final ActivityMonitor am = mActivityMonitors.get(i);       \n                ActivityResult result = null;                              \n                if (am.ignoreMatchingSpecificIntents()) {\n                    // true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 \n                    result = am.onStartActivity(intent);                   \n                }                                                          \n                if (result != null) {                                      \n                    am.mHits++;                                            \n                    return result;                                         \n                } else if (am.match(who, null, intent)) {\n                    // match 使用 IntentFilter 和 类名 进行匹配\n                    am.mHits++;                                            \n                    if (am.isBlocking()) {\n                        // 当前监视器阻止 Activity 启动\n                        return requestCode >= 0 ? am.getResult() : null;   \n                    }                                                      \n                    break;                                                 \n                }                                                          \n            }                                                              \n        }                                                                  \n    }                                                                      \n    try {\n        // 委托为 ActivityManagerService(AMS) 去处理\n        int result = ActivityManager.getService().startActivity();                          \n        // 检查 AMS 的处理结果\n        checkStartActivityResult(result, intent);                          \n    } catch (RemoteException e) {                                          \n        throw new RuntimeException(\"Failure from system\", e);              \n    }                                                                      \n    return null;                                                           \n}                                                                          \n```\n\n可以通过最后的调用委托给了`ActivityManager.getService`，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现\n\n> 相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC\n\n``` java\npublic static IActivityManager getService() {\n    return IActivityManagerSingleton.get();  \n}\n\nprivate static final Singleton<IActivityManager> IActivityManagerSingleton =          \n        new Singleton<IActivityManager>() {                                           \n            @Override                                                                 \n            protected IActivityManager create() {                                     \n                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);\n                final IActivityManager am = IActivityManager.Stub.asInterface(b);     \n                return am;                                                            \n            }                                                                         \n        };                                                                            \n```\n\n### ActivityManagerService\n\n``` java\n@Override                                                                                       \npublic final int startActivity() {                           \n    return startActivityAsUser();                                                     \n}\n\n@Override                                                                                                                          \npublic final int startActivityAsUser() {                                                                                                                                   \n    return mActivityStarter.startActivityMayWait();                                                                                                \n}                                                                                                                                  \n```\n\n这里将启动请求又委托给了 ActivityStarter\n\n### ActivityStarter\n\n``` java\nfinal int startActivityMayWait() {                                                \n    // Intent 的响应\n    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           \n    // Intent 的 Activity 信息                                                               \n    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        \n        final ActivityRecord[] outRecord = new ActivityRecord[1];\n    \t// 调用 startActivityLocked\n        int res = startActivityLocked(outRecord);                                                                                                                          \n        return res;                                                                                                       \n    }                                                                                                                     \n}                                                                                                                         \n```\n\n``` java\nprivate int startActivity() {\n    // 源 Activity 记录，即在哪个 Activity 进行 startActivity\n    ActivityRecord sourceRecord = null;\n    // 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity\n    ActivityRecord resultRecord = null;                                                                       \n    if (resultTo != null) {\n        // 获取 Activity Stack 中已经存在的源 Activity 记录\n        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 \n        if (sourceRecord != null) {                                                                           \n            if (requestCode >= 0 && !sourceRecord.finishing) {\n                // requestCode >= 0，源 Activity 同时为 结果 Activity\n                resultRecord = sourceRecord;                                                                  \n            }                                                                                                 \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    final int launchFlags = intent.getFlags();                                                                \n                                                                                                              \n    if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {                   \n        // 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity\n        // 比如：A -> B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A\n        if (requestCode >= 0) {\n            // 不允许有 requestCode\n            ActivityOptions.abort(options);                                                                   \n            return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        \n        }\n        // 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity\n        resultRecord = sourceRecord.resultTo;                                                                 \n        if (resultRecord != null && !resultRecord.isInStackLocked()) {                                        \n            resultRecord = null;                                                                              \n        }\n        // requestCode 处理\n        resultWho = sourceRecord.resultWho;                                                                   \n        requestCode = sourceRecord.requestCode;                                                               \n        sourceRecord.resultTo = null;                                                                         \n        if (resultRecord != null) {\n            // 删除源 Activity 记录\n            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           \n        }                                                                                                                                                                                         \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {                              \n        // component 找不到                                                                         \n        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && aInfo == null) {                                              \n        // ActivityInfo 找不到                                                                         \n        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && sourceRecord != null                                          \n            && sourceRecord.getTask().voiceSession != null) {                                                 \n        // 语音启动 Activity，检查是否符合                                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && voiceSession != null) {                                       \n        // 启动语音会话                                                       \n    }                                                                                                         \n                                                                                                              \n    final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack();                  \n                                                                                                              \n    if (err != START_SUCCESS) {\n        // 启动 Activity 失败\n        if (resultRecord != null) {\n            // 发送取消通知\n            resultStack.sendActivityResultLocked(                                                             \n                    -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);                         \n        }                                                                                                     \n        ActivityOptions.abort(options);                                                                       \n        return err;                                                                                           \n    }                                                                                                         \n                                                                                                              \n    // 进行一些权限检查，判断是否终止                                                              \n    if (abort) {\n        // 如果需要终止 Activity\n        if (resultRecord != null) {                                                                           \n            resultStack.sendActivityResultLocked();                                                                   \n        }                                                                                                     \n        // 返回启动成功，实际终止                                                                \n        ActivityOptions.abort(options);                                                                       \n        return START_SUCCESS;                                                                                 \n    }                                                                                                         \n                                                                                                              \n    // 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             \n                                                                                                              \n    // 处理 ephemeral app                                                                    \n    \n    // 构造一个 ActivityRecord\n    ActivityRecord r = new ActivityRecord();                                                   \n                                                                                                     \n    final ActivityStack stack = mSupervisor.mFocusedStack;                                                    \n    if (voiceSession == null && (stack.mResumedActivity == null                                               \n            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) {\n        // 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换\n        if (!mService.checkAppSwitchAllowedLocked() {                                          \n            PendingActivityLaunch pal =  new PendingActivityLaunch();                                              \n            mPendingActivityLaunches.add(pal);                                                                \n            ActivityOptions.abort(options);\n            // 切换 app 失败\n            return ActivityManager.START_SWITCHES_CANCELED;                                                   \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    if (mService.mDidAppSwitch) {                                                                             \n        // 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            \n        mService.mAppSwitchesAllowedTime = 0;                                                                 \n    } else {                                                                                                  \n        mService.mDidAppSwitch = true;                                                                        \n    }                                                                                                         \n    \n    // 执行因为不允许 app 切换，而加到等待启动的 Activity\n    doPendingActivityLaunchesLocked(false);                                                                   \n                                                                                                              \n    return startActivity();                                                                    \n}                                                                                                             \n```\n\n``` java\nprivate int startActivity() {                                                        \n    int result = START_CANCELED;                                                               \n    try {                                                                                      \n        mService.mWindowManager.deferSurfaceLayout();\n        // 下一步流程\n        result = startActivityUnchecked();                           \n    } finally {                                                                                \n        // 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      \n        if (!ActivityManager.isStartResultSuccessful(result)                                   \n                && mStartActivity.getTask() != null) {                                         \n            mStartActivity.getTask().removeActivity(mStartActivity);                           \n        }                                                                                      \n        mService.mWindowManager.continueSurfaceLayout();                                       \n    }                                                                                          \n                                                                                               \n    postStartActivityProcessing();                                                                     \n                                                                                               \n    return result;                                                                             \n}                                                                                              \n```\n\n``` java\nprivate int startActivityUnchecked() {\n\t\n    // 设置一些初始化状态\n    setInitialState();\n    // 计算 launch flags\n    computeLaunchingTaskFlags();\n    // 计算源 Task，源 Task 是否存在等\n    computeSourceStack();\n    // 获取是否存在可以复用的 Activity，根据 flags 和 launchMode\n    ActivityRecord reusedActivity = getReusableIntentActivity();\n    if (reusedActivity != null) {\n    \t// 存在可复用的 Activity，复用它\n        // 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置\n    }\n    if (mStartActivity.packageName == null) {\n    \treturn START_CLASS_NOT_FOUND;\n    }\n    // 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity\n    final boolean dontStart = top != null && mStartActivity.resultTo == null\n                && top.realActivity.equals(mStartActivity.realActivity)\n                && top.userId == mStartActivity.userId\n                && top.app != null && top.app.thread != null\n                && ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0\n                || mLaunchSingleTop || mLaunchSingleTask);\n    if(dontStart){\n        // 传递一个新的 Intent 到 onNewIntent \n        top.deliverNewIntentLocked();\n        return START_DELIVERED_TO_TOP;\n    }\n    \n    // 获取 mTargetStack\n    if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask\n                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n    \tnewTask = true;\n        // 需要创建新的 Task\n        result = setTaskFromReuseOrCreateNewTask();\n    } else if (mSourceRecord != null) {\n        // 从源 Activity 中获取 Task\n    \tresult = setTaskFromSourceRecord();\n    } else if (mInTask != null) {\n        // 从 InTask 中获取 Task\n    \tresult = setTaskFromInTask();\n    } else {\n        // 可能创建新的 Task 或使用当前 Task，一般不会发生\n    \tsetTaskToCurrentTopOrCreateNewTask();\n    }\n    \n    // 使用 mTargetStack 启动 Activity \n    mTargetStack.startActivityLocked();\n    \n    if (mDoResume) {\n        if (!mTargetStack.isFocusable()\n                    || (topTaskActivity != null && topTaskActivity.mTaskOverlay\n                    && mStartActivity != topTaskActivity)) {\n        \t// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity\n            // 那么我们不恢复目标 Task，只需要确保它可见即可\n            mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        }\n    } else {\n        if (mTargetStack.isFocusable() && !mSupervisor.isFocusedStack(mTargetStack)) {\n        \t// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台\n            mTargetStack.moveToFront(\"startActivityUnchecked\");\n        }\n        // 恢复目标 Task\n        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,\n                        mOptions);\n    } else {\n        // 如果不需要恢复，那么加到\"最近活动\"中\n        mTargetStack.addRecentActivityLocked(mStartActivity);\n    }\n    \n    return START_SUCCESS;\n}\n\nprivate void setInitialState(){\n    // 获取 DisplayId\n    mSourceDisplayId = getSourceDisplayId();\n    // 获取用于启动 Activity 的范围，Rect\n    mLaunchBounds = getOerrideBounds();\n    // launchMode\n    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;\n    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;\n    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;\n    // Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主\n    // 如果 requestCode >= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity\n    sendNewTaskResultRequestIfNeeded();\n}\n\nprivate void computeLaunchingTaskFlags(){\n    if (mSourceRecord == null && mInTask != null && mInTask.getStack() != null){\n        // 如果不存在源 Activity\n        final Intent baseIntent = mInTask.getBaseIntent();\n        final ActivityRecord root = mInTask.getRootActivity();\n        if (baseIntent == null){\n            throw new IllegalArgumentException();\n        }\n        if (mLaunchSingleInstance || mLaunchSingleTask) {\n            // 如果设置了 SingleInstacne 或 SingleTask\n        \tif (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent())){\n                // Task 不符合\n                throw new IllegalArgumentException();\n            }\n            \n            if(root != null){\n                // 已经存在 Task 根 Activity\n                throw new IllegalArgumentException();\n            }\n        }\n        \n        if (root == null) {\n        \t// 如果不存在根 Activity，重新设置 launch flags\n            mAddingToTask = true;\n        }else if ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n             mAddingToTask = false;\n        }else {\n            mAddingToTask = true;\n        }\n    }else {\n                     if ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) && mSourceRecord != null\n                    && mSourceRecord.isFreeform())  {\n                         // 如果使用 ResolverActivity 启动或者 noDisplay\n                mAddingToTask = true;\n            }\n    }\n    \n    if(mInTask == null){\n        if (mSourceRecord == null) {\n        \tif ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) == 0 && mInTask == null) {\n                // 不存在 Task，并且不存在源 Activity\n            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n            }\n        }else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) {\n        \t// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }else if (mLaunchSingleInstance || mLaunchSingleTask) {\n        \t// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }\n    }\n    \n}\n```\n\nActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity\n\n### ActivityStack\n\n``` java\nfinal void startActivityLocked(){\n    if(!newTask) {\n      // 如果从已存在的 Task 中启动 Activity\n      boolean startIt = true;\n      for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {\n      \ttask = mTaskHistory.get(taskNdx);\n          if (task.getTopActivity() == null){\n              // 如果 task 不存在 Activity\n              continue;\n          }\n          if (task == rTask) {\n          \t// 找到对应的 task\n            if (!startIt) {\n            \t// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动\n                r.createWindowContainer();\n                ActivityOptions.abort(options);\n                return;\n            }\n          } else if (task.numFullscreen > 0) {\n              startIt = false;\n          }\n      }\n    }\n    \n    // 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调\n    if (task == activityTask && mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) {\n        mStackSupervisor.mUserLeaving = false;\n    }\n    \n    if (!isHomeOrRecentsStack() || numActivities() > 0) {\n    \t// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0\n        \n        // 处理 动画\n        \n        if (newTask) {\n            if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {\n            // 如果设置了重置的标记\n            resetTaskIfNeededLocked(r, r);\n            doShow = topRunningNonDelayedActivityLocked(null) == r;\n            } else if (options != null && options.getAnimationType()\n                    == ActivityOptions.ANIM_SCENE_TRANSITION) {\n                // 需要进行转场动画\n                doShow = false;\n        }\n    }\n        \n        \n        if (r.mLaunchTaskBehind) {\n        \t// 如果为 true，那么不开启 window，但要确保 Activity 是可见的\n            r.setVisibility(true);\n            ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        } else if (SHOW_APP_STARTING_PREVIEW && doShow) {\n            TaskRecord prevTask = r.getTask();\n            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();\n            if (prev != null) {\n                // 以下两种情况不展示之前的 Activity 预览\n            \tif (prev.getTask() != prevTask) {\n                    // 之前的 Activity 在不同的 Task\n                \tprev = null;\n                } else if (prev.nowVisible) {\n                    // 现在可见\n                \t prev = null;\n                }\n            }\n            // 显示启动 Activity 的 Window\n        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));\n        } else {\n            // 当前为栈顶 Activity\n            ActivityOptions.abort(options);\n        }\n    \n}\n```\n\n`ActivityStack.startActivityLocked` 主要是创建 WindowContainer，同时显示 Window\n\n### ActivityStackSupervisor\n\n``` java\nboolean resumeFocusedStackTopActivityLocked(){\n    if (targetStack != null && isFocusedStack(targetStack)) {\n        // 存在 targetStack\n    \treturn targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);\n    }\n    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();\n    if (r == null || r.state != RESUMED) {\n        // 恢复聚焦 task\n    \tmFocusedStack.resumeTopActivityUncheckedLocked(null, null);\n    } else if (r.state == RESUMED) {\n        // 执行应用转场动画\n    \tmFocusedStack.executeAppTransition(targetOptions);\n    }\n}\n```\n\n### ActivityStack\n\n``` java\nboolean resumeTopActivityUncheckedLocked() {\n    if (mStackSupervisor.inResumeTopActivity) {\n        // 防止递归\n    \treturn false;\n    }\n    try {\n        // 设置恢复标记\n        mStackSupervisor.inResumeTopActivity = true;\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        mStackSupervisor.inResumeTopActivity = false;\n    }\n    // 在恢复过程中，确保必要的暂停逻辑\n    mStackSupervisor.checkReadyForSleepLocked();\n}\n```\n\n``` java\nprivate boolean resumeTopActivityInnerLocked() {\n    \n    // 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦\n    final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);\n    final boolean hasRunningActivity = next != null;\n    final ActivityRecord parent = mActivityContainer.mParentActivity;\n    final boolean isParentNotResumed = parent != null && parent.state != ActivityState.RESUMED;\n    if (hasRunningActivity\n                && (isParentNotResumed || !mActivityContainer.isAttachedLocked())) {\n           // 如果父 Activity 不是恢复状态，则不恢复当前 Activity\n            return false;\n        }\n    \n    if (!hasRunningActivity) {\n        // 当前 Task 没有需要恢复的 Activity\n    \treturn resumeTopActivityInNextFocusableStack(prev, options, \"noMoreActivities\");\n    }\n    \n    if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                    mStackSupervisor.allResumedActivitiesComplete()) {\n        // 如果 Activity 已经是恢复状态\n        // 确保已经执行了所有等待的转场\n        executeAppTransition(options);\n    \treturn false;\n    }\n    \n    if (mService.isSleepingOrShuttingDownLocked()\n                && mLastPausedActivity == next\n                && mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果系统处于休眠状态，当前 Activity 处于暂停状态\n        // 确保转场执行\n        executeAppTransition(options);\n        return false;\n    }\n    \n    if (!mService.mUserController.hasStartedUserState(next.userId)) {\n        // 如果拥有该 Activity 的用户没有启动\n    \treturn false;\n    }\n    \n    if (!mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果存在暂停 Activity 的操作未完成\n        return false;\n    }\n    \n    boolean lastResumedCanPip = false;\n    final ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();\n    if (lastFocusedStack != null && lastFocusedStack != this) {\n    \tfinal ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;\n        // 最后一个恢复的 Activity 是否可以 画中画\n        lastResumedCanPip = lastResumed != null && lastResumed.checkEnterPictureInPictureState(\n                    \"resumeTopActivity\", true /* noThrow */, userLeaving /* beforeStopping */);\n    }\n    \n    // 是否需要可以在上一个 Activity 暂停时进行恢复\n    final boolean resumeWhilePausing = (next.info.flags & FLAG_RESUME_WHILE_PAUSING) != 0\n                && !lastResumedCanPip;\n    // 是否暂停了回退的 task\n    boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);\n    \n    if (mResumedActivity != null) {\n        // 暂停上一个恢复状态的 Activity\n    \tpausing |= startPausingLocked(userLeaving, false, next, false);\n    }\n    \n    if (pausing && !resumeWhilePausing) {\n    \t// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity\n        if (next.app != null && next.app.thread != null) {\n            // hosting application，一般不执行\n            // 让当前 Activity 放在 Lru 的顶部，避免早早杀死\n        \tmService.updateLruProcessLocked(next.app, true, null);\n        }\n        return true;\n    } else if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                mStackSupervisor.allResumedActivitiesComplete()) {\n    \t// 当前需要恢复的 Activity 已经是恢复状态\n        // 确保执行转场\n        executeAppTransition(options);\n        return true;\n    }\n    \n    if (mService.isSleepingLocked() && mLastNoHistoryActivity != null &&\n                !mLastNoHistoryActivity.finishing) {\n        // 结束因为系统休眠而还没结束的 Activity\n    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,\n                    null, \"resume-no-history\", false);\n        mLastNoHistoryActivity = null;\n    }\n    \n    if (prev != null && prev != next) {\n    \tif (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)\n                    && next != null && !next.nowVisible) {\n        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);\n        } else {\n            // 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity\n            if (prev.finishing) {\n            \tprev.setVisibility(false);\n            } else {\n                \n            }\n        }\n    }\n    \n    // Activity 转场处理\n    \n    ActivityStack lastStack = mStackSupervisor.getLastStack();\n    if (next.app != null && next.app.thread != null) {\n        // 上一个 Activity 是否为透明\n    \tfinal boolean lastActivityTranslucent = lastStack != null\n                    && (!lastStack.mFullscreen\n                    || (lastStack.mLastPausedActivity != null\n                    && !lastStack.mLastPausedActivity.fullscreen));\n        \n        if (!next.visible || next.stopped || lastActivityTranslucent) {\n            // 前一个 Activity 为透明，并且当前 Activity 还没显示\n            // 设置为显示状态\n            next.setVisibility(true);\n        }\n        \n        // 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向\n    boolean notUpdated = true;\n    if (mStackSupervisor.isFocusedStack(this)) {\n    \tfinal Configuration config = mWindowManager.updateOrientationFromAppTokens(\n                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),\n                        next.mayFreezeScreenLocked(next.app) ? next.appToken : null, mDisplayId);\n        \n        if (config != null) {\n    \tnext.frozenBeforeDestroy = true;\n        }\n        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,\n                        false /* deferResume */, mDisplayId);\n    }\n    \n     if (notUpdated) {\n         // 配置发生更新无法保持已经存在的 Activity 实例\n         // 重新获取需要恢复的 Activity\n         ActivityRecord nextNext = topRunningActivityLocked();\n         // 确保 Activity 仍然保持在栈顶，同时安排另外一次执行\n         if (nextNext != next) {\n         \tmStackSupervisor.scheduleResumeTopActivities();\n         }\n         if (!next.visible || next.stopped) {\n         \tnext.setVisibility(true);\n         }\n         next.completeResumeLocked();\n         return true;\n     }\n    \n    try {\n        // 传递所有等待的结果\n        \n        if (next.newIntents != null){\n            next.app.thread.scheduleNewIntent(\n                            next.newIntents, next.appToken, false /* andPause */);\n        }\n        \n        next.notifyAppResumed(next.stopped);\n        \n        // 准备恢复 Activity\n        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,\n                        mService.isNextTransitionForward(), resumeAnimOptions);\n    } catch (Exception e){\n        // 发生异常，重新启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, false);\n        return true;\n    }\n        \n        try {\n            next.completeResumeLocked();\n        } catch(Exception e){\n            // 发生异常，结束 Activity\n            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null,\n                        \"resume-exception\", true);\n            return true;\n        }\n        \n    } else {\n        // 需要启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\n    }\n    \n    return true;\n\n}\n```\n\n如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：\n\n### ActivityStackSupervisor\n\n``` java\nvoid startSpecificActivityLocked() {\n    // 获取应用进程信息\n    ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n                r.info.applicationInfo.uid, true);\n    \n    if (app != null && app.thread != null) {\n    \t// 如果进程已经启动\n        try {\n            realStartActivityLocked(r, app, andResume, checkConfig);\n            return;\n        }catch (RemoteException e){\n            \n        }\n    }\n    \n    // 启动应用进程\n    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n}\n```\n\n``` java\nfinal boolean realStartActivityLocked() {\n    // 冻结屏幕\n    r.startFreezingScreenLocked(app, 0);\n    if (checkConfig) {\n    \t// 根据新的 Activity 顺序重新评估屏幕的方向\n    }\n    \n    int idx = app.activities.indexOf(r);\n    if (idx < 0) {\n        // 将 Activity 添加到应用进程中\n        app.activities.add(r);\n    }\n    \n    try {\n        app.thread.scheduleLaunchActivity();\n    }catch(RemoteException e){\n        // 发生异常，结束 Activity\n        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,\n                        \"2nd-crash\", false);\n        return false;\n    }\n    \n    return true;\n}\n```\n\n启动流程最后还是回到了 ApplicationThread\n\n### ApplicationThread\n\n``` java\npublic final void scheduleLaunchActivity() {\n    // 通过 Handler 发送 LAUNCH_ACTIVITY\n    sendMessage(H.LAUNCH_ACTIVITY, r);\n}\n```\n\n我们单独把 LAUNCH_ACTIVITY 的处理拿出来：\n\n``` java\nfinal ActivityClientRecord r = (ActivityClientRecord) msg.obj;\nr.packageInfo = getPackageInfoNoCheck(\n                            r.activityInfo.applicationInfo, r.compatInfo);\nhandleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n```\n\n### ActivityThread\n\n``` java\nprivate void handleLaunchActivity() {\n    // 执行启动 Activity\n    Activity a = performLaunchActivity(r, customIntent);\n    if (a != null) {\n        // resume activity\n        handleResumeActivity(r.token, false, r.isForward,\n                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);\n    } else {\n        \n    }\n}\n```\n\n``` java\nprivate performLaunchActivity() {\n    // Activity 信息初始化\n    \n    // 创建 context\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        // 构建 Activity\n        activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n    }catch(Exception e){\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        if(activity != null){\n        \tactivity.attach();\n            \n            // 通过 Instrumentation 执行 Activity onCreate\n            if (r.isPersistable()) {\n                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            }else {\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            \n            if (!r.activity.mFinished) {\n                // Activity onStart\n            \tactivity.performStart();\n            }\n            \n            // 通过 Instrumentation 执行 Activity onRestoreInstanceState\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                \tif (r.state != null || r.persistentState != null) {\n                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,\n                                    r.persistentState);\n                    }\n                } else if (r.state != null) {\n                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);\n                }\n            }\n            \n             // 通过 Instrumentation 执行 Activity onPostCreeate\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state,\n                                r.persistentState);\n                }else {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state);\n                }\n            }       \n    }\n        \n    return activity;\n    \n}\n```\n\n``` java\nfinal void handleResumeActivity() {\n    r = performResumeActivity();\n    if(r != null) {\n        final Activity a = r.activity;\n        if (r.window == null && !a.mFinished && willBeVisible) {\n            r.window = r.activity.getWindow();\n            View decor = r.window.getDecorView();\n            decor.setVisibility(View.INVISIBLE);\n            ViewManager wm = a.getWindowManager();\n            if (a.mVisibleFromClient) {\n            \tif (!a.mWindowAdded) {\n                \ta.mWindowAdded = true;\n                    // window\n                    wm.addView(decor, l);\n                }\n            }\n        }\n    }\n}\n```\n\n``` java\npublic final ActivityClientRecord performResumeActivity() {\n \tif (r != null && !r.activity.mFinished) {\n    \ttry {\n            // 处理等待的 Intent\n            if (r.pendingIntents != null) {\n            \tdeliverNewIntents(r, r.pendingIntents);\n                r.pendingIntents = null;\n            }\n            // 处理等待的 result\n            if (r.pendingResults != null) {\n            \tdeliverResults(r, r.pendingResults);\n                r.pendingResults = null;\n            }\n            // 执行 resume\n            r.activity.performResume();\n        }\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic Activity newActivity(){\n    return (Activity)cl.loadClass(className).newInstance();\n}\n```\n\n``` java\nprivate void callActivityOnCreate(){\n    prePerformCreate(activity);\n    activity.performCreate(icicle);\n    postPerformCreate(activity);\n}\n```\n\n### Activity\n\n``` java\nfinal void performCreate() {\n    restoreHasCurrentPermissionRequest(icicle);\n    // 调用 onCreate\n    onCreate(icicle);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n```\n\n``` java\nfinal void performStart() {\n    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());\n    mInstrumentation.callActivityOnStart(this);\n    mActivityTransitionState.enterReady(this);\n}\n```\n\n``` java\nfinal void performResume() {\n    // 执行 restart\n    performRestart();\n    mInstrumentation.callActivityOnResume(this);\n}\n```\n\n``` java\nfinal void performRestart() {\n    if (mStopped) {\n        mStopped = false;\n        mInstrumentation.callActivityOnRestart(this);\n        // 执行 start\n        performStart();\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic void callActivityOnStart() {\n    activity.onStart();\n}\n```\n\n``` java\npublic void callActivityOnResume() {\n     activity.mResumed = true;\n    activity.onResume();\n}\n```\n\n``` java\npublic void callActivityOnRestart() {\n    activity.onRestart();\n}\n```\n\n## 总结\n\n简单总结下 Activity 的启动流程：\n\n1. 从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信\n2. ActivityManagerService 用于管理所有的 Activity 活动\n   * 当接受到启动 Activity 的调用时，使用 `resolveActivity` ，查询系统中符合要求的 Activity\n   * 创建使用合适的  ActivityStack 和 launch flags 来启动 Activity\n   * 如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity\n   * 如果不存在应用进程，先创建应用进程\n3. 最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行\n   * 使用 Instrumentation 去通过反射构建 Activity 实例\n   * 使用 Handler 机制调用 Activity 的生命周期\n\n下面的图例来自[博客](http://gityuan.com/2016/03/12/start-activity/)：\n\n![启动流程](http://gityuan.com/images/activity/start_activity_process.jpg)\n\n### 时序图\n\n![Android启动流程](http://oy017242u.bkt.clouddn.com/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png)\n\n","source":"_posts/Activity启动流程-基于Android26.md","raw":"---\ntitle: Activity启动流程(基于Android26)\ndate: 2018-03-27 09:54:17\ncategories: Android Framework\ntags:\n---\n\n> 基于 Android 26，分析 Android Activity 启动流程\n\n## 参考\n\n[startActivity启动过程分析](http://gityuan.com/2016/03/12/start-activity/)\n\n## 源码\n\n**源码篇幅可能过长，所以会省略一下不必要的代码和注释**\n\n### Activity\n\n``` java\n@Override                                    \npublic void startActivity() {   \n    this.startActivity(intent, null);        \n}\n\n@Override                                                           \npublic void startActivity() {\n    if (options != null) {                                          \n        startActivityForResult(intent, -1, options);                \n    } else {                                                        \n        startActivityForResult(intent, -1);                         \n    }                                                               \n}                                                                   \n```\n\n最终都会调用到 `startActivityForResult`：\n\n``` java\npublic void startActivityForResult() {                                                             \n    if (mParent == null) {\n        // 转场动画的处理\n        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      \n        if (ar != null) {                                                                       \n            mMainThread.sendActivityResult();                                                                                                             \n        }                                                                                       \n        if (requestCode >= 0) {                                                                                        \n            mStartedActivity = true;                                                            \n        }                                                                                                                                                                             \n    } else {                                                                                    \n        // 如果存在 Parent Activity 则交由它处理                                                                                    \n    }                                                                                           \n}                                                                                               \n```\n\n可以知道 Activity 启动委托给了 Instrumentation 进行实现\n\n### Instrumentation\n\n``` java\npublic ActivityResult execStartActivity() {\n    // 由 ActivityThread.getApplicationThread 提供的 ApplicationThread\n    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                \n    if (mActivityMonitors != null) {                                       \n        synchronized (mSync) {                                             \n            final int N = mActivityMonitors.size();                        \n            for (int i=0; i<N; i++) {                                      \n                final ActivityMonitor am = mActivityMonitors.get(i);       \n                ActivityResult result = null;                              \n                if (am.ignoreMatchingSpecificIntents()) {\n                    // true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 \n                    result = am.onStartActivity(intent);                   \n                }                                                          \n                if (result != null) {                                      \n                    am.mHits++;                                            \n                    return result;                                         \n                } else if (am.match(who, null, intent)) {\n                    // match 使用 IntentFilter 和 类名 进行匹配\n                    am.mHits++;                                            \n                    if (am.isBlocking()) {\n                        // 当前监视器阻止 Activity 启动\n                        return requestCode >= 0 ? am.getResult() : null;   \n                    }                                                      \n                    break;                                                 \n                }                                                          \n            }                                                              \n        }                                                                  \n    }                                                                      \n    try {\n        // 委托为 ActivityManagerService(AMS) 去处理\n        int result = ActivityManager.getService().startActivity();                          \n        // 检查 AMS 的处理结果\n        checkStartActivityResult(result, intent);                          \n    } catch (RemoteException e) {                                          \n        throw new RuntimeException(\"Failure from system\", e);              \n    }                                                                      \n    return null;                                                           \n}                                                                          \n```\n\n可以通过最后的调用委托给了`ActivityManager.getService`，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现\n\n> 相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC\n\n``` java\npublic static IActivityManager getService() {\n    return IActivityManagerSingleton.get();  \n}\n\nprivate static final Singleton<IActivityManager> IActivityManagerSingleton =          \n        new Singleton<IActivityManager>() {                                           \n            @Override                                                                 \n            protected IActivityManager create() {                                     \n                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);\n                final IActivityManager am = IActivityManager.Stub.asInterface(b);     \n                return am;                                                            \n            }                                                                         \n        };                                                                            \n```\n\n### ActivityManagerService\n\n``` java\n@Override                                                                                       \npublic final int startActivity() {                           \n    return startActivityAsUser();                                                     \n}\n\n@Override                                                                                                                          \npublic final int startActivityAsUser() {                                                                                                                                   \n    return mActivityStarter.startActivityMayWait();                                                                                                \n}                                                                                                                                  \n```\n\n这里将启动请求又委托给了 ActivityStarter\n\n### ActivityStarter\n\n``` java\nfinal int startActivityMayWait() {                                                \n    // Intent 的响应\n    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           \n    // Intent 的 Activity 信息                                                               \n    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        \n        final ActivityRecord[] outRecord = new ActivityRecord[1];\n    \t// 调用 startActivityLocked\n        int res = startActivityLocked(outRecord);                                                                                                                          \n        return res;                                                                                                       \n    }                                                                                                                     \n}                                                                                                                         \n```\n\n``` java\nprivate int startActivity() {\n    // 源 Activity 记录，即在哪个 Activity 进行 startActivity\n    ActivityRecord sourceRecord = null;\n    // 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity\n    ActivityRecord resultRecord = null;                                                                       \n    if (resultTo != null) {\n        // 获取 Activity Stack 中已经存在的源 Activity 记录\n        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 \n        if (sourceRecord != null) {                                                                           \n            if (requestCode >= 0 && !sourceRecord.finishing) {\n                // requestCode >= 0，源 Activity 同时为 结果 Activity\n                resultRecord = sourceRecord;                                                                  \n            }                                                                                                 \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    final int launchFlags = intent.getFlags();                                                                \n                                                                                                              \n    if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {                   \n        // 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity\n        // 比如：A -> B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A\n        if (requestCode >= 0) {\n            // 不允许有 requestCode\n            ActivityOptions.abort(options);                                                                   \n            return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        \n        }\n        // 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity\n        resultRecord = sourceRecord.resultTo;                                                                 \n        if (resultRecord != null && !resultRecord.isInStackLocked()) {                                        \n            resultRecord = null;                                                                              \n        }\n        // requestCode 处理\n        resultWho = sourceRecord.resultWho;                                                                   \n        requestCode = sourceRecord.requestCode;                                                               \n        sourceRecord.resultTo = null;                                                                         \n        if (resultRecord != null) {\n            // 删除源 Activity 记录\n            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           \n        }                                                                                                                                                                                         \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {                              \n        // component 找不到                                                                         \n        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && aInfo == null) {                                              \n        // ActivityInfo 找不到                                                                         \n        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && sourceRecord != null                                          \n            && sourceRecord.getTask().voiceSession != null) {                                                 \n        // 语音启动 Activity，检查是否符合                                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && voiceSession != null) {                                       \n        // 启动语音会话                                                       \n    }                                                                                                         \n                                                                                                              \n    final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack();                  \n                                                                                                              \n    if (err != START_SUCCESS) {\n        // 启动 Activity 失败\n        if (resultRecord != null) {\n            // 发送取消通知\n            resultStack.sendActivityResultLocked(                                                             \n                    -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);                         \n        }                                                                                                     \n        ActivityOptions.abort(options);                                                                       \n        return err;                                                                                           \n    }                                                                                                         \n                                                                                                              \n    // 进行一些权限检查，判断是否终止                                                              \n    if (abort) {\n        // 如果需要终止 Activity\n        if (resultRecord != null) {                                                                           \n            resultStack.sendActivityResultLocked();                                                                   \n        }                                                                                                     \n        // 返回启动成功，实际终止                                                                \n        ActivityOptions.abort(options);                                                                       \n        return START_SUCCESS;                                                                                 \n    }                                                                                                         \n                                                                                                              \n    // 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             \n                                                                                                              \n    // 处理 ephemeral app                                                                    \n    \n    // 构造一个 ActivityRecord\n    ActivityRecord r = new ActivityRecord();                                                   \n                                                                                                     \n    final ActivityStack stack = mSupervisor.mFocusedStack;                                                    \n    if (voiceSession == null && (stack.mResumedActivity == null                                               \n            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) {\n        // 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换\n        if (!mService.checkAppSwitchAllowedLocked() {                                          \n            PendingActivityLaunch pal =  new PendingActivityLaunch();                                              \n            mPendingActivityLaunches.add(pal);                                                                \n            ActivityOptions.abort(options);\n            // 切换 app 失败\n            return ActivityManager.START_SWITCHES_CANCELED;                                                   \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    if (mService.mDidAppSwitch) {                                                                             \n        // 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            \n        mService.mAppSwitchesAllowedTime = 0;                                                                 \n    } else {                                                                                                  \n        mService.mDidAppSwitch = true;                                                                        \n    }                                                                                                         \n    \n    // 执行因为不允许 app 切换，而加到等待启动的 Activity\n    doPendingActivityLaunchesLocked(false);                                                                   \n                                                                                                              \n    return startActivity();                                                                    \n}                                                                                                             \n```\n\n``` java\nprivate int startActivity() {                                                        \n    int result = START_CANCELED;                                                               \n    try {                                                                                      \n        mService.mWindowManager.deferSurfaceLayout();\n        // 下一步流程\n        result = startActivityUnchecked();                           \n    } finally {                                                                                \n        // 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      \n        if (!ActivityManager.isStartResultSuccessful(result)                                   \n                && mStartActivity.getTask() != null) {                                         \n            mStartActivity.getTask().removeActivity(mStartActivity);                           \n        }                                                                                      \n        mService.mWindowManager.continueSurfaceLayout();                                       \n    }                                                                                          \n                                                                                               \n    postStartActivityProcessing();                                                                     \n                                                                                               \n    return result;                                                                             \n}                                                                                              \n```\n\n``` java\nprivate int startActivityUnchecked() {\n\t\n    // 设置一些初始化状态\n    setInitialState();\n    // 计算 launch flags\n    computeLaunchingTaskFlags();\n    // 计算源 Task，源 Task 是否存在等\n    computeSourceStack();\n    // 获取是否存在可以复用的 Activity，根据 flags 和 launchMode\n    ActivityRecord reusedActivity = getReusableIntentActivity();\n    if (reusedActivity != null) {\n    \t// 存在可复用的 Activity，复用它\n        // 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置\n    }\n    if (mStartActivity.packageName == null) {\n    \treturn START_CLASS_NOT_FOUND;\n    }\n    // 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity\n    final boolean dontStart = top != null && mStartActivity.resultTo == null\n                && top.realActivity.equals(mStartActivity.realActivity)\n                && top.userId == mStartActivity.userId\n                && top.app != null && top.app.thread != null\n                && ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0\n                || mLaunchSingleTop || mLaunchSingleTask);\n    if(dontStart){\n        // 传递一个新的 Intent 到 onNewIntent \n        top.deliverNewIntentLocked();\n        return START_DELIVERED_TO_TOP;\n    }\n    \n    // 获取 mTargetStack\n    if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask\n                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n    \tnewTask = true;\n        // 需要创建新的 Task\n        result = setTaskFromReuseOrCreateNewTask();\n    } else if (mSourceRecord != null) {\n        // 从源 Activity 中获取 Task\n    \tresult = setTaskFromSourceRecord();\n    } else if (mInTask != null) {\n        // 从 InTask 中获取 Task\n    \tresult = setTaskFromInTask();\n    } else {\n        // 可能创建新的 Task 或使用当前 Task，一般不会发生\n    \tsetTaskToCurrentTopOrCreateNewTask();\n    }\n    \n    // 使用 mTargetStack 启动 Activity \n    mTargetStack.startActivityLocked();\n    \n    if (mDoResume) {\n        if (!mTargetStack.isFocusable()\n                    || (topTaskActivity != null && topTaskActivity.mTaskOverlay\n                    && mStartActivity != topTaskActivity)) {\n        \t// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity\n            // 那么我们不恢复目标 Task，只需要确保它可见即可\n            mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        }\n    } else {\n        if (mTargetStack.isFocusable() && !mSupervisor.isFocusedStack(mTargetStack)) {\n        \t// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台\n            mTargetStack.moveToFront(\"startActivityUnchecked\");\n        }\n        // 恢复目标 Task\n        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,\n                        mOptions);\n    } else {\n        // 如果不需要恢复，那么加到\"最近活动\"中\n        mTargetStack.addRecentActivityLocked(mStartActivity);\n    }\n    \n    return START_SUCCESS;\n}\n\nprivate void setInitialState(){\n    // 获取 DisplayId\n    mSourceDisplayId = getSourceDisplayId();\n    // 获取用于启动 Activity 的范围，Rect\n    mLaunchBounds = getOerrideBounds();\n    // launchMode\n    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;\n    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;\n    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;\n    // Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主\n    // 如果 requestCode >= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity\n    sendNewTaskResultRequestIfNeeded();\n}\n\nprivate void computeLaunchingTaskFlags(){\n    if (mSourceRecord == null && mInTask != null && mInTask.getStack() != null){\n        // 如果不存在源 Activity\n        final Intent baseIntent = mInTask.getBaseIntent();\n        final ActivityRecord root = mInTask.getRootActivity();\n        if (baseIntent == null){\n            throw new IllegalArgumentException();\n        }\n        if (mLaunchSingleInstance || mLaunchSingleTask) {\n            // 如果设置了 SingleInstacne 或 SingleTask\n        \tif (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent())){\n                // Task 不符合\n                throw new IllegalArgumentException();\n            }\n            \n            if(root != null){\n                // 已经存在 Task 根 Activity\n                throw new IllegalArgumentException();\n            }\n        }\n        \n        if (root == null) {\n        \t// 如果不存在根 Activity，重新设置 launch flags\n            mAddingToTask = true;\n        }else if ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n             mAddingToTask = false;\n        }else {\n            mAddingToTask = true;\n        }\n    }else {\n                     if ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) && mSourceRecord != null\n                    && mSourceRecord.isFreeform())  {\n                         // 如果使用 ResolverActivity 启动或者 noDisplay\n                mAddingToTask = true;\n            }\n    }\n    \n    if(mInTask == null){\n        if (mSourceRecord == null) {\n        \tif ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) == 0 && mInTask == null) {\n                // 不存在 Task，并且不存在源 Activity\n            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n            }\n        }else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) {\n        \t// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }else if (mLaunchSingleInstance || mLaunchSingleTask) {\n        \t// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }\n    }\n    \n}\n```\n\nActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity\n\n### ActivityStack\n\n``` java\nfinal void startActivityLocked(){\n    if(!newTask) {\n      // 如果从已存在的 Task 中启动 Activity\n      boolean startIt = true;\n      for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {\n      \ttask = mTaskHistory.get(taskNdx);\n          if (task.getTopActivity() == null){\n              // 如果 task 不存在 Activity\n              continue;\n          }\n          if (task == rTask) {\n          \t// 找到对应的 task\n            if (!startIt) {\n            \t// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动\n                r.createWindowContainer();\n                ActivityOptions.abort(options);\n                return;\n            }\n          } else if (task.numFullscreen > 0) {\n              startIt = false;\n          }\n      }\n    }\n    \n    // 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调\n    if (task == activityTask && mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) {\n        mStackSupervisor.mUserLeaving = false;\n    }\n    \n    if (!isHomeOrRecentsStack() || numActivities() > 0) {\n    \t// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0\n        \n        // 处理 动画\n        \n        if (newTask) {\n            if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {\n            // 如果设置了重置的标记\n            resetTaskIfNeededLocked(r, r);\n            doShow = topRunningNonDelayedActivityLocked(null) == r;\n            } else if (options != null && options.getAnimationType()\n                    == ActivityOptions.ANIM_SCENE_TRANSITION) {\n                // 需要进行转场动画\n                doShow = false;\n        }\n    }\n        \n        \n        if (r.mLaunchTaskBehind) {\n        \t// 如果为 true，那么不开启 window，但要确保 Activity 是可见的\n            r.setVisibility(true);\n            ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        } else if (SHOW_APP_STARTING_PREVIEW && doShow) {\n            TaskRecord prevTask = r.getTask();\n            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();\n            if (prev != null) {\n                // 以下两种情况不展示之前的 Activity 预览\n            \tif (prev.getTask() != prevTask) {\n                    // 之前的 Activity 在不同的 Task\n                \tprev = null;\n                } else if (prev.nowVisible) {\n                    // 现在可见\n                \t prev = null;\n                }\n            }\n            // 显示启动 Activity 的 Window\n        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));\n        } else {\n            // 当前为栈顶 Activity\n            ActivityOptions.abort(options);\n        }\n    \n}\n```\n\n`ActivityStack.startActivityLocked` 主要是创建 WindowContainer，同时显示 Window\n\n### ActivityStackSupervisor\n\n``` java\nboolean resumeFocusedStackTopActivityLocked(){\n    if (targetStack != null && isFocusedStack(targetStack)) {\n        // 存在 targetStack\n    \treturn targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);\n    }\n    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();\n    if (r == null || r.state != RESUMED) {\n        // 恢复聚焦 task\n    \tmFocusedStack.resumeTopActivityUncheckedLocked(null, null);\n    } else if (r.state == RESUMED) {\n        // 执行应用转场动画\n    \tmFocusedStack.executeAppTransition(targetOptions);\n    }\n}\n```\n\n### ActivityStack\n\n``` java\nboolean resumeTopActivityUncheckedLocked() {\n    if (mStackSupervisor.inResumeTopActivity) {\n        // 防止递归\n    \treturn false;\n    }\n    try {\n        // 设置恢复标记\n        mStackSupervisor.inResumeTopActivity = true;\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        mStackSupervisor.inResumeTopActivity = false;\n    }\n    // 在恢复过程中，确保必要的暂停逻辑\n    mStackSupervisor.checkReadyForSleepLocked();\n}\n```\n\n``` java\nprivate boolean resumeTopActivityInnerLocked() {\n    \n    // 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦\n    final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);\n    final boolean hasRunningActivity = next != null;\n    final ActivityRecord parent = mActivityContainer.mParentActivity;\n    final boolean isParentNotResumed = parent != null && parent.state != ActivityState.RESUMED;\n    if (hasRunningActivity\n                && (isParentNotResumed || !mActivityContainer.isAttachedLocked())) {\n           // 如果父 Activity 不是恢复状态，则不恢复当前 Activity\n            return false;\n        }\n    \n    if (!hasRunningActivity) {\n        // 当前 Task 没有需要恢复的 Activity\n    \treturn resumeTopActivityInNextFocusableStack(prev, options, \"noMoreActivities\");\n    }\n    \n    if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                    mStackSupervisor.allResumedActivitiesComplete()) {\n        // 如果 Activity 已经是恢复状态\n        // 确保已经执行了所有等待的转场\n        executeAppTransition(options);\n    \treturn false;\n    }\n    \n    if (mService.isSleepingOrShuttingDownLocked()\n                && mLastPausedActivity == next\n                && mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果系统处于休眠状态，当前 Activity 处于暂停状态\n        // 确保转场执行\n        executeAppTransition(options);\n        return false;\n    }\n    \n    if (!mService.mUserController.hasStartedUserState(next.userId)) {\n        // 如果拥有该 Activity 的用户没有启动\n    \treturn false;\n    }\n    \n    if (!mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果存在暂停 Activity 的操作未完成\n        return false;\n    }\n    \n    boolean lastResumedCanPip = false;\n    final ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();\n    if (lastFocusedStack != null && lastFocusedStack != this) {\n    \tfinal ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;\n        // 最后一个恢复的 Activity 是否可以 画中画\n        lastResumedCanPip = lastResumed != null && lastResumed.checkEnterPictureInPictureState(\n                    \"resumeTopActivity\", true /* noThrow */, userLeaving /* beforeStopping */);\n    }\n    \n    // 是否需要可以在上一个 Activity 暂停时进行恢复\n    final boolean resumeWhilePausing = (next.info.flags & FLAG_RESUME_WHILE_PAUSING) != 0\n                && !lastResumedCanPip;\n    // 是否暂停了回退的 task\n    boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);\n    \n    if (mResumedActivity != null) {\n        // 暂停上一个恢复状态的 Activity\n    \tpausing |= startPausingLocked(userLeaving, false, next, false);\n    }\n    \n    if (pausing && !resumeWhilePausing) {\n    \t// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity\n        if (next.app != null && next.app.thread != null) {\n            // hosting application，一般不执行\n            // 让当前 Activity 放在 Lru 的顶部，避免早早杀死\n        \tmService.updateLruProcessLocked(next.app, true, null);\n        }\n        return true;\n    } else if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                mStackSupervisor.allResumedActivitiesComplete()) {\n    \t// 当前需要恢复的 Activity 已经是恢复状态\n        // 确保执行转场\n        executeAppTransition(options);\n        return true;\n    }\n    \n    if (mService.isSleepingLocked() && mLastNoHistoryActivity != null &&\n                !mLastNoHistoryActivity.finishing) {\n        // 结束因为系统休眠而还没结束的 Activity\n    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,\n                    null, \"resume-no-history\", false);\n        mLastNoHistoryActivity = null;\n    }\n    \n    if (prev != null && prev != next) {\n    \tif (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)\n                    && next != null && !next.nowVisible) {\n        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);\n        } else {\n            // 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity\n            if (prev.finishing) {\n            \tprev.setVisibility(false);\n            } else {\n                \n            }\n        }\n    }\n    \n    // Activity 转场处理\n    \n    ActivityStack lastStack = mStackSupervisor.getLastStack();\n    if (next.app != null && next.app.thread != null) {\n        // 上一个 Activity 是否为透明\n    \tfinal boolean lastActivityTranslucent = lastStack != null\n                    && (!lastStack.mFullscreen\n                    || (lastStack.mLastPausedActivity != null\n                    && !lastStack.mLastPausedActivity.fullscreen));\n        \n        if (!next.visible || next.stopped || lastActivityTranslucent) {\n            // 前一个 Activity 为透明，并且当前 Activity 还没显示\n            // 设置为显示状态\n            next.setVisibility(true);\n        }\n        \n        // 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向\n    boolean notUpdated = true;\n    if (mStackSupervisor.isFocusedStack(this)) {\n    \tfinal Configuration config = mWindowManager.updateOrientationFromAppTokens(\n                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),\n                        next.mayFreezeScreenLocked(next.app) ? next.appToken : null, mDisplayId);\n        \n        if (config != null) {\n    \tnext.frozenBeforeDestroy = true;\n        }\n        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,\n                        false /* deferResume */, mDisplayId);\n    }\n    \n     if (notUpdated) {\n         // 配置发生更新无法保持已经存在的 Activity 实例\n         // 重新获取需要恢复的 Activity\n         ActivityRecord nextNext = topRunningActivityLocked();\n         // 确保 Activity 仍然保持在栈顶，同时安排另外一次执行\n         if (nextNext != next) {\n         \tmStackSupervisor.scheduleResumeTopActivities();\n         }\n         if (!next.visible || next.stopped) {\n         \tnext.setVisibility(true);\n         }\n         next.completeResumeLocked();\n         return true;\n     }\n    \n    try {\n        // 传递所有等待的结果\n        \n        if (next.newIntents != null){\n            next.app.thread.scheduleNewIntent(\n                            next.newIntents, next.appToken, false /* andPause */);\n        }\n        \n        next.notifyAppResumed(next.stopped);\n        \n        // 准备恢复 Activity\n        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,\n                        mService.isNextTransitionForward(), resumeAnimOptions);\n    } catch (Exception e){\n        // 发生异常，重新启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, false);\n        return true;\n    }\n        \n        try {\n            next.completeResumeLocked();\n        } catch(Exception e){\n            // 发生异常，结束 Activity\n            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null,\n                        \"resume-exception\", true);\n            return true;\n        }\n        \n    } else {\n        // 需要启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\n    }\n    \n    return true;\n\n}\n```\n\n如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：\n\n### ActivityStackSupervisor\n\n``` java\nvoid startSpecificActivityLocked() {\n    // 获取应用进程信息\n    ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n                r.info.applicationInfo.uid, true);\n    \n    if (app != null && app.thread != null) {\n    \t// 如果进程已经启动\n        try {\n            realStartActivityLocked(r, app, andResume, checkConfig);\n            return;\n        }catch (RemoteException e){\n            \n        }\n    }\n    \n    // 启动应用进程\n    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n}\n```\n\n``` java\nfinal boolean realStartActivityLocked() {\n    // 冻结屏幕\n    r.startFreezingScreenLocked(app, 0);\n    if (checkConfig) {\n    \t// 根据新的 Activity 顺序重新评估屏幕的方向\n    }\n    \n    int idx = app.activities.indexOf(r);\n    if (idx < 0) {\n        // 将 Activity 添加到应用进程中\n        app.activities.add(r);\n    }\n    \n    try {\n        app.thread.scheduleLaunchActivity();\n    }catch(RemoteException e){\n        // 发生异常，结束 Activity\n        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,\n                        \"2nd-crash\", false);\n        return false;\n    }\n    \n    return true;\n}\n```\n\n启动流程最后还是回到了 ApplicationThread\n\n### ApplicationThread\n\n``` java\npublic final void scheduleLaunchActivity() {\n    // 通过 Handler 发送 LAUNCH_ACTIVITY\n    sendMessage(H.LAUNCH_ACTIVITY, r);\n}\n```\n\n我们单独把 LAUNCH_ACTIVITY 的处理拿出来：\n\n``` java\nfinal ActivityClientRecord r = (ActivityClientRecord) msg.obj;\nr.packageInfo = getPackageInfoNoCheck(\n                            r.activityInfo.applicationInfo, r.compatInfo);\nhandleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n```\n\n### ActivityThread\n\n``` java\nprivate void handleLaunchActivity() {\n    // 执行启动 Activity\n    Activity a = performLaunchActivity(r, customIntent);\n    if (a != null) {\n        // resume activity\n        handleResumeActivity(r.token, false, r.isForward,\n                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);\n    } else {\n        \n    }\n}\n```\n\n``` java\nprivate performLaunchActivity() {\n    // Activity 信息初始化\n    \n    // 创建 context\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        // 构建 Activity\n        activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n    }catch(Exception e){\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        if(activity != null){\n        \tactivity.attach();\n            \n            // 通过 Instrumentation 执行 Activity onCreate\n            if (r.isPersistable()) {\n                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            }else {\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            \n            if (!r.activity.mFinished) {\n                // Activity onStart\n            \tactivity.performStart();\n            }\n            \n            // 通过 Instrumentation 执行 Activity onRestoreInstanceState\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                \tif (r.state != null || r.persistentState != null) {\n                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,\n                                    r.persistentState);\n                    }\n                } else if (r.state != null) {\n                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);\n                }\n            }\n            \n             // 通过 Instrumentation 执行 Activity onPostCreeate\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state,\n                                r.persistentState);\n                }else {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state);\n                }\n            }       \n    }\n        \n    return activity;\n    \n}\n```\n\n``` java\nfinal void handleResumeActivity() {\n    r = performResumeActivity();\n    if(r != null) {\n        final Activity a = r.activity;\n        if (r.window == null && !a.mFinished && willBeVisible) {\n            r.window = r.activity.getWindow();\n            View decor = r.window.getDecorView();\n            decor.setVisibility(View.INVISIBLE);\n            ViewManager wm = a.getWindowManager();\n            if (a.mVisibleFromClient) {\n            \tif (!a.mWindowAdded) {\n                \ta.mWindowAdded = true;\n                    // window\n                    wm.addView(decor, l);\n                }\n            }\n        }\n    }\n}\n```\n\n``` java\npublic final ActivityClientRecord performResumeActivity() {\n \tif (r != null && !r.activity.mFinished) {\n    \ttry {\n            // 处理等待的 Intent\n            if (r.pendingIntents != null) {\n            \tdeliverNewIntents(r, r.pendingIntents);\n                r.pendingIntents = null;\n            }\n            // 处理等待的 result\n            if (r.pendingResults != null) {\n            \tdeliverResults(r, r.pendingResults);\n                r.pendingResults = null;\n            }\n            // 执行 resume\n            r.activity.performResume();\n        }\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic Activity newActivity(){\n    return (Activity)cl.loadClass(className).newInstance();\n}\n```\n\n``` java\nprivate void callActivityOnCreate(){\n    prePerformCreate(activity);\n    activity.performCreate(icicle);\n    postPerformCreate(activity);\n}\n```\n\n### Activity\n\n``` java\nfinal void performCreate() {\n    restoreHasCurrentPermissionRequest(icicle);\n    // 调用 onCreate\n    onCreate(icicle);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n```\n\n``` java\nfinal void performStart() {\n    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());\n    mInstrumentation.callActivityOnStart(this);\n    mActivityTransitionState.enterReady(this);\n}\n```\n\n``` java\nfinal void performResume() {\n    // 执行 restart\n    performRestart();\n    mInstrumentation.callActivityOnResume(this);\n}\n```\n\n``` java\nfinal void performRestart() {\n    if (mStopped) {\n        mStopped = false;\n        mInstrumentation.callActivityOnRestart(this);\n        // 执行 start\n        performStart();\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic void callActivityOnStart() {\n    activity.onStart();\n}\n```\n\n``` java\npublic void callActivityOnResume() {\n     activity.mResumed = true;\n    activity.onResume();\n}\n```\n\n``` java\npublic void callActivityOnRestart() {\n    activity.onRestart();\n}\n```\n\n## 总结\n\n简单总结下 Activity 的启动流程：\n\n1. 从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信\n2. ActivityManagerService 用于管理所有的 Activity 活动\n   * 当接受到启动 Activity 的调用时，使用 `resolveActivity` ，查询系统中符合要求的 Activity\n   * 创建使用合适的  ActivityStack 和 launch flags 来启动 Activity\n   * 如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity\n   * 如果不存在应用进程，先创建应用进程\n3. 最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行\n   * 使用 Instrumentation 去通过反射构建 Activity 实例\n   * 使用 Handler 机制调用 Activity 的生命周期\n\n下面的图例来自[博客](http://gityuan.com/2016/03/12/start-activity/)：\n\n![启动流程](http://gityuan.com/images/activity/start_activity_process.jpg)\n\n### 时序图\n\n![Android启动流程](http://oy017242u.bkt.clouddn.com/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png)\n\n","slug":"Activity启动流程-基于Android26","published":1,"updated":"2018-04-11T14:05:30.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjs0ht9f0003ero6zh7wpamw","content":"<blockquote>\n<p>基于 Android 26，分析 Android Activity 启动流程</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">startActivity启动过程分析</a></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><strong>源码篇幅可能过长，所以会省略一下不必要的代码和注释</strong></p>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.startActivity(intent, <span class=\"keyword\">null</span>);        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>, options);                </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                        </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>);                         </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终都会调用到 <code>startActivityForResult</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">()</span> </span>&#123;                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 转场动画的处理</span></span><br><span class=\"line\">        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;                                                                       </span><br><span class=\"line\">            mMainThread.sendActivityResult();                                                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;                                                                                        </span><br><span class=\"line\">            mStartedActivity = <span class=\"keyword\">true</span>;                                                            </span><br><span class=\"line\">        &#125;                                                                                                                                                                             </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                    </span><br><span class=\"line\">        <span class=\"comment\">// 如果存在 Parent Activity 则交由它处理                                                                                    </span></span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道 Activity 启动委托给了 Instrumentation 进行实现</p>\n<h3 id=\"Instrumentation\"><a href=\"#Instrumentation\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由 ActivityThread.getApplicationThread 提供的 ApplicationThread</span></span><br><span class=\"line\">    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActivityMonitors != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mSync) &#123;                                             </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = mActivityMonitors.size();                        </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;                                      </span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityMonitor am = mActivityMonitors.get(i);       </span><br><span class=\"line\">                ActivityResult result = <span class=\"keyword\">null</span>;                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 </span></span><br><span class=\"line\">                    result = am.onStartActivity(intent);                   </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;                                      </span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;                                         </span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (am.match(who, <span class=\"keyword\">null</span>, intent)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// match 使用 IntentFilter 和 类名 进行匹配</span></span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (am.isBlocking()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 当前监视器阻止 Activity 启动</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> requestCode &gt;= <span class=\"number\">0</span> ? am.getResult() : <span class=\"keyword\">null</span>;   </span><br><span class=\"line\">                    &#125;                                                      </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                 </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">            &#125;                                                              </span><br><span class=\"line\">        &#125;                                                                  </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 委托为 ActivityManagerService(AMS) 去处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ActivityManager.getService().startActivity();                          </span><br><span class=\"line\">        <span class=\"comment\">// 检查 AMS 的处理结果</span></span><br><span class=\"line\">        checkStartActivityResult(result, intent);                          </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Failure from system\"</span>, e);              </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以通过最后的调用委托给了<code>ActivityManager.getService</code>，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现</p>\n<blockquote>\n<p>相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IActivityManager <span class=\"title\">getService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> IActivityManagerSingleton.get();  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =          </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Singleton&lt;IActivityManager&gt;() &#123;                                           </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                                                 </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> IActivityManager <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">                <span class=\"keyword\">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);     </span><br><span class=\"line\">                <span class=\"keyword\">return</span> am;                                                            </span><br><span class=\"line\">            &#125;                                                                         </span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityManagerService\"><a href=\"#ActivityManagerService\" class=\"headerlink\" title=\"ActivityManagerService\"></a>ActivityManagerService</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                       </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                           </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivityAsUser();                                                     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">()</span> </span>&#123;                                                                                                                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mActivityStarter.startActivityMayWait();                                                                                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将启动请求又委托给了 ActivityStarter</p>\n<h3 id=\"ActivityStarter\"><a href=\"#ActivityStarter\" class=\"headerlink\" title=\"ActivityStarter\"></a>ActivityStarter</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityMayWait</span><span class=\"params\">()</span> </span>&#123;                                                </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的响应</span></span><br><span class=\"line\">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的 Activity 信息                                                               </span></span><br><span class=\"line\">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord[] outRecord = <span class=\"keyword\">new</span> ActivityRecord[<span class=\"number\">1</span>];</span><br><span class=\"line\">    \t<span class=\"comment\">// 调用 startActivityLocked</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = startActivityLocked(outRecord);                                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;                                                                                                       </span><br><span class=\"line\">    &#125;                                                                                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 源 Activity 记录，即在哪个 Activity 进行 startActivity</span></span><br><span class=\"line\">    ActivityRecord sourceRecord = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity</span></span><br><span class=\"line\">    ActivityRecord resultRecord = <span class=\"keyword\">null</span>;                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultTo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取 Activity Stack 中已经存在的源 Activity 记录</span></span><br><span class=\"line\">        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// requestCode &gt;= 0，源 Activity 同时为 结果 Activity</span></span><br><span class=\"line\">                resultRecord = sourceRecord;                                                                  </span><br><span class=\"line\">            &#125;                                                                                                 </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> launchFlags = intent.getFlags();                                                                </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class=\"number\">0</span> &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>) &#123;                   </span><br><span class=\"line\">        <span class=\"comment\">// 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity</span></span><br><span class=\"line\">        <span class=\"comment\">// 比如：A -&gt; B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不允许有 requestCode</span></span><br><span class=\"line\">            ActivityOptions.abort(options);                                                                   </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity</span></span><br><span class=\"line\">        resultRecord = sourceRecord.resultTo;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span> &amp;&amp; !resultRecord.isInStackLocked()) &#123;                                        </span><br><span class=\"line\">            resultRecord = <span class=\"keyword\">null</span>;                                                                              </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// requestCode 处理</span></span><br><span class=\"line\">        resultWho = sourceRecord.resultWho;                                                                   </span><br><span class=\"line\">        requestCode = sourceRecord.requestCode;                                                               </span><br><span class=\"line\">        sourceRecord.resultTo = <span class=\"keyword\">null</span>;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 删除源 Activity 记录</span></span><br><span class=\"line\">            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           </span><br><span class=\"line\">        &#125;                                                                                                                                                                                         </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class=\"keyword\">null</span>) &#123;                              </span><br><span class=\"line\">        <span class=\"comment\">// component 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class=\"keyword\">null</span>) &#123;                                              </span><br><span class=\"line\">        <span class=\"comment\">// ActivityInfo 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>                                          </span><br><span class=\"line\">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class=\"keyword\">null</span>) &#123;                                                 </span><br><span class=\"line\">        <span class=\"comment\">// 语音启动 Activity，检查是否符合                                                                      </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"comment\">// 启动语音会话                                                       </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack resultStack = resultRecord == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : resultRecord.getStack();                  </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err != START_SUCCESS) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 启动 Activity 失败</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发送取消通知</span></span><br><span class=\"line\">            resultStack.sendActivityResultLocked(                                                             </span><br><span class=\"line\">                    -<span class=\"number\">1</span>, resultRecord, resultWho, requestCode, RESULT_CANCELED, <span class=\"keyword\">null</span>);                         </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 进行一些权限检查，判断是否终止                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (abort) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果需要终止 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            resultStack.sendActivityResultLocked();                                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 返回启动成功，实际终止                                                                </span></span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_SUCCESS;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             </span></span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 处理 ephemeral app                                                                    </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造一个 ActivityRecord</span></span><br><span class=\"line\">    ActivityRecord r = <span class=\"keyword\">new</span> ActivityRecord();                                                   </span><br><span class=\"line\">                                                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack stack = mSupervisor.mFocusedStack;                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (voiceSession == <span class=\"keyword\">null</span> &amp;&amp; (stack.mResumedActivity == <span class=\"keyword\">null</span>                                               </span><br><span class=\"line\">            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mService.checkAppSwitchAllowedLocked() &#123;                                          </span><br><span class=\"line\">            PendingActivityLaunch pal =  <span class=\"keyword\">new</span> PendingActivityLaunch();                                              </span><br><span class=\"line\">            mPendingActivityLaunches.add(pal);                                                                </span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">            <span class=\"comment\">// 切换 app 失败</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_SWITCHES_CANCELED;                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.mDidAppSwitch) &#123;                                                                             </span><br><span class=\"line\">        <span class=\"comment\">// 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            </span></span><br><span class=\"line\">        mService.mAppSwitchesAllowedTime = <span class=\"number\">0</span>;                                                                 </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                                  </span><br><span class=\"line\">        mService.mDidAppSwitch = <span class=\"keyword\">true</span>;                                                                        </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 执行因为不允许 app 切换，而加到等待启动的 Activity</span></span><br><span class=\"line\">    doPendingActivityLaunchesLocked(<span class=\"keyword\">false</span>);                                                                   </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivity();                                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                                                        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = START_CANCELED;                                                               </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class=\"line\">        <span class=\"comment\">// 下一步流程</span></span><br><span class=\"line\">        result = startActivityUnchecked();                           </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ActivityManager.isStartResultSuccessful(result)                                   </span><br><span class=\"line\">                &amp;&amp; mStartActivity.getTask() != <span class=\"keyword\">null</span>) &#123;                                         </span><br><span class=\"line\">            mStartActivity.getTask().removeActivity(mStartActivity);                           </span><br><span class=\"line\">        &#125;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.continueSurfaceLayout();                                       </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    postStartActivityProcessing();                                                                     </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;                                                                             </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityUnchecked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 设置一些初始化状态</span></span><br><span class=\"line\">    setInitialState();</span><br><span class=\"line\">    <span class=\"comment\">// 计算 launch flags</span></span><br><span class=\"line\">    computeLaunchingTaskFlags();</span><br><span class=\"line\">    <span class=\"comment\">// 计算源 Task，源 Task 是否存在等</span></span><br><span class=\"line\">    computeSourceStack();</span><br><span class=\"line\">    <span class=\"comment\">// 获取是否存在可以复用的 Activity，根据 flags 和 launchMode</span></span><br><span class=\"line\">    ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reusedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 存在可复用的 Activity，复用它</span></span><br><span class=\"line\">        <span class=\"comment\">// 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.packageName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> START_CLASS_NOT_FOUND;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> dontStart = top != <span class=\"keyword\">null</span> &amp;&amp; mStartActivity.resultTo == <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class=\"line\">                &amp;&amp; top.userId == mStartActivity.userId</span><br><span class=\"line\">                &amp;&amp; top.app != <span class=\"keyword\">null</span> &amp;&amp; top.app.thread != <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != <span class=\"number\">0</span></span><br><span class=\"line\">                || mLaunchSingleTop || mLaunchSingleTask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dontStart)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递一个新的 Intent 到 onNewIntent </span></span><br><span class=\"line\">        top.deliverNewIntentLocked();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_DELIVERED_TO_TOP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取 mTargetStack</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.resultTo == <span class=\"keyword\">null</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span> &amp;&amp; !mAddingToTask</span><br><span class=\"line\">                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \tnewTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 需要创建新的 Task</span></span><br><span class=\"line\">        result = setTaskFromReuseOrCreateNewTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从源 Activity 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromSourceRecord();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mInTask != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 InTask 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromInTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可能创建新的 Task 或使用当前 Task，一般不会发生</span></span><br><span class=\"line\">    \tsetTaskToCurrentTopOrCreateNewTask();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用 mTargetStack 启动 Activity </span></span><br><span class=\"line\">    mTargetStack.startActivityLocked();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDoResume) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mTargetStack.isFocusable()</span><br><span class=\"line\">                    || (topTaskActivity != <span class=\"keyword\">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class=\"line\">                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity</span></span><br><span class=\"line\">            <span class=\"comment\">// 那么我们不恢复目标 Task，只需要确保它可见即可</span></span><br><span class=\"line\">            mTargetStack.ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台</span></span><br><span class=\"line\">            mTargetStack.moveToFront(<span class=\"string\">\"startActivityUnchecked\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复目标 Task</span></span><br><span class=\"line\">        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class=\"line\">                        mOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不需要恢复，那么加到\"最近活动\"中</span></span><br><span class=\"line\">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> START_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setInitialState</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 DisplayId</span></span><br><span class=\"line\">    mSourceDisplayId = getSourceDisplayId();</span><br><span class=\"line\">    <span class=\"comment\">// 获取用于启动 Activity 的范围，Rect</span></span><br><span class=\"line\">    mLaunchBounds = getOerrideBounds();</span><br><span class=\"line\">    <span class=\"comment\">// launchMode</span></span><br><span class=\"line\">    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;</span><br><span class=\"line\">    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;</span><br><span class=\"line\">    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;</span><br><span class=\"line\">    <span class=\"comment\">// Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 requestCode &gt;= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity</span></span><br><span class=\"line\">    sendNewTaskResultRequestIfNeeded();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">computeLaunchingTaskFlags</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span> &amp;&amp; mInTask != <span class=\"keyword\">null</span> &amp;&amp; mInTask.getStack() != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不存在源 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Intent baseIntent = mInTask.getBaseIntent();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord root = mInTask.getRootActivity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseIntent == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了 SingleInstacne 或 SingleTask</span></span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent()))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// Task 不符合</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 已经存在 Task 根 Activity</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果不存在根 Activity，重新设置 launch flags</span></span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">             mAddingToTask = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">if</span> ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) &amp;&amp; mSourceRecord != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; mSourceRecord.isFreeform())  &#123;</span><br><span class=\"line\">                         <span class=\"comment\">// 如果使用 ResolverActivity 启动或者 noDisplay</span></span><br><span class=\"line\">                mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mInTask == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 不存在 Task，并且不存在源 Activity</span></span><br><span class=\"line\">            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity</p>\n<h3 id=\"ActivityStack\"><a href=\"#ActivityStack\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!newTask) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果从已存在的 Task 中启动 Activity</span></span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> startIt = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> taskNdx = mTaskHistory.size() - <span class=\"number\">1</span>; taskNdx &gt;= <span class=\"number\">0</span>; --taskNdx) &#123;</span><br><span class=\"line\">      \ttask = mTaskHistory.get(taskNdx);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task.getTopActivity() == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果 task 不存在 Activity</span></span><br><span class=\"line\">              <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task == rTask) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// 找到对应的 task</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!startIt) &#123;</span><br><span class=\"line\">            \t<span class=\"comment\">// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动</span></span><br><span class=\"line\">                r.createWindowContainer();</span><br><span class=\"line\">                ActivityOptions.abort(options);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (task.numFullscreen &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              startIt = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == activityTask &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        mStackSupervisor.mUserLeaving = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHomeOrRecentsStack() || numActivities() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 处理 动画</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTask) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了重置的标记</span></span><br><span class=\"line\">            resetTaskIfNeededLocked(r, r);</span><br><span class=\"line\">            doShow = topRunningNonDelayedActivityLocked(<span class=\"keyword\">null</span>) == r;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span> &amp;&amp; options.getAnimationType()</span><br><span class=\"line\">                    == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 需要进行转场动画</span></span><br><span class=\"line\">                doShow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果为 true，那么不开启 window，但要确保 Activity 是可见的</span></span><br><span class=\"line\">            r.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class=\"line\">            TaskRecord prevTask = r.getTask();</span><br><span class=\"line\">            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 以下两种情况不展示之前的 Activity 预览</span></span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (prev.getTask() != prevTask) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 之前的 Activity 在不同的 Task</span></span><br><span class=\"line\">                \tprev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prev.nowVisible) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 现在可见</span></span><br><span class=\"line\">                \t prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 显示启动 Activity 的 Window</span></span><br><span class=\"line\">        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前为栈顶 Activity</span></span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ActivityStack.startActivityLocked</code> 主要是创建 WindowContainer，同时显示 Window</p>\n<h3 id=\"ActivityStackSupervisor\"><a href=\"#ActivityStackSupervisor\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeFocusedStackTopActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetStack != <span class=\"keyword\">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存在 targetStack</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"keyword\">null</span> || r.state != RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复聚焦 task</span></span><br><span class=\"line\">    \tmFocusedStack.resumeTopActivityUncheckedLocked(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state == RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行应用转场动画</span></span><br><span class=\"line\">    \tmFocusedStack.executeAppTransition(targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityStack-1\"><a href=\"#ActivityStack-1\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityUncheckedLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 防止递归</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置恢复标记</span></span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在恢复过程中，确保必要的暂停逻辑</span></span><br><span class=\"line\">    mStackSupervisor.checkReadyForSleepLocked();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityInnerLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord next = topRunningActivityLocked(<span class=\"keyword\">true</span> <span class=\"comment\">/* focusableOnly */</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasRunningActivity = next != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord parent = mActivityContainer.mParentActivity;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isParentNotResumed = parent != <span class=\"keyword\">null</span> &amp;&amp; parent.state != ActivityState.RESUMED;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasRunningActivity</span><br><span class=\"line\">                &amp;&amp; (isParentNotResumed || !mActivityContainer.isAttachedLocked())) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 如果父 Activity 不是恢复状态，则不恢复当前 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasRunningActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 Task 没有需要恢复的 Activity</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> resumeTopActivityInNextFocusableStack(prev, options, <span class=\"string\">\"noMoreActivities\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                    mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保已经执行了所有等待的转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingOrShuttingDownLocked()</span><br><span class=\"line\">                &amp;&amp; mLastPausedActivity == next</span><br><span class=\"line\">                &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果系统处于休眠状态，当前 Activity 处于暂停状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保转场执行</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mService.mUserController.hasStartedUserState(next.userId)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果拥有该 Activity 的用户没有启动</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果存在暂停 Activity 的操作未完成</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> lastResumedCanPip = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastFocusedStack != <span class=\"keyword\">null</span> &amp;&amp; lastFocusedStack != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class=\"line\">        <span class=\"comment\">// 最后一个恢复的 Activity 是否可以 画中画</span></span><br><span class=\"line\">        lastResumedCanPip = lastResumed != <span class=\"keyword\">null</span> &amp;&amp; lastResumed.checkEnterPictureInPictureState(</span><br><span class=\"line\">                    <span class=\"string\">\"resumeTopActivity\"</span>, <span class=\"keyword\">true</span> <span class=\"comment\">/* noThrow */</span>, userLeaving <span class=\"comment\">/* beforeStopping */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 是否需要可以在上一个 Activity 暂停时进行恢复</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; !lastResumedCanPip;</span><br><span class=\"line\">    <span class=\"comment\">// 是否暂停了回退的 task</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 暂停上一个恢复状态的 Activity</span></span><br><span class=\"line\">    \tpausing |= startPausingLocked(userLeaving, <span class=\"keyword\">false</span>, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hosting application，一般不执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 让当前 Activity 放在 Lru 的顶部，避免早早杀死</span></span><br><span class=\"line\">        \tmService.updateLruProcessLocked(next.app, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 当前需要恢复的 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保执行转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingLocked() &amp;&amp; mLastNoHistoryActivity != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                !mLastNoHistoryActivity.finishing) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 结束因为系统休眠而还没结束的 Activity</span></span><br><span class=\"line\">    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,</span><br><span class=\"line\">                    <span class=\"keyword\">null</span>, <span class=\"string\">\"resume-no-history\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        mLastNoHistoryActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span> &amp;&amp; prev != next) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class=\"line\">                    &amp;&amp; next != <span class=\"keyword\">null</span> &amp;&amp; !next.nowVisible) &#123;</span><br><span class=\"line\">        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev.finishing) &#123;</span><br><span class=\"line\">            \tprev.setVisibility(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity 转场处理</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 上一个 Activity 是否为透明</span></span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> lastActivityTranslucent = lastStack != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; (!lastStack.mFullscreen</span><br><span class=\"line\">                    || (lastStack.mLastPausedActivity != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; !lastStack.mLastPausedActivity.fullscreen));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!next.visible || next.stopped || lastActivityTranslucent) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 前一个 Activity 为透明，并且当前 Activity 还没显示</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置为显示状态</span></span><br><span class=\"line\">            next.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> notUpdated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.isFocusedStack(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> Configuration config = mWindowManager.updateOrientationFromAppTokens(</span><br><span class=\"line\">                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),</span><br><span class=\"line\">                        next.mayFreezeScreenLocked(next.app) ? next.appToken : <span class=\"keyword\">null</span>, mDisplayId);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tnext.frozenBeforeDestroy = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,</span><br><span class=\"line\">                        <span class=\"keyword\">false</span> <span class=\"comment\">/* deferResume */</span>, mDisplayId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (notUpdated) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 配置发生更新无法保持已经存在的 Activity 实例</span></span><br><span class=\"line\">         <span class=\"comment\">// 重新获取需要恢复的 Activity</span></span><br><span class=\"line\">         ActivityRecord nextNext = topRunningActivityLocked();</span><br><span class=\"line\">         <span class=\"comment\">// 确保 Activity 仍然保持在栈顶，同时安排另外一次执行</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (nextNext != next) &#123;</span><br><span class=\"line\">         \tmStackSupervisor.scheduleResumeTopActivities();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!next.visible || next.stopped) &#123;</span><br><span class=\"line\">         \tnext.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         next.completeResumeLocked();</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递所有等待的结果</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.newIntents != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            next.app.thread.scheduleNewIntent(</span><br><span class=\"line\">                            next.newIntents, next.appToken, <span class=\"keyword\">false</span> <span class=\"comment\">/* andPause */</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        next.notifyAppResumed(next.stopped);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 准备恢复 Activity</span></span><br><span class=\"line\">        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,</span><br><span class=\"line\">                        mService.isNextTransitionForward(), resumeAnimOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，重新启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            next.completeResumeLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"resume-exception\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 需要启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：</p>\n<h3 id=\"ActivityStackSupervisor-1\"><a href=\"#ActivityStackSupervisor-1\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取应用进程信息</span></span><br><span class=\"line\">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">                r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果进程已经启动</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (RemoteException e)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 启动应用进程</span></span><br><span class=\"line\">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 冻结屏幕</span></span><br><span class=\"line\">    r.startFreezingScreenLocked(app, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkConfig) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 根据新的 Activity 顺序重新评估屏幕的方向</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = app.activities.indexOf(r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将 Activity 添加到应用进程中</span></span><br><span class=\"line\">        app.activities.add(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        app.thread.scheduleLaunchActivity();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(RemoteException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"2nd-crash\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动流程最后还是回到了 ApplicationThread</p>\n<h3 id=\"ApplicationThread\"><a href=\"#ApplicationThread\" class=\"headerlink\" title=\"ApplicationThread\"></a>ApplicationThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 Handler 发送 LAUNCH_ACTIVITY</span></span><br><span class=\"line\">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们单独把 LAUNCH_ACTIVITY 的处理拿出来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\">r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">\"LAUNCH_ACTIVITY\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityThread\"><a href=\"#ActivityThread\" class=\"headerlink\" title=\"ActivityThread\"></a>ActivityThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行启动 Activity</span></span><br><span class=\"line\">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// resume activity</span></span><br><span class=\"line\">        handleResumeActivity(r.token, <span class=\"keyword\">false</span>, r.isForward,</span><br><span class=\"line\">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Activity 信息初始化</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 context</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        <span class=\"comment\">// 构建 Activity</span></span><br><span class=\"line\">        activity = mInstrumentation.newActivity(</span><br><span class=\"line\">                    cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(activity != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        \tactivity.attach();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onCreate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Activity onStart</span></span><br><span class=\"line\">            \tactivity.performStart();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onRestoreInstanceState</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                \t<span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span> || r.persistentState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class=\"line\">                                    r.persistentState);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">             <span class=\"comment\">// 通过 Instrumentation 执行 Activity onPostCreeate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class=\"line\">                                r.persistentState);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> activity;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    r = performResumeActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            r.window = r.activity.getWindow();</span><br><span class=\"line\">            View decor = r.window.getDecorView();</span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                \ta.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// window</span></span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span> &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 Intent</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingIntents != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverNewIntents(r, r.pendingIntents);</span><br><span class=\"line\">                r.pendingIntents = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 result</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingResults != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverResults(r, r.pendingResults);</span><br><span class=\"line\">                r.pendingResults = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 执行 resume</span></span><br><span class=\"line\">            r.activity.performResume();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-1\"><a href=\"#Instrumentation-1\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">newActivity</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    prePerformCreate(activity);</span><br><span class=\"line\">    activity.performCreate(icicle);</span><br><span class=\"line\">    postPerformCreate(activity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Activity-1\"><a href=\"#Activity-1\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class=\"line\">    <span class=\"comment\">// 调用 onCreate</span></span><br><span class=\"line\">    onCreate(icicle);</span><br><span class=\"line\">    mActivityTransitionState.readState(icicle);</span><br><span class=\"line\">    performCreateCommon();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mActivityTransitionState.setEnterActivityOptions(<span class=\"keyword\">this</span>, getActivityOptions());</span><br><span class=\"line\">    mInstrumentation.callActivityOnStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    mActivityTransitionState.enterReady(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行 restart</span></span><br><span class=\"line\">    performRestart();</span><br><span class=\"line\">    mInstrumentation.callActivityOnResume(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStopped) &#123;</span><br><span class=\"line\">        mStopped = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mInstrumentation.callActivityOnRestart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 执行 start</span></span><br><span class=\"line\">        performStart();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-2\"><a href=\"#Instrumentation-2\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onStart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     activity.mResumed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    activity.onResume();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onRestart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>简单总结下 Activity 的启动流程：</p>\n<ol>\n<li>从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信</li>\n<li>ActivityManagerService 用于管理所有的 Activity 活动<ul>\n<li>当接受到启动 Activity 的调用时，使用 <code>resolveActivity</code> ，查询系统中符合要求的 Activity</li>\n<li>创建使用合适的  ActivityStack 和 launch flags 来启动 Activity</li>\n<li>如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity</li>\n<li>如果不存在应用进程，先创建应用进程</li>\n</ul>\n</li>\n<li>最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行<ul>\n<li>使用 Instrumentation 去通过反射构建 Activity 实例</li>\n<li>使用 Handler 机制调用 Activity 的生命周期</li>\n</ul>\n</li>\n</ol>\n<p>下面的图例来自<a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">博客</a>：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://gityuan.com/images/activity/start_activity_process.jpg\" alt=\"启动流程\" title=\"\">\n                </div>\n                <div class=\"image-caption\">启动流程</div>\n            </figure>\n<h3 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png\" alt=\"Android启动流程\" title=\"\">\n                </div>\n                <div class=\"image-caption\">Android启动流程</div>\n            </figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>基于 Android 26，分析 Android Activity 启动流程</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">startActivity启动过程分析</a></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><strong>源码篇幅可能过长，所以会省略一下不必要的代码和注释</strong></p>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.startActivity(intent, <span class=\"keyword\">null</span>);        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>, options);                </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                        </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>);                         </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终都会调用到 <code>startActivityForResult</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">()</span> </span>&#123;                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 转场动画的处理</span></span><br><span class=\"line\">        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;                                                                       </span><br><span class=\"line\">            mMainThread.sendActivityResult();                                                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;                                                                                        </span><br><span class=\"line\">            mStartedActivity = <span class=\"keyword\">true</span>;                                                            </span><br><span class=\"line\">        &#125;                                                                                                                                                                             </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                    </span><br><span class=\"line\">        <span class=\"comment\">// 如果存在 Parent Activity 则交由它处理                                                                                    </span></span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道 Activity 启动委托给了 Instrumentation 进行实现</p>\n<h3 id=\"Instrumentation\"><a href=\"#Instrumentation\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由 ActivityThread.getApplicationThread 提供的 ApplicationThread</span></span><br><span class=\"line\">    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActivityMonitors != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mSync) &#123;                                             </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = mActivityMonitors.size();                        </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;                                      </span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityMonitor am = mActivityMonitors.get(i);       </span><br><span class=\"line\">                ActivityResult result = <span class=\"keyword\">null</span>;                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 </span></span><br><span class=\"line\">                    result = am.onStartActivity(intent);                   </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;                                      </span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;                                         </span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (am.match(who, <span class=\"keyword\">null</span>, intent)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// match 使用 IntentFilter 和 类名 进行匹配</span></span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (am.isBlocking()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 当前监视器阻止 Activity 启动</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> requestCode &gt;= <span class=\"number\">0</span> ? am.getResult() : <span class=\"keyword\">null</span>;   </span><br><span class=\"line\">                    &#125;                                                      </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                 </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">            &#125;                                                              </span><br><span class=\"line\">        &#125;                                                                  </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 委托为 ActivityManagerService(AMS) 去处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ActivityManager.getService().startActivity();                          </span><br><span class=\"line\">        <span class=\"comment\">// 检查 AMS 的处理结果</span></span><br><span class=\"line\">        checkStartActivityResult(result, intent);                          </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Failure from system\"</span>, e);              </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以通过最后的调用委托给了<code>ActivityManager.getService</code>，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现</p>\n<blockquote>\n<p>相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IActivityManager <span class=\"title\">getService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> IActivityManagerSingleton.get();  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =          </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Singleton&lt;IActivityManager&gt;() &#123;                                           </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                                                 </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> IActivityManager <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">                <span class=\"keyword\">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);     </span><br><span class=\"line\">                <span class=\"keyword\">return</span> am;                                                            </span><br><span class=\"line\">            &#125;                                                                         </span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityManagerService\"><a href=\"#ActivityManagerService\" class=\"headerlink\" title=\"ActivityManagerService\"></a>ActivityManagerService</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                       </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                           </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivityAsUser();                                                     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">()</span> </span>&#123;                                                                                                                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mActivityStarter.startActivityMayWait();                                                                                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将启动请求又委托给了 ActivityStarter</p>\n<h3 id=\"ActivityStarter\"><a href=\"#ActivityStarter\" class=\"headerlink\" title=\"ActivityStarter\"></a>ActivityStarter</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityMayWait</span><span class=\"params\">()</span> </span>&#123;                                                </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的响应</span></span><br><span class=\"line\">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的 Activity 信息                                                               </span></span><br><span class=\"line\">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord[] outRecord = <span class=\"keyword\">new</span> ActivityRecord[<span class=\"number\">1</span>];</span><br><span class=\"line\">    \t<span class=\"comment\">// 调用 startActivityLocked</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = startActivityLocked(outRecord);                                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;                                                                                                       </span><br><span class=\"line\">    &#125;                                                                                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 源 Activity 记录，即在哪个 Activity 进行 startActivity</span></span><br><span class=\"line\">    ActivityRecord sourceRecord = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity</span></span><br><span class=\"line\">    ActivityRecord resultRecord = <span class=\"keyword\">null</span>;                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultTo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取 Activity Stack 中已经存在的源 Activity 记录</span></span><br><span class=\"line\">        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// requestCode &gt;= 0，源 Activity 同时为 结果 Activity</span></span><br><span class=\"line\">                resultRecord = sourceRecord;                                                                  </span><br><span class=\"line\">            &#125;                                                                                                 </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> launchFlags = intent.getFlags();                                                                </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class=\"number\">0</span> &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>) &#123;                   </span><br><span class=\"line\">        <span class=\"comment\">// 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity</span></span><br><span class=\"line\">        <span class=\"comment\">// 比如：A -&gt; B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不允许有 requestCode</span></span><br><span class=\"line\">            ActivityOptions.abort(options);                                                                   </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity</span></span><br><span class=\"line\">        resultRecord = sourceRecord.resultTo;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span> &amp;&amp; !resultRecord.isInStackLocked()) &#123;                                        </span><br><span class=\"line\">            resultRecord = <span class=\"keyword\">null</span>;                                                                              </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// requestCode 处理</span></span><br><span class=\"line\">        resultWho = sourceRecord.resultWho;                                                                   </span><br><span class=\"line\">        requestCode = sourceRecord.requestCode;                                                               </span><br><span class=\"line\">        sourceRecord.resultTo = <span class=\"keyword\">null</span>;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 删除源 Activity 记录</span></span><br><span class=\"line\">            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           </span><br><span class=\"line\">        &#125;                                                                                                                                                                                         </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class=\"keyword\">null</span>) &#123;                              </span><br><span class=\"line\">        <span class=\"comment\">// component 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class=\"keyword\">null</span>) &#123;                                              </span><br><span class=\"line\">        <span class=\"comment\">// ActivityInfo 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>                                          </span><br><span class=\"line\">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class=\"keyword\">null</span>) &#123;                                                 </span><br><span class=\"line\">        <span class=\"comment\">// 语音启动 Activity，检查是否符合                                                                      </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"comment\">// 启动语音会话                                                       </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack resultStack = resultRecord == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : resultRecord.getStack();                  </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err != START_SUCCESS) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 启动 Activity 失败</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发送取消通知</span></span><br><span class=\"line\">            resultStack.sendActivityResultLocked(                                                             </span><br><span class=\"line\">                    -<span class=\"number\">1</span>, resultRecord, resultWho, requestCode, RESULT_CANCELED, <span class=\"keyword\">null</span>);                         </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 进行一些权限检查，判断是否终止                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (abort) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果需要终止 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            resultStack.sendActivityResultLocked();                                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 返回启动成功，实际终止                                                                </span></span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_SUCCESS;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             </span></span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 处理 ephemeral app                                                                    </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造一个 ActivityRecord</span></span><br><span class=\"line\">    ActivityRecord r = <span class=\"keyword\">new</span> ActivityRecord();                                                   </span><br><span class=\"line\">                                                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack stack = mSupervisor.mFocusedStack;                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (voiceSession == <span class=\"keyword\">null</span> &amp;&amp; (stack.mResumedActivity == <span class=\"keyword\">null</span>                                               </span><br><span class=\"line\">            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mService.checkAppSwitchAllowedLocked() &#123;                                          </span><br><span class=\"line\">            PendingActivityLaunch pal =  <span class=\"keyword\">new</span> PendingActivityLaunch();                                              </span><br><span class=\"line\">            mPendingActivityLaunches.add(pal);                                                                </span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">            <span class=\"comment\">// 切换 app 失败</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_SWITCHES_CANCELED;                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.mDidAppSwitch) &#123;                                                                             </span><br><span class=\"line\">        <span class=\"comment\">// 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            </span></span><br><span class=\"line\">        mService.mAppSwitchesAllowedTime = <span class=\"number\">0</span>;                                                                 </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                                  </span><br><span class=\"line\">        mService.mDidAppSwitch = <span class=\"keyword\">true</span>;                                                                        </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 执行因为不允许 app 切换，而加到等待启动的 Activity</span></span><br><span class=\"line\">    doPendingActivityLaunchesLocked(<span class=\"keyword\">false</span>);                                                                   </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivity();                                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                                                        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = START_CANCELED;                                                               </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class=\"line\">        <span class=\"comment\">// 下一步流程</span></span><br><span class=\"line\">        result = startActivityUnchecked();                           </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ActivityManager.isStartResultSuccessful(result)                                   </span><br><span class=\"line\">                &amp;&amp; mStartActivity.getTask() != <span class=\"keyword\">null</span>) &#123;                                         </span><br><span class=\"line\">            mStartActivity.getTask().removeActivity(mStartActivity);                           </span><br><span class=\"line\">        &#125;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.continueSurfaceLayout();                                       </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    postStartActivityProcessing();                                                                     </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;                                                                             </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityUnchecked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 设置一些初始化状态</span></span><br><span class=\"line\">    setInitialState();</span><br><span class=\"line\">    <span class=\"comment\">// 计算 launch flags</span></span><br><span class=\"line\">    computeLaunchingTaskFlags();</span><br><span class=\"line\">    <span class=\"comment\">// 计算源 Task，源 Task 是否存在等</span></span><br><span class=\"line\">    computeSourceStack();</span><br><span class=\"line\">    <span class=\"comment\">// 获取是否存在可以复用的 Activity，根据 flags 和 launchMode</span></span><br><span class=\"line\">    ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reusedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 存在可复用的 Activity，复用它</span></span><br><span class=\"line\">        <span class=\"comment\">// 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.packageName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> START_CLASS_NOT_FOUND;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> dontStart = top != <span class=\"keyword\">null</span> &amp;&amp; mStartActivity.resultTo == <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class=\"line\">                &amp;&amp; top.userId == mStartActivity.userId</span><br><span class=\"line\">                &amp;&amp; top.app != <span class=\"keyword\">null</span> &amp;&amp; top.app.thread != <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != <span class=\"number\">0</span></span><br><span class=\"line\">                || mLaunchSingleTop || mLaunchSingleTask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dontStart)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递一个新的 Intent 到 onNewIntent </span></span><br><span class=\"line\">        top.deliverNewIntentLocked();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_DELIVERED_TO_TOP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取 mTargetStack</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.resultTo == <span class=\"keyword\">null</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span> &amp;&amp; !mAddingToTask</span><br><span class=\"line\">                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \tnewTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 需要创建新的 Task</span></span><br><span class=\"line\">        result = setTaskFromReuseOrCreateNewTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从源 Activity 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromSourceRecord();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mInTask != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 InTask 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromInTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可能创建新的 Task 或使用当前 Task，一般不会发生</span></span><br><span class=\"line\">    \tsetTaskToCurrentTopOrCreateNewTask();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用 mTargetStack 启动 Activity </span></span><br><span class=\"line\">    mTargetStack.startActivityLocked();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDoResume) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mTargetStack.isFocusable()</span><br><span class=\"line\">                    || (topTaskActivity != <span class=\"keyword\">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class=\"line\">                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity</span></span><br><span class=\"line\">            <span class=\"comment\">// 那么我们不恢复目标 Task，只需要确保它可见即可</span></span><br><span class=\"line\">            mTargetStack.ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台</span></span><br><span class=\"line\">            mTargetStack.moveToFront(<span class=\"string\">\"startActivityUnchecked\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复目标 Task</span></span><br><span class=\"line\">        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class=\"line\">                        mOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不需要恢复，那么加到\"最近活动\"中</span></span><br><span class=\"line\">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> START_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setInitialState</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 DisplayId</span></span><br><span class=\"line\">    mSourceDisplayId = getSourceDisplayId();</span><br><span class=\"line\">    <span class=\"comment\">// 获取用于启动 Activity 的范围，Rect</span></span><br><span class=\"line\">    mLaunchBounds = getOerrideBounds();</span><br><span class=\"line\">    <span class=\"comment\">// launchMode</span></span><br><span class=\"line\">    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;</span><br><span class=\"line\">    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;</span><br><span class=\"line\">    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;</span><br><span class=\"line\">    <span class=\"comment\">// Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 requestCode &gt;= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity</span></span><br><span class=\"line\">    sendNewTaskResultRequestIfNeeded();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">computeLaunchingTaskFlags</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span> &amp;&amp; mInTask != <span class=\"keyword\">null</span> &amp;&amp; mInTask.getStack() != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不存在源 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Intent baseIntent = mInTask.getBaseIntent();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord root = mInTask.getRootActivity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseIntent == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了 SingleInstacne 或 SingleTask</span></span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent()))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// Task 不符合</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 已经存在 Task 根 Activity</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果不存在根 Activity，重新设置 launch flags</span></span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">             mAddingToTask = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">if</span> ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) &amp;&amp; mSourceRecord != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; mSourceRecord.isFreeform())  &#123;</span><br><span class=\"line\">                         <span class=\"comment\">// 如果使用 ResolverActivity 启动或者 noDisplay</span></span><br><span class=\"line\">                mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mInTask == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 不存在 Task，并且不存在源 Activity</span></span><br><span class=\"line\">            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity</p>\n<h3 id=\"ActivityStack\"><a href=\"#ActivityStack\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!newTask) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果从已存在的 Task 中启动 Activity</span></span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> startIt = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> taskNdx = mTaskHistory.size() - <span class=\"number\">1</span>; taskNdx &gt;= <span class=\"number\">0</span>; --taskNdx) &#123;</span><br><span class=\"line\">      \ttask = mTaskHistory.get(taskNdx);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task.getTopActivity() == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果 task 不存在 Activity</span></span><br><span class=\"line\">              <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task == rTask) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// 找到对应的 task</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!startIt) &#123;</span><br><span class=\"line\">            \t<span class=\"comment\">// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动</span></span><br><span class=\"line\">                r.createWindowContainer();</span><br><span class=\"line\">                ActivityOptions.abort(options);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (task.numFullscreen &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              startIt = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == activityTask &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        mStackSupervisor.mUserLeaving = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHomeOrRecentsStack() || numActivities() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 处理 动画</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTask) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了重置的标记</span></span><br><span class=\"line\">            resetTaskIfNeededLocked(r, r);</span><br><span class=\"line\">            doShow = topRunningNonDelayedActivityLocked(<span class=\"keyword\">null</span>) == r;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span> &amp;&amp; options.getAnimationType()</span><br><span class=\"line\">                    == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 需要进行转场动画</span></span><br><span class=\"line\">                doShow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果为 true，那么不开启 window，但要确保 Activity 是可见的</span></span><br><span class=\"line\">            r.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class=\"line\">            TaskRecord prevTask = r.getTask();</span><br><span class=\"line\">            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 以下两种情况不展示之前的 Activity 预览</span></span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (prev.getTask() != prevTask) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 之前的 Activity 在不同的 Task</span></span><br><span class=\"line\">                \tprev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prev.nowVisible) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 现在可见</span></span><br><span class=\"line\">                \t prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 显示启动 Activity 的 Window</span></span><br><span class=\"line\">        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前为栈顶 Activity</span></span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ActivityStack.startActivityLocked</code> 主要是创建 WindowContainer，同时显示 Window</p>\n<h3 id=\"ActivityStackSupervisor\"><a href=\"#ActivityStackSupervisor\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeFocusedStackTopActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetStack != <span class=\"keyword\">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存在 targetStack</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"keyword\">null</span> || r.state != RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复聚焦 task</span></span><br><span class=\"line\">    \tmFocusedStack.resumeTopActivityUncheckedLocked(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state == RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行应用转场动画</span></span><br><span class=\"line\">    \tmFocusedStack.executeAppTransition(targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityStack-1\"><a href=\"#ActivityStack-1\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityUncheckedLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 防止递归</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置恢复标记</span></span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在恢复过程中，确保必要的暂停逻辑</span></span><br><span class=\"line\">    mStackSupervisor.checkReadyForSleepLocked();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityInnerLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord next = topRunningActivityLocked(<span class=\"keyword\">true</span> <span class=\"comment\">/* focusableOnly */</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasRunningActivity = next != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord parent = mActivityContainer.mParentActivity;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isParentNotResumed = parent != <span class=\"keyword\">null</span> &amp;&amp; parent.state != ActivityState.RESUMED;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasRunningActivity</span><br><span class=\"line\">                &amp;&amp; (isParentNotResumed || !mActivityContainer.isAttachedLocked())) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 如果父 Activity 不是恢复状态，则不恢复当前 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasRunningActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 Task 没有需要恢复的 Activity</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> resumeTopActivityInNextFocusableStack(prev, options, <span class=\"string\">\"noMoreActivities\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                    mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保已经执行了所有等待的转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingOrShuttingDownLocked()</span><br><span class=\"line\">                &amp;&amp; mLastPausedActivity == next</span><br><span class=\"line\">                &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果系统处于休眠状态，当前 Activity 处于暂停状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保转场执行</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mService.mUserController.hasStartedUserState(next.userId)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果拥有该 Activity 的用户没有启动</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果存在暂停 Activity 的操作未完成</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> lastResumedCanPip = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastFocusedStack != <span class=\"keyword\">null</span> &amp;&amp; lastFocusedStack != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class=\"line\">        <span class=\"comment\">// 最后一个恢复的 Activity 是否可以 画中画</span></span><br><span class=\"line\">        lastResumedCanPip = lastResumed != <span class=\"keyword\">null</span> &amp;&amp; lastResumed.checkEnterPictureInPictureState(</span><br><span class=\"line\">                    <span class=\"string\">\"resumeTopActivity\"</span>, <span class=\"keyword\">true</span> <span class=\"comment\">/* noThrow */</span>, userLeaving <span class=\"comment\">/* beforeStopping */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 是否需要可以在上一个 Activity 暂停时进行恢复</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; !lastResumedCanPip;</span><br><span class=\"line\">    <span class=\"comment\">// 是否暂停了回退的 task</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 暂停上一个恢复状态的 Activity</span></span><br><span class=\"line\">    \tpausing |= startPausingLocked(userLeaving, <span class=\"keyword\">false</span>, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hosting application，一般不执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 让当前 Activity 放在 Lru 的顶部，避免早早杀死</span></span><br><span class=\"line\">        \tmService.updateLruProcessLocked(next.app, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 当前需要恢复的 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保执行转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingLocked() &amp;&amp; mLastNoHistoryActivity != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                !mLastNoHistoryActivity.finishing) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 结束因为系统休眠而还没结束的 Activity</span></span><br><span class=\"line\">    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,</span><br><span class=\"line\">                    <span class=\"keyword\">null</span>, <span class=\"string\">\"resume-no-history\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        mLastNoHistoryActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span> &amp;&amp; prev != next) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class=\"line\">                    &amp;&amp; next != <span class=\"keyword\">null</span> &amp;&amp; !next.nowVisible) &#123;</span><br><span class=\"line\">        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev.finishing) &#123;</span><br><span class=\"line\">            \tprev.setVisibility(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity 转场处理</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 上一个 Activity 是否为透明</span></span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> lastActivityTranslucent = lastStack != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; (!lastStack.mFullscreen</span><br><span class=\"line\">                    || (lastStack.mLastPausedActivity != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; !lastStack.mLastPausedActivity.fullscreen));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!next.visible || next.stopped || lastActivityTranslucent) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 前一个 Activity 为透明，并且当前 Activity 还没显示</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置为显示状态</span></span><br><span class=\"line\">            next.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> notUpdated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.isFocusedStack(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> Configuration config = mWindowManager.updateOrientationFromAppTokens(</span><br><span class=\"line\">                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),</span><br><span class=\"line\">                        next.mayFreezeScreenLocked(next.app) ? next.appToken : <span class=\"keyword\">null</span>, mDisplayId);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tnext.frozenBeforeDestroy = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,</span><br><span class=\"line\">                        <span class=\"keyword\">false</span> <span class=\"comment\">/* deferResume */</span>, mDisplayId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (notUpdated) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 配置发生更新无法保持已经存在的 Activity 实例</span></span><br><span class=\"line\">         <span class=\"comment\">// 重新获取需要恢复的 Activity</span></span><br><span class=\"line\">         ActivityRecord nextNext = topRunningActivityLocked();</span><br><span class=\"line\">         <span class=\"comment\">// 确保 Activity 仍然保持在栈顶，同时安排另外一次执行</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (nextNext != next) &#123;</span><br><span class=\"line\">         \tmStackSupervisor.scheduleResumeTopActivities();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!next.visible || next.stopped) &#123;</span><br><span class=\"line\">         \tnext.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         next.completeResumeLocked();</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递所有等待的结果</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.newIntents != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            next.app.thread.scheduleNewIntent(</span><br><span class=\"line\">                            next.newIntents, next.appToken, <span class=\"keyword\">false</span> <span class=\"comment\">/* andPause */</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        next.notifyAppResumed(next.stopped);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 准备恢复 Activity</span></span><br><span class=\"line\">        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,</span><br><span class=\"line\">                        mService.isNextTransitionForward(), resumeAnimOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，重新启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            next.completeResumeLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"resume-exception\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 需要启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：</p>\n<h3 id=\"ActivityStackSupervisor-1\"><a href=\"#ActivityStackSupervisor-1\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取应用进程信息</span></span><br><span class=\"line\">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">                r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果进程已经启动</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (RemoteException e)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 启动应用进程</span></span><br><span class=\"line\">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 冻结屏幕</span></span><br><span class=\"line\">    r.startFreezingScreenLocked(app, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkConfig) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 根据新的 Activity 顺序重新评估屏幕的方向</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = app.activities.indexOf(r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将 Activity 添加到应用进程中</span></span><br><span class=\"line\">        app.activities.add(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        app.thread.scheduleLaunchActivity();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(RemoteException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"2nd-crash\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动流程最后还是回到了 ApplicationThread</p>\n<h3 id=\"ApplicationThread\"><a href=\"#ApplicationThread\" class=\"headerlink\" title=\"ApplicationThread\"></a>ApplicationThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 Handler 发送 LAUNCH_ACTIVITY</span></span><br><span class=\"line\">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们单独把 LAUNCH_ACTIVITY 的处理拿出来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\">r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">\"LAUNCH_ACTIVITY\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityThread\"><a href=\"#ActivityThread\" class=\"headerlink\" title=\"ActivityThread\"></a>ActivityThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行启动 Activity</span></span><br><span class=\"line\">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// resume activity</span></span><br><span class=\"line\">        handleResumeActivity(r.token, <span class=\"keyword\">false</span>, r.isForward,</span><br><span class=\"line\">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Activity 信息初始化</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 context</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        <span class=\"comment\">// 构建 Activity</span></span><br><span class=\"line\">        activity = mInstrumentation.newActivity(</span><br><span class=\"line\">                    cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(activity != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        \tactivity.attach();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onCreate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Activity onStart</span></span><br><span class=\"line\">            \tactivity.performStart();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onRestoreInstanceState</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                \t<span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span> || r.persistentState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class=\"line\">                                    r.persistentState);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">             <span class=\"comment\">// 通过 Instrumentation 执行 Activity onPostCreeate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class=\"line\">                                r.persistentState);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> activity;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    r = performResumeActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            r.window = r.activity.getWindow();</span><br><span class=\"line\">            View decor = r.window.getDecorView();</span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                \ta.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// window</span></span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span> &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 Intent</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingIntents != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverNewIntents(r, r.pendingIntents);</span><br><span class=\"line\">                r.pendingIntents = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 result</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingResults != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverResults(r, r.pendingResults);</span><br><span class=\"line\">                r.pendingResults = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 执行 resume</span></span><br><span class=\"line\">            r.activity.performResume();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-1\"><a href=\"#Instrumentation-1\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">newActivity</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    prePerformCreate(activity);</span><br><span class=\"line\">    activity.performCreate(icicle);</span><br><span class=\"line\">    postPerformCreate(activity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Activity-1\"><a href=\"#Activity-1\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class=\"line\">    <span class=\"comment\">// 调用 onCreate</span></span><br><span class=\"line\">    onCreate(icicle);</span><br><span class=\"line\">    mActivityTransitionState.readState(icicle);</span><br><span class=\"line\">    performCreateCommon();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mActivityTransitionState.setEnterActivityOptions(<span class=\"keyword\">this</span>, getActivityOptions());</span><br><span class=\"line\">    mInstrumentation.callActivityOnStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    mActivityTransitionState.enterReady(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行 restart</span></span><br><span class=\"line\">    performRestart();</span><br><span class=\"line\">    mInstrumentation.callActivityOnResume(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStopped) &#123;</span><br><span class=\"line\">        mStopped = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mInstrumentation.callActivityOnRestart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 执行 start</span></span><br><span class=\"line\">        performStart();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-2\"><a href=\"#Instrumentation-2\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onStart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     activity.mResumed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    activity.onResume();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onRestart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>简单总结下 Activity 的启动流程：</p>\n<ol>\n<li>从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信</li>\n<li>ActivityManagerService 用于管理所有的 Activity 活动<ul>\n<li>当接受到启动 Activity 的调用时，使用 <code>resolveActivity</code> ，查询系统中符合要求的 Activity</li>\n<li>创建使用合适的  ActivityStack 和 launch flags 来启动 Activity</li>\n<li>如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity</li>\n<li>如果不存在应用进程，先创建应用进程</li>\n</ul>\n</li>\n<li>最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行<ul>\n<li>使用 Instrumentation 去通过反射构建 Activity 实例</li>\n<li>使用 Handler 机制调用 Activity 的生命周期</li>\n</ul>\n</li>\n</ol>\n<p>下面的图例来自<a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">博客</a>：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://gityuan.com/images/activity/start_activity_process.jpg\" alt=\"启动流程\" title=\"\">\n                </div>\n                <div class=\"image-caption\">启动流程</div>\n            </figure>\n<h3 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png\" alt=\"Android启动流程\" title=\"\">\n                </div>\n                <div class=\"image-caption\">Android启动流程</div>\n            </figure>\n"},{"title":"Gradle插件-基础篇","date":"2018-05-16T01:20:58.000Z","_content":"\n## 前言\n\n本文是 Gradle 系列的第三篇，前两篇都是关于 Gradle 多项目构建，有兴趣的同学可以去翻看下。Gradle 系列作者会一直更新下去，这些知识大部分都来自于 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html)，但我并不想写成翻译类型的文章，从最基础的知识开始深入，因为这样前期枯燥的理论知识会让人感到厌倦，所以从用户最常用的知识入手，再穿插必要的基础知识，最终达到知识的融会贯通。因为作者从事 Android 开发，所以会更多提及 Android 中关于 Gradle 的知识。\n\n> 博客中的[源码地址](https://github.com/LinXiaoTao/GradleCaseProject)\n\n## Gradle插件\n\nGradle 是非常强大的构建工具，所有的知识都围绕着 project 和 task 这两个知识点。project 在前面的文章中我们已经简单介绍了，task 现在是穿插着讲，后续会考虑单独写成文章。而我们今天讲的 plugin 对于大部分的 Gradle 使用者来说，可能是一个熟悉又陌生的知识点，熟悉是因为用的太频繁了，比如 Android 项目中，我们都会使用以下配置：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion xxx\n    buildToolsVersion xxx\n    defaultConfig {\n        \n    }\n}\n```\n\n但另外一方面，我们对 plugin 的实现又似懂非懂，使用 Android Application Plugin 后，`android {}` 配置块是如何生成的，又有哪些配置可以用。现在有很多自定义的 Gradle Plugin，比如使用 AOP 实现的代码插桩，打点等等功能的库，那么这些库又是如何通过 Plugin 功能实现的。\n\n接下来，我们将基于 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html) 中关于 Plugin 的知识，从 Plugin 的理论知识到自定义实现 Plugin 写一系列文章。\n\n> 友情提示：如果想深入理解 Gradle 知识，最好还是从 Gradle 官方文档入手，比如 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html)，[API 文档](https://docs.gradle.org/current/javadoc/) 等等，如果只是想快速了解，那么可以继续往下读。\n\n### 设计\n\nGradle Plugin 的设计应该符合以下准则：\n\n#### 架构\n\n* 可复用的逻辑应该写成二进制形式\n\n  Gradle Plugin 有两种形式：脚本插件和二进制插件。脚本插件就是普通的构建脚本，虽然脚本插件也可以组织构建逻辑，但是它不能进行测试，也不能定义可复用的类型，难于长期维护。\n\n* 考虑性能影响\n\n  虽然在设计 Gradle Plugin 时，可以实现你能想到的任何逻辑，但是应该考虑对构建时间的影响。\n\n* 约定大于配置\n\n  Gradle Plugin 的设计应该秉承**约定大于配置**的准则，尽量减少用户陷入繁琐的配置中，又提供配置入口给具有自定义需求的用户。比如 Android Application Plugin 的 ***sourceSets*** 配置，如果不进行配置，会使用默认的目录，可以使用  `./gradlew :app:sourceSets` 打印默认使用的目录。\n\n* 功能与约定\n\n  为了让用户能够更灵活地使用你设计的 Plugin，你应该提供更为灵活的使用方式，其中一个方式就是，将实现功能与通用配置分离开来。比如： [Java Base Plugin](https://docs.gradle.org/current/userguide/standard_plugins.html?_ga=2.84655903.747719590.1526541985-590693097.1523454314#sec:base_plugins) 和 [Java Plugin](https://docs.gradle.org/current/userguide/java_plugin.html?_ga=2.72588053.747719590.1526541985-590693097.1523454314)：\n\n  * Java Base Plugin：提供了 ***sourceSets*** 配置属性，用于定义源文件的目录，但它并不会被用于任何构建任务\n  * Java Plugin：则是在 Java Base Plugin 提供的 ***sourceSets*** 配置上读取源文件，同时定义了具体的构建任务\n\n  如果用户想实现更深层次的定制，则可以继承于 Java Base Plugin 实现自定义构建任务。\n\n  在实现自定义 Plugin 可以这样实现：\n\n  假设 `BasePlugin` 实现了通用配置：\n\n  ``` groovy\n  public class BasePlugin implements Plugin<Project> {\n      public void apply(Project project) {\n          \n      }\n  }\n  ```\n\n  `MyPlugin` 则是基于 `BasePlugin` 实现了特定功能：\n\n  ``` groovy\n  public class MyPlugin implements Plugin<Project> {\n      public void apply(Project project) {\n          proejct.getPlugins().apply(BasePlugin.class);\n      }\n  }\n  ```\n\n  #### 技术实现\n\n* 倾向于使用静态类型语言来实现\n\n  Gradle Plugin 的实现语言可以是任何 JVM 语言（即编译产物能在 JVM 上运行），可以是 Java、Kotlin、Groovy 等等。\n\n  但建议使用 Java 或 Kotlin 等静态类型语言来实现，以降低出现不兼容的可能。\n\n* 使用 Gradle 公开 API 实现\n\n  当实现 Gradle Plugin，需要指定使用的 Gradle API 版本，例如以下配置：\n\n  ``` groovy\n  dependencies {\n      compile gradleAPi()\n  }\n  ```\n\n  但因为 Gradle 的历史原因，公开和内部的 API 并没有分离开来，为了确保与各个 Gradle 版本的兼容性，请尽量使用公开的 API\n\n  > 能在 [DSL 文档](https://docs.gradle.org/current/dsl/?_ga=2.131010252.258862271.1526633053-590693097.1523454314) 和  [DOC 文档](https://docs.gradle.org/current/javadoc/?_ga=2.131010252.258862271.1526633053-590693097.1523454314) 中找到的，即为公开的 API\n\n* 最大程度地减少外部库的依赖\n\n  当我们在编写 Plugin 时，可能会习惯性地去引入某个功能齐全的外部库，比如：Guave，但是这同时也会带来一些问题，可以使用 `buildEnvironment` task 查看构建环境依赖关系，包括 Plugin：\n\n  ```\n  classpath\n  +--- com.android.tools.build:gradle:2.3.3\n  |    \\--- com.android.tools.build:gradle-core:2.3.3\n  |         +--- com.android.tools.build:builder:2.3.3\n  ```\n\n  因为 Gradle Plugin 并没有独立的类加载器运行环境，所以这些依赖可能会与其他 Plugin 的依赖发生冲突。\n\n### 例子\n\n上面是自定义 Gradle Plugin 的一些规范和注意事项，下面我们通过一个比较简单的自定义 Plugin 来实践下。\n\n这个 Plugin 的功能很简单，创建一个 task，获取配置的属性，再打印出来。\n\n上面我们说到，Plugin 可以分为脚本插件和二进制插件两种，脚本插件就是 Gradle 文件，而二进制文件的可以像普通依赖一样，从中央仓库上下载，还有一种方式是，将源码存放到当前项目下的 ***buildSrc*** module，当应用插件时，会从中查找。为了方便起见，我们使用后面那种方式。\n\n* 首先，我们创建一个名为 ***buildSrc*** 的 module，记得在 `setting.gradle` 中配置，在该 module 的根目录下创建 `build.gradle`，因为我们打算用 Java 实现，所以先引入 Java Plugin，同时依赖 Gradle API。\n\n  > Gradle 同时也提供了一个 Plugin 用于简化这些步骤，具体可以查看 [java-gradle-plugin](https://docs.gradle.org/4.7/userguide/java_gradle_plugin.html?_ga=2.132564685.258862271.1526633053-590693097.1523454314)\n\n  ``` groovy\n  apply plugin: 'java-library'\n  \n  dependencies {\n      implementation fileTree(dir: 'libs', include: ['*.jar'])\n      implementation gradleApi()\n  }\n  \n  sourceCompatibility = \"1.8\"\n  targetCompatibility = \"1.8\"\n  ```\n\n* 接着，创建一个 Task 类型，命名为 `HelloWorld`：\n\n  ``` java\n  public class HelloWorld extends DefaultTask {\n      \n      public String userName;\n  \n      @TaskAction\n      public void run() {\n          System.out.println(\"Hello World，\" + userName);\n      }\n  }\n  ```\n\n  一般继承于 `DefaultTask` 也可以选择其他 Task 基类，`@TaskAction` 是必须的，用于注解方法为 Task 运行时执行的代码，`userName` 是可选配置。\n\n* 其实上一步做完，我们已经可以在其他 module 下的 gradle 文件中直接引用这个 Task 类型，比如：\n\n  ``` groovy\n  import com.example.gradle.HelloWorld\n  \n  task hello(type: HelloWorld) {\n      userName = \"leo\"\n  }\n  ```\n\n  执行 `./gradlew :app:hello` 输出 \"Hello World，leo\"\n\n  > 注意：上面这样做的前提是，这部分的代码位于 ***buildSrc*** module，这也是约定配置，符合**约定大于配置**规范\n\n  在我们这个例子中，我们通过 Plugin 去动态创建一个 Task：\n\n  ``` java\n  public final class HelloWorldPlugin implements Plugin<Project> {\n      @Override\n      public void apply(Project project) {\n          project.getTasks().create(\"pluginHello\", HelloWorld.class, helloWorld ->\n                  helloWorld.userName = \"leo\");\n      }\n  }\n  ```\n\n  实现自定义 Plugin 需要实现于 Plugin，接着在 `apply()` 中添加一个名为 \"pluginHello\"，类型为 `HelloWorld` 的 Task。\n\n* 至此，我们已经写好了 Plugin 的逻辑代码，要想在当前项目中的其他 module 中引用 ***buildSrc*** 中的 Plugin，需要给 `HelloWorldPlugin` 指定一个 ID，注：直接写在构建脚本中的插件则不需要。具体配置如下：\n\n  在 `src/main/resources/META-INF/gradle-plugins/` 目录下创建一个配置文件，命名规则为：***[PluginID].properties***，在我们这个例子中为：`com.example.hello.properties`：\n\n  ``` properties\n  implementation-class=com.example.gradle.HelloWorldPlugin\n  ```\n\n  `implementation-class` 表示 Plugin 类\n\n  > Plugin ID 应该符合以下规定：\n  >\n  > * 可以包含任何字母、字符，'.'、'-'\n  > * 必须至少包含一个 '.' 分隔命名空间和插件名称\n  > * 按照惯例，使用域名反向小写作为命名空间\n  > * 按照惯例，命名空间只使用小写字母\n  > * `org.gradle` 和 `com.gradleware` 命名空间不能被使用\n  > * 不能使用 '.' 作为开始或结束字符\n  > * 不能使用连续的 '.' 字符\n\n* 至此，我们已经写好了一个简单自定义 Plugin，我们在 app module 下的 `build.gradle` 引入这个它：\n\n  ```\n  apply plugin: 'com.example.hello'\n  ```\n\n  执行 `./gradlew :app:pluginHello` 输出 \"Hello World，leo\"\n\n  > 上面我们提到了 java-gradle-plugin，如果使用这个 Plugin 的话，可以无需手动配置 properties，只需在 gradle 中配置如下即可：\n  >\n  > ``` groovy\n  > gradlePlugin {\n  >     plugins {\n  >         helloPlugin {\n  >             id = 'com.example.hello'\n  >             implementationClass = 'com.example.gradle.HelloWorldPlugin'\n  >         }\n  >     }\n  > }\n  > ```\n\n### 插件源码\n\n在上面的例子中，我们将代码写在了 ***buildSrc*** module 中，那么除此之外还有：\n\n* 构建脚本\n\n  可以将 Plugin 的源码直接包含在构建脚本中，这样子可以方便地在当前构建脚本直接使用该 Plugin，但是无法在其他构建脚本中使用。\n\n  ***build.gradle***\n\n  ``` groovy\n  class TestPlugin implements Plugin<Project> {\n      void apply(Project project) {\n          project.tasks.create('pluginTest') {\n              doLast {\n                  println \"This is Test\"\n              }\n          }\n      }\n  }\n  \n  apply plugin: TestPlugin\n  ```\n\n  > 需要注意：上面的书写顺序，还记得我们之前说的**边读取边解释**\n\n* 单独的项目\n\n  你可以为 Gradle Plugin 创建一个单独的项目，这种方式和 ***buildSrc*** 类似，并且可以生成 JAR 上传到中央仓库提供给其他开发者使用，而 ***buildSrc*** 只能在当前项目中使用。\n\n  ### 结束语\n\n由于篇幅的限制，基础篇我们就讲到这里，后续的文章还会更深入地讲解 Gradle Plugin 知识。","source":"_posts/Gradle插件-基础篇.md","raw":"---\ntitle: Gradle插件-基础篇\ndate: 2018-05-16 09:20:58\ncategories: Gradle\ntags: \n---\n\n## 前言\n\n本文是 Gradle 系列的第三篇，前两篇都是关于 Gradle 多项目构建，有兴趣的同学可以去翻看下。Gradle 系列作者会一直更新下去，这些知识大部分都来自于 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html)，但我并不想写成翻译类型的文章，从最基础的知识开始深入，因为这样前期枯燥的理论知识会让人感到厌倦，所以从用户最常用的知识入手，再穿插必要的基础知识，最终达到知识的融会贯通。因为作者从事 Android 开发，所以会更多提及 Android 中关于 Gradle 的知识。\n\n> 博客中的[源码地址](https://github.com/LinXiaoTao/GradleCaseProject)\n\n## Gradle插件\n\nGradle 是非常强大的构建工具，所有的知识都围绕着 project 和 task 这两个知识点。project 在前面的文章中我们已经简单介绍了，task 现在是穿插着讲，后续会考虑单独写成文章。而我们今天讲的 plugin 对于大部分的 Gradle 使用者来说，可能是一个熟悉又陌生的知识点，熟悉是因为用的太频繁了，比如 Android 项目中，我们都会使用以下配置：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion xxx\n    buildToolsVersion xxx\n    defaultConfig {\n        \n    }\n}\n```\n\n但另外一方面，我们对 plugin 的实现又似懂非懂，使用 Android Application Plugin 后，`android {}` 配置块是如何生成的，又有哪些配置可以用。现在有很多自定义的 Gradle Plugin，比如使用 AOP 实现的代码插桩，打点等等功能的库，那么这些库又是如何通过 Plugin 功能实现的。\n\n接下来，我们将基于 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html) 中关于 Plugin 的知识，从 Plugin 的理论知识到自定义实现 Plugin 写一系列文章。\n\n> 友情提示：如果想深入理解 Gradle 知识，最好还是从 Gradle 官方文档入手，比如 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html)，[API 文档](https://docs.gradle.org/current/javadoc/) 等等，如果只是想快速了解，那么可以继续往下读。\n\n### 设计\n\nGradle Plugin 的设计应该符合以下准则：\n\n#### 架构\n\n* 可复用的逻辑应该写成二进制形式\n\n  Gradle Plugin 有两种形式：脚本插件和二进制插件。脚本插件就是普通的构建脚本，虽然脚本插件也可以组织构建逻辑，但是它不能进行测试，也不能定义可复用的类型，难于长期维护。\n\n* 考虑性能影响\n\n  虽然在设计 Gradle Plugin 时，可以实现你能想到的任何逻辑，但是应该考虑对构建时间的影响。\n\n* 约定大于配置\n\n  Gradle Plugin 的设计应该秉承**约定大于配置**的准则，尽量减少用户陷入繁琐的配置中，又提供配置入口给具有自定义需求的用户。比如 Android Application Plugin 的 ***sourceSets*** 配置，如果不进行配置，会使用默认的目录，可以使用  `./gradlew :app:sourceSets` 打印默认使用的目录。\n\n* 功能与约定\n\n  为了让用户能够更灵活地使用你设计的 Plugin，你应该提供更为灵活的使用方式，其中一个方式就是，将实现功能与通用配置分离开来。比如： [Java Base Plugin](https://docs.gradle.org/current/userguide/standard_plugins.html?_ga=2.84655903.747719590.1526541985-590693097.1523454314#sec:base_plugins) 和 [Java Plugin](https://docs.gradle.org/current/userguide/java_plugin.html?_ga=2.72588053.747719590.1526541985-590693097.1523454314)：\n\n  * Java Base Plugin：提供了 ***sourceSets*** 配置属性，用于定义源文件的目录，但它并不会被用于任何构建任务\n  * Java Plugin：则是在 Java Base Plugin 提供的 ***sourceSets*** 配置上读取源文件，同时定义了具体的构建任务\n\n  如果用户想实现更深层次的定制，则可以继承于 Java Base Plugin 实现自定义构建任务。\n\n  在实现自定义 Plugin 可以这样实现：\n\n  假设 `BasePlugin` 实现了通用配置：\n\n  ``` groovy\n  public class BasePlugin implements Plugin<Project> {\n      public void apply(Project project) {\n          \n      }\n  }\n  ```\n\n  `MyPlugin` 则是基于 `BasePlugin` 实现了特定功能：\n\n  ``` groovy\n  public class MyPlugin implements Plugin<Project> {\n      public void apply(Project project) {\n          proejct.getPlugins().apply(BasePlugin.class);\n      }\n  }\n  ```\n\n  #### 技术实现\n\n* 倾向于使用静态类型语言来实现\n\n  Gradle Plugin 的实现语言可以是任何 JVM 语言（即编译产物能在 JVM 上运行），可以是 Java、Kotlin、Groovy 等等。\n\n  但建议使用 Java 或 Kotlin 等静态类型语言来实现，以降低出现不兼容的可能。\n\n* 使用 Gradle 公开 API 实现\n\n  当实现 Gradle Plugin，需要指定使用的 Gradle API 版本，例如以下配置：\n\n  ``` groovy\n  dependencies {\n      compile gradleAPi()\n  }\n  ```\n\n  但因为 Gradle 的历史原因，公开和内部的 API 并没有分离开来，为了确保与各个 Gradle 版本的兼容性，请尽量使用公开的 API\n\n  > 能在 [DSL 文档](https://docs.gradle.org/current/dsl/?_ga=2.131010252.258862271.1526633053-590693097.1523454314) 和  [DOC 文档](https://docs.gradle.org/current/javadoc/?_ga=2.131010252.258862271.1526633053-590693097.1523454314) 中找到的，即为公开的 API\n\n* 最大程度地减少外部库的依赖\n\n  当我们在编写 Plugin 时，可能会习惯性地去引入某个功能齐全的外部库，比如：Guave，但是这同时也会带来一些问题，可以使用 `buildEnvironment` task 查看构建环境依赖关系，包括 Plugin：\n\n  ```\n  classpath\n  +--- com.android.tools.build:gradle:2.3.3\n  |    \\--- com.android.tools.build:gradle-core:2.3.3\n  |         +--- com.android.tools.build:builder:2.3.3\n  ```\n\n  因为 Gradle Plugin 并没有独立的类加载器运行环境，所以这些依赖可能会与其他 Plugin 的依赖发生冲突。\n\n### 例子\n\n上面是自定义 Gradle Plugin 的一些规范和注意事项，下面我们通过一个比较简单的自定义 Plugin 来实践下。\n\n这个 Plugin 的功能很简单，创建一个 task，获取配置的属性，再打印出来。\n\n上面我们说到，Plugin 可以分为脚本插件和二进制插件两种，脚本插件就是 Gradle 文件，而二进制文件的可以像普通依赖一样，从中央仓库上下载，还有一种方式是，将源码存放到当前项目下的 ***buildSrc*** module，当应用插件时，会从中查找。为了方便起见，我们使用后面那种方式。\n\n* 首先，我们创建一个名为 ***buildSrc*** 的 module，记得在 `setting.gradle` 中配置，在该 module 的根目录下创建 `build.gradle`，因为我们打算用 Java 实现，所以先引入 Java Plugin，同时依赖 Gradle API。\n\n  > Gradle 同时也提供了一个 Plugin 用于简化这些步骤，具体可以查看 [java-gradle-plugin](https://docs.gradle.org/4.7/userguide/java_gradle_plugin.html?_ga=2.132564685.258862271.1526633053-590693097.1523454314)\n\n  ``` groovy\n  apply plugin: 'java-library'\n  \n  dependencies {\n      implementation fileTree(dir: 'libs', include: ['*.jar'])\n      implementation gradleApi()\n  }\n  \n  sourceCompatibility = \"1.8\"\n  targetCompatibility = \"1.8\"\n  ```\n\n* 接着，创建一个 Task 类型，命名为 `HelloWorld`：\n\n  ``` java\n  public class HelloWorld extends DefaultTask {\n      \n      public String userName;\n  \n      @TaskAction\n      public void run() {\n          System.out.println(\"Hello World，\" + userName);\n      }\n  }\n  ```\n\n  一般继承于 `DefaultTask` 也可以选择其他 Task 基类，`@TaskAction` 是必须的，用于注解方法为 Task 运行时执行的代码，`userName` 是可选配置。\n\n* 其实上一步做完，我们已经可以在其他 module 下的 gradle 文件中直接引用这个 Task 类型，比如：\n\n  ``` groovy\n  import com.example.gradle.HelloWorld\n  \n  task hello(type: HelloWorld) {\n      userName = \"leo\"\n  }\n  ```\n\n  执行 `./gradlew :app:hello` 输出 \"Hello World，leo\"\n\n  > 注意：上面这样做的前提是，这部分的代码位于 ***buildSrc*** module，这也是约定配置，符合**约定大于配置**规范\n\n  在我们这个例子中，我们通过 Plugin 去动态创建一个 Task：\n\n  ``` java\n  public final class HelloWorldPlugin implements Plugin<Project> {\n      @Override\n      public void apply(Project project) {\n          project.getTasks().create(\"pluginHello\", HelloWorld.class, helloWorld ->\n                  helloWorld.userName = \"leo\");\n      }\n  }\n  ```\n\n  实现自定义 Plugin 需要实现于 Plugin，接着在 `apply()` 中添加一个名为 \"pluginHello\"，类型为 `HelloWorld` 的 Task。\n\n* 至此，我们已经写好了 Plugin 的逻辑代码，要想在当前项目中的其他 module 中引用 ***buildSrc*** 中的 Plugin，需要给 `HelloWorldPlugin` 指定一个 ID，注：直接写在构建脚本中的插件则不需要。具体配置如下：\n\n  在 `src/main/resources/META-INF/gradle-plugins/` 目录下创建一个配置文件，命名规则为：***[PluginID].properties***，在我们这个例子中为：`com.example.hello.properties`：\n\n  ``` properties\n  implementation-class=com.example.gradle.HelloWorldPlugin\n  ```\n\n  `implementation-class` 表示 Plugin 类\n\n  > Plugin ID 应该符合以下规定：\n  >\n  > * 可以包含任何字母、字符，'.'、'-'\n  > * 必须至少包含一个 '.' 分隔命名空间和插件名称\n  > * 按照惯例，使用域名反向小写作为命名空间\n  > * 按照惯例，命名空间只使用小写字母\n  > * `org.gradle` 和 `com.gradleware` 命名空间不能被使用\n  > * 不能使用 '.' 作为开始或结束字符\n  > * 不能使用连续的 '.' 字符\n\n* 至此，我们已经写好了一个简单自定义 Plugin，我们在 app module 下的 `build.gradle` 引入这个它：\n\n  ```\n  apply plugin: 'com.example.hello'\n  ```\n\n  执行 `./gradlew :app:pluginHello` 输出 \"Hello World，leo\"\n\n  > 上面我们提到了 java-gradle-plugin，如果使用这个 Plugin 的话，可以无需手动配置 properties，只需在 gradle 中配置如下即可：\n  >\n  > ``` groovy\n  > gradlePlugin {\n  >     plugins {\n  >         helloPlugin {\n  >             id = 'com.example.hello'\n  >             implementationClass = 'com.example.gradle.HelloWorldPlugin'\n  >         }\n  >     }\n  > }\n  > ```\n\n### 插件源码\n\n在上面的例子中，我们将代码写在了 ***buildSrc*** module 中，那么除此之外还有：\n\n* 构建脚本\n\n  可以将 Plugin 的源码直接包含在构建脚本中，这样子可以方便地在当前构建脚本直接使用该 Plugin，但是无法在其他构建脚本中使用。\n\n  ***build.gradle***\n\n  ``` groovy\n  class TestPlugin implements Plugin<Project> {\n      void apply(Project project) {\n          project.tasks.create('pluginTest') {\n              doLast {\n                  println \"This is Test\"\n              }\n          }\n      }\n  }\n  \n  apply plugin: TestPlugin\n  ```\n\n  > 需要注意：上面的书写顺序，还记得我们之前说的**边读取边解释**\n\n* 单独的项目\n\n  你可以为 Gradle Plugin 创建一个单独的项目，这种方式和 ***buildSrc*** 类似，并且可以生成 JAR 上传到中央仓库提供给其他开发者使用，而 ***buildSrc*** 只能在当前项目中使用。\n\n  ### 结束语\n\n由于篇幅的限制，基础篇我们就讲到这里，后续的文章还会更深入地讲解 Gradle Plugin 知识。","slug":"Gradle插件-基础篇","published":1,"updated":"2018-05-19T09:08:09.447Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjs0ht9y0009ero6s7f755f3","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文是 Gradle 系列的第三篇，前两篇都是关于 Gradle 多项目构建，有兴趣的同学可以去翻看下。Gradle 系列作者会一直更新下去，这些知识大部分都来自于 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a>，但我并不想写成翻译类型的文章，从最基础的知识开始深入，因为这样前期枯燥的理论知识会让人感到厌倦，所以从用户最常用的知识入手，再穿插必要的基础知识，最终达到知识的融会贯通。因为作者从事 Android 开发，所以会更多提及 Android 中关于 Gradle 的知识。</p>\n<blockquote>\n<p>博客中的<a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n</blockquote>\n<h2 id=\"Gradle插件\"><a href=\"#Gradle插件\" class=\"headerlink\" title=\"Gradle插件\"></a>Gradle插件</h2><p>Gradle 是非常强大的构建工具，所有的知识都围绕着 project 和 task 这两个知识点。project 在前面的文章中我们已经简单介绍了，task 现在是穿插着讲，后续会考虑单独写成文章。而我们今天讲的 plugin 对于大部分的 Gradle 使用者来说，可能是一个熟悉又陌生的知识点，熟悉是因为用的太频繁了，比如 Android 项目中，我们都会使用以下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion xxx</span><br><span class=\"line\">    buildToolsVersion xxx</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但另外一方面，我们对 plugin 的实现又似懂非懂，使用 Android Application Plugin 后，<code>android {}</code> 配置块是如何生成的，又有哪些配置可以用。现在有很多自定义的 Gradle Plugin，比如使用 AOP 实现的代码插桩，打点等等功能的库，那么这些库又是如何通过 Plugin 功能实现的。</p>\n<p>接下来，我们将基于 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a> 中关于 Plugin 的知识，从 Plugin 的理论知识到自定义实现 Plugin 写一系列文章。</p>\n<blockquote>\n<p>友情提示：如果想深入理解 Gradle 知识，最好还是从 Gradle 官方文档入手，比如 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a>，<a href=\"https://docs.gradle.org/current/javadoc/\" target=\"_blank\" rel=\"noopener\">API 文档</a> 等等，如果只是想快速了解，那么可以继续往下读。</p>\n</blockquote>\n<h3 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h3><p>Gradle Plugin 的设计应该符合以下准则：</p>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><p>可复用的逻辑应该写成二进制形式</p>\n<p>Gradle Plugin 有两种形式：脚本插件和二进制插件。脚本插件就是普通的构建脚本，虽然脚本插件也可以组织构建逻辑，但是它不能进行测试，也不能定义可复用的类型，难于长期维护。</p>\n</li>\n<li><p>考虑性能影响</p>\n<p>虽然在设计 Gradle Plugin 时，可以实现你能想到的任何逻辑，但是应该考虑对构建时间的影响。</p>\n</li>\n<li><p>约定大于配置</p>\n<p>Gradle Plugin 的设计应该秉承<strong>约定大于配置</strong>的准则，尽量减少用户陷入繁琐的配置中，又提供配置入口给具有自定义需求的用户。比如 Android Application Plugin 的 <strong><em>sourceSets</em></strong> 配置，如果不进行配置，会使用默认的目录，可以使用  <code>./gradlew :app:sourceSets</code> 打印默认使用的目录。</p>\n</li>\n<li><p>功能与约定</p>\n<p>为了让用户能够更灵活地使用你设计的 Plugin，你应该提供更为灵活的使用方式，其中一个方式就是，将实现功能与通用配置分离开来。比如： <a href=\"https://docs.gradle.org/current/userguide/standard_plugins.html?_ga=2.84655903.747719590.1526541985-590693097.1523454314#sec:base_plugins\" target=\"_blank\" rel=\"noopener\">Java Base Plugin</a> 和 <a href=\"https://docs.gradle.org/current/userguide/java_plugin.html?_ga=2.72588053.747719590.1526541985-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">Java Plugin</a>：</p>\n<ul>\n<li>Java Base Plugin：提供了 <strong><em>sourceSets</em></strong> 配置属性，用于定义源文件的目录，但它并不会被用于任何构建任务</li>\n<li>Java Plugin：则是在 Java Base Plugin 提供的 <strong><em>sourceSets</em></strong> 配置上读取源文件，同时定义了具体的构建任务</li>\n</ul>\n<p>如果用户想实现更深层次的定制，则可以继承于 Java Base Plugin 实现自定义构建任务。</p>\n<p>在实现自定义 Plugin 可以这样实现：</p>\n<p>假设 <code>BasePlugin</code> 实现了通用配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasePlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MyPlugin</code> 则是基于 <code>BasePlugin</code> 实现了特定功能：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        proejct.getPlugins().apply(BasePlugin.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h4></li>\n<li><p>倾向于使用静态类型语言来实现</p>\n<p>Gradle Plugin 的实现语言可以是任何 JVM 语言（即编译产物能在 JVM 上运行），可以是 Java、Kotlin、Groovy 等等。</p>\n<p>但建议使用 Java 或 Kotlin 等静态类型语言来实现，以降低出现不兼容的可能。</p>\n</li>\n<li><p>使用 Gradle 公开 API 实现</p>\n<p>当实现 Gradle Plugin，需要指定使用的 Gradle API 版本，例如以下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile gradleAPi()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但因为 Gradle 的历史原因，公开和内部的 API 并没有分离开来，为了确保与各个 Gradle 版本的兼容性，请尽量使用公开的 API</p>\n<blockquote>\n<p>能在 <a href=\"https://docs.gradle.org/current/dsl/?_ga=2.131010252.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">DSL 文档</a> 和  <a href=\"https://docs.gradle.org/current/javadoc/?_ga=2.131010252.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">DOC 文档</a> 中找到的，即为公开的 API</p>\n</blockquote>\n</li>\n<li><p>最大程度地减少外部库的依赖</p>\n<p>当我们在编写 Plugin 时，可能会习惯性地去引入某个功能齐全的外部库，比如：Guave，但是这同时也会带来一些问题，可以使用 <code>buildEnvironment</code> task 查看构建环境依赖关系，包括 Plugin：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classpath</span><br><span class=\"line\">+--- com.android.tools.build:gradle:2.3.3</span><br><span class=\"line\">|    \\--- com.android.tools.build:gradle-core:2.3.3</span><br><span class=\"line\">|         +--- com.android.tools.build:builder:2.3.3</span><br></pre></td></tr></table></figure>\n<p>因为 Gradle Plugin 并没有独立的类加载器运行环境，所以这些依赖可能会与其他 Plugin 的依赖发生冲突。</p>\n</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>上面是自定义 Gradle Plugin 的一些规范和注意事项，下面我们通过一个比较简单的自定义 Plugin 来实践下。</p>\n<p>这个 Plugin 的功能很简单，创建一个 task，获取配置的属性，再打印出来。</p>\n<p>上面我们说到，Plugin 可以分为脚本插件和二进制插件两种，脚本插件就是 Gradle 文件，而二进制文件的可以像普通依赖一样，从中央仓库上下载，还有一种方式是，将源码存放到当前项目下的 <strong><em>buildSrc</em></strong> module，当应用插件时，会从中查找。为了方便起见，我们使用后面那种方式。</p>\n<ul>\n<li><p>首先，我们创建一个名为 <strong><em>buildSrc</em></strong> 的 module，记得在 <code>setting.gradle</code> 中配置，在该 module 的根目录下创建 <code>build.gradle</code>，因为我们打算用 Java 实现，所以先引入 Java Plugin，同时依赖 Gradle API。</p>\n<blockquote>\n<p>Gradle 同时也提供了一个 Plugin 用于简化这些步骤，具体可以查看 <a href=\"https://docs.gradle.org/4.7/userguide/java_gradle_plugin.html?_ga=2.132564685.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">java-gradle-plugin</a></p>\n</blockquote>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation gradleApi()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = <span class=\"string\">\"1.8\"</span></span><br><span class=\"line\">targetCompatibility = <span class=\"string\">\"1.8\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接着，创建一个 Task 类型，命名为 <code>HelloWorld</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String userName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@TaskAction</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello World，\"</span> + userName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般继承于 <code>DefaultTask</code> 也可以选择其他 Task 基类，<code>@TaskAction</code> 是必须的，用于注解方法为 Task 运行时执行的代码，<code>userName</code> 是可选配置。</p>\n</li>\n<li><p>其实上一步做完，我们已经可以在其他 module 下的 gradle 文件中直接引用这个 Task 类型，比如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.gradle.HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">task hello(<span class=\"string\">type:</span> HelloWorld) &#123;</span><br><span class=\"line\">    userName = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew :app:hello</code> 输出 “Hello World，leo”</p>\n<blockquote>\n<p>注意：上面这样做的前提是，这部分的代码位于 <strong><em>buildSrc</em></strong> module，这也是约定配置，符合<strong>约定大于配置</strong>规范</p>\n</blockquote>\n<p>在我们这个例子中，我们通过 Plugin 去动态创建一个 Task：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorldPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">apply</span><span class=\"params\">(Project project)</span> </span>&#123;</span><br><span class=\"line\">        project.getTasks().create(<span class=\"string\">\"pluginHello\"</span>, HelloWorld.class, helloWorld -&gt;</span><br><span class=\"line\">                helloWorld.userName = <span class=\"string\">\"leo\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现自定义 Plugin 需要实现于 Plugin，接着在 <code>apply()</code> 中添加一个名为 “pluginHello”，类型为 <code>HelloWorld</code> 的 Task。</p>\n</li>\n<li><p>至此，我们已经写好了 Plugin 的逻辑代码，要想在当前项目中的其他 module 中引用 <strong><em>buildSrc</em></strong> 中的 Plugin，需要给 <code>HelloWorldPlugin</code> 指定一个 ID，注：直接写在构建脚本中的插件则不需要。具体配置如下：</p>\n<p>在 <code>src/main/resources/META-INF/gradle-plugins/</code> 目录下创建一个配置文件，命名规则为：<strong><em>[PluginID].properties</em></strong>，在我们这个例子中为：<code>com.example.hello.properties</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation-class=com.example.gradle.HelloWorldPlugin</span><br></pre></td></tr></table></figure>\n<p><code>implementation-class</code> 表示 Plugin 类</p>\n<blockquote>\n<p>Plugin ID 应该符合以下规定：</p>\n<ul>\n<li>可以包含任何字母、字符，’.’、’-‘</li>\n<li>必须至少包含一个 ‘.’ 分隔命名空间和插件名称</li>\n<li>按照惯例，使用域名反向小写作为命名空间</li>\n<li>按照惯例，命名空间只使用小写字母</li>\n<li><code>org.gradle</code> 和 <code>com.gradleware</code> 命名空间不能被使用</li>\n<li>不能使用 ‘.’ 作为开始或结束字符</li>\n<li>不能使用连续的 ‘.’ 字符</li>\n</ul>\n</blockquote>\n</li>\n<li><p>至此，我们已经写好了一个简单自定义 Plugin，我们在 app module 下的 <code>build.gradle</code> 引入这个它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;com.example.hello&apos;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew :app:pluginHello</code> 输出 “Hello World，leo”</p>\n<blockquote>\n<p>上面我们提到了 java-gradle-plugin，如果使用这个 Plugin 的话，可以无需手动配置 properties，只需在 gradle 中配置如下即可：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradlePlugin &#123;</span><br><span class=\"line\">&gt;     plugins &#123;</span><br><span class=\"line\">&gt;         helloPlugin &#123;</span><br><span class=\"line\">&gt;             id = <span class=\"string\">'com.example.hello'</span></span><br><span class=\"line\">&gt;             implementationClass = <span class=\"string\">'com.example.gradle.HelloWorldPlugin'</span></span><br><span class=\"line\">&gt;         &#125;</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"插件源码\"><a href=\"#插件源码\" class=\"headerlink\" title=\"插件源码\"></a>插件源码</h3><p>在上面的例子中，我们将代码写在了 <strong><em>buildSrc</em></strong> module 中，那么除此之外还有：</p>\n<ul>\n<li><p>构建脚本</p>\n<p>可以将 Plugin 的源码直接包含在构建脚本中，这样子可以方便地在当前构建脚本直接使用该 Plugin，但是无法在其他构建脚本中使用。</p>\n<p><strong><em>build.gradle</em></strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        project.tasks.create(<span class=\"string\">'pluginTest'</span>) &#123;</span><br><span class=\"line\">            doLast &#123;</span><br><span class=\"line\">                println <span class=\"string\">\"This is Test\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> TestPlugin</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>需要注意：上面的书写顺序，还记得我们之前说的<strong>边读取边解释</strong></p>\n</blockquote>\n</li>\n<li><p>单独的项目</p>\n<p>你可以为 Gradle Plugin 创建一个单独的项目，这种方式和 <strong><em>buildSrc</em></strong> 类似，并且可以生成 JAR 上传到中央仓库提供给其他开发者使用，而 <strong><em>buildSrc</em></strong> 只能在当前项目中使用。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3></li>\n</ul>\n<p>由于篇幅的限制，基础篇我们就讲到这里，后续的文章还会更深入地讲解 Gradle Plugin 知识。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文是 Gradle 系列的第三篇，前两篇都是关于 Gradle 多项目构建，有兴趣的同学可以去翻看下。Gradle 系列作者会一直更新下去，这些知识大部分都来自于 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a>，但我并不想写成翻译类型的文章，从最基础的知识开始深入，因为这样前期枯燥的理论知识会让人感到厌倦，所以从用户最常用的知识入手，再穿插必要的基础知识，最终达到知识的融会贯通。因为作者从事 Android 开发，所以会更多提及 Android 中关于 Gradle 的知识。</p>\n<blockquote>\n<p>博客中的<a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n</blockquote>\n<h2 id=\"Gradle插件\"><a href=\"#Gradle插件\" class=\"headerlink\" title=\"Gradle插件\"></a>Gradle插件</h2><p>Gradle 是非常强大的构建工具，所有的知识都围绕着 project 和 task 这两个知识点。project 在前面的文章中我们已经简单介绍了，task 现在是穿插着讲，后续会考虑单独写成文章。而我们今天讲的 plugin 对于大部分的 Gradle 使用者来说，可能是一个熟悉又陌生的知识点，熟悉是因为用的太频繁了，比如 Android 项目中，我们都会使用以下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion xxx</span><br><span class=\"line\">    buildToolsVersion xxx</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但另外一方面，我们对 plugin 的实现又似懂非懂，使用 Android Application Plugin 后，<code>android {}</code> 配置块是如何生成的，又有哪些配置可以用。现在有很多自定义的 Gradle Plugin，比如使用 AOP 实现的代码插桩，打点等等功能的库，那么这些库又是如何通过 Plugin 功能实现的。</p>\n<p>接下来，我们将基于 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a> 中关于 Plugin 的知识，从 Plugin 的理论知识到自定义实现 Plugin 写一系列文章。</p>\n<blockquote>\n<p>友情提示：如果想深入理解 Gradle 知识，最好还是从 Gradle 官方文档入手，比如 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a>，<a href=\"https://docs.gradle.org/current/javadoc/\" target=\"_blank\" rel=\"noopener\">API 文档</a> 等等，如果只是想快速了解，那么可以继续往下读。</p>\n</blockquote>\n<h3 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h3><p>Gradle Plugin 的设计应该符合以下准则：</p>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><p>可复用的逻辑应该写成二进制形式</p>\n<p>Gradle Plugin 有两种形式：脚本插件和二进制插件。脚本插件就是普通的构建脚本，虽然脚本插件也可以组织构建逻辑，但是它不能进行测试，也不能定义可复用的类型，难于长期维护。</p>\n</li>\n<li><p>考虑性能影响</p>\n<p>虽然在设计 Gradle Plugin 时，可以实现你能想到的任何逻辑，但是应该考虑对构建时间的影响。</p>\n</li>\n<li><p>约定大于配置</p>\n<p>Gradle Plugin 的设计应该秉承<strong>约定大于配置</strong>的准则，尽量减少用户陷入繁琐的配置中，又提供配置入口给具有自定义需求的用户。比如 Android Application Plugin 的 <strong><em>sourceSets</em></strong> 配置，如果不进行配置，会使用默认的目录，可以使用  <code>./gradlew :app:sourceSets</code> 打印默认使用的目录。</p>\n</li>\n<li><p>功能与约定</p>\n<p>为了让用户能够更灵活地使用你设计的 Plugin，你应该提供更为灵活的使用方式，其中一个方式就是，将实现功能与通用配置分离开来。比如： <a href=\"https://docs.gradle.org/current/userguide/standard_plugins.html?_ga=2.84655903.747719590.1526541985-590693097.1523454314#sec:base_plugins\" target=\"_blank\" rel=\"noopener\">Java Base Plugin</a> 和 <a href=\"https://docs.gradle.org/current/userguide/java_plugin.html?_ga=2.72588053.747719590.1526541985-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">Java Plugin</a>：</p>\n<ul>\n<li>Java Base Plugin：提供了 <strong><em>sourceSets</em></strong> 配置属性，用于定义源文件的目录，但它并不会被用于任何构建任务</li>\n<li>Java Plugin：则是在 Java Base Plugin 提供的 <strong><em>sourceSets</em></strong> 配置上读取源文件，同时定义了具体的构建任务</li>\n</ul>\n<p>如果用户想实现更深层次的定制，则可以继承于 Java Base Plugin 实现自定义构建任务。</p>\n<p>在实现自定义 Plugin 可以这样实现：</p>\n<p>假设 <code>BasePlugin</code> 实现了通用配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasePlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MyPlugin</code> 则是基于 <code>BasePlugin</code> 实现了特定功能：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        proejct.getPlugins().apply(BasePlugin.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h4></li>\n<li><p>倾向于使用静态类型语言来实现</p>\n<p>Gradle Plugin 的实现语言可以是任何 JVM 语言（即编译产物能在 JVM 上运行），可以是 Java、Kotlin、Groovy 等等。</p>\n<p>但建议使用 Java 或 Kotlin 等静态类型语言来实现，以降低出现不兼容的可能。</p>\n</li>\n<li><p>使用 Gradle 公开 API 实现</p>\n<p>当实现 Gradle Plugin，需要指定使用的 Gradle API 版本，例如以下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile gradleAPi()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但因为 Gradle 的历史原因，公开和内部的 API 并没有分离开来，为了确保与各个 Gradle 版本的兼容性，请尽量使用公开的 API</p>\n<blockquote>\n<p>能在 <a href=\"https://docs.gradle.org/current/dsl/?_ga=2.131010252.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">DSL 文档</a> 和  <a href=\"https://docs.gradle.org/current/javadoc/?_ga=2.131010252.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">DOC 文档</a> 中找到的，即为公开的 API</p>\n</blockquote>\n</li>\n<li><p>最大程度地减少外部库的依赖</p>\n<p>当我们在编写 Plugin 时，可能会习惯性地去引入某个功能齐全的外部库，比如：Guave，但是这同时也会带来一些问题，可以使用 <code>buildEnvironment</code> task 查看构建环境依赖关系，包括 Plugin：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classpath</span><br><span class=\"line\">+--- com.android.tools.build:gradle:2.3.3</span><br><span class=\"line\">|    \\--- com.android.tools.build:gradle-core:2.3.3</span><br><span class=\"line\">|         +--- com.android.tools.build:builder:2.3.3</span><br></pre></td></tr></table></figure>\n<p>因为 Gradle Plugin 并没有独立的类加载器运行环境，所以这些依赖可能会与其他 Plugin 的依赖发生冲突。</p>\n</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>上面是自定义 Gradle Plugin 的一些规范和注意事项，下面我们通过一个比较简单的自定义 Plugin 来实践下。</p>\n<p>这个 Plugin 的功能很简单，创建一个 task，获取配置的属性，再打印出来。</p>\n<p>上面我们说到，Plugin 可以分为脚本插件和二进制插件两种，脚本插件就是 Gradle 文件，而二进制文件的可以像普通依赖一样，从中央仓库上下载，还有一种方式是，将源码存放到当前项目下的 <strong><em>buildSrc</em></strong> module，当应用插件时，会从中查找。为了方便起见，我们使用后面那种方式。</p>\n<ul>\n<li><p>首先，我们创建一个名为 <strong><em>buildSrc</em></strong> 的 module，记得在 <code>setting.gradle</code> 中配置，在该 module 的根目录下创建 <code>build.gradle</code>，因为我们打算用 Java 实现，所以先引入 Java Plugin，同时依赖 Gradle API。</p>\n<blockquote>\n<p>Gradle 同时也提供了一个 Plugin 用于简化这些步骤，具体可以查看 <a href=\"https://docs.gradle.org/4.7/userguide/java_gradle_plugin.html?_ga=2.132564685.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">java-gradle-plugin</a></p>\n</blockquote>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation gradleApi()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = <span class=\"string\">\"1.8\"</span></span><br><span class=\"line\">targetCompatibility = <span class=\"string\">\"1.8\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接着，创建一个 Task 类型，命名为 <code>HelloWorld</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String userName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@TaskAction</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello World，\"</span> + userName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般继承于 <code>DefaultTask</code> 也可以选择其他 Task 基类，<code>@TaskAction</code> 是必须的，用于注解方法为 Task 运行时执行的代码，<code>userName</code> 是可选配置。</p>\n</li>\n<li><p>其实上一步做完，我们已经可以在其他 module 下的 gradle 文件中直接引用这个 Task 类型，比如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.gradle.HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">task hello(<span class=\"string\">type:</span> HelloWorld) &#123;</span><br><span class=\"line\">    userName = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew :app:hello</code> 输出 “Hello World，leo”</p>\n<blockquote>\n<p>注意：上面这样做的前提是，这部分的代码位于 <strong><em>buildSrc</em></strong> module，这也是约定配置，符合<strong>约定大于配置</strong>规范</p>\n</blockquote>\n<p>在我们这个例子中，我们通过 Plugin 去动态创建一个 Task：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorldPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">apply</span><span class=\"params\">(Project project)</span> </span>&#123;</span><br><span class=\"line\">        project.getTasks().create(<span class=\"string\">\"pluginHello\"</span>, HelloWorld.class, helloWorld -&gt;</span><br><span class=\"line\">                helloWorld.userName = <span class=\"string\">\"leo\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现自定义 Plugin 需要实现于 Plugin，接着在 <code>apply()</code> 中添加一个名为 “pluginHello”，类型为 <code>HelloWorld</code> 的 Task。</p>\n</li>\n<li><p>至此，我们已经写好了 Plugin 的逻辑代码，要想在当前项目中的其他 module 中引用 <strong><em>buildSrc</em></strong> 中的 Plugin，需要给 <code>HelloWorldPlugin</code> 指定一个 ID，注：直接写在构建脚本中的插件则不需要。具体配置如下：</p>\n<p>在 <code>src/main/resources/META-INF/gradle-plugins/</code> 目录下创建一个配置文件，命名规则为：<strong><em>[PluginID].properties</em></strong>，在我们这个例子中为：<code>com.example.hello.properties</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation-class=com.example.gradle.HelloWorldPlugin</span><br></pre></td></tr></table></figure>\n<p><code>implementation-class</code> 表示 Plugin 类</p>\n<blockquote>\n<p>Plugin ID 应该符合以下规定：</p>\n<ul>\n<li>可以包含任何字母、字符，’.’、’-‘</li>\n<li>必须至少包含一个 ‘.’ 分隔命名空间和插件名称</li>\n<li>按照惯例，使用域名反向小写作为命名空间</li>\n<li>按照惯例，命名空间只使用小写字母</li>\n<li><code>org.gradle</code> 和 <code>com.gradleware</code> 命名空间不能被使用</li>\n<li>不能使用 ‘.’ 作为开始或结束字符</li>\n<li>不能使用连续的 ‘.’ 字符</li>\n</ul>\n</blockquote>\n</li>\n<li><p>至此，我们已经写好了一个简单自定义 Plugin，我们在 app module 下的 <code>build.gradle</code> 引入这个它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;com.example.hello&apos;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew :app:pluginHello</code> 输出 “Hello World，leo”</p>\n<blockquote>\n<p>上面我们提到了 java-gradle-plugin，如果使用这个 Plugin 的话，可以无需手动配置 properties，只需在 gradle 中配置如下即可：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradlePlugin &#123;</span><br><span class=\"line\">&gt;     plugins &#123;</span><br><span class=\"line\">&gt;         helloPlugin &#123;</span><br><span class=\"line\">&gt;             id = <span class=\"string\">'com.example.hello'</span></span><br><span class=\"line\">&gt;             implementationClass = <span class=\"string\">'com.example.gradle.HelloWorldPlugin'</span></span><br><span class=\"line\">&gt;         &#125;</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"插件源码\"><a href=\"#插件源码\" class=\"headerlink\" title=\"插件源码\"></a>插件源码</h3><p>在上面的例子中，我们将代码写在了 <strong><em>buildSrc</em></strong> module 中，那么除此之外还有：</p>\n<ul>\n<li><p>构建脚本</p>\n<p>可以将 Plugin 的源码直接包含在构建脚本中，这样子可以方便地在当前构建脚本直接使用该 Plugin，但是无法在其他构建脚本中使用。</p>\n<p><strong><em>build.gradle</em></strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        project.tasks.create(<span class=\"string\">'pluginTest'</span>) &#123;</span><br><span class=\"line\">            doLast &#123;</span><br><span class=\"line\">                println <span class=\"string\">\"This is Test\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> TestPlugin</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>需要注意：上面的书写顺序，还记得我们之前说的<strong>边读取边解释</strong></p>\n</blockquote>\n</li>\n<li><p>单独的项目</p>\n<p>你可以为 Gradle Plugin 创建一个单独的项目，这种方式和 <strong><em>buildSrc</em></strong> 类似，并且可以生成 JAR 上传到中央仓库提供给其他开发者使用，而 <strong><em>buildSrc</em></strong> 只能在当前项目中使用。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3></li>\n</ul>\n<p>由于篇幅的限制，基础篇我们就讲到这里，后续的文章还会更深入地讲解 Gradle Plugin 知识。</p>\n"},{"title":"Hello World","_content":"## 面朝大海，春暖花开\n\n从明天起，做一个幸福的人\n\n喂马、劈柴、周游世界\n\n从明天起，关心粮食和蔬菜\n\n我有一所房子，面朝大海，春暖花开\n\n\n\n从明天起，和每一个亲人通信\n\n告诉他们我的幸福\n\n那幸福的闪电告诉我的\n\n我将告诉每一个人\n\n\n\n给每一条河每一座山取一个温暖的名字\n\n陌生人，我也为你祝福\n\n愿你有一个灿烂的前程\n\n愿你有情人总成眷属\n\n愿你在尘世获得幸福\n\n我只愿面朝大海，春暖花开\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategories: 随笔\n---\n## 面朝大海，春暖花开\n\n从明天起，做一个幸福的人\n\n喂马、劈柴、周游世界\n\n从明天起，关心粮食和蔬菜\n\n我有一所房子，面朝大海，春暖花开\n\n\n\n从明天起，和每一个亲人通信\n\n告诉他们我的幸福\n\n那幸福的闪电告诉我的\n\n我将告诉每一个人\n\n\n\n给每一条河每一座山取一个温暖的名字\n\n陌生人，我也为你祝福\n\n愿你有一个灿烂的前程\n\n愿你有情人总成眷属\n\n愿你在尘世获得幸福\n\n我只愿面朝大海，春暖花开\n","slug":"hello-world","published":1,"date":"2018-04-11T14:05:30.096Z","updated":"2018-04-11T14:05:30.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjs0hta1000bero6n48k01ax","content":"<h2 id=\"面朝大海，春暖花开\"><a href=\"#面朝大海，春暖花开\" class=\"headerlink\" title=\"面朝大海，春暖花开\"></a>面朝大海，春暖花开</h2><p>从明天起，做一个幸福的人</p>\n<p>喂马、劈柴、周游世界</p>\n<p>从明天起，关心粮食和蔬菜</p>\n<p>我有一所房子，面朝大海，春暖花开</p>\n<p>从明天起，和每一个亲人通信</p>\n<p>告诉他们我的幸福</p>\n<p>那幸福的闪电告诉我的</p>\n<p>我将告诉每一个人</p>\n<p>给每一条河每一座山取一个温暖的名字</p>\n<p>陌生人，我也为你祝福</p>\n<p>愿你有一个灿烂的前程</p>\n<p>愿你有情人总成眷属</p>\n<p>愿你在尘世获得幸福</p>\n<p>我只愿面朝大海，春暖花开</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"面朝大海，春暖花开\"><a href=\"#面朝大海，春暖花开\" class=\"headerlink\" title=\"面朝大海，春暖花开\"></a>面朝大海，春暖花开</h2><p>从明天起，做一个幸福的人</p>\n<p>喂马、劈柴、周游世界</p>\n<p>从明天起，关心粮食和蔬菜</p>\n<p>我有一所房子，面朝大海，春暖花开</p>\n<p>从明天起，和每一个亲人通信</p>\n<p>告诉他们我的幸福</p>\n<p>那幸福的闪电告诉我的</p>\n<p>我将告诉每一个人</p>\n<p>给每一条河每一座山取一个温暖的名字</p>\n<p>陌生人，我也为你祝福</p>\n<p>愿你有一个灿烂的前程</p>\n<p>愿你有情人总成眷属</p>\n<p>愿你在尘世获得幸福</p>\n<p>我只愿面朝大海，春暖花开</p>\n"},{"title":"熟悉又陌生的Context","date":"2018-04-12T02:45:36.000Z","_content":"\n## 感谢\n\n[android-context](http://gityuan.com/2017/04/09/android_context/)\n\n## 概述\n\n> 本文中涉及的源码分析都是基于 Android 27\n\nContext 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 `getResources()` 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：\n\n![Context](http://oy017242u.bkt.clouddn.com/Context.png)\n\n其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：\n\n``` java\npublic ContextWrapper(Context base) {\n\tmBase = base;\n}\n\n@Override\npublic void startActivity(Intent intent) {\n    mBase.startActivity(intent);\n}\n```\n\n通过在构造函数中将 ContextImpl 实例赋值给 `mBase`，然后在比如 `startActivity` 等方法实现中，将调用转发给 `mBase`，至于 `mBase` 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。\n\n通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。\n\n## Context初始化\n\n### Activity\n\n在前面的 [Activity 启动分析](https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/)中，我们知道 Activity 启动方法是 `ActivityThread.performLaunchActivity()`\n\n``` java\nprivate void performLaunchActivity() {\n    // 初始化 LoadedApk\n    if (r.packageInfo == null) {\n    \tr.packageInfo = getPackageInfo();\n    }\n    \n    // 创建 ContextImpl 实例\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n    } catch (Exception e) {\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        appContext.setOuterContext(activity);\n        activity.attach();\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n首先获取 LoadedApk 实例，接着调用 `createBaseContextForActivity()` 创建 ContextImpl 实例，之前我们提到 ContextWrapper 是将 Context 核心功能转发给 ContextImpl 实现的，而 `ContextWrapper.mBase` 的赋值，在 Activity 启动流程中，是通过调用 `Activity.attach()` 实现，这个我们在后面的分析中可以知道。\n\n#### create \n\n``` java\nprivate ComtextImpl createBaseContextForActivity() {\n    final int displayId;\n    try {\n        displayId = ActivityManager.getService().getActivityDisplayId(r.token);\n    } catch (RemoteException e) {\n        \n    }\n    \n    ContextImpl appContext = ContextImpl.createActivityContext();\n}\n```\n\n``` java\nstatic ContextImpl createActivityContext() {\n    ContextImpl context = new ContextImpl();\n    \n    // Activity Resource\n    final ResourcesManager resourcesManager = ResourcesManager.getInstance();\n    context.setResources(resourcesManager.createBaseActivityResources(activityToken,\n                packageInfo.getResDir(),\n                splitDirs,\n                packageInfo.getOverlayDirs(),\n                packageInfo.getApplicationInfo().sharedLibraryFiles,\n                displayId,\n                overrideConfiguration,\n                compatInfo,\n                classLoader));\n    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,\n                context.getResources());\n}\n```\n\n#### attach\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n}\n```\n\n``` java\nprotected void attachBaseContext() {\n    super.attachBaseContext(newBase);\n}\n```\n\n这个步骤比较简单，最终也是调用 `ContextWrapper.attachBaseContext()`\n\n### Service\n\nService 的创建是在 `ActivityThread.handleCreateService()`\n\n``` java\n// 初始化 LoadedApk\nLoadedApk packageInfo = getPackageInfoNoCheck();\n\nService service = null;\ntry {\n    java.lang.ClassLoader cl = packageInfo.getClassLoader();\n    // 通过反射实例化 Service\n    service = (Service) cl.loadClass(data.info.name).newInstance();\n} catch (Exception e) {\n    \n}\n\ntry {\n    ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n    context.setOuterContext(service);\n    \n    Application app = packageInfo.makeApplication(false, mInstrumentation);\n    service.attach();\n} catch (Exception e) {\n    \n}\n```\n\nService 的 Context 初始化流程和 Activity 是差不多，相同的 LoadedApk -> ContextImpl -> attach\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    // Service 的 Resources 相对于 Activity 是比较简单的\n    context.setResources(packageInfo.getResources());\n    return context;\n}\n```\n\n#### attach\n\n``` java\npublic final void attach() {\n    attachBaseContext(context);\n}\n```\n\nService 的 attach 和 Activity 相同，都是调用 `ContextWrapper.attachBaseContext()`\n\n### Application\n\nApplication 的创建是在 `LoadedApk.makeApplication()` \n\n``` java\npublic Application makeApplication() {\n    // 保持单例\n    if (mApplication != null) {\n    \treturn mApplication;\n    }\n    Application app = null;\n    String appClass = mApplicationInfo.className;\n    if (forceDefaultAppClass || (appClass == null)) {\n        // 如果强制使用默认 Application，或者没有实现自定义 Application\n    \tappClass = \"android.app.Application\";\n    }\n    try {\n        java.lang.ClassLoader cl = getClassLoader();\n        if (!mPackageName.equals(\"android\")) {\n            // 包名不是 \"android\"，即非系统进程\n        \tinitializeJavaContextClassLoader();\n        }\n        // 创建 ContextImpl 实例\n        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n        // 创建 Application 实例\n    \tapp = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n    \tappContext.setOuterContext(app);\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n咋一看好像 Application 的流程和其他两个不太相同，其实 Application 的 attach 是在 `Instrumentation.newApplication()`\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    context.setResources(packageInfo.getResources());\n}\n```\n\n#### attach\n\n``` java\npublic static Application newApplication() {\n    // 反射获取实例\n    Application app = (Application)clazz.newInstance();\n    app.attach(context);\n    return app;\n}\n```\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;\n}\n```\n\n### 小结\n\n Activity、Service、Application 的 Context 初始化流程大致是这样，首先创建 ContextImpl 实例，接着调用 `ContextWrapper.attachBaseContext()` 赋值给 `mBase`，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。\n\n## 实践\n\n通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过对实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。\n\n### View Context\n\n#### 问题\n\n我们知道可以通过调用 `View.getContext()` 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。\n\n#### 分析\n\n首先我们对 View 的 `mContext` 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。\n\n如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：\n\n``` java\nLayoutInflater layoutInflater = LayoutInflater.from(context);\nView view = layoutInflater.inflate(R.layout.xxx,null);\n```\n\n首先我们看下 `LayoutInflater.from()`：\n\n``` java\npublic static LayoutInflater from(Context context) {\nLayoutInflater LayoutInflater =\t\t  (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    if (LayoutInflater == null) {\n        throw new AssertionError(\"LayoutInflater not found.\");\n    }\n    return LayoutInflater;\n}\n```\n\n在前面，我们提到 Context 的核心方法都转发给 `mBase` 即 ContextImpl 实例，所以看下 ContextImpl 类的实现：\n\n``` java\npublic Object getSystemService(String name) {\n    return SystemServiceRegistry.getSystemService(this, name);\n}\n\npublic static Object getSystemService(ContextImpl ctx, String name) {\n    ServiceFetcher<?> fetcher = SYSTEM_SERVICE_FETCHERS.get(name);\n    return fetcher != null ? fetcher.getService(ctx) : null;\n}\n```\n\n可以看到最终的调用都转发给了 ServiceFetcher，而 `SYSTEM_SERVICE_FETCHERS` 则是存储着各个类型的 Fetcher 的实例\n\n``` java\n// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name->Fetcher\nprivate static final HashMap<String, ServiceFetcher<?>> SYSTEM_SERVICE_FETCHERS =\n            new HashMap<String, ServiceFetcher<?>>();\n// 存储 Class->Name\nprivate static final HashMap<Class<?>, String> SYSTEM_SERVICE_NAMES =\n            new HashMap<Class<?>, String>();\n\nprivate static <T> void registerService(String serviceName, Class<T> serviceClass,\n            ServiceFetcher<T> serviceFetcher) {\n    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);\n    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);\n}\n```\n\n`SYSTEM_SERVICE_FETCHERS` 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 `registerService()`，这里我们只关心 LayoutInflater 的注册：\n\n``` java\nregisterService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,\n        new CachedServiceFetcher<LayoutInflater>() {                  \n    @Override                                                         \n    public LayoutInflater createService(ContextImpl ctx) {            \n        return new PhoneLayoutInflater(ctx.getOuterContext());        \n    }});                                                              \n```\n\nLayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 只是简单的继承 LayoutInflater，核心代码都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 `CachedServiceFetcher.getService()`\n\n``` java\npublic final T getService(ContextImpl ctx) {\n    final Object[] cache = ctx.mServiceCache;\n    synchronized (cache) {\n        Object service = cache[mCacheIndex];\n        if (service == null) {\n            try {\n                service = createService(ctx);\n                cache[mCacheIndex] = service;\n            } catch (ServiceNotFoundException e) {\n                \n            }\n        }\n        return (T)service;\n    }\n}\n```\n\n注意到，Service 的缓存是存储在 `ContextImpl.mServiceCache` 并且该字段不是静态的，即**Service 的缓存是针对于相同的 Context 实例的**，如果不存在缓存，那么调用 `createService()`，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：\n\n```java\n// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application\nreturn new PhoneLayoutInflater(ctx.getOuterContext()); \n```\n\n而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：\n\n``` java\nprotected LayoutInflater(Context context) {\n    // 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到\n    mContext = context;\n}\n```\n\n接下来我们看下 `inflate()` 源码：\n\n``` java\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n```\n\n``` java\npublic View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n    synchronized (mConstructorArgs) {\n        // mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了\n        final Context inflaterContext = mContext;\n        final AttributeSet attrs = Xml.asAttributeSet(parser);\n    \tContext lastContext = (Context) mConstructorArgs[0];\n        mConstructorArgs[0] = inflaterContext;\n        View result = root;\n        \n        try {\n            // 解析 xml 中的节点\n            \n            final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n        } catch () {\n            \n        } finally {\n            mConstructorArgs[0] = lastContext;\n            mConstructorArgs[1] = null;\n        }\n        \n        return result;\n    }\n}\n    \n```\n\n`inflater()` 就是对 xml 布局进行解析，接着实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 `createViewFromTag()` 它是根据标签名称去实例化具体的 View 实例\n\n``` java\nView createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n            boolean ignoreThemeAttr) {\n    if (name.equals(\"view\")) {\n        // 如果我们使用 view 标签则从 class 属性中获取具体类名称\n        name = attrs.getAttributeValue(null, \"class\");\n    }\n    \n    if (!ignoreThemeAttr) {\n        // 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性\n        // 获取设置的 theme 属性值\n        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);\n    \tfinal int themeResId = ta.getResourceId(0, 0);\n        if (themeResId != 0) {\n            // 如果设置了，则将 context 包装成 ContextThemeWrapper\n            // 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性\n            context = new ContextThemeWrapper(context, themeResId);\n        }\n        ta.recycle();\n    }\n    \n    try {\n        View view;\n        \n        // Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView\n        if (mFactory2 != null) {\n        \tview = mFactory2.onCreateView(parent, name, context, attrs);\n        } else if (mFactory != null) {\n            view = mFactory.onCreateView(name, context, attrs);\n        } else {\n            view = null;\n        }\n        \n        if (view == null && mPrivateFactory != null) {\n        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);\n        }\n        \n        if (view == null) {\n            final Object lastContext = mConstructorArgs[0];\n            mConstructorArgs[0] = context;\n            try {\n                if (-1 == name.indexOf('.')) {\n                    // 系统控件\n                    view = onCreateView(parent, name, attrs);\n                } else {\n                    // 自定义控件\n                    view = createView(name, null, attrs);\n                }\n            } finally {\n                mConstructorArgs[0] = lastContext;\n            }\n        }\n        \n        return view;\n    } catch () {\n        \n    }\n}\n```\n\n不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 `createView()`\n\n``` java\npublic final View createView(String name, String prefix, AttributeSet attrs){\n\t// 缓存构造函数\n    Constructor<? extends View> constructor = sConstructorMap.get(name);\n    // 检查构造函数类加载器\n    if (constructor != null && !verifyClassLoader(constructor)){\n        constructor = null;\n        sConstructorMap.remove(name);\n    }\n    Class<? extends View> clazz = null;\n    try {\n        \n        // 获取 View 构造函数实例，并处理过滤情况\n        if (constructor == null) {\n        \tclazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n        \n            if (mFilter != null && clazz != null) {\n            // 检查是否过滤\n        \tboolean allowed = mFilter.onLoadClass(clazz);\n            if (!allowed) {\n                failNotAllowed(name, prefix, attrs);\n            }\n            }\n            constructor = clazz.getConstructor(mConstructorSignature);\n            constructor.setAccessible(true);\n            sConstructorMap.put(name, constructor);\n        } else {\n            if (mFilter != null) {\n                // 存在过滤器\n                Boolean allowedState = mFilterMap.get(name);\n                if (allowedState == null) {\n                    // 没有缓存过滤结果，新的类\n                    clazz = mContext.getClassLoader().loadClass(                            \n                    prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \tboolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                \tmFilterMap.put(name, allowed);\n                    if (!allowed) {\n                    \tfailNotAllowed(name, prefix, attrs);\n                    }\n                } else if (allowedState.equals(Boolean.FALSE)) {\n                    failNotAllowed(name, prefix, attrs);\n                } \n            }\n        }\n        \n        Object lastContext = mConstructorArgs[0];\n        if (mConstructorArgs[0] == null) {\n            // 如果还没设置 context 参数\n            mConstructorArgs[0] = mContext;\n        }\n        Object[] args = mConstructorArgs;\n        args[1] = attrs;\n        // 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知\n        final View view = constructor.newInstance(args); \n        if (view instanceof ViewStub) {\n            // 使用相同的 Context 处理 ViewStub\n            final ViewStub viewStub = (ViewStub) view;\n            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n        }\n        mConstructorArgs[0] = lastContext;\n        return view;\n    } catech () {\n        \n    }\n}\n```\n\n最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同的地方，我们先通过一个例子来看下效果：\n\n``` java\nprotected void onCreate(Bundle savedInstanceState) {\n    // 使用两种 Context 创建两个 EditText\n    addEditText(this);                   \n\taddEditText(getApplicationContext());\n}\nprivate void addEditText(@Nullable Context context) { \n                                                      \n    if (mRootLayout == null) {                        \n        return;                                       \n    }                                                 \n                                                      \n    if (context == null) {                            \n        return;                                       \n    }                                                 \n                                                                                                       \n    EditText editText = new EditText(context);        \n    mRootLayout.addView(editText);                    \n    editText.setText(context.toString());                                                               \n}                                                     \n```\n\n代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题\n\n``` xml\n<Applicatin \n  android:theme=\"@style/AppTheme\">\n</Applicatin>\n\n<item name=\"colorAccent\">@color/colorAccent</item>\n<color name=\"colorAccent\">#FF4081</color>\n```\n\n![ActivityContextEditText](http://oy017242u.bkt.clouddn.com/ActivityContextEditText.png?time=123)\n\n![ApplicationContextEditText](http://oy017242u.bkt.clouddn.com/ApplicationContextEditText.png)\n\n我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：\n\n``` java\npublic Resources.Theme getTheme() {\n    if (mTheme != null) {\n        return mTheme;\n    }\n    if (mThemeResource == 0) {\n        mThemeResource = R.style.Theme_AppCompat_Light;\n    }\n    initializeTheme();\n    return mTheme;\n}\n\nprivate void initializeTheme() {\n    final boolean first = mTheme == null;\n    if (first) {\n        mTheme = getResources().newTheme();\n        Resources.Theme theme = getBaseContext().getTheme();\n        if (theme != null) {\n            mTheme.setTo(theme);\n        }\n    }\n    onApplyThemeResource(mTheme, mThemeResource, first);\n}\n\nprotected void onApplyThemeResource(Resources.Theme theme, int resid, boolean first) {\n    theme.applyStyle(resid, true);\n}\n```\n\n`mTheme` 和 `mThemeResource` 都可以通过构造方法和 set 方法进行赋值，假设没有给 `mTheme` 赋值，只给 `mThemeResource` 赋值，那么上面的代码将 `mThemeSource` 应用到 `ContextWrapper.getTheme()` 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 `ActivityThread.performLaunchActivity()` 中，其中涉及 Theme 的赋值是：\n\n``` java\nint theme = r.activityInfo.getThemeResource();\nif (theme != 0) {\n    activity.setTheme(theme);\n}\n```\n\n现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。\n\n#### 小结\n\n通过上面的源码分析，我们可以知道：\n\n1. 当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 `View(Context,AttributeSet)` 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。\n2. Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。\n\n### getApplication()和getApplicatinContext()\n\n**接下来的分析参考于 [android-context](http://gityuan.com/2017/04/09/android_context/)**\n\n绝大数情况下，这两个方法的返回值是一样。\n\n`getApplicationContext()` 的存在是 Android 历史原因，`getApplication()` 这个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 `getApplicationContext()`。\n\n两者对比：\n\n1. 对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过\n2. BroadcastReceiver 只能通过 `getApplicationContext()` 获取 Application 实例\n3. ContentProvider 也只能通过 `getApplicationContext()` 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 `getApplicationContext()` 则会返回空。\n\n#### 小结\n\n绝大数情况下，`getApplication()` 和 `getApplicationContext()` 返回是一样的，但如果不是特别熟悉，最好对 `getApplicationContext()` 进行空值判断。\n\n### Dialog Context\n\n我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：\n\n```\nCaused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?\n```\n\n### start Activity\n\n通过调用 `startActivity()` 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 `startActivity()` 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：\n\n在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记的话，则会抛出以下异常：\n\n```\nCaused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?\n```\n\nAndroid 26 上 ContextImpl 的相关代码如下：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n\n    }\n}\n```\n\n只要没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记就会抛异常。\n\n而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0\n        && options != null && ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n    }\n}\n```\n\n只有在指定了 `options` 同时其中没有指定 LaunchTaskId 才会抛异常。\n\n## 总结\n\n上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。\n\n不管如何谨慎小心，怀着诚惶诚恐的心态写作，但是毕竟作者的水平有限，如果有写的不对的地方，敬请指教，先行感谢。","source":"_posts/熟悉又陌生的Context.md","raw":"---\ntitle: 熟悉又陌生的Context\ndate: 2018-04-12 10:45:36\ncategories: Android Framework\n---\n\n## 感谢\n\n[android-context](http://gityuan.com/2017/04/09/android_context/)\n\n## 概述\n\n> 本文中涉及的源码分析都是基于 Android 27\n\nContext 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 `getResources()` 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：\n\n![Context](http://oy017242u.bkt.clouddn.com/Context.png)\n\n其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：\n\n``` java\npublic ContextWrapper(Context base) {\n\tmBase = base;\n}\n\n@Override\npublic void startActivity(Intent intent) {\n    mBase.startActivity(intent);\n}\n```\n\n通过在构造函数中将 ContextImpl 实例赋值给 `mBase`，然后在比如 `startActivity` 等方法实现中，将调用转发给 `mBase`，至于 `mBase` 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。\n\n通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。\n\n## Context初始化\n\n### Activity\n\n在前面的 [Activity 启动分析](https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/)中，我们知道 Activity 启动方法是 `ActivityThread.performLaunchActivity()`\n\n``` java\nprivate void performLaunchActivity() {\n    // 初始化 LoadedApk\n    if (r.packageInfo == null) {\n    \tr.packageInfo = getPackageInfo();\n    }\n    \n    // 创建 ContextImpl 实例\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n    } catch (Exception e) {\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        appContext.setOuterContext(activity);\n        activity.attach();\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n首先获取 LoadedApk 实例，接着调用 `createBaseContextForActivity()` 创建 ContextImpl 实例，之前我们提到 ContextWrapper 是将 Context 核心功能转发给 ContextImpl 实现的，而 `ContextWrapper.mBase` 的赋值，在 Activity 启动流程中，是通过调用 `Activity.attach()` 实现，这个我们在后面的分析中可以知道。\n\n#### create \n\n``` java\nprivate ComtextImpl createBaseContextForActivity() {\n    final int displayId;\n    try {\n        displayId = ActivityManager.getService().getActivityDisplayId(r.token);\n    } catch (RemoteException e) {\n        \n    }\n    \n    ContextImpl appContext = ContextImpl.createActivityContext();\n}\n```\n\n``` java\nstatic ContextImpl createActivityContext() {\n    ContextImpl context = new ContextImpl();\n    \n    // Activity Resource\n    final ResourcesManager resourcesManager = ResourcesManager.getInstance();\n    context.setResources(resourcesManager.createBaseActivityResources(activityToken,\n                packageInfo.getResDir(),\n                splitDirs,\n                packageInfo.getOverlayDirs(),\n                packageInfo.getApplicationInfo().sharedLibraryFiles,\n                displayId,\n                overrideConfiguration,\n                compatInfo,\n                classLoader));\n    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,\n                context.getResources());\n}\n```\n\n#### attach\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n}\n```\n\n``` java\nprotected void attachBaseContext() {\n    super.attachBaseContext(newBase);\n}\n```\n\n这个步骤比较简单，最终也是调用 `ContextWrapper.attachBaseContext()`\n\n### Service\n\nService 的创建是在 `ActivityThread.handleCreateService()`\n\n``` java\n// 初始化 LoadedApk\nLoadedApk packageInfo = getPackageInfoNoCheck();\n\nService service = null;\ntry {\n    java.lang.ClassLoader cl = packageInfo.getClassLoader();\n    // 通过反射实例化 Service\n    service = (Service) cl.loadClass(data.info.name).newInstance();\n} catch (Exception e) {\n    \n}\n\ntry {\n    ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n    context.setOuterContext(service);\n    \n    Application app = packageInfo.makeApplication(false, mInstrumentation);\n    service.attach();\n} catch (Exception e) {\n    \n}\n```\n\nService 的 Context 初始化流程和 Activity 是差不多，相同的 LoadedApk -> ContextImpl -> attach\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    // Service 的 Resources 相对于 Activity 是比较简单的\n    context.setResources(packageInfo.getResources());\n    return context;\n}\n```\n\n#### attach\n\n``` java\npublic final void attach() {\n    attachBaseContext(context);\n}\n```\n\nService 的 attach 和 Activity 相同，都是调用 `ContextWrapper.attachBaseContext()`\n\n### Application\n\nApplication 的创建是在 `LoadedApk.makeApplication()` \n\n``` java\npublic Application makeApplication() {\n    // 保持单例\n    if (mApplication != null) {\n    \treturn mApplication;\n    }\n    Application app = null;\n    String appClass = mApplicationInfo.className;\n    if (forceDefaultAppClass || (appClass == null)) {\n        // 如果强制使用默认 Application，或者没有实现自定义 Application\n    \tappClass = \"android.app.Application\";\n    }\n    try {\n        java.lang.ClassLoader cl = getClassLoader();\n        if (!mPackageName.equals(\"android\")) {\n            // 包名不是 \"android\"，即非系统进程\n        \tinitializeJavaContextClassLoader();\n        }\n        // 创建 ContextImpl 实例\n        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n        // 创建 Application 实例\n    \tapp = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n    \tappContext.setOuterContext(app);\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n咋一看好像 Application 的流程和其他两个不太相同，其实 Application 的 attach 是在 `Instrumentation.newApplication()`\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    context.setResources(packageInfo.getResources());\n}\n```\n\n#### attach\n\n``` java\npublic static Application newApplication() {\n    // 反射获取实例\n    Application app = (Application)clazz.newInstance();\n    app.attach(context);\n    return app;\n}\n```\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;\n}\n```\n\n### 小结\n\n Activity、Service、Application 的 Context 初始化流程大致是这样，首先创建 ContextImpl 实例，接着调用 `ContextWrapper.attachBaseContext()` 赋值给 `mBase`，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。\n\n## 实践\n\n通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过对实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。\n\n### View Context\n\n#### 问题\n\n我们知道可以通过调用 `View.getContext()` 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。\n\n#### 分析\n\n首先我们对 View 的 `mContext` 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。\n\n如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：\n\n``` java\nLayoutInflater layoutInflater = LayoutInflater.from(context);\nView view = layoutInflater.inflate(R.layout.xxx,null);\n```\n\n首先我们看下 `LayoutInflater.from()`：\n\n``` java\npublic static LayoutInflater from(Context context) {\nLayoutInflater LayoutInflater =\t\t  (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    if (LayoutInflater == null) {\n        throw new AssertionError(\"LayoutInflater not found.\");\n    }\n    return LayoutInflater;\n}\n```\n\n在前面，我们提到 Context 的核心方法都转发给 `mBase` 即 ContextImpl 实例，所以看下 ContextImpl 类的实现：\n\n``` java\npublic Object getSystemService(String name) {\n    return SystemServiceRegistry.getSystemService(this, name);\n}\n\npublic static Object getSystemService(ContextImpl ctx, String name) {\n    ServiceFetcher<?> fetcher = SYSTEM_SERVICE_FETCHERS.get(name);\n    return fetcher != null ? fetcher.getService(ctx) : null;\n}\n```\n\n可以看到最终的调用都转发给了 ServiceFetcher，而 `SYSTEM_SERVICE_FETCHERS` 则是存储着各个类型的 Fetcher 的实例\n\n``` java\n// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name->Fetcher\nprivate static final HashMap<String, ServiceFetcher<?>> SYSTEM_SERVICE_FETCHERS =\n            new HashMap<String, ServiceFetcher<?>>();\n// 存储 Class->Name\nprivate static final HashMap<Class<?>, String> SYSTEM_SERVICE_NAMES =\n            new HashMap<Class<?>, String>();\n\nprivate static <T> void registerService(String serviceName, Class<T> serviceClass,\n            ServiceFetcher<T> serviceFetcher) {\n    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);\n    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);\n}\n```\n\n`SYSTEM_SERVICE_FETCHERS` 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 `registerService()`，这里我们只关心 LayoutInflater 的注册：\n\n``` java\nregisterService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,\n        new CachedServiceFetcher<LayoutInflater>() {                  \n    @Override                                                         \n    public LayoutInflater createService(ContextImpl ctx) {            \n        return new PhoneLayoutInflater(ctx.getOuterContext());        \n    }});                                                              \n```\n\nLayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 只是简单的继承 LayoutInflater，核心代码都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 `CachedServiceFetcher.getService()`\n\n``` java\npublic final T getService(ContextImpl ctx) {\n    final Object[] cache = ctx.mServiceCache;\n    synchronized (cache) {\n        Object service = cache[mCacheIndex];\n        if (service == null) {\n            try {\n                service = createService(ctx);\n                cache[mCacheIndex] = service;\n            } catch (ServiceNotFoundException e) {\n                \n            }\n        }\n        return (T)service;\n    }\n}\n```\n\n注意到，Service 的缓存是存储在 `ContextImpl.mServiceCache` 并且该字段不是静态的，即**Service 的缓存是针对于相同的 Context 实例的**，如果不存在缓存，那么调用 `createService()`，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：\n\n```java\n// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application\nreturn new PhoneLayoutInflater(ctx.getOuterContext()); \n```\n\n而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：\n\n``` java\nprotected LayoutInflater(Context context) {\n    // 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到\n    mContext = context;\n}\n```\n\n接下来我们看下 `inflate()` 源码：\n\n``` java\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n```\n\n``` java\npublic View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n    synchronized (mConstructorArgs) {\n        // mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了\n        final Context inflaterContext = mContext;\n        final AttributeSet attrs = Xml.asAttributeSet(parser);\n    \tContext lastContext = (Context) mConstructorArgs[0];\n        mConstructorArgs[0] = inflaterContext;\n        View result = root;\n        \n        try {\n            // 解析 xml 中的节点\n            \n            final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n        } catch () {\n            \n        } finally {\n            mConstructorArgs[0] = lastContext;\n            mConstructorArgs[1] = null;\n        }\n        \n        return result;\n    }\n}\n    \n```\n\n`inflater()` 就是对 xml 布局进行解析，接着实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 `createViewFromTag()` 它是根据标签名称去实例化具体的 View 实例\n\n``` java\nView createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n            boolean ignoreThemeAttr) {\n    if (name.equals(\"view\")) {\n        // 如果我们使用 view 标签则从 class 属性中获取具体类名称\n        name = attrs.getAttributeValue(null, \"class\");\n    }\n    \n    if (!ignoreThemeAttr) {\n        // 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性\n        // 获取设置的 theme 属性值\n        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);\n    \tfinal int themeResId = ta.getResourceId(0, 0);\n        if (themeResId != 0) {\n            // 如果设置了，则将 context 包装成 ContextThemeWrapper\n            // 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性\n            context = new ContextThemeWrapper(context, themeResId);\n        }\n        ta.recycle();\n    }\n    \n    try {\n        View view;\n        \n        // Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView\n        if (mFactory2 != null) {\n        \tview = mFactory2.onCreateView(parent, name, context, attrs);\n        } else if (mFactory != null) {\n            view = mFactory.onCreateView(name, context, attrs);\n        } else {\n            view = null;\n        }\n        \n        if (view == null && mPrivateFactory != null) {\n        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);\n        }\n        \n        if (view == null) {\n            final Object lastContext = mConstructorArgs[0];\n            mConstructorArgs[0] = context;\n            try {\n                if (-1 == name.indexOf('.')) {\n                    // 系统控件\n                    view = onCreateView(parent, name, attrs);\n                } else {\n                    // 自定义控件\n                    view = createView(name, null, attrs);\n                }\n            } finally {\n                mConstructorArgs[0] = lastContext;\n            }\n        }\n        \n        return view;\n    } catch () {\n        \n    }\n}\n```\n\n不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 `createView()`\n\n``` java\npublic final View createView(String name, String prefix, AttributeSet attrs){\n\t// 缓存构造函数\n    Constructor<? extends View> constructor = sConstructorMap.get(name);\n    // 检查构造函数类加载器\n    if (constructor != null && !verifyClassLoader(constructor)){\n        constructor = null;\n        sConstructorMap.remove(name);\n    }\n    Class<? extends View> clazz = null;\n    try {\n        \n        // 获取 View 构造函数实例，并处理过滤情况\n        if (constructor == null) {\n        \tclazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n        \n            if (mFilter != null && clazz != null) {\n            // 检查是否过滤\n        \tboolean allowed = mFilter.onLoadClass(clazz);\n            if (!allowed) {\n                failNotAllowed(name, prefix, attrs);\n            }\n            }\n            constructor = clazz.getConstructor(mConstructorSignature);\n            constructor.setAccessible(true);\n            sConstructorMap.put(name, constructor);\n        } else {\n            if (mFilter != null) {\n                // 存在过滤器\n                Boolean allowedState = mFilterMap.get(name);\n                if (allowedState == null) {\n                    // 没有缓存过滤结果，新的类\n                    clazz = mContext.getClassLoader().loadClass(                            \n                    prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \tboolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                \tmFilterMap.put(name, allowed);\n                    if (!allowed) {\n                    \tfailNotAllowed(name, prefix, attrs);\n                    }\n                } else if (allowedState.equals(Boolean.FALSE)) {\n                    failNotAllowed(name, prefix, attrs);\n                } \n            }\n        }\n        \n        Object lastContext = mConstructorArgs[0];\n        if (mConstructorArgs[0] == null) {\n            // 如果还没设置 context 参数\n            mConstructorArgs[0] = mContext;\n        }\n        Object[] args = mConstructorArgs;\n        args[1] = attrs;\n        // 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知\n        final View view = constructor.newInstance(args); \n        if (view instanceof ViewStub) {\n            // 使用相同的 Context 处理 ViewStub\n            final ViewStub viewStub = (ViewStub) view;\n            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n        }\n        mConstructorArgs[0] = lastContext;\n        return view;\n    } catech () {\n        \n    }\n}\n```\n\n最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同的地方，我们先通过一个例子来看下效果：\n\n``` java\nprotected void onCreate(Bundle savedInstanceState) {\n    // 使用两种 Context 创建两个 EditText\n    addEditText(this);                   \n\taddEditText(getApplicationContext());\n}\nprivate void addEditText(@Nullable Context context) { \n                                                      \n    if (mRootLayout == null) {                        \n        return;                                       \n    }                                                 \n                                                      \n    if (context == null) {                            \n        return;                                       \n    }                                                 \n                                                                                                       \n    EditText editText = new EditText(context);        \n    mRootLayout.addView(editText);                    \n    editText.setText(context.toString());                                                               \n}                                                     \n```\n\n代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题\n\n``` xml\n<Applicatin \n  android:theme=\"@style/AppTheme\">\n</Applicatin>\n\n<item name=\"colorAccent\">@color/colorAccent</item>\n<color name=\"colorAccent\">#FF4081</color>\n```\n\n![ActivityContextEditText](http://oy017242u.bkt.clouddn.com/ActivityContextEditText.png?time=123)\n\n![ApplicationContextEditText](http://oy017242u.bkt.clouddn.com/ApplicationContextEditText.png)\n\n我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：\n\n``` java\npublic Resources.Theme getTheme() {\n    if (mTheme != null) {\n        return mTheme;\n    }\n    if (mThemeResource == 0) {\n        mThemeResource = R.style.Theme_AppCompat_Light;\n    }\n    initializeTheme();\n    return mTheme;\n}\n\nprivate void initializeTheme() {\n    final boolean first = mTheme == null;\n    if (first) {\n        mTheme = getResources().newTheme();\n        Resources.Theme theme = getBaseContext().getTheme();\n        if (theme != null) {\n            mTheme.setTo(theme);\n        }\n    }\n    onApplyThemeResource(mTheme, mThemeResource, first);\n}\n\nprotected void onApplyThemeResource(Resources.Theme theme, int resid, boolean first) {\n    theme.applyStyle(resid, true);\n}\n```\n\n`mTheme` 和 `mThemeResource` 都可以通过构造方法和 set 方法进行赋值，假设没有给 `mTheme` 赋值，只给 `mThemeResource` 赋值，那么上面的代码将 `mThemeSource` 应用到 `ContextWrapper.getTheme()` 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 `ActivityThread.performLaunchActivity()` 中，其中涉及 Theme 的赋值是：\n\n``` java\nint theme = r.activityInfo.getThemeResource();\nif (theme != 0) {\n    activity.setTheme(theme);\n}\n```\n\n现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。\n\n#### 小结\n\n通过上面的源码分析，我们可以知道：\n\n1. 当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 `View(Context,AttributeSet)` 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。\n2. Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。\n\n### getApplication()和getApplicatinContext()\n\n**接下来的分析参考于 [android-context](http://gityuan.com/2017/04/09/android_context/)**\n\n绝大数情况下，这两个方法的返回值是一样。\n\n`getApplicationContext()` 的存在是 Android 历史原因，`getApplication()` 这个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 `getApplicationContext()`。\n\n两者对比：\n\n1. 对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过\n2. BroadcastReceiver 只能通过 `getApplicationContext()` 获取 Application 实例\n3. ContentProvider 也只能通过 `getApplicationContext()` 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 `getApplicationContext()` 则会返回空。\n\n#### 小结\n\n绝大数情况下，`getApplication()` 和 `getApplicationContext()` 返回是一样的，但如果不是特别熟悉，最好对 `getApplicationContext()` 进行空值判断。\n\n### Dialog Context\n\n我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：\n\n```\nCaused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?\n```\n\n### start Activity\n\n通过调用 `startActivity()` 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 `startActivity()` 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：\n\n在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记的话，则会抛出以下异常：\n\n```\nCaused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?\n```\n\nAndroid 26 上 ContextImpl 的相关代码如下：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n\n    }\n}\n```\n\n只要没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记就会抛异常。\n\n而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0\n        && options != null && ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n    }\n}\n```\n\n只有在指定了 `options` 同时其中没有指定 LaunchTaskId 才会抛异常。\n\n## 总结\n\n上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。\n\n不管如何谨慎小心，怀着诚惶诚恐的心态写作，但是毕竟作者的水平有限，如果有写的不对的地方，敬请指教，先行感谢。","slug":"熟悉又陌生的Context","published":1,"updated":"2018-04-15T14:12:11.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjs0hta3000dero6trx8463k","content":"<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><blockquote>\n<p>本文中涉及的源码分析都是基于 Android 27</p>\n</blockquote>\n<p>Context 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 <code>getResources()</code> 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/Context.png\" alt=\"Context\" title=\"\">\n                </div>\n                <div class=\"image-caption\">Context</div>\n            </figure>\n<p>其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ContextWrapper</span><span class=\"params\">(Context base)</span> </span>&#123;</span><br><span class=\"line\">\tmBase = base;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    mBase.startActivity(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过在构造函数中将 ContextImpl 实例赋值给 <code>mBase</code>，然后在比如 <code>startActivity</code> 等方法实现中，将调用转发给 <code>mBase</code>，至于 <code>mBase</code> 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。</p>\n<p>通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。</p>\n<h2 id=\"Context初始化\"><a href=\"#Context初始化\" class=\"headerlink\" title=\"Context初始化\"></a>Context初始化</h2><h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>在前面的 <a href=\"https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/\">Activity 启动分析</a>中，我们知道 Activity 启动方法是 <code>ActivityThread.performLaunchActivity()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.packageInfo == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tr.packageInfo = getPackageInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        appContext.setOuterContext(activity);</span><br><span class=\"line\">        activity.attach();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先获取 LoadedApk 实例，接着调用 <code>createBaseContextForActivity()</code> 创建 ContextImpl 实例，之前我们提到 ContextWrapper 是将 Context 核心功能转发给 ContextImpl 实现的，而 <code>ContextWrapper.mBase</code> 的赋值，在 Activity 启动流程中，是通过调用 <code>Activity.attach()</code> 实现，这个我们在后面的分析中可以知道。</p>\n<h4 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ComtextImpl <span class=\"title\">createBaseContextForActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> displayId;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        displayId = ActivityManager.getService().getActivityDisplayId(r.token);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ContextImpl appContext = ContextImpl.createActivityContext();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createActivityContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ResourcesManager resourcesManager = ResourcesManager.getInstance();</span><br><span class=\"line\">    context.setResources(resourcesManager.createBaseActivityResources(activityToken,</span><br><span class=\"line\">                packageInfo.getResDir(),</span><br><span class=\"line\">                splitDirs,</span><br><span class=\"line\">                packageInfo.getOverlayDirs(),</span><br><span class=\"line\">                packageInfo.getApplicationInfo().sharedLibraryFiles,</span><br><span class=\"line\">                displayId,</span><br><span class=\"line\">                overrideConfiguration,</span><br><span class=\"line\">                compatInfo,</span><br><span class=\"line\">                classLoader));</span><br><span class=\"line\">    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,</span><br><span class=\"line\">                context.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach\"><a href=\"#attach\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">attachBaseContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.attachBaseContext(newBase);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个步骤比较简单，最终也是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h3><p>Service 的创建是在 <code>ActivityThread.handleCreateService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">LoadedApk packageInfo = getPackageInfoNoCheck();</span><br><span class=\"line\"></span><br><span class=\"line\">Service service = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class=\"line\">    <span class=\"comment\">// 通过反射实例化 Service</span></span><br><span class=\"line\">    service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ContextImpl context = ContextImpl.createAppContext(<span class=\"keyword\">this</span>, packageInfo);</span><br><span class=\"line\">    context.setOuterContext(service);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Application app = packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">    service.attach();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 Context 初始化流程和 Activity 是差不多，相同的 LoadedApk -&gt; ContextImpl -&gt; attach</p>\n<h4 id=\"create-1\"><a href=\"#create-1\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    <span class=\"comment\">// Service 的 Resources 相对于 Activity 是比较简单的</span></span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-1\"><a href=\"#attach-1\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 attach 和 Activity 相同，都是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h3><p>Application 的创建是在 <code>LoadedApk.makeApplication()</code> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Application <span class=\"title\">makeApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保持单例</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> mApplication;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Application app = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    String appClass = mApplicationInfo.className;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forceDefaultAppClass || (appClass == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果强制使用默认 Application，或者没有实现自定义 Application</span></span><br><span class=\"line\">    \tappClass = <span class=\"string\">\"android.app.Application\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mPackageName.equals(<span class=\"string\">\"android\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 包名不是 \"android\"，即非系统进程</span></span><br><span class=\"line\">        \tinitializeJavaContextClassLoader();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建 Application 实例</span></span><br><span class=\"line\">    \tapp = mActivityThread.mInstrumentation.newApplication(</span><br><span class=\"line\">                    cl, appClass, appContext);</span><br><span class=\"line\">    \tappContext.setOuterContext(app);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>咋一看好像 Application 的流程和其他两个不太相同，其实 Application 的 attach 是在 <code>Instrumentation.newApplication()</code></p>\n<h4 id=\"create-2\"><a href=\"#create-2\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-2\"><a href=\"#attach-2\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Application <span class=\"title\">newApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 反射获取实例</span></span><br><span class=\"line\">    Application app = (Application)clazz.newInstance();</span><br><span class=\"line\">    app.attach(context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p> Activity、Service、Application 的 Context 初始化流程大致是这样，首先创建 ContextImpl 实例，接着调用 <code>ContextWrapper.attachBaseContext()</code> 赋值给 <code>mBase</code>，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过对实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。</p>\n<h3 id=\"View-Context\"><a href=\"#View-Context\" class=\"headerlink\" title=\"View Context\"></a>View Context</h3><h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>我们知道可以通过调用 <code>View.getContext()</code> 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>首先我们对 View 的 <code>mContext</code> 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。</p>\n<p>如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater layoutInflater = LayoutInflater.from(context);</span><br><span class=\"line\">View view = layoutInflater.inflate(R.layout.xxx,<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>首先我们看下 <code>LayoutInflater.from()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LayoutInflater <span class=\"title\">from</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">LayoutInflater LayoutInflater =\t\t  (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LayoutInflater == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"LayoutInflater not found.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> LayoutInflater;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在前面，我们提到 Context 的核心方法都转发给 <code>mBase</code> 即 ContextImpl 实例，所以看下 ContextImpl 类的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SystemServiceRegistry.getSystemService(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class=\"line\">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetcher != <span class=\"keyword\">null</span> ? fetcher.getService(ctx) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到最终的调用都转发给了 ServiceFetcher，而 <code>SYSTEM_SERVICE_FETCHERS</code> 则是存储着各个类型的 Fetcher 的实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name-&gt;Fetcher</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 存储 Class-&gt;Name</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">registerService</span><span class=\"params\">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class=\"line\">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class=\"line\">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SYSTEM_SERVICE_FETCHERS</code> 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 <code>registerService()</code>，这里我们只关心 LayoutInflater 的注册：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;                  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutInflater <span class=\"title\">createService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());        </span><br><span class=\"line\">    &#125;&#125;);</span><br></pre></td></tr></table></figure>\n<p>LayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 只是简单的继承 LayoutInflater，核心代码都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 <code>CachedServiceFetcher.getService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> T <span class=\"title\">getService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] cache = ctx.mServiceCache;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (cache) &#123;</span><br><span class=\"line\">        Object service = cache[mCacheIndex];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                service = createService(ctx);</span><br><span class=\"line\">                cache[mCacheIndex] = service;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ServiceNotFoundException e) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意到，Service 的缓存是存储在 <code>ContextImpl.mServiceCache</code> 并且该字段不是静态的，即<strong>Service 的缓存是针对于相同的 Context 实例的</strong>，如果不存在缓存，那么调用 <code>createService()</code>，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br></pre></td></tr></table></figure>\n<p>而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">LayoutInflater</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到</span></span><br><span class=\"line\">    mContext = context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们看下 <code>inflate()</code> 源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> resource, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Resources res = getContext().getResources();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inflate(parser, root, attachToRoot);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        parser.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(XmlPullParser parser, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mConstructorArgs) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Context inflaterContext = mContext;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class=\"line\">    \tContext lastContext = (Context) mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = inflaterContext;</span><br><span class=\"line\">        View result = root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 解析 xml 中的节点</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>inflater()</code> 就是对 xml 布局进行解析，接着实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 <code>createViewFromTag()</code> 它是根据标签名称去实例化具体的 View 实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">View <span class=\"title\">createViewFromTag</span><span class=\"params\">(View parent, String name, Context context, AttributeSet attrs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name.equals(<span class=\"string\">\"view\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果我们使用 view 标签则从 class 属性中获取具体类名称</span></span><br><span class=\"line\">        name = attrs.getAttributeValue(<span class=\"keyword\">null</span>, <span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ignoreThemeAttr) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取设置的 theme 属性值</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> themeResId = ta.getResourceId(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (themeResId != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了，则将 context 包装成 ContextThemeWrapper</span></span><br><span class=\"line\">            <span class=\"comment\">// 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性</span></span><br><span class=\"line\">            context = <span class=\"keyword\">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ta.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        View view;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFactory2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            view = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span> &amp;&amp; mPrivateFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = context;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == name.indexOf(<span class=\"string\">'.'</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 系统控件</span></span><br><span class=\"line\">                    view = onCreateView(parent, name, attrs);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 自定义控件</span></span><br><span class=\"line\">                    view = createView(name, <span class=\"keyword\">null</span>, attrs);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 <code>createView()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> View <span class=\"title\">createView</span><span class=\"params\">(String name, String prefix, AttributeSet attrs)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存构造函数</span></span><br><span class=\"line\">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class=\"line\">    <span class=\"comment\">// 检查构造函数类加载器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (constructor != <span class=\"keyword\">null</span> &amp;&amp; !verifyClassLoader(constructor))&#123;</span><br><span class=\"line\">        constructor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        sConstructorMap.remove(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Class&lt;? extends View&gt; clazz = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取 View 构造函数实例，并处理过滤情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (constructor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tclazz = mContext.getClassLoader().loadClass(</span><br><span class=\"line\">                        prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span> &amp;&amp; clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 检查是否过滤</span></span><br><span class=\"line\">        \t<span class=\"keyword\">boolean</span> allowed = mFilter.onLoadClass(clazz);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class=\"line\">            constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            sConstructorMap.put(name, constructor);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 存在过滤器</span></span><br><span class=\"line\">                Boolean allowedState = mFilterMap.get(name);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (allowedState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 没有缓存过滤结果，新的类</span></span><br><span class=\"line\">                    clazz = mContext.getClassLoader().loadClass(                            </span><br><span class=\"line\">                    prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">                \t<span class=\"keyword\">boolean</span> allowed = clazz != <span class=\"keyword\">null</span> &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class=\"line\">                \tmFilterMap.put(name, allowed);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                    \tfailNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (allowedState.equals(Boolean.FALSE)) &#123;</span><br><span class=\"line\">                    failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mConstructorArgs[<span class=\"number\">0</span>] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果还没设置 context 参数</span></span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = mContext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object[] args = mConstructorArgs;</span><br><span class=\"line\">        args[<span class=\"number\">1</span>] = attrs;</span><br><span class=\"line\">        <span class=\"comment\">// 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View view = constructor.newInstance(args); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view <span class=\"keyword\">instanceof</span> ViewStub) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用相同的 Context 处理 ViewStub</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> ViewStub viewStub = (ViewStub) view;</span><br><span class=\"line\">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; catech () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同的地方，我们先通过一个例子来看下效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用两种 Context 创建两个 EditText</span></span><br><span class=\"line\">    addEditText(<span class=\"keyword\">this</span>);                   </span><br><span class=\"line\">\taddEditText(getApplicationContext());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addEditText</span><span class=\"params\">(@Nullable Context context)</span> </span>&#123; </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mRootLayout == <span class=\"keyword\">null</span>) &#123;                        </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;                            </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                                                                       </span><br><span class=\"line\">    EditText editText = <span class=\"keyword\">new</span> EditText(context);        </span><br><span class=\"line\">    mRootLayout.addView(editText);                    </span><br><span class=\"line\">    editText.setText(context.toString());                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Applicatin</span> </span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/AppTheme\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Applicatin</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>@color/colorAccent<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">color</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>#FF4081<span class=\"tag\">&lt;/<span class=\"name\">color</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/ActivityContextEditText.png?time=123\" alt=\"ActivityContextEditText\" title=\"\">\n                </div>\n                <div class=\"image-caption\">ActivityContextEditText</div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/ApplicationContextEditText.png\" alt=\"ApplicationContextEditText\" title=\"\">\n                </div>\n                <div class=\"image-caption\">ApplicationContextEditText</div>\n            </figure>\n<p>我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Resources.<span class=\"function\">Theme <span class=\"title\">getTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTheme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThemeResource == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mThemeResource = R.style.Theme_AppCompat_Light;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    initializeTheme();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initializeTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> first = mTheme == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first) &#123;</span><br><span class=\"line\">        mTheme = getResources().newTheme();</span><br><span class=\"line\">        Resources.Theme theme = getBaseContext().getTheme();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (theme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mTheme.setTo(theme);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    onApplyThemeResource(mTheme, mThemeResource, first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplyThemeResource</span><span class=\"params\">(Resources.Theme theme, <span class=\"keyword\">int</span> resid, <span class=\"keyword\">boolean</span> first)</span> </span>&#123;</span><br><span class=\"line\">    theme.applyStyle(resid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mTheme</code> 和 <code>mThemeResource</code> 都可以通过构造方法和 set 方法进行赋值，假设没有给 <code>mTheme</code> 赋值，只给 <code>mThemeResource</code> 赋值，那么上面的代码将 <code>mThemeSource</code> 应用到 <code>ContextWrapper.getTheme()</code> 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 <code>ActivityThread.performLaunchActivity()</code> 中，其中涉及 Theme 的赋值是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (theme != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    activity.setTheme(theme);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过上面的源码分析，我们可以知道：</p>\n<ol>\n<li>当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 <code>View(Context,AttributeSet)</code> 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。</li>\n<li>Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。</li>\n</ol>\n<h3 id=\"getApplication-和getApplicatinContext\"><a href=\"#getApplication-和getApplicatinContext\" class=\"headerlink\" title=\"getApplication()和getApplicatinContext()\"></a>getApplication()和getApplicatinContext()</h3><p><strong>接下来的分析参考于 <a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></strong></p>\n<p>绝大数情况下，这两个方法的返回值是一样。</p>\n<p><code>getApplicationContext()</code> 的存在是 Android 历史原因，<code>getApplication()</code> 这个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 <code>getApplicationContext()</code>。</p>\n<p>两者对比：</p>\n<ol>\n<li>对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过</li>\n<li>BroadcastReceiver 只能通过 <code>getApplicationContext()</code> 获取 Application 实例</li>\n<li>ContentProvider 也只能通过 <code>getApplicationContext()</code> 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 <code>getApplicationContext()</code> 则会返回空。</li>\n</ol>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>绝大数情况下，<code>getApplication()</code> 和 <code>getApplicationContext()</code> 返回是一样的，但如果不是特别熟悉，最好对 <code>getApplicationContext()</code> 进行空值判断。</p>\n<h3 id=\"Dialog-Context\"><a href=\"#Dialog-Context\" class=\"headerlink\" title=\"Dialog Context\"></a>Dialog Context</h3><p>我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?</span><br></pre></td></tr></table></figure>\n<h3 id=\"start-Activity\"><a href=\"#start-Activity\" class=\"headerlink\" title=\"start Activity\"></a>start Activity</h3><p>通过调用 <code>startActivity()</code> 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 <code>startActivity()</code> 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：</p>\n<p>在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记的话，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br></pre></td></tr></table></figure>\n<p>Android 26 上 ContextImpl 的相关代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记就会抛异常。</p>\n<p>而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span></span><br><span class=\"line\">        &amp;&amp; options != <span class=\"keyword\">null</span> &amp;&amp; ActivityOptions.fromBundle(options).getLaunchTaskId() == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有在指定了 <code>options</code> 同时其中没有指定 LaunchTaskId 才会抛异常。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。</p>\n<p>不管如何谨慎小心，怀着诚惶诚恐的心态写作，但是毕竟作者的水平有限，如果有写的不对的地方，敬请指教，先行感谢。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><blockquote>\n<p>本文中涉及的源码分析都是基于 Android 27</p>\n</blockquote>\n<p>Context 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 <code>getResources()</code> 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/Context.png\" alt=\"Context\" title=\"\">\n                </div>\n                <div class=\"image-caption\">Context</div>\n            </figure>\n<p>其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ContextWrapper</span><span class=\"params\">(Context base)</span> </span>&#123;</span><br><span class=\"line\">\tmBase = base;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    mBase.startActivity(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过在构造函数中将 ContextImpl 实例赋值给 <code>mBase</code>，然后在比如 <code>startActivity</code> 等方法实现中，将调用转发给 <code>mBase</code>，至于 <code>mBase</code> 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。</p>\n<p>通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。</p>\n<h2 id=\"Context初始化\"><a href=\"#Context初始化\" class=\"headerlink\" title=\"Context初始化\"></a>Context初始化</h2><h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>在前面的 <a href=\"https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/\">Activity 启动分析</a>中，我们知道 Activity 启动方法是 <code>ActivityThread.performLaunchActivity()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.packageInfo == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tr.packageInfo = getPackageInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        appContext.setOuterContext(activity);</span><br><span class=\"line\">        activity.attach();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先获取 LoadedApk 实例，接着调用 <code>createBaseContextForActivity()</code> 创建 ContextImpl 实例，之前我们提到 ContextWrapper 是将 Context 核心功能转发给 ContextImpl 实现的，而 <code>ContextWrapper.mBase</code> 的赋值，在 Activity 启动流程中，是通过调用 <code>Activity.attach()</code> 实现，这个我们在后面的分析中可以知道。</p>\n<h4 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ComtextImpl <span class=\"title\">createBaseContextForActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> displayId;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        displayId = ActivityManager.getService().getActivityDisplayId(r.token);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ContextImpl appContext = ContextImpl.createActivityContext();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createActivityContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ResourcesManager resourcesManager = ResourcesManager.getInstance();</span><br><span class=\"line\">    context.setResources(resourcesManager.createBaseActivityResources(activityToken,</span><br><span class=\"line\">                packageInfo.getResDir(),</span><br><span class=\"line\">                splitDirs,</span><br><span class=\"line\">                packageInfo.getOverlayDirs(),</span><br><span class=\"line\">                packageInfo.getApplicationInfo().sharedLibraryFiles,</span><br><span class=\"line\">                displayId,</span><br><span class=\"line\">                overrideConfiguration,</span><br><span class=\"line\">                compatInfo,</span><br><span class=\"line\">                classLoader));</span><br><span class=\"line\">    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,</span><br><span class=\"line\">                context.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach\"><a href=\"#attach\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">attachBaseContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.attachBaseContext(newBase);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个步骤比较简单，最终也是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h3><p>Service 的创建是在 <code>ActivityThread.handleCreateService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">LoadedApk packageInfo = getPackageInfoNoCheck();</span><br><span class=\"line\"></span><br><span class=\"line\">Service service = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class=\"line\">    <span class=\"comment\">// 通过反射实例化 Service</span></span><br><span class=\"line\">    service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ContextImpl context = ContextImpl.createAppContext(<span class=\"keyword\">this</span>, packageInfo);</span><br><span class=\"line\">    context.setOuterContext(service);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Application app = packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">    service.attach();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 Context 初始化流程和 Activity 是差不多，相同的 LoadedApk -&gt; ContextImpl -&gt; attach</p>\n<h4 id=\"create-1\"><a href=\"#create-1\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    <span class=\"comment\">// Service 的 Resources 相对于 Activity 是比较简单的</span></span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-1\"><a href=\"#attach-1\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 attach 和 Activity 相同，都是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h3><p>Application 的创建是在 <code>LoadedApk.makeApplication()</code> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Application <span class=\"title\">makeApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保持单例</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> mApplication;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Application app = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    String appClass = mApplicationInfo.className;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forceDefaultAppClass || (appClass == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果强制使用默认 Application，或者没有实现自定义 Application</span></span><br><span class=\"line\">    \tappClass = <span class=\"string\">\"android.app.Application\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mPackageName.equals(<span class=\"string\">\"android\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 包名不是 \"android\"，即非系统进程</span></span><br><span class=\"line\">        \tinitializeJavaContextClassLoader();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建 Application 实例</span></span><br><span class=\"line\">    \tapp = mActivityThread.mInstrumentation.newApplication(</span><br><span class=\"line\">                    cl, appClass, appContext);</span><br><span class=\"line\">    \tappContext.setOuterContext(app);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>咋一看好像 Application 的流程和其他两个不太相同，其实 Application 的 attach 是在 <code>Instrumentation.newApplication()</code></p>\n<h4 id=\"create-2\"><a href=\"#create-2\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-2\"><a href=\"#attach-2\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Application <span class=\"title\">newApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 反射获取实例</span></span><br><span class=\"line\">    Application app = (Application)clazz.newInstance();</span><br><span class=\"line\">    app.attach(context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p> Activity、Service、Application 的 Context 初始化流程大致是这样，首先创建 ContextImpl 实例，接着调用 <code>ContextWrapper.attachBaseContext()</code> 赋值给 <code>mBase</code>，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过对实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。</p>\n<h3 id=\"View-Context\"><a href=\"#View-Context\" class=\"headerlink\" title=\"View Context\"></a>View Context</h3><h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>我们知道可以通过调用 <code>View.getContext()</code> 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>首先我们对 View 的 <code>mContext</code> 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。</p>\n<p>如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater layoutInflater = LayoutInflater.from(context);</span><br><span class=\"line\">View view = layoutInflater.inflate(R.layout.xxx,<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>首先我们看下 <code>LayoutInflater.from()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LayoutInflater <span class=\"title\">from</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">LayoutInflater LayoutInflater =\t\t  (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LayoutInflater == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"LayoutInflater not found.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> LayoutInflater;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在前面，我们提到 Context 的核心方法都转发给 <code>mBase</code> 即 ContextImpl 实例，所以看下 ContextImpl 类的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SystemServiceRegistry.getSystemService(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class=\"line\">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetcher != <span class=\"keyword\">null</span> ? fetcher.getService(ctx) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到最终的调用都转发给了 ServiceFetcher，而 <code>SYSTEM_SERVICE_FETCHERS</code> 则是存储着各个类型的 Fetcher 的实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name-&gt;Fetcher</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 存储 Class-&gt;Name</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">registerService</span><span class=\"params\">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class=\"line\">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class=\"line\">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SYSTEM_SERVICE_FETCHERS</code> 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 <code>registerService()</code>，这里我们只关心 LayoutInflater 的注册：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;                  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutInflater <span class=\"title\">createService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());        </span><br><span class=\"line\">    &#125;&#125;);</span><br></pre></td></tr></table></figure>\n<p>LayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 只是简单的继承 LayoutInflater，核心代码都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 <code>CachedServiceFetcher.getService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> T <span class=\"title\">getService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] cache = ctx.mServiceCache;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (cache) &#123;</span><br><span class=\"line\">        Object service = cache[mCacheIndex];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                service = createService(ctx);</span><br><span class=\"line\">                cache[mCacheIndex] = service;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ServiceNotFoundException e) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意到，Service 的缓存是存储在 <code>ContextImpl.mServiceCache</code> 并且该字段不是静态的，即<strong>Service 的缓存是针对于相同的 Context 实例的</strong>，如果不存在缓存，那么调用 <code>createService()</code>，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br></pre></td></tr></table></figure>\n<p>而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">LayoutInflater</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到</span></span><br><span class=\"line\">    mContext = context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们看下 <code>inflate()</code> 源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> resource, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Resources res = getContext().getResources();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inflate(parser, root, attachToRoot);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        parser.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(XmlPullParser parser, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mConstructorArgs) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Context inflaterContext = mContext;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class=\"line\">    \tContext lastContext = (Context) mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = inflaterContext;</span><br><span class=\"line\">        View result = root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 解析 xml 中的节点</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>inflater()</code> 就是对 xml 布局进行解析，接着实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 <code>createViewFromTag()</code> 它是根据标签名称去实例化具体的 View 实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">View <span class=\"title\">createViewFromTag</span><span class=\"params\">(View parent, String name, Context context, AttributeSet attrs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name.equals(<span class=\"string\">\"view\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果我们使用 view 标签则从 class 属性中获取具体类名称</span></span><br><span class=\"line\">        name = attrs.getAttributeValue(<span class=\"keyword\">null</span>, <span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ignoreThemeAttr) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取设置的 theme 属性值</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> themeResId = ta.getResourceId(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (themeResId != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了，则将 context 包装成 ContextThemeWrapper</span></span><br><span class=\"line\">            <span class=\"comment\">// 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性</span></span><br><span class=\"line\">            context = <span class=\"keyword\">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ta.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        View view;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFactory2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            view = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span> &amp;&amp; mPrivateFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = context;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == name.indexOf(<span class=\"string\">'.'</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 系统控件</span></span><br><span class=\"line\">                    view = onCreateView(parent, name, attrs);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 自定义控件</span></span><br><span class=\"line\">                    view = createView(name, <span class=\"keyword\">null</span>, attrs);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 <code>createView()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> View <span class=\"title\">createView</span><span class=\"params\">(String name, String prefix, AttributeSet attrs)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存构造函数</span></span><br><span class=\"line\">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class=\"line\">    <span class=\"comment\">// 检查构造函数类加载器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (constructor != <span class=\"keyword\">null</span> &amp;&amp; !verifyClassLoader(constructor))&#123;</span><br><span class=\"line\">        constructor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        sConstructorMap.remove(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Class&lt;? extends View&gt; clazz = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取 View 构造函数实例，并处理过滤情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (constructor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tclazz = mContext.getClassLoader().loadClass(</span><br><span class=\"line\">                        prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span> &amp;&amp; clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 检查是否过滤</span></span><br><span class=\"line\">        \t<span class=\"keyword\">boolean</span> allowed = mFilter.onLoadClass(clazz);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class=\"line\">            constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            sConstructorMap.put(name, constructor);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 存在过滤器</span></span><br><span class=\"line\">                Boolean allowedState = mFilterMap.get(name);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (allowedState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 没有缓存过滤结果，新的类</span></span><br><span class=\"line\">                    clazz = mContext.getClassLoader().loadClass(                            </span><br><span class=\"line\">                    prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">                \t<span class=\"keyword\">boolean</span> allowed = clazz != <span class=\"keyword\">null</span> &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class=\"line\">                \tmFilterMap.put(name, allowed);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                    \tfailNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (allowedState.equals(Boolean.FALSE)) &#123;</span><br><span class=\"line\">                    failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mConstructorArgs[<span class=\"number\">0</span>] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果还没设置 context 参数</span></span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = mContext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object[] args = mConstructorArgs;</span><br><span class=\"line\">        args[<span class=\"number\">1</span>] = attrs;</span><br><span class=\"line\">        <span class=\"comment\">// 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View view = constructor.newInstance(args); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view <span class=\"keyword\">instanceof</span> ViewStub) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用相同的 Context 处理 ViewStub</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> ViewStub viewStub = (ViewStub) view;</span><br><span class=\"line\">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; catech () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同的地方，我们先通过一个例子来看下效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用两种 Context 创建两个 EditText</span></span><br><span class=\"line\">    addEditText(<span class=\"keyword\">this</span>);                   </span><br><span class=\"line\">\taddEditText(getApplicationContext());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addEditText</span><span class=\"params\">(@Nullable Context context)</span> </span>&#123; </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mRootLayout == <span class=\"keyword\">null</span>) &#123;                        </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;                            </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                                                                       </span><br><span class=\"line\">    EditText editText = <span class=\"keyword\">new</span> EditText(context);        </span><br><span class=\"line\">    mRootLayout.addView(editText);                    </span><br><span class=\"line\">    editText.setText(context.toString());                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Applicatin</span> </span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/AppTheme\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Applicatin</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>@color/colorAccent<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">color</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>#FF4081<span class=\"tag\">&lt;/<span class=\"name\">color</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/ActivityContextEditText.png?time=123\" alt=\"ActivityContextEditText\" title=\"\">\n                </div>\n                <div class=\"image-caption\">ActivityContextEditText</div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/ApplicationContextEditText.png\" alt=\"ApplicationContextEditText\" title=\"\">\n                </div>\n                <div class=\"image-caption\">ApplicationContextEditText</div>\n            </figure>\n<p>我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Resources.<span class=\"function\">Theme <span class=\"title\">getTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTheme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThemeResource == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mThemeResource = R.style.Theme_AppCompat_Light;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    initializeTheme();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initializeTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> first = mTheme == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first) &#123;</span><br><span class=\"line\">        mTheme = getResources().newTheme();</span><br><span class=\"line\">        Resources.Theme theme = getBaseContext().getTheme();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (theme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mTheme.setTo(theme);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    onApplyThemeResource(mTheme, mThemeResource, first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplyThemeResource</span><span class=\"params\">(Resources.Theme theme, <span class=\"keyword\">int</span> resid, <span class=\"keyword\">boolean</span> first)</span> </span>&#123;</span><br><span class=\"line\">    theme.applyStyle(resid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mTheme</code> 和 <code>mThemeResource</code> 都可以通过构造方法和 set 方法进行赋值，假设没有给 <code>mTheme</code> 赋值，只给 <code>mThemeResource</code> 赋值，那么上面的代码将 <code>mThemeSource</code> 应用到 <code>ContextWrapper.getTheme()</code> 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 <code>ActivityThread.performLaunchActivity()</code> 中，其中涉及 Theme 的赋值是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (theme != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    activity.setTheme(theme);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过上面的源码分析，我们可以知道：</p>\n<ol>\n<li>当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 <code>View(Context,AttributeSet)</code> 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。</li>\n<li>Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。</li>\n</ol>\n<h3 id=\"getApplication-和getApplicatinContext\"><a href=\"#getApplication-和getApplicatinContext\" class=\"headerlink\" title=\"getApplication()和getApplicatinContext()\"></a>getApplication()和getApplicatinContext()</h3><p><strong>接下来的分析参考于 <a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></strong></p>\n<p>绝大数情况下，这两个方法的返回值是一样。</p>\n<p><code>getApplicationContext()</code> 的存在是 Android 历史原因，<code>getApplication()</code> 这个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 <code>getApplicationContext()</code>。</p>\n<p>两者对比：</p>\n<ol>\n<li>对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过</li>\n<li>BroadcastReceiver 只能通过 <code>getApplicationContext()</code> 获取 Application 实例</li>\n<li>ContentProvider 也只能通过 <code>getApplicationContext()</code> 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 <code>getApplicationContext()</code> 则会返回空。</li>\n</ol>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>绝大数情况下，<code>getApplication()</code> 和 <code>getApplicationContext()</code> 返回是一样的，但如果不是特别熟悉，最好对 <code>getApplicationContext()</code> 进行空值判断。</p>\n<h3 id=\"Dialog-Context\"><a href=\"#Dialog-Context\" class=\"headerlink\" title=\"Dialog Context\"></a>Dialog Context</h3><p>我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?</span><br></pre></td></tr></table></figure>\n<h3 id=\"start-Activity\"><a href=\"#start-Activity\" class=\"headerlink\" title=\"start Activity\"></a>start Activity</h3><p>通过调用 <code>startActivity()</code> 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 <code>startActivity()</code> 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：</p>\n<p>在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记的话，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br></pre></td></tr></table></figure>\n<p>Android 26 上 ContextImpl 的相关代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记就会抛异常。</p>\n<p>而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span></span><br><span class=\"line\">        &amp;&amp; options != <span class=\"keyword\">null</span> &amp;&amp; ActivityOptions.fromBundle(options).getLaunchTaskId() == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有在指定了 <code>options</code> 同时其中没有指定 LaunchTaskId 才会抛异常。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。</p>\n<p>不管如何谨慎小心，怀着诚惶诚恐的心态写作，但是毕竟作者的水平有限，如果有写的不对的地方，敬请指教，先行感谢。</p>\n"},{"title":"Android消息机制-Handler","date":"2018-03-23T12:29:21.000Z","_content":"\n### 参考\n\n[Android消息机制1-Handler(Java层)](http://gityuan.com/2015/12/26/handler-message-framework/)\n\n[Android消息机制2-Handler(Native层)](http://gityuan.com/2015/12/27/handler-message-native/)\n\n[Android应用程序消息处理机制（Looper、Handler）分析](http://blog.csdn.net/luoshengyang/article/details/6817933)\n\n[管道(Unix)](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix))\n\n[Epoll](https://zh.wikipedia.org/zh-hans/Epoll)\n\n[文件描述符](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)\n\nHandler 机制主要由四个部分组成：\n\n* Looper\n* MessageQueue\n* Message\n* Handler\n\n### 典型用法\n\n``` java\nclass LooperThread extends Thread {\n    public Handler mHandler;\n    \n    public void run() {\n        Looper.prepare();\n        \n        mHandler = new Handler() {\n            public void handleMessage(Message msg) {\n                // process incoming messages here\n            }\n        };\n        \n        Looper.loop();\n    }\n}\n```\n\n### Looper\n\n不断循环执行 `Looper.loop`，按分发机制将消息分发给目标处理者\n\n``` java\nprivate static void prepare(boolean quitAllowed) {\n    if(sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    // 构建 Looper 存储到 ThreadLocal\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n`sThreadLocal` 是一个 ThreadLocal 类型的静态变量\n\n> ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域\n\n``` java\nprivate Looper(boolean quitAllowed) {\n    // Looper 中创建 MessageQueue\n    mQueue = new MessageQueue(quitAllowed);\n    mThread = Thread.currentThread();\n}\n```\n\n``` java\npublic static void loop() {                                                                     \n    final Looper me = myLooper();                                                               \n    if (me == null) {                                                                           \n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }                                                                                           \n    final MessageQueue queue = me.mQueue;                                                       \n                                                                                                \n    // Make sure the identity of this thread is that of the local process,                      \n    // and keep track of what that identity token actually is.                                  \n    Binder.clearCallingIdentity();                                                              \n    final long ident = Binder.clearCallingIdentity();                                           \n                                                                                                \n    for (;;) {                                                                                  \n        Message msg = queue.next(); // 获取下一条 Message，可能会阻塞                                              \n        if (msg == null) {                                                                      \n            // No message indicates that the message queue is quitting.                         \n            return;                                                                             \n        }                                                                                       \n                                                                                                \n        // This must be in a local variable, in case a UI event sets the logger                 \n        final Printer logging = me.mLogging;                                                    \n        if (logging != null) {                                                                  \n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +                        \n                    msg.callback + \": \" + msg.what);                                            \n        }                                                                                       \n                                                                                                \n        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       \n                                                                                                \n        //省略\n        \n        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();     \n        final long end;                                                                         \n        try {\n            // 分发 Message\n            msg.target.dispatchMessage(msg);                                                    \n            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();              \n        } finally {                                                                             \n            if (traceTag != 0) {                                                                \n                Trace.traceEnd(traceTag);                                                       \n            }                                                                                   \n        }                                                                                       \n        if (slowDispatchThresholdMs > 0) {                                                      \n            final long time = end - start;                                                      \n            if (time > slowDispatchThresholdMs) {                                               \n                Slog.w(TAG, \"Dispatch took \" + time + \"ms on \"                                  \n                        + Thread.currentThread().getName() + \", h=\" +                           \n                        msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what);               \n            }                                                                                   \n        }                                                                                       \n                                                                                                \n        if (logging != null) {                                                                  \n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);            \n        }                                                                                       \n                                                                                                \n        // Make sure that during the course of dispatching the                                  \n        // identity of the thread wasn't corrupted.                                             \n        final long newIdent = Binder.clearCallingIdentity();                                    \n        if (ident != newIdent) {                                                                \n            Log.wtf(TAG, \"Thread identity changed from 0x\"                                      \n                    + Long.toHexString(ident) + \" to 0x\"                                        \n                    + Long.toHexString(newIdent) + \" while dispatching to \"                     \n                    + msg.target.getClass().getName() + \" \"                                     \n                    + msg.callback + \" what=\" + msg.what);                                      \n        }                                                                                       \n         \n        // 释放 Message\n        msg.recycleUnchecked();                                                                 \n    }                                                                                           \n}                                                                                               \n```\n\n``` java\n// Looper.quit 最终调用的都是 MessageQueue.quit\npublic void quit() {\n    mQueue.quit(false); // 移除消息\n}\n\npublic void quitSafely() {\n    mQueue.quit(true); // 安全移除消息\n}\n```\n\nMessageQueue 在构造方法中，会调用 native 方法 `nativeInit` 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper\n\n``` cpp\n// frameworks/base/libs\nLooper::Looper(bool allowNonCallbacks) :  \n    mAllowNonCallbacks(allowNonCallbacks),  \n    mResponseIndex(0) {\n    // 管道机制\n    int wakeFds[2];  \n    int result = pipe(wakeFds);  \n    ......  \n  \n    mWakeReadPipeFd = wakeFds[0];  \n    mWakeWritePipeFd = wakeFds[1];  \n  \t\n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    // 分配新的 epoll 实例同时注册唤醒管道\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  \n    ......  \n  \n    struct epoll_event eventItem;  \n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    // 观察 EPOLLIN 事件\n    eventItem.events = EPOLLIN;  \n    eventItem.data.fd = mWakeReadPipeFd;  \n    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem);  \n    ......  \n#else  \n    ......  \n#endif  \n  \n    ......  \n}  \n```\n\n> 管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。\n>\n> epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。\n\npipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。\n\n以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。\n\n### Handler\n\n``` java\npublic Handler(Callback callback, boolean async) {                                                  \n    if (FIND_POTENTIAL_LEAKS) {                                                                     \n        final Class<? extends Handler> klass = getClass();                                          \n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&          \n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            // 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +      \n                klass.getCanonicalName());                                                          \n        }                                                                                           \n    }                                                                                               \n    // 默认使用当前线程的 Looper                                                                                                \n    mLooper = Looper.myLooper();                                                                    \n    if (mLooper == null) {                                                                          \n        throw new RuntimeException(                                                                 \n            \"Can't create handler inside thread that has not called Looper.prepare()\");             \n    }                                                                                               \n    mQueue = mLooper.mQueue;                                                                        \n    mCallback = callback;\n    // 是否为异步处理\n    mAsynchronous = async;                                                                          \n}                                                                                                   \n```\n\n在 `Looper.loop` 中，当存在 Message 需要处理时，会调用 `dispatchMessage` 来进行分发：\n\n``` java\npublic void dispatchMessage(Message msg) {      \n    if (msg.callback != null) {\n        // 先调用 callback\n        handleCallback(msg);                    \n    } else {                                    \n        if (mCallback != null) {\n            // 接着检查通过构造方法传进来的 Callback\n            if (mCallback.handleMessage(msg)) { \n                return;                         \n            }                                   \n        }\n        // 最后调用 handleMessage\n        handleMessage(msg);                     \n    }                                           \n}                                               \n```\n\n通过 Handler 发送消息：\n\n![发送消息调用链](http://gityuan.com/images/handler/java_sendmessage.png)\n\n最终所有的方法都会调用到 `MessageQueue.enqueueMessage`\n\n### MessageQueue\n\n> 消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理\n\n``` java\nMessageQueue(boolean quitAllowed) { \n    mQuitAllowed = quitAllowed;\n    // used by native code\n    mPtr = nativeInit();            \n}                                   \n```\n\nMessageQueue 的初始化工作主要由 native 方法来执行\n\n``` cpp\n//frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {\n    // 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();  \n    if (! nativeMessageQueue) {  \n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");  \n        return;  \n    }  \n  \t\n    // 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量\n    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  \n}  \n```\n\n`nativeInit` 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 `mPtr`，关联了 NativeMessageQueue 和 MessageQueue\n\n``` java\nMessage next() {                                                                              \n    // messsage loop has already quit                                                              \n    final long ptr = mPtr;                                                                    \n    if (ptr == 0) {                                                                           \n        return null;                                                                          \n    }                                                                                         \n                                                                                              \n    int pendingIdleHandlerCount = -1; // -1 only during first iteration                       \n    int nextPollTimeoutMillis = 0;                                                            \n    for (;;) {                                                                                \n        if (nextPollTimeoutMillis != 0) {                                                     \n            Binder.flushPendingCommands();                                                    \n        }                                                                                     \n        // 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回\n        // ptr 是在 JNI 层创建的 NativeMessageQueue\n        nativePollOnce(ptr, nextPollTimeoutMillis);                                           \n        \n        // 当前 nativePollOnce 返回后，查看消息队列中是否存在消息\n        synchronized (this) {                                                                 \n            // 尝试检索下一条消息，如果找到则返回                            \n            final long now = SystemClock.uptimeMillis();                                      \n            Message prevMsg = null;                                                           \n            Message msg = mMessages;                                                          \n            if (msg != null && msg.target == null) {                                          \n                // 找到下一条异步消息或者没有消息了，则退出循环\n                do {                                                                          \n                    prevMsg = msg;                                                            \n                    msg = msg.next;                                                           \n                } while (msg != null && !msg.isAsynchronous());                               \n            }                                                                                 \n            if (msg != null) {                                                                \n                if (now < msg.when) {                                                         \n                    // 下一个消息还没准备好，重新设置唤醒超时时间\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {                                                                      \n                    // 获取一条消息                                                         \n                    mBlocked = false;\n                    if (prevMsg != null) {                                                    \n                        prevMsg.next = msg.next;                                              \n                    } else {                                                                  \n                        mMessages = msg.next;                                                 \n                    }                                                                         \n                    msg.next = null;                                                          \n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    // 标记当前消息已使用\n                    msg.markInUse();                                                          \n                    return msg;                                                               \n                }                                                                             \n            } else {                                                                          \n                // 当前还没有消息，设置为 -1，无限等待中                                                     \n                nextPollTimeoutMillis = -1;                                                   \n            }                                                                                 \n                                                                                              \n            // Process the quit message now that all pending messages have been handled.      \n            if (mQuitting) {                                                                  \n                dispose();                                                                    \n                return null;                                                                  \n            }                                                                                 \n                                                                                              \n            // queue is empty or if the first message\n            // get pending idle handler count\n            if (pendingIdleHandlerCount < 0                                                   \n                    && (mMessages == null || now < mMessages.when)) {                         \n                pendingIdleHandlerCount = mIdleHandlers.size();                               \n            }                                                                                 \n            if (pendingIdleHandlerCount <= 0) {                                               \n                // 没有 idle handlers 需要运行，循环继续等待                        \n                mBlocked = true;                                                              \n                continue;                                                                     \n            }                                                                                 \n                                                                                              \n            if (mPendingIdleHandlers == null) {                                               \n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; \n            }                                                                                 \n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               \n        }                                                                                     \n                                                                                              \n        // Run the idle handlers.                                                        \n        // We only ever reach this code block during the first iteration                    \n        for (int i = 0; i < pendingIdleHandlerCount; i++) {                                   \n            final IdleHandler idler = mPendingIdleHandlers[i];                                \n            mPendingIdleHandlers[i] = null;           \n                                                                                              \n            boolean keep = false;                                                             \n            try {                                                                             \n                keep = idler.queueIdle();                                                     \n            } catch (Throwable t) {                                                           \n                Log.wtf(TAG, \"IdleHandler threw exception\", t);                               \n            }                                                                                 \n                                                                                              \n            if (!keep) {                                                                      \n                synchronized (this) {\n                    mIdleHandlers.remove(idler);                                              \n                }                                                                             \n            }                                                                                 \n        }                                                                                     \n                                                                                              \n        // Reset the idle handler count to 0 so we do not run them again.                     \n        pendingIdleHandlerCount = 0;                                                          \n                                                                                              \n        //不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                \n        nextPollTimeoutMillis = 0;                                                            \n    }                                                                                         \n}                                                                                             \n```\n\n在 `next` 方法中，`nativePollOnce` 是阻塞操作，其中 `nextPollTimeoutMillis` 代表下一个消息到来之前，还需要等待的时长；`nextPollTimeoutMillis == -1` 表示当前没有更多消息。`nativePollOnce` 调用结束后，从 `mMessages` 中提取一个消息\n\n当处于空闲时，执行 `IdleHandler` 中的回调方法。\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,  \n        jint ptr, jint timeoutMillis) {\n    // 通过前面设置的 mPrt 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr); \n    // 调用 NativeMessageQueue.pollOnce 进行轮询\n    nativeMessageQueue->pollOnce(timeoutMillis);  \n}  \n```\n\n``` cpp\nvoid NativeMessageQueue::pollOnce(int timeoutMillis) {\n    // 将调用转发给了 JNI 层的 Looper\n    mLooper->pollOnce(timeoutMillis);  \n} \n```\n\n`pollOnce` 会调用 `pollnner` 来进一步操作，如果 `pollnner` 返回值不等于 0，则返回\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nint Looper::pollInner(int timeoutMillis) {  \n    ......  \n  \n    int result = ALOOPER_POLL_WAKE;  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis\n    // 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件\n    // 如果检查成功或者超时，则结束等待\n    // 处于 Idle 状态\n    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    bool acquiredLock = false;  \n#else  \n    ......  \n#endif  \n    \n    // eventCount < 0 可能出错了\n    if (eventCount < 0) {  \n        if (errno == EINTR) {  \n            goto Done;  \n        }  \n  \n        LOGW(\"Poll failed with an unexpected error, errno=%d\", errno);  \n        result = ALOOPER_POLL_ERROR;  \n        goto Done;  \n    }  \n  \t\n    // eventCount == 0 超时\n    if (eventCount == 0) {  \n        ......  \n        result = ALOOPER_POLL_TIMEOUT;  \n        goto Done;  \n    }  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL\n    // eventCount > 0 存在事件\n    for (int i = 0; i < eventCount; i++) {  \n        int fd = eventItems[i].data.fd;  \n        uint32_t epollEvents = eventItems[i].events;  \n        if (fd == mWakeReadPipeFd) {  \n            if (epollEvents & EPOLLIN) {\n                // Looper 中使用 epoll 监听的 EPOLLIN 事件\n                awoken();  \n            } else {  \n                LOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents);  \n            }  \n        } else {  \n            ......  \n        }  \n    }  \n    if (acquiredLock) {  \n        mLock.unlock();  \n    }  \nDone: ;  \n#else  \n    ......  \n#endif  \n  \n    ......  \n  \n    return result;  \n} \n```\n\n``` cpp\nvoid Looper::awoken() {  \n    ......  \n  \n    char buffer[16];  \n    ssize_t nRead;  \n    do {  \n        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));  \n    } while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));  \n}  \n```\n\n总结上面的代码，Looper 通过 `loop` 调用 MessageQueue 的 `next`，`next` 中又会调用到 native 方法 `nativePollOnce`，在这个方法中，会调用到 NativeMessageQueue 的 `pollInner`，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 `awoken`，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。\n\n``` java\nboolean enqueueMessage(Message msg, long when) {                                         \n    if (msg.target == null) {                                                            \n        throw new IllegalArgumentException(\"Message must have a target.\");               \n    }                                                                                    \n    if (msg.isInUse()) {                                                                 \n        throw new IllegalStateException(msg + \" This message is already in use.\");       \n    }                                                                                    \n                                                                                         \n    synchronized (this) {                                                                \n        if (mQuitting) {                                                                 \n            IllegalStateException e = new IllegalStateException(                         \n                    msg.target + \" sending message to a Handler on a dead thread\");      \n            Log.w(TAG, e.getMessage(), e);                                               \n            msg.recycle();                                                               \n            return false;                                                                \n        }                                                                                \n                                                                                         \n        msg.markInUse();                                                                 \n        msg.when = when;                                                                 \n        Message p = mMessages;                                                           \n        boolean needWake;                                                                \n        if (p == null || when == 0 || when < p.when) {                                   \n            // 不存在头部消息或立即执行或执行时机快于头部消息\n            // 将处理的消息作为新的头部消息\n            msg.next = p;                                                                \n            mMessages = msg;                                                             \n            needWake = mBlocked;                                                         \n        } else {                                                                         \n            // 将处理的消息插入到队列的尾部\n            // 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();             \n            Message prev;                                                                \n            for (;;) {                                                                   \n                prev = p;                                                                \n                p = p.next;                                                              \n                if (p == null || when < p.when) {                                        \n                    break;                                                               \n                }                                                                        \n                if (needWake && p.isAsynchronous()) {                                    \n                    needWake = false;                                                    \n                }                                                                        \n            }                                                                            \n            msg.next = p; // invariant: p == prev.next                                   \n            prev.next = msg;                                                             \n        }                                                                                \n                                                                                         \n        // We can assume mPtr != 0 because mQuitting is false.                           \n        if (needWake) {                                                                  \n            nativeWake(mPtr);                                                            \n        }                                                                                \n    }                                                                                    \n    return true;                                                                         \n}                                                                                        \n```\n\n`MessageQueue` 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。\n\n如果当前线程处于空闲等待状态，那么还需要调用 `nativeWake` 来唤醒：\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj, jint ptr) {\n    // ptr 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);  \n    return nativeMessageQueue->wake();  \n}  \n```\n\n这里将唤醒请求转发到 Looper `wake`：\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nvoid Looper::wake() {  \n    ......  \n  \n    ssize_t nWrite;  \n    do {\n        // 先管道中写入 \"W\n        nWrite = write(mWakeWritePipeFd, \"W\", 1);  \n    } while (nWrite == -1 && errno == EINTR);  \n  \n    .......  \n}  \n```\n\n往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 `polllnner` 中调用 `epoll_wait` 进入\n\n``` java\nvoid removeMessages(Handler h, int what, Object object) {     \n    if (h == null) {                                          \n        return;                                               \n    }                                                         \n                                                              \n    synchronized (this) {                                     \n        Message p = mMessages;                                \n                                                              \n        // 从队列头部开始，移除连续的所有符合条件的消息                     \n        while (p != null && p.target == h && p.what == what   \n               && (object == null || p.obj == object)) {      \n            Message n = p.next;                               \n            mMessages = n;\n            // 找到对应的消息，释放它\n            p.recycleUnchecked();                             \n            p = n;                                            \n        }                                                     \n                                                              \n        //  从新的队列头部开始，移除全部符合条件的消息                  \n        while (p != null) {                                   \n            Message n = p.next;                               \n            if (n != null) {                                  \n                if (n.target == h && n.what == what           \n                    && (object == null || n.obj == object)) { \n                    Message nn = n.next;                      \n                    n.recycleUnchecked();                     \n                    p.next = nn;                              \n                    continue;                                 \n                }                                             \n            }                                                 \n            p = n;                                            \n        }                                                     \n    }                                                         \n}                                                             \n```\n\n`postSyncBarrier` 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 `removeSyncBarrier`\n\n当 MessageQueue 退出时，需要 `dispose`：\n\n``` java\n// Disposes of the underlying message queue.                 \n// Must only be called on the looper thread or the finalizer.\nprivate void dispose() {                                     \n    if (mPtr != 0) {\n        // native 方法\n        nativeDestroy(mPtr);\n        // mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量\n        mPtr = 0;                                            \n    }                                                        \n}                                                            \n```\n\n`nativeDestroy` 最终会调用 RefBase 的 `decStrong`：\n\n``` cpp\nvoid RefBase::decStrong(const void* id) const\n{\n    weakref_impl* const refs = mRefs;\n    refs->removeStrongRef(id); //移除强引用\n    const int32_t c = android_atomic_dec(&refs->mStrong);\n    if (c == 1) {\n        refs->mBase->onLastStrongRef(id);\n        if ((refs->mFlags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {\n            delete this;\n        }\n    }\n    refs->decWeak(id); // 移除弱引用\n}\n```\n\n### Message\n\n``` java\nvoid recycleUnchecked() {                 \n    // 标记为使用状态，清除其他状态     \n    flags = FLAG_IN_USE;                  \n    what = 0;                             \n    arg1 = 0;                             \n    arg2 = 0;                             \n    obj = null;                           \n    replyTo = null;                       \n    sendingUid = -1;                      \n    when = 0;                             \n    target = null;                        \n    callback = null;                      \n    data = null;                          \n                                          \n    synchronized (sPoolSync) {\n        // 消息缓存\n        if (sPoolSize < MAX_POOL_SIZE) {  \n            next = sPool;                 \n            sPool = this;                 \n            sPoolSize++;                  \n        }                                 \n    }                                     \n}                                         \n```\n\n``` java\npublic static Message obtain() {             \n    synchronized (sPoolSync) {               \n        if (sPool != null) {\n            // 从缓存中获取\n            Message m = sPool;               \n            sPool = m.next;                  \n            m.next = null;                   \n            m.flags = 0; // clear in-use flag\n            sPoolSize--;                     \n            return m;                        \n        }                                    \n    }                                        \n    return new Message();                    \n}                                            \n```\n\n### 总结\n\n![消息机制](http://gityuan.com/images/handler/handler_java.jpg)\n\nJava 层：\n\n* Handler 通过 `sendMessage`，将 Message 通过 `MessageQueue.enqueueMessage` 添加到队列中\n* Looper 通过 `loop` 提取需要执行的 Message，并交与 `Message.target` 的 Handler 进行 `dispatchMessage` 分发\n*  将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler \n\nJNI 层：\n\n* 线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态\n* 通过 epoll 机制监听 `EPOLLIN` 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程\n\n消息分发的优先级：\n\n1. `Message.callback.run()`\n2. `Handler.mCallback.handleMessage()`\n3. `Handler.handleMessage()`\n\n> EPOLL：Linux 内核的可扩展 I/O 事件通知机制\n>\n> PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入\n>\n> 文件描述符(File descriptor)：用于表述指向[文件](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6)的引用的抽象化概念","source":"_posts/Android消息机制-Handler.md","raw":"---\ntitle: Android消息机制-Handler\ndate: 2018-03-23 20:29:21\ncategories: Android Framework\n---\n\n### 参考\n\n[Android消息机制1-Handler(Java层)](http://gityuan.com/2015/12/26/handler-message-framework/)\n\n[Android消息机制2-Handler(Native层)](http://gityuan.com/2015/12/27/handler-message-native/)\n\n[Android应用程序消息处理机制（Looper、Handler）分析](http://blog.csdn.net/luoshengyang/article/details/6817933)\n\n[管道(Unix)](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix))\n\n[Epoll](https://zh.wikipedia.org/zh-hans/Epoll)\n\n[文件描述符](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)\n\nHandler 机制主要由四个部分组成：\n\n* Looper\n* MessageQueue\n* Message\n* Handler\n\n### 典型用法\n\n``` java\nclass LooperThread extends Thread {\n    public Handler mHandler;\n    \n    public void run() {\n        Looper.prepare();\n        \n        mHandler = new Handler() {\n            public void handleMessage(Message msg) {\n                // process incoming messages here\n            }\n        };\n        \n        Looper.loop();\n    }\n}\n```\n\n### Looper\n\n不断循环执行 `Looper.loop`，按分发机制将消息分发给目标处理者\n\n``` java\nprivate static void prepare(boolean quitAllowed) {\n    if(sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    // 构建 Looper 存储到 ThreadLocal\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n`sThreadLocal` 是一个 ThreadLocal 类型的静态变量\n\n> ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域\n\n``` java\nprivate Looper(boolean quitAllowed) {\n    // Looper 中创建 MessageQueue\n    mQueue = new MessageQueue(quitAllowed);\n    mThread = Thread.currentThread();\n}\n```\n\n``` java\npublic static void loop() {                                                                     \n    final Looper me = myLooper();                                                               \n    if (me == null) {                                                                           \n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }                                                                                           \n    final MessageQueue queue = me.mQueue;                                                       \n                                                                                                \n    // Make sure the identity of this thread is that of the local process,                      \n    // and keep track of what that identity token actually is.                                  \n    Binder.clearCallingIdentity();                                                              \n    final long ident = Binder.clearCallingIdentity();                                           \n                                                                                                \n    for (;;) {                                                                                  \n        Message msg = queue.next(); // 获取下一条 Message，可能会阻塞                                              \n        if (msg == null) {                                                                      \n            // No message indicates that the message queue is quitting.                         \n            return;                                                                             \n        }                                                                                       \n                                                                                                \n        // This must be in a local variable, in case a UI event sets the logger                 \n        final Printer logging = me.mLogging;                                                    \n        if (logging != null) {                                                                  \n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +                        \n                    msg.callback + \": \" + msg.what);                                            \n        }                                                                                       \n                                                                                                \n        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       \n                                                                                                \n        //省略\n        \n        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();     \n        final long end;                                                                         \n        try {\n            // 分发 Message\n            msg.target.dispatchMessage(msg);                                                    \n            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();              \n        } finally {                                                                             \n            if (traceTag != 0) {                                                                \n                Trace.traceEnd(traceTag);                                                       \n            }                                                                                   \n        }                                                                                       \n        if (slowDispatchThresholdMs > 0) {                                                      \n            final long time = end - start;                                                      \n            if (time > slowDispatchThresholdMs) {                                               \n                Slog.w(TAG, \"Dispatch took \" + time + \"ms on \"                                  \n                        + Thread.currentThread().getName() + \", h=\" +                           \n                        msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what);               \n            }                                                                                   \n        }                                                                                       \n                                                                                                \n        if (logging != null) {                                                                  \n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);            \n        }                                                                                       \n                                                                                                \n        // Make sure that during the course of dispatching the                                  \n        // identity of the thread wasn't corrupted.                                             \n        final long newIdent = Binder.clearCallingIdentity();                                    \n        if (ident != newIdent) {                                                                \n            Log.wtf(TAG, \"Thread identity changed from 0x\"                                      \n                    + Long.toHexString(ident) + \" to 0x\"                                        \n                    + Long.toHexString(newIdent) + \" while dispatching to \"                     \n                    + msg.target.getClass().getName() + \" \"                                     \n                    + msg.callback + \" what=\" + msg.what);                                      \n        }                                                                                       \n         \n        // 释放 Message\n        msg.recycleUnchecked();                                                                 \n    }                                                                                           \n}                                                                                               \n```\n\n``` java\n// Looper.quit 最终调用的都是 MessageQueue.quit\npublic void quit() {\n    mQueue.quit(false); // 移除消息\n}\n\npublic void quitSafely() {\n    mQueue.quit(true); // 安全移除消息\n}\n```\n\nMessageQueue 在构造方法中，会调用 native 方法 `nativeInit` 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper\n\n``` cpp\n// frameworks/base/libs\nLooper::Looper(bool allowNonCallbacks) :  \n    mAllowNonCallbacks(allowNonCallbacks),  \n    mResponseIndex(0) {\n    // 管道机制\n    int wakeFds[2];  \n    int result = pipe(wakeFds);  \n    ......  \n  \n    mWakeReadPipeFd = wakeFds[0];  \n    mWakeWritePipeFd = wakeFds[1];  \n  \t\n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    // 分配新的 epoll 实例同时注册唤醒管道\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  \n    ......  \n  \n    struct epoll_event eventItem;  \n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    // 观察 EPOLLIN 事件\n    eventItem.events = EPOLLIN;  \n    eventItem.data.fd = mWakeReadPipeFd;  \n    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem);  \n    ......  \n#else  \n    ......  \n#endif  \n  \n    ......  \n}  \n```\n\n> 管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。\n>\n> epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。\n\npipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。\n\n以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。\n\n### Handler\n\n``` java\npublic Handler(Callback callback, boolean async) {                                                  \n    if (FIND_POTENTIAL_LEAKS) {                                                                     \n        final Class<? extends Handler> klass = getClass();                                          \n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&          \n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            // 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +      \n                klass.getCanonicalName());                                                          \n        }                                                                                           \n    }                                                                                               \n    // 默认使用当前线程的 Looper                                                                                                \n    mLooper = Looper.myLooper();                                                                    \n    if (mLooper == null) {                                                                          \n        throw new RuntimeException(                                                                 \n            \"Can't create handler inside thread that has not called Looper.prepare()\");             \n    }                                                                                               \n    mQueue = mLooper.mQueue;                                                                        \n    mCallback = callback;\n    // 是否为异步处理\n    mAsynchronous = async;                                                                          \n}                                                                                                   \n```\n\n在 `Looper.loop` 中，当存在 Message 需要处理时，会调用 `dispatchMessage` 来进行分发：\n\n``` java\npublic void dispatchMessage(Message msg) {      \n    if (msg.callback != null) {\n        // 先调用 callback\n        handleCallback(msg);                    \n    } else {                                    \n        if (mCallback != null) {\n            // 接着检查通过构造方法传进来的 Callback\n            if (mCallback.handleMessage(msg)) { \n                return;                         \n            }                                   \n        }\n        // 最后调用 handleMessage\n        handleMessage(msg);                     \n    }                                           \n}                                               \n```\n\n通过 Handler 发送消息：\n\n![发送消息调用链](http://gityuan.com/images/handler/java_sendmessage.png)\n\n最终所有的方法都会调用到 `MessageQueue.enqueueMessage`\n\n### MessageQueue\n\n> 消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理\n\n``` java\nMessageQueue(boolean quitAllowed) { \n    mQuitAllowed = quitAllowed;\n    // used by native code\n    mPtr = nativeInit();            \n}                                   \n```\n\nMessageQueue 的初始化工作主要由 native 方法来执行\n\n``` cpp\n//frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {\n    // 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();  \n    if (! nativeMessageQueue) {  \n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");  \n        return;  \n    }  \n  \t\n    // 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量\n    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  \n}  \n```\n\n`nativeInit` 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 `mPtr`，关联了 NativeMessageQueue 和 MessageQueue\n\n``` java\nMessage next() {                                                                              \n    // messsage loop has already quit                                                              \n    final long ptr = mPtr;                                                                    \n    if (ptr == 0) {                                                                           \n        return null;                                                                          \n    }                                                                                         \n                                                                                              \n    int pendingIdleHandlerCount = -1; // -1 only during first iteration                       \n    int nextPollTimeoutMillis = 0;                                                            \n    for (;;) {                                                                                \n        if (nextPollTimeoutMillis != 0) {                                                     \n            Binder.flushPendingCommands();                                                    \n        }                                                                                     \n        // 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回\n        // ptr 是在 JNI 层创建的 NativeMessageQueue\n        nativePollOnce(ptr, nextPollTimeoutMillis);                                           \n        \n        // 当前 nativePollOnce 返回后，查看消息队列中是否存在消息\n        synchronized (this) {                                                                 \n            // 尝试检索下一条消息，如果找到则返回                            \n            final long now = SystemClock.uptimeMillis();                                      \n            Message prevMsg = null;                                                           \n            Message msg = mMessages;                                                          \n            if (msg != null && msg.target == null) {                                          \n                // 找到下一条异步消息或者没有消息了，则退出循环\n                do {                                                                          \n                    prevMsg = msg;                                                            \n                    msg = msg.next;                                                           \n                } while (msg != null && !msg.isAsynchronous());                               \n            }                                                                                 \n            if (msg != null) {                                                                \n                if (now < msg.when) {                                                         \n                    // 下一个消息还没准备好，重新设置唤醒超时时间\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {                                                                      \n                    // 获取一条消息                                                         \n                    mBlocked = false;\n                    if (prevMsg != null) {                                                    \n                        prevMsg.next = msg.next;                                              \n                    } else {                                                                  \n                        mMessages = msg.next;                                                 \n                    }                                                                         \n                    msg.next = null;                                                          \n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    // 标记当前消息已使用\n                    msg.markInUse();                                                          \n                    return msg;                                                               \n                }                                                                             \n            } else {                                                                          \n                // 当前还没有消息，设置为 -1，无限等待中                                                     \n                nextPollTimeoutMillis = -1;                                                   \n            }                                                                                 \n                                                                                              \n            // Process the quit message now that all pending messages have been handled.      \n            if (mQuitting) {                                                                  \n                dispose();                                                                    \n                return null;                                                                  \n            }                                                                                 \n                                                                                              \n            // queue is empty or if the first message\n            // get pending idle handler count\n            if (pendingIdleHandlerCount < 0                                                   \n                    && (mMessages == null || now < mMessages.when)) {                         \n                pendingIdleHandlerCount = mIdleHandlers.size();                               \n            }                                                                                 \n            if (pendingIdleHandlerCount <= 0) {                                               \n                // 没有 idle handlers 需要运行，循环继续等待                        \n                mBlocked = true;                                                              \n                continue;                                                                     \n            }                                                                                 \n                                                                                              \n            if (mPendingIdleHandlers == null) {                                               \n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; \n            }                                                                                 \n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               \n        }                                                                                     \n                                                                                              \n        // Run the idle handlers.                                                        \n        // We only ever reach this code block during the first iteration                    \n        for (int i = 0; i < pendingIdleHandlerCount; i++) {                                   \n            final IdleHandler idler = mPendingIdleHandlers[i];                                \n            mPendingIdleHandlers[i] = null;           \n                                                                                              \n            boolean keep = false;                                                             \n            try {                                                                             \n                keep = idler.queueIdle();                                                     \n            } catch (Throwable t) {                                                           \n                Log.wtf(TAG, \"IdleHandler threw exception\", t);                               \n            }                                                                                 \n                                                                                              \n            if (!keep) {                                                                      \n                synchronized (this) {\n                    mIdleHandlers.remove(idler);                                              \n                }                                                                             \n            }                                                                                 \n        }                                                                                     \n                                                                                              \n        // Reset the idle handler count to 0 so we do not run them again.                     \n        pendingIdleHandlerCount = 0;                                                          \n                                                                                              \n        //不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                \n        nextPollTimeoutMillis = 0;                                                            \n    }                                                                                         \n}                                                                                             \n```\n\n在 `next` 方法中，`nativePollOnce` 是阻塞操作，其中 `nextPollTimeoutMillis` 代表下一个消息到来之前，还需要等待的时长；`nextPollTimeoutMillis == -1` 表示当前没有更多消息。`nativePollOnce` 调用结束后，从 `mMessages` 中提取一个消息\n\n当处于空闲时，执行 `IdleHandler` 中的回调方法。\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,  \n        jint ptr, jint timeoutMillis) {\n    // 通过前面设置的 mPrt 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr); \n    // 调用 NativeMessageQueue.pollOnce 进行轮询\n    nativeMessageQueue->pollOnce(timeoutMillis);  \n}  \n```\n\n``` cpp\nvoid NativeMessageQueue::pollOnce(int timeoutMillis) {\n    // 将调用转发给了 JNI 层的 Looper\n    mLooper->pollOnce(timeoutMillis);  \n} \n```\n\n`pollOnce` 会调用 `pollnner` 来进一步操作，如果 `pollnner` 返回值不等于 0，则返回\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nint Looper::pollInner(int timeoutMillis) {  \n    ......  \n  \n    int result = ALOOPER_POLL_WAKE;  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis\n    // 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件\n    // 如果检查成功或者超时，则结束等待\n    // 处于 Idle 状态\n    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    bool acquiredLock = false;  \n#else  \n    ......  \n#endif  \n    \n    // eventCount < 0 可能出错了\n    if (eventCount < 0) {  \n        if (errno == EINTR) {  \n            goto Done;  \n        }  \n  \n        LOGW(\"Poll failed with an unexpected error, errno=%d\", errno);  \n        result = ALOOPER_POLL_ERROR;  \n        goto Done;  \n    }  \n  \t\n    // eventCount == 0 超时\n    if (eventCount == 0) {  \n        ......  \n        result = ALOOPER_POLL_TIMEOUT;  \n        goto Done;  \n    }  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL\n    // eventCount > 0 存在事件\n    for (int i = 0; i < eventCount; i++) {  \n        int fd = eventItems[i].data.fd;  \n        uint32_t epollEvents = eventItems[i].events;  \n        if (fd == mWakeReadPipeFd) {  \n            if (epollEvents & EPOLLIN) {\n                // Looper 中使用 epoll 监听的 EPOLLIN 事件\n                awoken();  \n            } else {  \n                LOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents);  \n            }  \n        } else {  \n            ......  \n        }  \n    }  \n    if (acquiredLock) {  \n        mLock.unlock();  \n    }  \nDone: ;  \n#else  \n    ......  \n#endif  \n  \n    ......  \n  \n    return result;  \n} \n```\n\n``` cpp\nvoid Looper::awoken() {  \n    ......  \n  \n    char buffer[16];  \n    ssize_t nRead;  \n    do {  \n        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));  \n    } while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));  \n}  \n```\n\n总结上面的代码，Looper 通过 `loop` 调用 MessageQueue 的 `next`，`next` 中又会调用到 native 方法 `nativePollOnce`，在这个方法中，会调用到 NativeMessageQueue 的 `pollInner`，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 `awoken`，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。\n\n``` java\nboolean enqueueMessage(Message msg, long when) {                                         \n    if (msg.target == null) {                                                            \n        throw new IllegalArgumentException(\"Message must have a target.\");               \n    }                                                                                    \n    if (msg.isInUse()) {                                                                 \n        throw new IllegalStateException(msg + \" This message is already in use.\");       \n    }                                                                                    \n                                                                                         \n    synchronized (this) {                                                                \n        if (mQuitting) {                                                                 \n            IllegalStateException e = new IllegalStateException(                         \n                    msg.target + \" sending message to a Handler on a dead thread\");      \n            Log.w(TAG, e.getMessage(), e);                                               \n            msg.recycle();                                                               \n            return false;                                                                \n        }                                                                                \n                                                                                         \n        msg.markInUse();                                                                 \n        msg.when = when;                                                                 \n        Message p = mMessages;                                                           \n        boolean needWake;                                                                \n        if (p == null || when == 0 || when < p.when) {                                   \n            // 不存在头部消息或立即执行或执行时机快于头部消息\n            // 将处理的消息作为新的头部消息\n            msg.next = p;                                                                \n            mMessages = msg;                                                             \n            needWake = mBlocked;                                                         \n        } else {                                                                         \n            // 将处理的消息插入到队列的尾部\n            // 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();             \n            Message prev;                                                                \n            for (;;) {                                                                   \n                prev = p;                                                                \n                p = p.next;                                                              \n                if (p == null || when < p.when) {                                        \n                    break;                                                               \n                }                                                                        \n                if (needWake && p.isAsynchronous()) {                                    \n                    needWake = false;                                                    \n                }                                                                        \n            }                                                                            \n            msg.next = p; // invariant: p == prev.next                                   \n            prev.next = msg;                                                             \n        }                                                                                \n                                                                                         \n        // We can assume mPtr != 0 because mQuitting is false.                           \n        if (needWake) {                                                                  \n            nativeWake(mPtr);                                                            \n        }                                                                                \n    }                                                                                    \n    return true;                                                                         \n}                                                                                        \n```\n\n`MessageQueue` 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。\n\n如果当前线程处于空闲等待状态，那么还需要调用 `nativeWake` 来唤醒：\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj, jint ptr) {\n    // ptr 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);  \n    return nativeMessageQueue->wake();  \n}  \n```\n\n这里将唤醒请求转发到 Looper `wake`：\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nvoid Looper::wake() {  \n    ......  \n  \n    ssize_t nWrite;  \n    do {\n        // 先管道中写入 \"W\n        nWrite = write(mWakeWritePipeFd, \"W\", 1);  \n    } while (nWrite == -1 && errno == EINTR);  \n  \n    .......  \n}  \n```\n\n往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 `polllnner` 中调用 `epoll_wait` 进入\n\n``` java\nvoid removeMessages(Handler h, int what, Object object) {     \n    if (h == null) {                                          \n        return;                                               \n    }                                                         \n                                                              \n    synchronized (this) {                                     \n        Message p = mMessages;                                \n                                                              \n        // 从队列头部开始，移除连续的所有符合条件的消息                     \n        while (p != null && p.target == h && p.what == what   \n               && (object == null || p.obj == object)) {      \n            Message n = p.next;                               \n            mMessages = n;\n            // 找到对应的消息，释放它\n            p.recycleUnchecked();                             \n            p = n;                                            \n        }                                                     \n                                                              \n        //  从新的队列头部开始，移除全部符合条件的消息                  \n        while (p != null) {                                   \n            Message n = p.next;                               \n            if (n != null) {                                  \n                if (n.target == h && n.what == what           \n                    && (object == null || n.obj == object)) { \n                    Message nn = n.next;                      \n                    n.recycleUnchecked();                     \n                    p.next = nn;                              \n                    continue;                                 \n                }                                             \n            }                                                 \n            p = n;                                            \n        }                                                     \n    }                                                         \n}                                                             \n```\n\n`postSyncBarrier` 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 `removeSyncBarrier`\n\n当 MessageQueue 退出时，需要 `dispose`：\n\n``` java\n// Disposes of the underlying message queue.                 \n// Must only be called on the looper thread or the finalizer.\nprivate void dispose() {                                     \n    if (mPtr != 0) {\n        // native 方法\n        nativeDestroy(mPtr);\n        // mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量\n        mPtr = 0;                                            \n    }                                                        \n}                                                            \n```\n\n`nativeDestroy` 最终会调用 RefBase 的 `decStrong`：\n\n``` cpp\nvoid RefBase::decStrong(const void* id) const\n{\n    weakref_impl* const refs = mRefs;\n    refs->removeStrongRef(id); //移除强引用\n    const int32_t c = android_atomic_dec(&refs->mStrong);\n    if (c == 1) {\n        refs->mBase->onLastStrongRef(id);\n        if ((refs->mFlags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {\n            delete this;\n        }\n    }\n    refs->decWeak(id); // 移除弱引用\n}\n```\n\n### Message\n\n``` java\nvoid recycleUnchecked() {                 \n    // 标记为使用状态，清除其他状态     \n    flags = FLAG_IN_USE;                  \n    what = 0;                             \n    arg1 = 0;                             \n    arg2 = 0;                             \n    obj = null;                           \n    replyTo = null;                       \n    sendingUid = -1;                      \n    when = 0;                             \n    target = null;                        \n    callback = null;                      \n    data = null;                          \n                                          \n    synchronized (sPoolSync) {\n        // 消息缓存\n        if (sPoolSize < MAX_POOL_SIZE) {  \n            next = sPool;                 \n            sPool = this;                 \n            sPoolSize++;                  \n        }                                 \n    }                                     \n}                                         \n```\n\n``` java\npublic static Message obtain() {             \n    synchronized (sPoolSync) {               \n        if (sPool != null) {\n            // 从缓存中获取\n            Message m = sPool;               \n            sPool = m.next;                  \n            m.next = null;                   \n            m.flags = 0; // clear in-use flag\n            sPoolSize--;                     \n            return m;                        \n        }                                    \n    }                                        \n    return new Message();                    \n}                                            \n```\n\n### 总结\n\n![消息机制](http://gityuan.com/images/handler/handler_java.jpg)\n\nJava 层：\n\n* Handler 通过 `sendMessage`，将 Message 通过 `MessageQueue.enqueueMessage` 添加到队列中\n* Looper 通过 `loop` 提取需要执行的 Message，并交与 `Message.target` 的 Handler 进行 `dispatchMessage` 分发\n*  将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler \n\nJNI 层：\n\n* 线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态\n* 通过 epoll 机制监听 `EPOLLIN` 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程\n\n消息分发的优先级：\n\n1. `Message.callback.run()`\n2. `Handler.mCallback.handleMessage()`\n3. `Handler.handleMessage()`\n\n> EPOLL：Linux 内核的可扩展 I/O 事件通知机制\n>\n> PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入\n>\n> 文件描述符(File descriptor)：用于表述指向[文件](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6)的引用的抽象化概念","slug":"Android消息机制-Handler","published":1,"updated":"2018-04-11T14:05:30.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjs0hta5000fero6sxjwef8m","content":"<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://gityuan.com/2015/12/26/handler-message-framework/\" target=\"_blank\" rel=\"noopener\">Android消息机制1-Handler(Java层)</a></p>\n<p><a href=\"http://gityuan.com/2015/12/27/handler-message-native/\" target=\"_blank\" rel=\"noopener\">Android消息机制2-Handler(Native层)</a></p>\n<p><a href=\"http://blog.csdn.net/luoshengyang/article/details/6817933\" target=\"_blank\" rel=\"noopener\">Android应用程序消息处理机制（Looper、Handler）分析</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix\" target=\"_blank\" rel=\"noopener\">管道(Unix)</a>)</p>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/Epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">文件描述符</a></p>\n<p>Handler 机制主要由四个部分组成：</p>\n<ul>\n<li>Looper</li>\n<li>MessageQueue</li>\n<li>Message</li>\n<li>Handler</li>\n</ul>\n<h3 id=\"典型用法\"><a href=\"#典型用法\" class=\"headerlink\" title=\"典型用法\"></a>典型用法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        </span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>不断循环执行 <code>Looper.loop</code>，按分发机制将消息分发给目标处理者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构建 Looper 存储到 ThreadLocal</span></span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>sThreadLocal</code> 是一个 ThreadLocal 类型的静态变量</p>\n<blockquote>\n<p>ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Looper 中创建 MessageQueue</span></span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,                      </span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.                                  </span></span><br><span class=\"line\">    Binder.clearCallingIdentity();                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();                                           </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                  </span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// 获取下一条 Message，可能会阻塞                                              </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;                                                                      </span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.                         </span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger                 </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Printer logging = me.mLogging;                                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +                        </span><br><span class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);                                            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">//省略</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> end;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 分发 Message</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);                                                    </span><br><span class=\"line\">            end = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();              </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;                                                                             </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;                                                                </span><br><span class=\"line\">                Trace.traceEnd(traceTag);                                                       </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>) &#123;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> time = end - start;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; slowDispatchThresholdMs) &#123;                                               </span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Dispatch took \"</span> + time + <span class=\"string\">\"ms on \"</span>                                  </span><br><span class=\"line\">                        + Thread.currentThread().getName() + <span class=\"string\">\", h=\"</span> +                           </span><br><span class=\"line\">                        msg.target + <span class=\"string\">\" cb=\"</span> + msg.callback + <span class=\"string\">\" msg=\"</span> + msg.what);               </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the                                  </span></span><br><span class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.                                             </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;                                                                </span><br><span class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span>                                      </span><br><span class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span>                                        </span><br><span class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span>                     </span><br><span class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span>                                     </span><br><span class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);                                      </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"comment\">// 释放 Message</span></span><br><span class=\"line\">        msg.recycleUnchecked();                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Looper.quit 最终调用的都是 MessageQueue.quit</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">false</span>); <span class=\"comment\">// 移除消息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quitSafely</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">true</span>); <span class=\"comment\">// 安全移除消息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 在构造方法中，会调用 native 方法 <code>nativeInit</code> 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs</span></span><br><span class=\"line\">Looper::Looper(<span class=\"keyword\">bool</span> allowNonCallbacks) :  </span><br><span class=\"line\">    mAllowNonCallbacks(allowNonCallbacks),  </span><br><span class=\"line\">    mResponseIndex(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 管道机制</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> wakeFds[<span class=\"number\">2</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = pipe(wakeFds);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    mWakeReadPipeFd = wakeFds[<span class=\"number\">0</span>];  </span><br><span class=\"line\">    mWakeWritePipeFd = wakeFds[<span class=\"number\">1</span>];  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"comment\">// 分配新的 epoll 实例同时注册唤醒管道</span></span><br><span class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItem</span>;</span>  </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp; eventItem, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(epoll_event)); <span class=\"comment\">// zero out unused members of data field union</span></span><br><span class=\"line\">    <span class=\"comment\">// 观察 EPOLLIN 事件</span></span><br><span class=\"line\">    eventItem.events = EPOLLIN;  </span><br><span class=\"line\">    eventItem.data.fd = mWakeReadPipeFd;  </span><br><span class=\"line\">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。</p>\n<p>epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p>\n</blockquote>\n<p>pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。</p>\n<p>以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;                                                                     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();                                          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;          </span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏</span></span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +      </span><br><span class=\"line\">                klass.getCanonicalName());                                                          </span><br><span class=\"line\">        &#125;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    <span class=\"comment\">// 默认使用当前线程的 Looper                                                                                                </span></span><br><span class=\"line\">    mLooper = Looper.myLooper();                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(                                                                 </span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread that has not called Looper.prepare()\"</span>);             </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    mQueue = mLooper.mQueue;                                                                        </span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    <span class=\"comment\">// 是否为异步处理</span></span><br><span class=\"line\">    mAsynchronous = async;                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>Looper.loop</code> 中，当存在 Message 需要处理时，会调用 <code>dispatchMessage</code> 来进行分发：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用 callback</span></span><br><span class=\"line\">        handleCallback(msg);                    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接着检查通过构造方法传进来的 Callback</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123; </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;                         </span><br><span class=\"line\">            &#125;                                   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 最后调用 handleMessage</span></span><br><span class=\"line\">        handleMessage(msg);                     </span><br><span class=\"line\">    &#125;                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 Handler 发送消息：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://gityuan.com/images/handler/java_sendmessage.png\" alt=\"发送消息调用链\" title=\"\">\n                </div>\n                <div class=\"image-caption\">发送消息调用链</div>\n            </figure>\n<p>最终所有的方法都会调用到 <code>MessageQueue.enqueueMessage</code></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><blockquote>\n<p>消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123; </span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    <span class=\"comment\">// used by native code</span></span><br><span class=\"line\">    mPtr = nativeInit();            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 的初始化工作主要由 native 方法来执行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> NativeMessageQueue();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! nativeMessageQueue) &#123;  </span><br><span class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Unable to allocate native queue\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量</span></span><br><span class=\"line\">    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeInit</code> 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 <code>mPtr</code>，关联了 NativeMessageQueue 和 MessageQueue</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// messsage loop has already quit                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                          </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration                       </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;                                                     </span><br><span class=\"line\">            Binder.flushPendingCommands();                                                    </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class=\"line\">        <span class=\"comment\">// ptr 是在 JNI 层创建的 NativeMessageQueue</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);                                           </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 当前 nativePollOnce 返回后，查看消息队列中是否存在消息</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                 </span><br><span class=\"line\">            <span class=\"comment\">// 尝试检索下一条消息，如果找到则返回                            </span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();                                      </span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">            Message msg = mMessages;                                                          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">                <span class=\"comment\">// 找到下一条异步消息或者没有消息了，则退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;                                                                          </span><br><span class=\"line\">                    prevMsg = msg;                                                            </span><br><span class=\"line\">                    msg = msg.next;                                                           </span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;                                                                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;                                                         </span><br><span class=\"line\">                    <span class=\"comment\">// 下一个消息还没准备好，重新设置唤醒超时时间</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;                                                                      </span><br><span class=\"line\">                    <span class=\"comment\">// 获取一条消息                                                         </span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;                                                    </span><br><span class=\"line\">                        prevMsg.next = msg.next;                                              </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;                                                                  </span><br><span class=\"line\">                        mMessages = msg.next;                                                 </span><br><span class=\"line\">                    &#125;                                                                         </span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"Returning message: \"</span> + msg);</span><br><span class=\"line\">                    <span class=\"comment\">// 标记当前消息已使用</span></span><br><span class=\"line\">                    msg.markInUse();                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;                                                               </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;                                                                          </span><br><span class=\"line\">                <span class=\"comment\">// 当前还没有消息，设置为 -1，无限等待中                                                     </span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;                                                   </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.      </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                  </span><br><span class=\"line\">                dispose();                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                  </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// get pending idle handler count</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span>                                                   </span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;                         </span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">                <span class=\"comment\">// 没有 idle handlers 需要运行，循环继续等待                        </span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                                                                     </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;                                               </span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)]; </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.                                                        </span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration                    </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;                                   </span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];                                </span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>;           </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;                                                             </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;                                                                             </span><br><span class=\"line\">                keep = idler.queueIdle();                                                     </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;                                                           </span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;                                                                      </span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);                                              </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.                     </span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;                                                          </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">//不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                </span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>next</code> 方法中，<code>nativePollOnce</code> 是阻塞操作，其中 <code>nextPollTimeoutMillis</code> 代表下一个消息到来之前，还需要等待的时长；<code>nextPollTimeoutMillis == -1</code> 表示当前没有更多消息。<code>nativePollOnce</code> 调用结束后，从 <code>mMessages</code> 中提取一个消息</p>\n<p>当处于空闲时，执行 <code>IdleHandler</code> 中的回调方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jint ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过前面设置的 mPrt 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr); </span><br><span class=\"line\">    <span class=\"comment\">// 调用 NativeMessageQueue.pollOnce 进行轮询</span></span><br><span class=\"line\">    nativeMessageQueue-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> NativeMessageQueue::pollOnce(<span class=\"keyword\">int</span> timeoutMillis) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将调用转发给了 JNI 层的 Looper</span></span><br><span class=\"line\">    mLooper-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>pollOnce</code> 会调用 <code>pollnner</code> 来进一步操作，如果 <code>pollnner</code> 返回值不等于 0，则返回</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Looper::pollInner(<span class=\"keyword\">int</span> timeoutMillis) &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = ALOOPER_POLL_WAKE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItems</span>[<span class=\"title\">EPOLL_MAX_EVENTS</span>];</span></span><br><span class=\"line\">    <span class=\"comment\">// 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis</span></span><br><span class=\"line\">    <span class=\"comment\">// 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果检查成功或者超时，则结束等待</span></span><br><span class=\"line\">    <span class=\"comment\">// 处于 Idle 状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> acquiredLock = <span class=\"literal\">false</span>;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// eventCount &lt; 0 可能出错了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        LOGW(<span class=\"string\">\"Poll failed with an unexpected error, errno=%d\"</span>, errno);  </span><br><span class=\"line\">        result = ALOOPER_POLL_ERROR;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// eventCount == 0 超时</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        ......  </span><br><span class=\"line\">        result = ALOOPER_POLL_TIMEOUT;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL</span></span><br><span class=\"line\">    <span class=\"comment\">// eventCount &gt; 0 存在事件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd = eventItems[i].data.fd;  </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Looper 中使用 epoll 监听的 EPOLLIN 事件</span></span><br><span class=\"line\">                awoken();  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                LOGW(<span class=\"string\">\"Ignoring unexpected epoll events 0x%x on wake read pipe.\"</span>, epollEvents);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            ......  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquiredLock) &#123;  </span><br><span class=\"line\">        mLock.unlock();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">Done: ;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::awoken() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">16</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nRead;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">        nRead = read(mWakeReadPipeFd, buffer, <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((nRead == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结上面的代码，Looper 通过 <code>loop</code> 调用 MessageQueue 的 <code>next</code>，<code>next</code> 中又会调用到 native 方法 <code>nativePollOnce</code>，在这个方法中，会调用到 NativeMessageQueue 的 <code>pollInner</code>，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 <code>awoken</code>，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;                                                            </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Message must have a target.\"</span>);               </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">\" This message is already in use.\"</span>);       </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                 </span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(                         </span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);      </span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);                                               </span><br><span class=\"line\">            msg.recycle();                                                               </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        msg.markInUse();                                                                 </span><br><span class=\"line\">        msg.when = when;                                                                 </span><br><span class=\"line\">        Message p = mMessages;                                                           </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;                                   </span><br><span class=\"line\">            <span class=\"comment\">// 不存在头部消息或立即执行或执行时机快于头部消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息作为新的头部消息</span></span><br><span class=\"line\">            msg.next = p;                                                                </span><br><span class=\"line\">            mMessages = msg;                                                             </span><br><span class=\"line\">            needWake = mBlocked;                                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                                         </span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息插入到队列的尾部</span></span><br><span class=\"line\">            <span class=\"comment\">// 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();             </span><br><span class=\"line\">            Message prev;                                                                </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;                                                                   </span><br><span class=\"line\">                prev = p;                                                                </span><br><span class=\"line\">                p = p.next;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;                                        </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                               </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;                                    </span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;                                                    </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">            &#125;                                                                            </span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next                                   </span></span><br><span class=\"line\">            prev.next = msg;                                                             </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.                           </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;                                                                  </span><br><span class=\"line\">            nativeWake(mPtr);                                                            </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MessageQueue</code> 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。</p>\n<p>如果当前线程处于空闲等待状态，那么还需要调用 <code>nativeWake</code> 来唤醒：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jobject obj, jint ptr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ptr 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nativeMessageQueue-&gt;wake();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将唤醒请求转发到 Looper <code>wake</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Looper::wake() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nWrite;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先管道中写入 \"W</span></span><br><span class=\"line\">        nWrite = write(mWakeWritePipeFd, <span class=\"string\">\"W\"</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (nWrite == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    .......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 <code>polllnner</code> 中调用 <code>epoll_wait</code> 进入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, <span class=\"keyword\">int</span> what, Object object)</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                               </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                     </span><br><span class=\"line\">        Message p = mMessages;                                </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">// 从队列头部开始，移除连续的所有符合条件的消息                     </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what   </span><br><span class=\"line\">               &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;      </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            <span class=\"comment\">// 找到对应的消息，释放它</span></span><br><span class=\"line\">            p.recycleUnchecked();                             </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">//  从新的队列头部开始，移除全部符合条件的消息                  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;                                   </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;                                  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.what == what           </span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123; </span><br><span class=\"line\">                    Message nn = n.next;                      </span><br><span class=\"line\">                    n.recycleUnchecked();                     </span><br><span class=\"line\">                    p.next = nn;                              </span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;                                 </span><br><span class=\"line\">                &#125;                                             </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSyncBarrier</code> 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 <code>removeSyncBarrier</code></p>\n<p>当 MessageQueue 退出时，需要 <code>dispose</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposes of the underlying message queue.                 </span></span><br><span class=\"line\"><span class=\"comment\">// Must only be called on the looper thread or the finalizer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPtr != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// native 方法</span></span><br><span class=\"line\">        nativeDestroy(mPtr);</span><br><span class=\"line\">        <span class=\"comment\">// mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量</span></span><br><span class=\"line\">        mPtr = <span class=\"number\">0</span>;                                            </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeDestroy</code> 最终会调用 RefBase 的 <code>decStrong</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> RefBase::decStrong(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* id) <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weakref_impl* <span class=\"keyword\">const</span> refs = mRefs;</span><br><span class=\"line\">    refs-&gt;removeStrongRef(id); <span class=\"comment\">//移除强引用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs-&gt;decWeak(id); <span class=\"comment\">// 移除弱引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycleUnchecked</span><span class=\"params\">()</span> </span>&#123;                 </span><br><span class=\"line\">    <span class=\"comment\">// 标记为使用状态，清除其他状态     </span></span><br><span class=\"line\">    flags = FLAG_IN_USE;                  </span><br><span class=\"line\">    what = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg1 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg2 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    obj = <span class=\"keyword\">null</span>;                           </span><br><span class=\"line\">    replyTo = <span class=\"keyword\">null</span>;                       </span><br><span class=\"line\">    sendingUid = -<span class=\"number\">1</span>;                      </span><br><span class=\"line\">    when = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    target = <span class=\"keyword\">null</span>;                        </span><br><span class=\"line\">    callback = <span class=\"keyword\">null</span>;                      </span><br><span class=\"line\">    data = <span class=\"keyword\">null</span>;                          </span><br><span class=\"line\">                                          </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;  </span><br><span class=\"line\">            next = sPool;                 </span><br><span class=\"line\">            sPool = <span class=\"keyword\">this</span>;                 </span><br><span class=\"line\">            sPoolSize++;                  </span><br><span class=\"line\">        &#125;                                 </span><br><span class=\"line\">    &#125;                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;             </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从缓存中获取</span></span><br><span class=\"line\">            Message m = sPool;               </span><br><span class=\"line\">            sPool = m.next;                  </span><br><span class=\"line\">            m.next = <span class=\"keyword\">null</span>;                   </span><br><span class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></span><br><span class=\"line\">            sPoolSize--;                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;                        </span><br><span class=\"line\">        &#125;                                    </span><br><span class=\"line\">    &#125;                                        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://gityuan.com/images/handler/handler_java.jpg\" alt=\"消息机制\" title=\"\">\n                </div>\n                <div class=\"image-caption\">消息机制</div>\n            </figure>\n<p>Java 层：</p>\n<ul>\n<li>Handler 通过 <code>sendMessage</code>，将 Message 通过 <code>MessageQueue.enqueueMessage</code> 添加到队列中</li>\n<li>Looper 通过 <code>loop</code> 提取需要执行的 Message，并交与 <code>Message.target</code> 的 Handler 进行 <code>dispatchMessage</code> 分发</li>\n<li>将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler </li>\n</ul>\n<p>JNI 层：</p>\n<ul>\n<li>线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态</li>\n<li>通过 epoll 机制监听 <code>EPOLLIN</code> 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程</li>\n</ul>\n<p>消息分发的优先级：</p>\n<ol>\n<li><code>Message.callback.run()</code></li>\n<li><code>Handler.mCallback.handleMessage()</code></li>\n<li><code>Handler.handleMessage()</code></li>\n</ol>\n<blockquote>\n<p>EPOLL：Linux 内核的可扩展 I/O 事件通知机制</p>\n<p>PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入</p>\n<p>文件描述符(File descriptor)：用于表述指向<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">文件</a>的引用的抽象化概念</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://gityuan.com/2015/12/26/handler-message-framework/\" target=\"_blank\" rel=\"noopener\">Android消息机制1-Handler(Java层)</a></p>\n<p><a href=\"http://gityuan.com/2015/12/27/handler-message-native/\" target=\"_blank\" rel=\"noopener\">Android消息机制2-Handler(Native层)</a></p>\n<p><a href=\"http://blog.csdn.net/luoshengyang/article/details/6817933\" target=\"_blank\" rel=\"noopener\">Android应用程序消息处理机制（Looper、Handler）分析</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix\" target=\"_blank\" rel=\"noopener\">管道(Unix)</a>)</p>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/Epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">文件描述符</a></p>\n<p>Handler 机制主要由四个部分组成：</p>\n<ul>\n<li>Looper</li>\n<li>MessageQueue</li>\n<li>Message</li>\n<li>Handler</li>\n</ul>\n<h3 id=\"典型用法\"><a href=\"#典型用法\" class=\"headerlink\" title=\"典型用法\"></a>典型用法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        </span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>不断循环执行 <code>Looper.loop</code>，按分发机制将消息分发给目标处理者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构建 Looper 存储到 ThreadLocal</span></span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>sThreadLocal</code> 是一个 ThreadLocal 类型的静态变量</p>\n<blockquote>\n<p>ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Looper 中创建 MessageQueue</span></span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,                      </span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.                                  </span></span><br><span class=\"line\">    Binder.clearCallingIdentity();                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();                                           </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                  </span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// 获取下一条 Message，可能会阻塞                                              </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;                                                                      </span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.                         </span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger                 </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Printer logging = me.mLogging;                                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +                        </span><br><span class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);                                            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">//省略</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> end;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 分发 Message</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);                                                    </span><br><span class=\"line\">            end = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();              </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;                                                                             </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;                                                                </span><br><span class=\"line\">                Trace.traceEnd(traceTag);                                                       </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>) &#123;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> time = end - start;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; slowDispatchThresholdMs) &#123;                                               </span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Dispatch took \"</span> + time + <span class=\"string\">\"ms on \"</span>                                  </span><br><span class=\"line\">                        + Thread.currentThread().getName() + <span class=\"string\">\", h=\"</span> +                           </span><br><span class=\"line\">                        msg.target + <span class=\"string\">\" cb=\"</span> + msg.callback + <span class=\"string\">\" msg=\"</span> + msg.what);               </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the                                  </span></span><br><span class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.                                             </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;                                                                </span><br><span class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span>                                      </span><br><span class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span>                                        </span><br><span class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span>                     </span><br><span class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span>                                     </span><br><span class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);                                      </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"comment\">// 释放 Message</span></span><br><span class=\"line\">        msg.recycleUnchecked();                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Looper.quit 最终调用的都是 MessageQueue.quit</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">false</span>); <span class=\"comment\">// 移除消息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quitSafely</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">true</span>); <span class=\"comment\">// 安全移除消息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 在构造方法中，会调用 native 方法 <code>nativeInit</code> 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs</span></span><br><span class=\"line\">Looper::Looper(<span class=\"keyword\">bool</span> allowNonCallbacks) :  </span><br><span class=\"line\">    mAllowNonCallbacks(allowNonCallbacks),  </span><br><span class=\"line\">    mResponseIndex(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 管道机制</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> wakeFds[<span class=\"number\">2</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = pipe(wakeFds);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    mWakeReadPipeFd = wakeFds[<span class=\"number\">0</span>];  </span><br><span class=\"line\">    mWakeWritePipeFd = wakeFds[<span class=\"number\">1</span>];  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"comment\">// 分配新的 epoll 实例同时注册唤醒管道</span></span><br><span class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItem</span>;</span>  </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp; eventItem, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(epoll_event)); <span class=\"comment\">// zero out unused members of data field union</span></span><br><span class=\"line\">    <span class=\"comment\">// 观察 EPOLLIN 事件</span></span><br><span class=\"line\">    eventItem.events = EPOLLIN;  </span><br><span class=\"line\">    eventItem.data.fd = mWakeReadPipeFd;  </span><br><span class=\"line\">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。</p>\n<p>epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p>\n</blockquote>\n<p>pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。</p>\n<p>以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;                                                                     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();                                          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;          </span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏</span></span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +      </span><br><span class=\"line\">                klass.getCanonicalName());                                                          </span><br><span class=\"line\">        &#125;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    <span class=\"comment\">// 默认使用当前线程的 Looper                                                                                                </span></span><br><span class=\"line\">    mLooper = Looper.myLooper();                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(                                                                 </span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread that has not called Looper.prepare()\"</span>);             </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    mQueue = mLooper.mQueue;                                                                        </span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    <span class=\"comment\">// 是否为异步处理</span></span><br><span class=\"line\">    mAsynchronous = async;                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>Looper.loop</code> 中，当存在 Message 需要处理时，会调用 <code>dispatchMessage</code> 来进行分发：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用 callback</span></span><br><span class=\"line\">        handleCallback(msg);                    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接着检查通过构造方法传进来的 Callback</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123; </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;                         </span><br><span class=\"line\">            &#125;                                   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 最后调用 handleMessage</span></span><br><span class=\"line\">        handleMessage(msg);                     </span><br><span class=\"line\">    &#125;                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 Handler 发送消息：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://gityuan.com/images/handler/java_sendmessage.png\" alt=\"发送消息调用链\" title=\"\">\n                </div>\n                <div class=\"image-caption\">发送消息调用链</div>\n            </figure>\n<p>最终所有的方法都会调用到 <code>MessageQueue.enqueueMessage</code></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><blockquote>\n<p>消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123; </span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    <span class=\"comment\">// used by native code</span></span><br><span class=\"line\">    mPtr = nativeInit();            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 的初始化工作主要由 native 方法来执行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> NativeMessageQueue();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! nativeMessageQueue) &#123;  </span><br><span class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Unable to allocate native queue\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量</span></span><br><span class=\"line\">    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeInit</code> 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 <code>mPtr</code>，关联了 NativeMessageQueue 和 MessageQueue</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// messsage loop has already quit                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                          </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration                       </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;                                                     </span><br><span class=\"line\">            Binder.flushPendingCommands();                                                    </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class=\"line\">        <span class=\"comment\">// ptr 是在 JNI 层创建的 NativeMessageQueue</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);                                           </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 当前 nativePollOnce 返回后，查看消息队列中是否存在消息</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                 </span><br><span class=\"line\">            <span class=\"comment\">// 尝试检索下一条消息，如果找到则返回                            </span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();                                      </span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">            Message msg = mMessages;                                                          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">                <span class=\"comment\">// 找到下一条异步消息或者没有消息了，则退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;                                                                          </span><br><span class=\"line\">                    prevMsg = msg;                                                            </span><br><span class=\"line\">                    msg = msg.next;                                                           </span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;                                                                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;                                                         </span><br><span class=\"line\">                    <span class=\"comment\">// 下一个消息还没准备好，重新设置唤醒超时时间</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;                                                                      </span><br><span class=\"line\">                    <span class=\"comment\">// 获取一条消息                                                         </span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;                                                    </span><br><span class=\"line\">                        prevMsg.next = msg.next;                                              </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;                                                                  </span><br><span class=\"line\">                        mMessages = msg.next;                                                 </span><br><span class=\"line\">                    &#125;                                                                         </span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"Returning message: \"</span> + msg);</span><br><span class=\"line\">                    <span class=\"comment\">// 标记当前消息已使用</span></span><br><span class=\"line\">                    msg.markInUse();                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;                                                               </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;                                                                          </span><br><span class=\"line\">                <span class=\"comment\">// 当前还没有消息，设置为 -1，无限等待中                                                     </span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;                                                   </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.      </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                  </span><br><span class=\"line\">                dispose();                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                  </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// get pending idle handler count</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span>                                                   </span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;                         </span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">                <span class=\"comment\">// 没有 idle handlers 需要运行，循环继续等待                        </span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                                                                     </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;                                               </span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)]; </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.                                                        </span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration                    </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;                                   </span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];                                </span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>;           </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;                                                             </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;                                                                             </span><br><span class=\"line\">                keep = idler.queueIdle();                                                     </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;                                                           </span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;                                                                      </span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);                                              </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.                     </span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;                                                          </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">//不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                </span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>next</code> 方法中，<code>nativePollOnce</code> 是阻塞操作，其中 <code>nextPollTimeoutMillis</code> 代表下一个消息到来之前，还需要等待的时长；<code>nextPollTimeoutMillis == -1</code> 表示当前没有更多消息。<code>nativePollOnce</code> 调用结束后，从 <code>mMessages</code> 中提取一个消息</p>\n<p>当处于空闲时，执行 <code>IdleHandler</code> 中的回调方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jint ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过前面设置的 mPrt 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr); </span><br><span class=\"line\">    <span class=\"comment\">// 调用 NativeMessageQueue.pollOnce 进行轮询</span></span><br><span class=\"line\">    nativeMessageQueue-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> NativeMessageQueue::pollOnce(<span class=\"keyword\">int</span> timeoutMillis) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将调用转发给了 JNI 层的 Looper</span></span><br><span class=\"line\">    mLooper-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>pollOnce</code> 会调用 <code>pollnner</code> 来进一步操作，如果 <code>pollnner</code> 返回值不等于 0，则返回</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Looper::pollInner(<span class=\"keyword\">int</span> timeoutMillis) &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = ALOOPER_POLL_WAKE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItems</span>[<span class=\"title\">EPOLL_MAX_EVENTS</span>];</span></span><br><span class=\"line\">    <span class=\"comment\">// 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis</span></span><br><span class=\"line\">    <span class=\"comment\">// 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果检查成功或者超时，则结束等待</span></span><br><span class=\"line\">    <span class=\"comment\">// 处于 Idle 状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> acquiredLock = <span class=\"literal\">false</span>;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// eventCount &lt; 0 可能出错了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        LOGW(<span class=\"string\">\"Poll failed with an unexpected error, errno=%d\"</span>, errno);  </span><br><span class=\"line\">        result = ALOOPER_POLL_ERROR;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// eventCount == 0 超时</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        ......  </span><br><span class=\"line\">        result = ALOOPER_POLL_TIMEOUT;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL</span></span><br><span class=\"line\">    <span class=\"comment\">// eventCount &gt; 0 存在事件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd = eventItems[i].data.fd;  </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Looper 中使用 epoll 监听的 EPOLLIN 事件</span></span><br><span class=\"line\">                awoken();  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                LOGW(<span class=\"string\">\"Ignoring unexpected epoll events 0x%x on wake read pipe.\"</span>, epollEvents);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            ......  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquiredLock) &#123;  </span><br><span class=\"line\">        mLock.unlock();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">Done: ;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::awoken() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">16</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nRead;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">        nRead = read(mWakeReadPipeFd, buffer, <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((nRead == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结上面的代码，Looper 通过 <code>loop</code> 调用 MessageQueue 的 <code>next</code>，<code>next</code> 中又会调用到 native 方法 <code>nativePollOnce</code>，在这个方法中，会调用到 NativeMessageQueue 的 <code>pollInner</code>，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 <code>awoken</code>，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;                                                            </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Message must have a target.\"</span>);               </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">\" This message is already in use.\"</span>);       </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                 </span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(                         </span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);      </span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);                                               </span><br><span class=\"line\">            msg.recycle();                                                               </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        msg.markInUse();                                                                 </span><br><span class=\"line\">        msg.when = when;                                                                 </span><br><span class=\"line\">        Message p = mMessages;                                                           </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;                                   </span><br><span class=\"line\">            <span class=\"comment\">// 不存在头部消息或立即执行或执行时机快于头部消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息作为新的头部消息</span></span><br><span class=\"line\">            msg.next = p;                                                                </span><br><span class=\"line\">            mMessages = msg;                                                             </span><br><span class=\"line\">            needWake = mBlocked;                                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                                         </span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息插入到队列的尾部</span></span><br><span class=\"line\">            <span class=\"comment\">// 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();             </span><br><span class=\"line\">            Message prev;                                                                </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;                                                                   </span><br><span class=\"line\">                prev = p;                                                                </span><br><span class=\"line\">                p = p.next;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;                                        </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                               </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;                                    </span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;                                                    </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">            &#125;                                                                            </span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next                                   </span></span><br><span class=\"line\">            prev.next = msg;                                                             </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.                           </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;                                                                  </span><br><span class=\"line\">            nativeWake(mPtr);                                                            </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MessageQueue</code> 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。</p>\n<p>如果当前线程处于空闲等待状态，那么还需要调用 <code>nativeWake</code> 来唤醒：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jobject obj, jint ptr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ptr 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nativeMessageQueue-&gt;wake();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将唤醒请求转发到 Looper <code>wake</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Looper::wake() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nWrite;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先管道中写入 \"W</span></span><br><span class=\"line\">        nWrite = write(mWakeWritePipeFd, <span class=\"string\">\"W\"</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (nWrite == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    .......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 <code>polllnner</code> 中调用 <code>epoll_wait</code> 进入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, <span class=\"keyword\">int</span> what, Object object)</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                               </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                     </span><br><span class=\"line\">        Message p = mMessages;                                </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">// 从队列头部开始，移除连续的所有符合条件的消息                     </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what   </span><br><span class=\"line\">               &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;      </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            <span class=\"comment\">// 找到对应的消息，释放它</span></span><br><span class=\"line\">            p.recycleUnchecked();                             </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">//  从新的队列头部开始，移除全部符合条件的消息                  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;                                   </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;                                  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.what == what           </span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123; </span><br><span class=\"line\">                    Message nn = n.next;                      </span><br><span class=\"line\">                    n.recycleUnchecked();                     </span><br><span class=\"line\">                    p.next = nn;                              </span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;                                 </span><br><span class=\"line\">                &#125;                                             </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSyncBarrier</code> 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 <code>removeSyncBarrier</code></p>\n<p>当 MessageQueue 退出时，需要 <code>dispose</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposes of the underlying message queue.                 </span></span><br><span class=\"line\"><span class=\"comment\">// Must only be called on the looper thread or the finalizer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPtr != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// native 方法</span></span><br><span class=\"line\">        nativeDestroy(mPtr);</span><br><span class=\"line\">        <span class=\"comment\">// mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量</span></span><br><span class=\"line\">        mPtr = <span class=\"number\">0</span>;                                            </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeDestroy</code> 最终会调用 RefBase 的 <code>decStrong</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> RefBase::decStrong(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* id) <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weakref_impl* <span class=\"keyword\">const</span> refs = mRefs;</span><br><span class=\"line\">    refs-&gt;removeStrongRef(id); <span class=\"comment\">//移除强引用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs-&gt;decWeak(id); <span class=\"comment\">// 移除弱引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycleUnchecked</span><span class=\"params\">()</span> </span>&#123;                 </span><br><span class=\"line\">    <span class=\"comment\">// 标记为使用状态，清除其他状态     </span></span><br><span class=\"line\">    flags = FLAG_IN_USE;                  </span><br><span class=\"line\">    what = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg1 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg2 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    obj = <span class=\"keyword\">null</span>;                           </span><br><span class=\"line\">    replyTo = <span class=\"keyword\">null</span>;                       </span><br><span class=\"line\">    sendingUid = -<span class=\"number\">1</span>;                      </span><br><span class=\"line\">    when = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    target = <span class=\"keyword\">null</span>;                        </span><br><span class=\"line\">    callback = <span class=\"keyword\">null</span>;                      </span><br><span class=\"line\">    data = <span class=\"keyword\">null</span>;                          </span><br><span class=\"line\">                                          </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;  </span><br><span class=\"line\">            next = sPool;                 </span><br><span class=\"line\">            sPool = <span class=\"keyword\">this</span>;                 </span><br><span class=\"line\">            sPoolSize++;                  </span><br><span class=\"line\">        &#125;                                 </span><br><span class=\"line\">    &#125;                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;             </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从缓存中获取</span></span><br><span class=\"line\">            Message m = sPool;               </span><br><span class=\"line\">            sPool = m.next;                  </span><br><span class=\"line\">            m.next = <span class=\"keyword\">null</span>;                   </span><br><span class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></span><br><span class=\"line\">            sPoolSize--;                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;                        </span><br><span class=\"line\">        &#125;                                    </span><br><span class=\"line\">    &#125;                                        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://gityuan.com/images/handler/handler_java.jpg\" alt=\"消息机制\" title=\"\">\n                </div>\n                <div class=\"image-caption\">消息机制</div>\n            </figure>\n<p>Java 层：</p>\n<ul>\n<li>Handler 通过 <code>sendMessage</code>，将 Message 通过 <code>MessageQueue.enqueueMessage</code> 添加到队列中</li>\n<li>Looper 通过 <code>loop</code> 提取需要执行的 Message，并交与 <code>Message.target</code> 的 Handler 进行 <code>dispatchMessage</code> 分发</li>\n<li>将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler </li>\n</ul>\n<p>JNI 层：</p>\n<ul>\n<li>线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态</li>\n<li>通过 epoll 机制监听 <code>EPOLLIN</code> 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程</li>\n</ul>\n<p>消息分发的优先级：</p>\n<ol>\n<li><code>Message.callback.run()</code></li>\n<li><code>Handler.mCallback.handleMessage()</code></li>\n<li><code>Handler.handleMessage()</code></li>\n</ol>\n<blockquote>\n<p>EPOLL：Linux 内核的可扩展 I/O 事件通知机制</p>\n<p>PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入</p>\n<p>文件描述符(File descriptor)：用于表述指向<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">文件</a>的引用的抽象化概念</p>\n</blockquote>\n"},{"title":"Gradle插件-提高篇","date":"2018-05-21T00:44:35.000Z","_content":"\n## 前言\n\n在上一篇文章 [Gradle插件-基础篇](https://linxiaotao.github.io/2018/05/16/Gradle%E6%8F%92%E4%BB%B6-%E5%9F%BA%E7%A1%80%E7%AF%87/) 中，我们学习了 Plugin 的设计规范，并且通过一个非常简单的例子对自定义 Plugin 有了初步认识，在这篇文章中，我们来继续学习 Gradle Plugin 更为深入的知识点。\n\n> 本文参考 [Gradle用户手册](https://guides.gradle.org/implementing-gradle-plugins/?_ga=2.31320828.258862271.1526633053-590693097.1523454314#writing-and-using-custom-task-types) \n\n## Gradle插件\n\n> 本文涉及的所有源码都位于 [github](https://github.com/LinXiaoTao/GradleCaseProject)\n\n### 简单扩展\n\n当我们引入 Android Plugin 时，在 `android{}` 有一些常用的配置，比如：\n\n``` groovy\nandroid {\n    compileSdkVersion 27\n}\n```\n\n如果我们想在自定义的 Plugin 中也使用这样的配置，可以使用 Gradle 提供的扩展功能：`Extensions` ，在第一篇文章中我们自定义了一个简单的 `com.example.hello` 插件，我们现在就在这个基础上添加一个扩展功能，最终实现的配置如下：\n\n``` groovy\nhello {\n    outFile 'hello'\n}\n```\n\n向 outFile 指定的文件中写入一句 \"Hello World\"，如文件不存在则创建它。\n\n为了创建扩展，我们先定义一个数据模型用于读取配置：\n\n``` java\npublic class HelloModel {\n    \n    private String outFile;\n\n    public String getOutFile() {\n        return outFile;\n    }\n\n    public void setOutFile(String outFile) {\n        this.outFile = outFile;\n    }\n}\n```\n\n接着使用 `ExtensionContainer` 创建一个扩展：\n\n``` java\nproject.getExtensions().create(\"hello\", HelloModel.class);\n```\n\n`getExtensions(String,Class,Object...)` 这个方法有三个参数，第一个参数为扩展的名称即在 ***gradle*** 文件中使用的配置块，第二个参数为扩展的模型，用于定义可配置的属性，在上面的例子上，只有一个简单的 `outFile` 表示输出文件，第三个参数为可变长参数，表示模型的构造参数，在这个例子中，我们使用默认的无参构造函数。\n\n经过上面的步骤，我们已经创建好了扩展，接下来是读取扩展的属性值，还记得我们之前说的，**Gradle 是边读取边解释**，所以当我们 `apply plugin` 时，会创建好扩展，而扩展的属性值配置只能在 `apply plugin` 之后，所以我们在 plugin 中直接读取扩展属性值是不行的，必须在项目评估完成之后：\n\n``` java \nproject.afterEvaluate(project1 -> {\n            HelloModel helloModel = project1.getExtensions().getByType(HelloModel.class);\n            mLogger.quiet(\"hello : \" + helloModel);\n            if (helloModel.getOutFile() == null || helloModel.getOutFile().isEmpty()) {\n                throw new GradleException(\"outFile 不能等于空\");\n            }\n            FileOutputStream fileOutputStream = null;\n            try {\n                File outFile = project1.file(helloModel.getOutFile());\n                if (!outFile.exists()) {\n                    outFile.createNewFile();\n                }\n                fileOutputStream = new FileOutputStream(outFile);\n                fileOutputStream.write(\"Hello World\".getBytes());\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (fileOutputStream != null) {\n                    try {\n                        fileOutputStream.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n```\n\n逻辑比较简单，我们现在直接运行在 `.gradlew` 即可，可以看到在 app 目录下生成一个 ***hello*** 文件：\n\n```\nHello World\n```\n\n### 嵌套扩展\n\n如果要想实现如下 DSL 配置：\n\n``` groovy\nandroid {\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n    }\n}\n```\n\nGradle 也支持这种嵌套扩展，同样是上面的例子，我们现在想添加一个 `info` 配置块，将这部分的信息也写入到文件中，最终配置如下：\n\n``` groovy\nhello {\n    outFile = 'hello'\n    info {\n        username = \"leo\"\n        email = \"linxiaotao1993@vip.qq.com\"\n    }\n}\n```\n\n首先我们先创建一个 InfoModel，这里有个要注意的地方：用于实现扩展的类不能是 `final`，因为最终用于扩展的实现类就是继承于这个类。\n\n``` java\nstatic class InfoModel {\n        private String username;\n        private String email;\n\n        @Inject\n        public InfoModel() {\n        }\n\n        public String getUsername() {\n            return username;\n        }\n\n        public void setUsername(String username) {\n            this.username = username;\n        }\n\n        public String getEmail() {\n            return email;\n        }\n\n        public void setEmail(String email) {\n            this.email = email;\n        }\n\n        @Override\n        public String toString() {\n            return \"InfoModel{\" +\n                    \"username='\" + username + '\\'' +\n                    \", email='\" + email + '\\'' +\n                    '}';\n        }\n    }\n```\n\n上面在构造方法中添加 `@Inject` 注解是为了能用 Gradle 提供的 `ObjectFactor` 用于实现依赖注入功能。而在原来的 `HelloModel` 中，我们增加了 `private final InfoModel info;` 同时在构建函数中增加了 `ObjectFactory` 参数：\n\n``` java\npublic HelloModel(ObjectFactory objectFactory) {\n        info = objectFactory.newInstance(InfoModel.class);\n}\n```\n\n但这样还不够，还需要当 `info` 配置块被调用时所传递的实例：\n\n``` java\npublic void info(Action<InfoModel> action) {\n        action.execute(info);\n}\n```\n\n注意：这里的方法名和 DSL 中的使用的配置块名称一致。\n\n最后我们在写入文件时，将这部分配置的信息也写入，同时在生成扩展时提供 `ObjectFactor` 实例：\n\n``` java\nproject.getExtensions().create(\"hello\", HelloModel.class, project.getObjects());\n\nfileOutputStream.write(String.format(\n                        Locale.getDefault(),\n                        \"Hello World\\ncreate by %s %s\",\n                        helloModel.getInfo().getUsername(),\n                        helloModel.getInfo().getEmail()).getBytes()\n                      );\n```\n\n最后执行下就可以看到结果了。\n\n> 可以看到 Gradle 可以很方便地使用依赖注入。\n\n### 配置容器\n\n在 Android 项目中，我们可以去配置不同的构建变体：\n\n``` groovy\nflavorDimensions \"api\", \"mode\"\n    productFlavors {\n        demo {\n            dimension \"mode\"\n        }\n        full {\n            dimension \"mode\"\n        }\n        minApi24 {\n            dimension \"api\"\n        }\n        minApi23 {\n            dimension \"api\"\n        }\n    }\n```\n\n如果我们想要实现类似 `productFlavors` 这种动态生成的 DSL 配置块，我们可以使用 `NamedDomainObjectContainer` 来实现，接着上面的例子，我们最终的配置如下：\n\n``` groovy\nhello {\n    outFile = 'hello'\n    info {\n        username = \"leo\"\n        email = \"linxiaotao1993@vip.qq.com\"\n    }\n    other {\n        time {\n            value = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date())\n        }\n    }\n}\n```\n\n我们先创建 `ValueModel` 用于表示容器中每一项的格式，注意：这个类必须有个字段为 `name` ，比如上面的例子中，`name` 就是我们配置的 `time`：\n\n``` java\npublic class ValueModel {\n\n    private final String name;\n    private String value;\n\n    public ValueModel(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"ValueModel{\" +\n                \"name='\" + name + '\\'' +\n                \", value='\" + value + '\\'' +\n                '}';\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n```\n\n> 这个类不能写成内部类，静态内部类也不行\n\n接着，我们在 `HelloModel` 中同样创建 `other` 配置块，需要注意的是，这里我们要使用 `NamedDomainObjectContainer` ：\n\n``` java\npublic void other(Action<NamedDomainObjectContainer<ValueModel>> action) {\n        action.execute(other);\n}\n```\n\n而 `other` 则是这样子创建的：\n\n``` java\nother = project.container(ValueModel.class);\n```\n\n最后，同样的，我们将这块的配置也写入到 `hello` 文件中：\n\n``` java\nStringBuilder otherString = new StringBuilder();\n                helloModel.getOther().forEach(valueModel ->\n                        otherString.append(valueModel.getName())\n                                .append(\"：\")\n                                .append(valueModel.getValue())\n                                .append(\"\\n\"));\n                fileOutputStream.write(String.format(\n                        Locale.getDefault(),\n                        \"Hello World\\ncreate by %s %s\\n%s\",\n                        helloModel.getInfo().getUsername(),\n                        helloModel.getInfo().getEmail(),\n                        otherString.toString()).getBytes()\n);\n```\n\n### 懒加载属性\n\n在上面的例子中，我们都是通过使用原始数据类型去映射在构建脚本中的配置，这种方式会在配置完成之后直接映射，Gradle 4.0 提供了 `Provider` 和 `Property` 来提供懒加载属性，其中 `Provider` 表示不可变属性，`Property` 表示可变属性。这个 API 提供了两个好处：\n\n1. 可以放心地连接不同的数据模型，而不用担心某个数据模型的值是否已经知道。举个例子，比如你想将扩展中的属性映射到 task 中的属性，但扩展的属性值只有在构建脚本配置后才能知道。\n2. 避免在构建阶段进行资源密集型工作，比如当属性值时从文件中解析时\n\n使用也比较简单，首先我们先声明一个`Property<String>` 然后使用 `ObjectFactor` 去创建：\n\n``` java\nprivate final Property<String> testProperty;\n\ntestProperty = project.getObjects().property(String.class);\n```\n\n> Gradle 会自动为 `Property` 生成 setter 方法，同时允许你使用 \"=\" 操作符来设置属性值\n\n## 总结\n\n在这篇文章中，我们主要讲的是，在自定义 Plugin 中经常用的到扩展功能，下一篇文章中，我们就开始进入 Plugin 的编写。","source":"_posts/Gradle插件-提高篇.md","raw":"---\ntitle: Gradle插件-提高篇\ndate: 2018-05-21 08:44:35\ncategories: Gradle\ntags:\n---\n\n## 前言\n\n在上一篇文章 [Gradle插件-基础篇](https://linxiaotao.github.io/2018/05/16/Gradle%E6%8F%92%E4%BB%B6-%E5%9F%BA%E7%A1%80%E7%AF%87/) 中，我们学习了 Plugin 的设计规范，并且通过一个非常简单的例子对自定义 Plugin 有了初步认识，在这篇文章中，我们来继续学习 Gradle Plugin 更为深入的知识点。\n\n> 本文参考 [Gradle用户手册](https://guides.gradle.org/implementing-gradle-plugins/?_ga=2.31320828.258862271.1526633053-590693097.1523454314#writing-and-using-custom-task-types) \n\n## Gradle插件\n\n> 本文涉及的所有源码都位于 [github](https://github.com/LinXiaoTao/GradleCaseProject)\n\n### 简单扩展\n\n当我们引入 Android Plugin 时，在 `android{}` 有一些常用的配置，比如：\n\n``` groovy\nandroid {\n    compileSdkVersion 27\n}\n```\n\n如果我们想在自定义的 Plugin 中也使用这样的配置，可以使用 Gradle 提供的扩展功能：`Extensions` ，在第一篇文章中我们自定义了一个简单的 `com.example.hello` 插件，我们现在就在这个基础上添加一个扩展功能，最终实现的配置如下：\n\n``` groovy\nhello {\n    outFile 'hello'\n}\n```\n\n向 outFile 指定的文件中写入一句 \"Hello World\"，如文件不存在则创建它。\n\n为了创建扩展，我们先定义一个数据模型用于读取配置：\n\n``` java\npublic class HelloModel {\n    \n    private String outFile;\n\n    public String getOutFile() {\n        return outFile;\n    }\n\n    public void setOutFile(String outFile) {\n        this.outFile = outFile;\n    }\n}\n```\n\n接着使用 `ExtensionContainer` 创建一个扩展：\n\n``` java\nproject.getExtensions().create(\"hello\", HelloModel.class);\n```\n\n`getExtensions(String,Class,Object...)` 这个方法有三个参数，第一个参数为扩展的名称即在 ***gradle*** 文件中使用的配置块，第二个参数为扩展的模型，用于定义可配置的属性，在上面的例子上，只有一个简单的 `outFile` 表示输出文件，第三个参数为可变长参数，表示模型的构造参数，在这个例子中，我们使用默认的无参构造函数。\n\n经过上面的步骤，我们已经创建好了扩展，接下来是读取扩展的属性值，还记得我们之前说的，**Gradle 是边读取边解释**，所以当我们 `apply plugin` 时，会创建好扩展，而扩展的属性值配置只能在 `apply plugin` 之后，所以我们在 plugin 中直接读取扩展属性值是不行的，必须在项目评估完成之后：\n\n``` java \nproject.afterEvaluate(project1 -> {\n            HelloModel helloModel = project1.getExtensions().getByType(HelloModel.class);\n            mLogger.quiet(\"hello : \" + helloModel);\n            if (helloModel.getOutFile() == null || helloModel.getOutFile().isEmpty()) {\n                throw new GradleException(\"outFile 不能等于空\");\n            }\n            FileOutputStream fileOutputStream = null;\n            try {\n                File outFile = project1.file(helloModel.getOutFile());\n                if (!outFile.exists()) {\n                    outFile.createNewFile();\n                }\n                fileOutputStream = new FileOutputStream(outFile);\n                fileOutputStream.write(\"Hello World\".getBytes());\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (fileOutputStream != null) {\n                    try {\n                        fileOutputStream.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n```\n\n逻辑比较简单，我们现在直接运行在 `.gradlew` 即可，可以看到在 app 目录下生成一个 ***hello*** 文件：\n\n```\nHello World\n```\n\n### 嵌套扩展\n\n如果要想实现如下 DSL 配置：\n\n``` groovy\nandroid {\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n    }\n}\n```\n\nGradle 也支持这种嵌套扩展，同样是上面的例子，我们现在想添加一个 `info` 配置块，将这部分的信息也写入到文件中，最终配置如下：\n\n``` groovy\nhello {\n    outFile = 'hello'\n    info {\n        username = \"leo\"\n        email = \"linxiaotao1993@vip.qq.com\"\n    }\n}\n```\n\n首先我们先创建一个 InfoModel，这里有个要注意的地方：用于实现扩展的类不能是 `final`，因为最终用于扩展的实现类就是继承于这个类。\n\n``` java\nstatic class InfoModel {\n        private String username;\n        private String email;\n\n        @Inject\n        public InfoModel() {\n        }\n\n        public String getUsername() {\n            return username;\n        }\n\n        public void setUsername(String username) {\n            this.username = username;\n        }\n\n        public String getEmail() {\n            return email;\n        }\n\n        public void setEmail(String email) {\n            this.email = email;\n        }\n\n        @Override\n        public String toString() {\n            return \"InfoModel{\" +\n                    \"username='\" + username + '\\'' +\n                    \", email='\" + email + '\\'' +\n                    '}';\n        }\n    }\n```\n\n上面在构造方法中添加 `@Inject` 注解是为了能用 Gradle 提供的 `ObjectFactor` 用于实现依赖注入功能。而在原来的 `HelloModel` 中，我们增加了 `private final InfoModel info;` 同时在构建函数中增加了 `ObjectFactory` 参数：\n\n``` java\npublic HelloModel(ObjectFactory objectFactory) {\n        info = objectFactory.newInstance(InfoModel.class);\n}\n```\n\n但这样还不够，还需要当 `info` 配置块被调用时所传递的实例：\n\n``` java\npublic void info(Action<InfoModel> action) {\n        action.execute(info);\n}\n```\n\n注意：这里的方法名和 DSL 中的使用的配置块名称一致。\n\n最后我们在写入文件时，将这部分配置的信息也写入，同时在生成扩展时提供 `ObjectFactor` 实例：\n\n``` java\nproject.getExtensions().create(\"hello\", HelloModel.class, project.getObjects());\n\nfileOutputStream.write(String.format(\n                        Locale.getDefault(),\n                        \"Hello World\\ncreate by %s %s\",\n                        helloModel.getInfo().getUsername(),\n                        helloModel.getInfo().getEmail()).getBytes()\n                      );\n```\n\n最后执行下就可以看到结果了。\n\n> 可以看到 Gradle 可以很方便地使用依赖注入。\n\n### 配置容器\n\n在 Android 项目中，我们可以去配置不同的构建变体：\n\n``` groovy\nflavorDimensions \"api\", \"mode\"\n    productFlavors {\n        demo {\n            dimension \"mode\"\n        }\n        full {\n            dimension \"mode\"\n        }\n        minApi24 {\n            dimension \"api\"\n        }\n        minApi23 {\n            dimension \"api\"\n        }\n    }\n```\n\n如果我们想要实现类似 `productFlavors` 这种动态生成的 DSL 配置块，我们可以使用 `NamedDomainObjectContainer` 来实现，接着上面的例子，我们最终的配置如下：\n\n``` groovy\nhello {\n    outFile = 'hello'\n    info {\n        username = \"leo\"\n        email = \"linxiaotao1993@vip.qq.com\"\n    }\n    other {\n        time {\n            value = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date())\n        }\n    }\n}\n```\n\n我们先创建 `ValueModel` 用于表示容器中每一项的格式，注意：这个类必须有个字段为 `name` ，比如上面的例子中，`name` 就是我们配置的 `time`：\n\n``` java\npublic class ValueModel {\n\n    private final String name;\n    private String value;\n\n    public ValueModel(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"ValueModel{\" +\n                \"name='\" + name + '\\'' +\n                \", value='\" + value + '\\'' +\n                '}';\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n```\n\n> 这个类不能写成内部类，静态内部类也不行\n\n接着，我们在 `HelloModel` 中同样创建 `other` 配置块，需要注意的是，这里我们要使用 `NamedDomainObjectContainer` ：\n\n``` java\npublic void other(Action<NamedDomainObjectContainer<ValueModel>> action) {\n        action.execute(other);\n}\n```\n\n而 `other` 则是这样子创建的：\n\n``` java\nother = project.container(ValueModel.class);\n```\n\n最后，同样的，我们将这块的配置也写入到 `hello` 文件中：\n\n``` java\nStringBuilder otherString = new StringBuilder();\n                helloModel.getOther().forEach(valueModel ->\n                        otherString.append(valueModel.getName())\n                                .append(\"：\")\n                                .append(valueModel.getValue())\n                                .append(\"\\n\"));\n                fileOutputStream.write(String.format(\n                        Locale.getDefault(),\n                        \"Hello World\\ncreate by %s %s\\n%s\",\n                        helloModel.getInfo().getUsername(),\n                        helloModel.getInfo().getEmail(),\n                        otherString.toString()).getBytes()\n);\n```\n\n### 懒加载属性\n\n在上面的例子中，我们都是通过使用原始数据类型去映射在构建脚本中的配置，这种方式会在配置完成之后直接映射，Gradle 4.0 提供了 `Provider` 和 `Property` 来提供懒加载属性，其中 `Provider` 表示不可变属性，`Property` 表示可变属性。这个 API 提供了两个好处：\n\n1. 可以放心地连接不同的数据模型，而不用担心某个数据模型的值是否已经知道。举个例子，比如你想将扩展中的属性映射到 task 中的属性，但扩展的属性值只有在构建脚本配置后才能知道。\n2. 避免在构建阶段进行资源密集型工作，比如当属性值时从文件中解析时\n\n使用也比较简单，首先我们先声明一个`Property<String>` 然后使用 `ObjectFactor` 去创建：\n\n``` java\nprivate final Property<String> testProperty;\n\ntestProperty = project.getObjects().property(String.class);\n```\n\n> Gradle 会自动为 `Property` 生成 setter 方法，同时允许你使用 \"=\" 操作符来设置属性值\n\n## 总结\n\n在这篇文章中，我们主要讲的是，在自定义 Plugin 中经常用的到扩展功能，下一篇文章中，我们就开始进入 Plugin 的编写。","slug":"Gradle插件-提高篇","published":1,"updated":"2018-05-27T04:41:56.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjs0hta6000hero60l6ktu1y","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在上一篇文章 <a href=\"https://linxiaotao.github.io/2018/05/16/Gradle%E6%8F%92%E4%BB%B6-%E5%9F%BA%E7%A1%80%E7%AF%87/\">Gradle插件-基础篇</a> 中，我们学习了 Plugin 的设计规范，并且通过一个非常简单的例子对自定义 Plugin 有了初步认识，在这篇文章中，我们来继续学习 Gradle Plugin 更为深入的知识点。</p>\n<blockquote>\n<p>本文参考 <a href=\"https://guides.gradle.org/implementing-gradle-plugins/?_ga=2.31320828.258862271.1526633053-590693097.1523454314#writing-and-using-custom-task-types\" target=\"_blank\" rel=\"noopener\">Gradle用户手册</a> </p>\n</blockquote>\n<h2 id=\"Gradle插件\"><a href=\"#Gradle插件\" class=\"headerlink\" title=\"Gradle插件\"></a>Gradle插件</h2><blockquote>\n<p>本文涉及的所有源码都位于 <a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">github</a></p>\n</blockquote>\n<h3 id=\"简单扩展\"><a href=\"#简单扩展\" class=\"headerlink\" title=\"简单扩展\"></a>简单扩展</h3><p>当我们引入 Android Plugin 时，在 <code>android{}</code> 有一些常用的配置，比如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想在自定义的 Plugin 中也使用这样的配置，可以使用 Gradle 提供的扩展功能：<code>Extensions</code> ，在第一篇文章中我们自定义了一个简单的 <code>com.example.hello</code> 插件，我们现在就在这个基础上添加一个扩展功能，最终实现的配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>向 outFile 指定的文件中写入一句 “Hello World”，如文件不存在则创建它。</p>\n<p>为了创建扩展，我们先定义一个数据模型用于读取配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloModel</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String outFile;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getOutFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outFile;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOutFile</span><span class=\"params\">(String outFile)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.outFile = outFile;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着使用 <code>ExtensionContainer</code> 创建一个扩展：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.getExtensions().create(<span class=\"string\">\"hello\"</span>, HelloModel.class);</span><br></pre></td></tr></table></figure>\n<p><code>getExtensions(String,Class,Object...)</code> 这个方法有三个参数，第一个参数为扩展的名称即在 <strong><em>gradle</em></strong> 文件中使用的配置块，第二个参数为扩展的模型，用于定义可配置的属性，在上面的例子上，只有一个简单的 <code>outFile</code> 表示输出文件，第三个参数为可变长参数，表示模型的构造参数，在这个例子中，我们使用默认的无参构造函数。</p>\n<p>经过上面的步骤，我们已经创建好了扩展，接下来是读取扩展的属性值，还记得我们之前说的，<strong>Gradle 是边读取边解释</strong>，所以当我们 <code>apply plugin</code> 时，会创建好扩展，而扩展的属性值配置只能在 <code>apply plugin</code> 之后，所以我们在 plugin 中直接读取扩展属性值是不行的，必须在项目评估完成之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.afterEvaluate(project1 -&gt; &#123;</span><br><span class=\"line\">            HelloModel helloModel = project1.getExtensions().getByType(HelloModel.class);</span><br><span class=\"line\">            mLogger.quiet(<span class=\"string\">\"hello : \"</span> + helloModel);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (helloModel.getOutFile() == <span class=\"keyword\">null</span> || helloModel.getOutFile().isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> GradleException(<span class=\"string\">\"outFile 不能等于空\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            FileOutputStream fileOutputStream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                File outFile = project1.file(helloModel.getOutFile());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!outFile.exists()) &#123;</span><br><span class=\"line\">                    outFile.createNewFile();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                fileOutputStream = <span class=\"keyword\">new</span> FileOutputStream(outFile);</span><br><span class=\"line\">                fileOutputStream.write(<span class=\"string\">\"Hello World\"</span>.getBytes());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fileOutputStream != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        fileOutputStream.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<p>逻辑比较简单，我们现在直接运行在 <code>.gradlew</code> 即可，可以看到在 app 目录下生成一个 <strong><em>hello</em></strong> 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌套扩展\"><a href=\"#嵌套扩展\" class=\"headerlink\" title=\"嵌套扩展\"></a>嵌套扩展</h3><p>如果要想实现如下 DSL 配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Gradle 也支持这种嵌套扩展，同样是上面的例子，我们现在想添加一个 <code>info</code> 配置块，将这部分的信息也写入到文件中，最终配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile = <span class=\"string\">'hello'</span></span><br><span class=\"line\">    info &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">        email = <span class=\"string\">\"linxiaotao1993@vip.qq.com\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们先创建一个 InfoModel，这里有个要注意的地方：用于实现扩展的类不能是 <code>final</code>，因为最终用于扩展的实现类就是继承于这个类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InfoModel</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Inject</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InfoModel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUsername</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> username;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.username = username;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> email;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(String email)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.email = email;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"InfoModel&#123;\"</span> +</span><br><span class=\"line\">                    <span class=\"string\">\"username='\"</span> + username + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                    <span class=\"string\">\", email='\"</span> + email + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                    <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面在构造方法中添加 <code>@Inject</code> 注解是为了能用 Gradle 提供的 <code>ObjectFactor</code> 用于实现依赖注入功能。而在原来的 <code>HelloModel</code> 中，我们增加了 <code>private final InfoModel info;</code> 同时在构建函数中增加了 <code>ObjectFactory</code> 参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloModel</span><span class=\"params\">(ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class=\"line\">        info = objectFactory.newInstance(InfoModel.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但这样还不够，还需要当 <code>info</code> 配置块被调用时所传递的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">info</span><span class=\"params\">(Action&lt;InfoModel&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        action.execute(info);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：这里的方法名和 DSL 中的使用的配置块名称一致。</p>\n<p>最后我们在写入文件时，将这部分配置的信息也写入，同时在生成扩展时提供 <code>ObjectFactor</code> 实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.getExtensions().create(<span class=\"string\">\"hello\"</span>, HelloModel.class, project.getObjects());</span><br><span class=\"line\"></span><br><span class=\"line\">fileOutputStream.write(String.format(</span><br><span class=\"line\">                        Locale.getDefault(),</span><br><span class=\"line\">                        <span class=\"string\">\"Hello World\\ncreate by %s %s\"</span>,</span><br><span class=\"line\">                        helloModel.getInfo().getUsername(),</span><br><span class=\"line\">                        helloModel.getInfo().getEmail()).getBytes()</span><br><span class=\"line\">                      );</span><br></pre></td></tr></table></figure>\n<p>最后执行下就可以看到结果了。</p>\n<blockquote>\n<p>可以看到 Gradle 可以很方便地使用依赖注入。</p>\n</blockquote>\n<h3 id=\"配置容器\"><a href=\"#配置容器\" class=\"headerlink\" title=\"配置容器\"></a>配置容器</h3><p>在 Android 项目中，我们可以去配置不同的构建变体：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flavorDimensions <span class=\"string\">\"api\"</span>, <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">    productFlavors &#123;</span><br><span class=\"line\">        demo &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        full &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        minApi24 &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"api\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        minApi23 &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"api\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想要实现类似 <code>productFlavors</code> 这种动态生成的 DSL 配置块，我们可以使用 <code>NamedDomainObjectContainer</code> 来实现，接着上面的例子，我们最终的配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile = <span class=\"string\">'hello'</span></span><br><span class=\"line\">    info &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">        email = <span class=\"string\">\"linxiaotao1993@vip.qq.com\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    other &#123;</span><br><span class=\"line\">        time &#123;</span><br><span class=\"line\">            value = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd\"</span>).format(<span class=\"keyword\">new</span> Date())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们先创建 <code>ValueModel</code> 用于表示容器中每一项的格式，注意：这个类必须有个字段为 <code>name</code> ，比如上面的例子中，<code>name</code> 就是我们配置的 <code>time</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValueModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ValueModel</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"ValueModel&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"name='\"</span> + name + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">\", value='\"</span> + value + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(String value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这个类不能写成内部类，静态内部类也不行</p>\n</blockquote>\n<p>接着，我们在 <code>HelloModel</code> 中同样创建 <code>other</code> 配置块，需要注意的是，这里我们要使用 <code>NamedDomainObjectContainer</code> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">other</span><span class=\"params\">(Action&lt;NamedDomainObjectContainer&lt;ValueModel&gt;&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        action.execute(other);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 <code>other</code> 则是这样子创建的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">other = project.container(ValueModel.class);</span><br></pre></td></tr></table></figure>\n<p>最后，同样的，我们将这块的配置也写入到 <code>hello</code> 文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder otherString = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                helloModel.getOther().forEach(valueModel -&gt;</span><br><span class=\"line\">                        otherString.append(valueModel.getName())</span><br><span class=\"line\">                                .append(<span class=\"string\">\"：\"</span>)</span><br><span class=\"line\">                                .append(valueModel.getValue())</span><br><span class=\"line\">                                .append(<span class=\"string\">\"\\n\"</span>));</span><br><span class=\"line\">                fileOutputStream.write(String.format(</span><br><span class=\"line\">                        Locale.getDefault(),</span><br><span class=\"line\">                        <span class=\"string\">\"Hello World\\ncreate by %s %s\\n%s\"</span>,</span><br><span class=\"line\">                        helloModel.getInfo().getUsername(),</span><br><span class=\"line\">                        helloModel.getInfo().getEmail(),</span><br><span class=\"line\">                        otherString.toString()).getBytes()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"懒加载属性\"><a href=\"#懒加载属性\" class=\"headerlink\" title=\"懒加载属性\"></a>懒加载属性</h3><p>在上面的例子中，我们都是通过使用原始数据类型去映射在构建脚本中的配置，这种方式会在配置完成之后直接映射，Gradle 4.0 提供了 <code>Provider</code> 和 <code>Property</code> 来提供懒加载属性，其中 <code>Provider</code> 表示不可变属性，<code>Property</code> 表示可变属性。这个 API 提供了两个好处：</p>\n<ol>\n<li>可以放心地连接不同的数据模型，而不用担心某个数据模型的值是否已经知道。举个例子，比如你想将扩展中的属性映射到 task 中的属性，但扩展的属性值只有在构建脚本配置后才能知道。</li>\n<li>避免在构建阶段进行资源密集型工作，比如当属性值时从文件中解析时</li>\n</ol>\n<p>使用也比较简单，首先我们先声明一个<code>Property&lt;String&gt;</code> 然后使用 <code>ObjectFactor</code> 去创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Property&lt;String&gt; testProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">testProperty = project.getObjects().property(String.class);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Gradle 会自动为 <code>Property</code> 生成 setter 方法，同时允许你使用 “=” 操作符来设置属性值</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在这篇文章中，我们主要讲的是，在自定义 Plugin 中经常用的到扩展功能，下一篇文章中，我们就开始进入 Plugin 的编写。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在上一篇文章 <a href=\"https://linxiaotao.github.io/2018/05/16/Gradle%E6%8F%92%E4%BB%B6-%E5%9F%BA%E7%A1%80%E7%AF%87/\">Gradle插件-基础篇</a> 中，我们学习了 Plugin 的设计规范，并且通过一个非常简单的例子对自定义 Plugin 有了初步认识，在这篇文章中，我们来继续学习 Gradle Plugin 更为深入的知识点。</p>\n<blockquote>\n<p>本文参考 <a href=\"https://guides.gradle.org/implementing-gradle-plugins/?_ga=2.31320828.258862271.1526633053-590693097.1523454314#writing-and-using-custom-task-types\" target=\"_blank\" rel=\"noopener\">Gradle用户手册</a> </p>\n</blockquote>\n<h2 id=\"Gradle插件\"><a href=\"#Gradle插件\" class=\"headerlink\" title=\"Gradle插件\"></a>Gradle插件</h2><blockquote>\n<p>本文涉及的所有源码都位于 <a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">github</a></p>\n</blockquote>\n<h3 id=\"简单扩展\"><a href=\"#简单扩展\" class=\"headerlink\" title=\"简单扩展\"></a>简单扩展</h3><p>当我们引入 Android Plugin 时，在 <code>android{}</code> 有一些常用的配置，比如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想在自定义的 Plugin 中也使用这样的配置，可以使用 Gradle 提供的扩展功能：<code>Extensions</code> ，在第一篇文章中我们自定义了一个简单的 <code>com.example.hello</code> 插件，我们现在就在这个基础上添加一个扩展功能，最终实现的配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>向 outFile 指定的文件中写入一句 “Hello World”，如文件不存在则创建它。</p>\n<p>为了创建扩展，我们先定义一个数据模型用于读取配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloModel</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String outFile;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getOutFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outFile;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOutFile</span><span class=\"params\">(String outFile)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.outFile = outFile;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着使用 <code>ExtensionContainer</code> 创建一个扩展：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.getExtensions().create(<span class=\"string\">\"hello\"</span>, HelloModel.class);</span><br></pre></td></tr></table></figure>\n<p><code>getExtensions(String,Class,Object...)</code> 这个方法有三个参数，第一个参数为扩展的名称即在 <strong><em>gradle</em></strong> 文件中使用的配置块，第二个参数为扩展的模型，用于定义可配置的属性，在上面的例子上，只有一个简单的 <code>outFile</code> 表示输出文件，第三个参数为可变长参数，表示模型的构造参数，在这个例子中，我们使用默认的无参构造函数。</p>\n<p>经过上面的步骤，我们已经创建好了扩展，接下来是读取扩展的属性值，还记得我们之前说的，<strong>Gradle 是边读取边解释</strong>，所以当我们 <code>apply plugin</code> 时，会创建好扩展，而扩展的属性值配置只能在 <code>apply plugin</code> 之后，所以我们在 plugin 中直接读取扩展属性值是不行的，必须在项目评估完成之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.afterEvaluate(project1 -&gt; &#123;</span><br><span class=\"line\">            HelloModel helloModel = project1.getExtensions().getByType(HelloModel.class);</span><br><span class=\"line\">            mLogger.quiet(<span class=\"string\">\"hello : \"</span> + helloModel);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (helloModel.getOutFile() == <span class=\"keyword\">null</span> || helloModel.getOutFile().isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> GradleException(<span class=\"string\">\"outFile 不能等于空\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            FileOutputStream fileOutputStream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                File outFile = project1.file(helloModel.getOutFile());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!outFile.exists()) &#123;</span><br><span class=\"line\">                    outFile.createNewFile();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                fileOutputStream = <span class=\"keyword\">new</span> FileOutputStream(outFile);</span><br><span class=\"line\">                fileOutputStream.write(<span class=\"string\">\"Hello World\"</span>.getBytes());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fileOutputStream != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        fileOutputStream.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<p>逻辑比较简单，我们现在直接运行在 <code>.gradlew</code> 即可，可以看到在 app 目录下生成一个 <strong><em>hello</em></strong> 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌套扩展\"><a href=\"#嵌套扩展\" class=\"headerlink\" title=\"嵌套扩展\"></a>嵌套扩展</h3><p>如果要想实现如下 DSL 配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Gradle 也支持这种嵌套扩展，同样是上面的例子，我们现在想添加一个 <code>info</code> 配置块，将这部分的信息也写入到文件中，最终配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile = <span class=\"string\">'hello'</span></span><br><span class=\"line\">    info &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">        email = <span class=\"string\">\"linxiaotao1993@vip.qq.com\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们先创建一个 InfoModel，这里有个要注意的地方：用于实现扩展的类不能是 <code>final</code>，因为最终用于扩展的实现类就是继承于这个类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InfoModel</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Inject</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InfoModel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUsername</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> username;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.username = username;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> email;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(String email)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.email = email;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"InfoModel&#123;\"</span> +</span><br><span class=\"line\">                    <span class=\"string\">\"username='\"</span> + username + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                    <span class=\"string\">\", email='\"</span> + email + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                    <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面在构造方法中添加 <code>@Inject</code> 注解是为了能用 Gradle 提供的 <code>ObjectFactor</code> 用于实现依赖注入功能。而在原来的 <code>HelloModel</code> 中，我们增加了 <code>private final InfoModel info;</code> 同时在构建函数中增加了 <code>ObjectFactory</code> 参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloModel</span><span class=\"params\">(ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class=\"line\">        info = objectFactory.newInstance(InfoModel.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但这样还不够，还需要当 <code>info</code> 配置块被调用时所传递的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">info</span><span class=\"params\">(Action&lt;InfoModel&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        action.execute(info);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：这里的方法名和 DSL 中的使用的配置块名称一致。</p>\n<p>最后我们在写入文件时，将这部分配置的信息也写入，同时在生成扩展时提供 <code>ObjectFactor</code> 实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.getExtensions().create(<span class=\"string\">\"hello\"</span>, HelloModel.class, project.getObjects());</span><br><span class=\"line\"></span><br><span class=\"line\">fileOutputStream.write(String.format(</span><br><span class=\"line\">                        Locale.getDefault(),</span><br><span class=\"line\">                        <span class=\"string\">\"Hello World\\ncreate by %s %s\"</span>,</span><br><span class=\"line\">                        helloModel.getInfo().getUsername(),</span><br><span class=\"line\">                        helloModel.getInfo().getEmail()).getBytes()</span><br><span class=\"line\">                      );</span><br></pre></td></tr></table></figure>\n<p>最后执行下就可以看到结果了。</p>\n<blockquote>\n<p>可以看到 Gradle 可以很方便地使用依赖注入。</p>\n</blockquote>\n<h3 id=\"配置容器\"><a href=\"#配置容器\" class=\"headerlink\" title=\"配置容器\"></a>配置容器</h3><p>在 Android 项目中，我们可以去配置不同的构建变体：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flavorDimensions <span class=\"string\">\"api\"</span>, <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">    productFlavors &#123;</span><br><span class=\"line\">        demo &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        full &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        minApi24 &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"api\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        minApi23 &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"api\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想要实现类似 <code>productFlavors</code> 这种动态生成的 DSL 配置块，我们可以使用 <code>NamedDomainObjectContainer</code> 来实现，接着上面的例子，我们最终的配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile = <span class=\"string\">'hello'</span></span><br><span class=\"line\">    info &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">        email = <span class=\"string\">\"linxiaotao1993@vip.qq.com\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    other &#123;</span><br><span class=\"line\">        time &#123;</span><br><span class=\"line\">            value = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd\"</span>).format(<span class=\"keyword\">new</span> Date())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们先创建 <code>ValueModel</code> 用于表示容器中每一项的格式，注意：这个类必须有个字段为 <code>name</code> ，比如上面的例子中，<code>name</code> 就是我们配置的 <code>time</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValueModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ValueModel</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"ValueModel&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"name='\"</span> + name + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">\", value='\"</span> + value + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(String value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这个类不能写成内部类，静态内部类也不行</p>\n</blockquote>\n<p>接着，我们在 <code>HelloModel</code> 中同样创建 <code>other</code> 配置块，需要注意的是，这里我们要使用 <code>NamedDomainObjectContainer</code> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">other</span><span class=\"params\">(Action&lt;NamedDomainObjectContainer&lt;ValueModel&gt;&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        action.execute(other);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 <code>other</code> 则是这样子创建的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">other = project.container(ValueModel.class);</span><br></pre></td></tr></table></figure>\n<p>最后，同样的，我们将这块的配置也写入到 <code>hello</code> 文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder otherString = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                helloModel.getOther().forEach(valueModel -&gt;</span><br><span class=\"line\">                        otherString.append(valueModel.getName())</span><br><span class=\"line\">                                .append(<span class=\"string\">\"：\"</span>)</span><br><span class=\"line\">                                .append(valueModel.getValue())</span><br><span class=\"line\">                                .append(<span class=\"string\">\"\\n\"</span>));</span><br><span class=\"line\">                fileOutputStream.write(String.format(</span><br><span class=\"line\">                        Locale.getDefault(),</span><br><span class=\"line\">                        <span class=\"string\">\"Hello World\\ncreate by %s %s\\n%s\"</span>,</span><br><span class=\"line\">                        helloModel.getInfo().getUsername(),</span><br><span class=\"line\">                        helloModel.getInfo().getEmail(),</span><br><span class=\"line\">                        otherString.toString()).getBytes()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"懒加载属性\"><a href=\"#懒加载属性\" class=\"headerlink\" title=\"懒加载属性\"></a>懒加载属性</h3><p>在上面的例子中，我们都是通过使用原始数据类型去映射在构建脚本中的配置，这种方式会在配置完成之后直接映射，Gradle 4.0 提供了 <code>Provider</code> 和 <code>Property</code> 来提供懒加载属性，其中 <code>Provider</code> 表示不可变属性，<code>Property</code> 表示可变属性。这个 API 提供了两个好处：</p>\n<ol>\n<li>可以放心地连接不同的数据模型，而不用担心某个数据模型的值是否已经知道。举个例子，比如你想将扩展中的属性映射到 task 中的属性，但扩展的属性值只有在构建脚本配置后才能知道。</li>\n<li>避免在构建阶段进行资源密集型工作，比如当属性值时从文件中解析时</li>\n</ol>\n<p>使用也比较简单，首先我们先声明一个<code>Property&lt;String&gt;</code> 然后使用 <code>ObjectFactor</code> 去创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Property&lt;String&gt; testProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">testProperty = project.getObjects().property(String.class);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Gradle 会自动为 <code>Property</code> 生成 setter 方法，同时允许你使用 “=” 操作符来设置属性值</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在这篇文章中，我们主要讲的是，在自定义 Plugin 中经常用的到扩展功能，下一篇文章中，我们就开始进入 Plugin 的编写。</p>\n"},{"title":"性能优化第一步","date":"2018-04-19T03:37:45.000Z","_content":"\n## 感谢\n\n[cpu-profiler](https://developer.android.com/studio/profile/cpu-profiler.html)\n\n## 前言\n\n对于有一定 Android 应用开发经验的同学来说，性能优化是避不开的话题，一般来说，Android 上我们常说的性能优化包括，内存优化和界面优化，当然还有电量优化、网络优化等等。性能优化知识的学习是一个长期的过程，也不可能通过一两篇文章就能说的清楚，需要在具有相关的理论知识的前提下，同时在日常开发中加以实践，才能在这方面的工作中得心应手。\n\n同时作者也并不是这方面的大牛，还处于入门学习的阶段，所以也会遇到初学者经常碰到的问题，其中，我个人认为阻碍初学者在这方面深入学习的一个原因是，大部分的文章都偏向于理论知识和工具使用说明，很多同学包括作者在看完这些文章，都有着似懂非懂的感觉，只记住了工具的名称，但等到自己去实际使用时，却不知道如何下手。这也是这个系列文章存在的意义，希望能通过实际例子去使用工具，从而能掌握工具基本的使用，之后在实际开发中，通过经常使用来达到得心应手的地步。\n\n## 例子\n\n作者最近刚接手一个新项目，在首页列表滑动时就感到有点不顺畅，特别是在滑动到有 ViewPager 部分的时候，如果是熟悉的项目，可能会第一时间会去检查代码，但前面说到这个是刚接手的项目，同时首页的代码逻辑比较复杂，不花点时间熟悉下代码可能很难找出问题来，那在这种情况下，我们就只能通过外部工具来检查，快速定位问题。\n\nAndroid Studio 提供了一个非常好用的工具：Android Profiler，基本可以满足大部分的场景了。所以下面的分析我们都基于 Android Profiler。\n\n为了更直观的观察问题，我创建了个 Demo，里面包含了问题代码，首先我们先通过两个 gif 图来看下，没有问题代码之前和加了问题代码之后的运行情况：\n\n![正常](http://oy017242u.bkt.clouddn.com/source.gif)\n\n![问题代码](http://oy017242u.bkt.clouddn.com/low.gif)\n\n上面的 gif 图中，我们先开启了 [GPU 呈现模式分析](https://github.com/LinXiaoTao/notes/blob/master/android/topic/performance/rendering/profile-gpu.md) 后面的文章中我们会说到这个，现在只需要了解横坐标表示应用绘制渲染的每一帧，纵坐标表示每一帧绘制渲染的时间，绿线表示 16.6 ms，也就是要想保持应用能够流畅使用，我们应该让页面绘制渲染时间尽量位于绿线之下。\n\n从第一张动图中可以看到页面每一帧的绘制渲染时间都基本处于绿线之下，而第二章动图加了问题代码之后，出现了不少帧出现了绘制渲染时间过长的情况。\n\n接下来，我们可以使用 Android Profiler 来对应用进行分析，在这个例子中，我们只使用 [cpu-profiler](https://developer.android.com/studio/profile/cpu-profiler.html) 功能。具体介绍可以看官方文档，下面就官方提供的图片简单说下：\n\n![cpu-profiler](http://oy017242u.bkt.clouddn.com/cpu_profiler_L2-2X.png)\n\n这是 cpu-profiler 的主界面，具体各个部分的说明可以阅读官方文档，我们只需要知道这里记录了各个线程的活动状态：\n\n* 绿色：表示线程处于活动状态或准备使用 CPU。 即，它正在“运行中”或处于“可运行”状态。\n* 黄色：表示线程处于活动状态，但它正在等待一个 I/O 操作（如磁盘或网络 I/O），然后才能完成它的工作。\n* 灰色：表示线程正在休眠且没有消耗任何 CPU 时间。 当线程需要访问尚不可用的资源时偶尔会发生这种情况。 线程进入自主休眠或内核将此线程置于休眠状态，直到所需的资源可用。\n\n可以看到标记 5 为一个记录按钮，用于开始和停止记录[函数跟踪](https://developer.android.com/studio/profile/cpu-profiler.html#method_traces)。这个是我们这篇文章所要着重讲的功能，接下来我们看下函数跟踪的功能面板，图片同样来源于官方文档：\n\n![method-traces](http://oy017242u.bkt.clouddn.com/cpu_profiler_L3-2X.png)\n\n使用方式很简单，先点击记录按钮，接着在应用上操作一小会，接着再次按下按钮，结束记录。上图则是记录后的面版：\n\n* 标记 1和标记 2 表示这次函数跟踪的时间段\n* 标记 3 表示函数跟踪的结果，具体展示跟标记 4 所选的展示标签有关\n* 标记 4 则是不同的展示标签\n* 标记 5 则是函数调用的时间信息：\n  * Wall clock time: 壁钟时间信息表示实际经过的时间\n  * Thread time: 线程时间信息表示实际经过的时间减去线程没有消耗 CPU 资源的任意时间部分。 对于任何给定函数，其线程时间始终少于或等于其壁钟时间。 使用线程时间可以让您更好地了解线程的实际 CPU 使用率中有多少是给定函数消耗的\n\n标记 4 中包含的标签包括：Call Chart、Flame Chart、Top Down 和 Bottom Up，具体的含义可以阅读[官方文档](https://developer.android.com/studio/profile/cpu-profiler.html#method_traces)，这里我们同样只是简单解释下：\n\n* Call Chart：函数调用情况的图形化界面。从上至下表示父函数和子函数的调用情况。\n\n  > 这里我们的父函数指的是，调用其他函数的函数，而被调用的函数称为该父函数的子函数。\n\n  ![call-chart](http://oy017242u.bkt.clouddn.com/call-chart.png)\n\n  可以看到，应用的执行开始于 `ZygoteInit.main()` 其中系统 API 的调用表示为橙色，第三方 API 包括 Java 的调用表示为蓝色，应用自有函数的调用表示为绿色。\n\n* Flame Chart：提供一个倒置的调用图表，其汇总相同的调用堆栈，简单来说就是将 Call Chart 倒置过来\n\n  ![flame-chart](http://oy017242u.bkt.clouddn.com/flame-chart.png)\n\n* Top Down：显示一个函数调用列表，在该列表中展开函数节点会被调用的子函数\n\n  ![top-down](http://oy017242u.bkt.clouddn.com/top-down.png)\n\n* Bottom Up：显示一个函数调用列表，在该列表中展开函数节点将显示函数的父函数\n\n  ![bottom-up](http://oy017242u.bkt.clouddn.com/bottom-up.png)\n\n简单了解每个选项的功能后，我们针对上面的 demo 来实践下，这里我们选择 bottom up 选项，从上面图看出，每个函数所展示的信息有：Total（函数总共花费的时间）、%（所占的百分比）、Self（函数自身花费的时间）、%（所占的百分比）、Children（函数所调用的子函数花费的时间），%（所占百分比）。可以看到 `main()` `run()` 这些方法的时间主要都是花费在调用子函数上。那么我们先找出本身最耗时的方法，使用 Self 进行排序：\n\n![max-self-method](http://oy017242u.bkt.clouddn.com/max-self-method.png)\n\n很清楚的看出， `setConfiguration()` 函数是除了 `nativePollOnce()` 之外最耗时的函数，而 `nativePollOnce()` 是系统函数，是 Handle 用于阻塞获取栈中下一个执行的消息，具体可以看另外一篇文章，[Android消息机制-Handler](https://linxiaotao.github.io/2018/03/23/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler/) 所以这个函数我们这里不需要关心它，所以我们打开 `setConfiguration()` 的父函数调用链，可以发现最终指到我们应用自身的函数，即 `MainActivity.getResources()` 这时候，我们就可以找到对应的类和函数，也可以使用快捷跳转方式：\t**Jump To Source**，我们看下具体的函数实现：\n\n``` java\n@Override                                                     \npublic Resources getResources() {                             \n    Resources res = super.getResources();                     \n    Configuration config = new Configuration();               \n    config.setToDefaults();                                   \n    res.updateConfiguration(config, res.getDisplayMetrics()); \n    return res;                                               \n}                                                             \n```\n\n从代码中可以看出，耗时函数就出在 `res.updateConfiguration()`，而 `getResources()` 会在比如 View 的构造函数中或者 inflate 布局时候被调用，我们上面的例子实现的是，使用 ViewPager 去实现图片滑动浏览的效果，ViewPager 在滑动的时候会调用 `instantiateItem()` 函数去生成新的 item：\n\n``` java\n@NonNull                                                                                                         \n@Override                                                                                                        \npublic Object instantiateItem(@NonNull ViewGroup container, int position) {                                      \n    final TextView childView = (TextView) View.inflate(container.getContext(), R.layout.item_image, null);       \n    childView.setText(String.valueOf(position));                                                                 \n    container.addView(childView);                                                                                \n    return childView;                                                                                            \n}                                                                                                                \n```\n\n这里会调用 `inflate()` 从 xml 布局文件中构建 View，而这个函数又会调用 `getResources()` 函数，最终调用到 `setConfiguration()` 上，这也是我们之所以在滑动的时候，会出现卡顿的原因。\n\n## 小结\n\n在上面的例子上，我们不需要去纠结为什么要重载 `getResources()` 而是通过这个例子达到能简单使用 cpu-profiler 的目的。\n\n当然你也可以使用其他工具来检查，比如 [method-trace](https://developer.android.com/studio/profile/am-methodtrace.html) 等等，但最终目的是一样的，找到耗时函数，从而去优化它。\n\n","source":"_posts/性能优化第一步.md","raw":"---\ntitle: 性能优化第一步\ndate: 2018-04-19 11:37:45\ncategories: Android Application\n---\n\n## 感谢\n\n[cpu-profiler](https://developer.android.com/studio/profile/cpu-profiler.html)\n\n## 前言\n\n对于有一定 Android 应用开发经验的同学来说，性能优化是避不开的话题，一般来说，Android 上我们常说的性能优化包括，内存优化和界面优化，当然还有电量优化、网络优化等等。性能优化知识的学习是一个长期的过程，也不可能通过一两篇文章就能说的清楚，需要在具有相关的理论知识的前提下，同时在日常开发中加以实践，才能在这方面的工作中得心应手。\n\n同时作者也并不是这方面的大牛，还处于入门学习的阶段，所以也会遇到初学者经常碰到的问题，其中，我个人认为阻碍初学者在这方面深入学习的一个原因是，大部分的文章都偏向于理论知识和工具使用说明，很多同学包括作者在看完这些文章，都有着似懂非懂的感觉，只记住了工具的名称，但等到自己去实际使用时，却不知道如何下手。这也是这个系列文章存在的意义，希望能通过实际例子去使用工具，从而能掌握工具基本的使用，之后在实际开发中，通过经常使用来达到得心应手的地步。\n\n## 例子\n\n作者最近刚接手一个新项目，在首页列表滑动时就感到有点不顺畅，特别是在滑动到有 ViewPager 部分的时候，如果是熟悉的项目，可能会第一时间会去检查代码，但前面说到这个是刚接手的项目，同时首页的代码逻辑比较复杂，不花点时间熟悉下代码可能很难找出问题来，那在这种情况下，我们就只能通过外部工具来检查，快速定位问题。\n\nAndroid Studio 提供了一个非常好用的工具：Android Profiler，基本可以满足大部分的场景了。所以下面的分析我们都基于 Android Profiler。\n\n为了更直观的观察问题，我创建了个 Demo，里面包含了问题代码，首先我们先通过两个 gif 图来看下，没有问题代码之前和加了问题代码之后的运行情况：\n\n![正常](http://oy017242u.bkt.clouddn.com/source.gif)\n\n![问题代码](http://oy017242u.bkt.clouddn.com/low.gif)\n\n上面的 gif 图中，我们先开启了 [GPU 呈现模式分析](https://github.com/LinXiaoTao/notes/blob/master/android/topic/performance/rendering/profile-gpu.md) 后面的文章中我们会说到这个，现在只需要了解横坐标表示应用绘制渲染的每一帧，纵坐标表示每一帧绘制渲染的时间，绿线表示 16.6 ms，也就是要想保持应用能够流畅使用，我们应该让页面绘制渲染时间尽量位于绿线之下。\n\n从第一张动图中可以看到页面每一帧的绘制渲染时间都基本处于绿线之下，而第二章动图加了问题代码之后，出现了不少帧出现了绘制渲染时间过长的情况。\n\n接下来，我们可以使用 Android Profiler 来对应用进行分析，在这个例子中，我们只使用 [cpu-profiler](https://developer.android.com/studio/profile/cpu-profiler.html) 功能。具体介绍可以看官方文档，下面就官方提供的图片简单说下：\n\n![cpu-profiler](http://oy017242u.bkt.clouddn.com/cpu_profiler_L2-2X.png)\n\n这是 cpu-profiler 的主界面，具体各个部分的说明可以阅读官方文档，我们只需要知道这里记录了各个线程的活动状态：\n\n* 绿色：表示线程处于活动状态或准备使用 CPU。 即，它正在“运行中”或处于“可运行”状态。\n* 黄色：表示线程处于活动状态，但它正在等待一个 I/O 操作（如磁盘或网络 I/O），然后才能完成它的工作。\n* 灰色：表示线程正在休眠且没有消耗任何 CPU 时间。 当线程需要访问尚不可用的资源时偶尔会发生这种情况。 线程进入自主休眠或内核将此线程置于休眠状态，直到所需的资源可用。\n\n可以看到标记 5 为一个记录按钮，用于开始和停止记录[函数跟踪](https://developer.android.com/studio/profile/cpu-profiler.html#method_traces)。这个是我们这篇文章所要着重讲的功能，接下来我们看下函数跟踪的功能面板，图片同样来源于官方文档：\n\n![method-traces](http://oy017242u.bkt.clouddn.com/cpu_profiler_L3-2X.png)\n\n使用方式很简单，先点击记录按钮，接着在应用上操作一小会，接着再次按下按钮，结束记录。上图则是记录后的面版：\n\n* 标记 1和标记 2 表示这次函数跟踪的时间段\n* 标记 3 表示函数跟踪的结果，具体展示跟标记 4 所选的展示标签有关\n* 标记 4 则是不同的展示标签\n* 标记 5 则是函数调用的时间信息：\n  * Wall clock time: 壁钟时间信息表示实际经过的时间\n  * Thread time: 线程时间信息表示实际经过的时间减去线程没有消耗 CPU 资源的任意时间部分。 对于任何给定函数，其线程时间始终少于或等于其壁钟时间。 使用线程时间可以让您更好地了解线程的实际 CPU 使用率中有多少是给定函数消耗的\n\n标记 4 中包含的标签包括：Call Chart、Flame Chart、Top Down 和 Bottom Up，具体的含义可以阅读[官方文档](https://developer.android.com/studio/profile/cpu-profiler.html#method_traces)，这里我们同样只是简单解释下：\n\n* Call Chart：函数调用情况的图形化界面。从上至下表示父函数和子函数的调用情况。\n\n  > 这里我们的父函数指的是，调用其他函数的函数，而被调用的函数称为该父函数的子函数。\n\n  ![call-chart](http://oy017242u.bkt.clouddn.com/call-chart.png)\n\n  可以看到，应用的执行开始于 `ZygoteInit.main()` 其中系统 API 的调用表示为橙色，第三方 API 包括 Java 的调用表示为蓝色，应用自有函数的调用表示为绿色。\n\n* Flame Chart：提供一个倒置的调用图表，其汇总相同的调用堆栈，简单来说就是将 Call Chart 倒置过来\n\n  ![flame-chart](http://oy017242u.bkt.clouddn.com/flame-chart.png)\n\n* Top Down：显示一个函数调用列表，在该列表中展开函数节点会被调用的子函数\n\n  ![top-down](http://oy017242u.bkt.clouddn.com/top-down.png)\n\n* Bottom Up：显示一个函数调用列表，在该列表中展开函数节点将显示函数的父函数\n\n  ![bottom-up](http://oy017242u.bkt.clouddn.com/bottom-up.png)\n\n简单了解每个选项的功能后，我们针对上面的 demo 来实践下，这里我们选择 bottom up 选项，从上面图看出，每个函数所展示的信息有：Total（函数总共花费的时间）、%（所占的百分比）、Self（函数自身花费的时间）、%（所占的百分比）、Children（函数所调用的子函数花费的时间），%（所占百分比）。可以看到 `main()` `run()` 这些方法的时间主要都是花费在调用子函数上。那么我们先找出本身最耗时的方法，使用 Self 进行排序：\n\n![max-self-method](http://oy017242u.bkt.clouddn.com/max-self-method.png)\n\n很清楚的看出， `setConfiguration()` 函数是除了 `nativePollOnce()` 之外最耗时的函数，而 `nativePollOnce()` 是系统函数，是 Handle 用于阻塞获取栈中下一个执行的消息，具体可以看另外一篇文章，[Android消息机制-Handler](https://linxiaotao.github.io/2018/03/23/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler/) 所以这个函数我们这里不需要关心它，所以我们打开 `setConfiguration()` 的父函数调用链，可以发现最终指到我们应用自身的函数，即 `MainActivity.getResources()` 这时候，我们就可以找到对应的类和函数，也可以使用快捷跳转方式：\t**Jump To Source**，我们看下具体的函数实现：\n\n``` java\n@Override                                                     \npublic Resources getResources() {                             \n    Resources res = super.getResources();                     \n    Configuration config = new Configuration();               \n    config.setToDefaults();                                   \n    res.updateConfiguration(config, res.getDisplayMetrics()); \n    return res;                                               \n}                                                             \n```\n\n从代码中可以看出，耗时函数就出在 `res.updateConfiguration()`，而 `getResources()` 会在比如 View 的构造函数中或者 inflate 布局时候被调用，我们上面的例子实现的是，使用 ViewPager 去实现图片滑动浏览的效果，ViewPager 在滑动的时候会调用 `instantiateItem()` 函数去生成新的 item：\n\n``` java\n@NonNull                                                                                                         \n@Override                                                                                                        \npublic Object instantiateItem(@NonNull ViewGroup container, int position) {                                      \n    final TextView childView = (TextView) View.inflate(container.getContext(), R.layout.item_image, null);       \n    childView.setText(String.valueOf(position));                                                                 \n    container.addView(childView);                                                                                \n    return childView;                                                                                            \n}                                                                                                                \n```\n\n这里会调用 `inflate()` 从 xml 布局文件中构建 View，而这个函数又会调用 `getResources()` 函数，最终调用到 `setConfiguration()` 上，这也是我们之所以在滑动的时候，会出现卡顿的原因。\n\n## 小结\n\n在上面的例子上，我们不需要去纠结为什么要重载 `getResources()` 而是通过这个例子达到能简单使用 cpu-profiler 的目的。\n\n当然你也可以使用其他工具来检查，比如 [method-trace](https://developer.android.com/studio/profile/am-methodtrace.html) 等等，但最终目的是一样的，找到耗时函数，从而去优化它。\n\n","slug":"性能优化第一步","published":1,"updated":"2018-04-22T04:45:28.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjs0hta8000iero6q14j1nyz","content":"<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"https://developer.android.com/studio/profile/cpu-profiler.html\" target=\"_blank\" rel=\"noopener\">cpu-profiler</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于有一定 Android 应用开发经验的同学来说，性能优化是避不开的话题，一般来说，Android 上我们常说的性能优化包括，内存优化和界面优化，当然还有电量优化、网络优化等等。性能优化知识的学习是一个长期的过程，也不可能通过一两篇文章就能说的清楚，需要在具有相关的理论知识的前提下，同时在日常开发中加以实践，才能在这方面的工作中得心应手。</p>\n<p>同时作者也并不是这方面的大牛，还处于入门学习的阶段，所以也会遇到初学者经常碰到的问题，其中，我个人认为阻碍初学者在这方面深入学习的一个原因是，大部分的文章都偏向于理论知识和工具使用说明，很多同学包括作者在看完这些文章，都有着似懂非懂的感觉，只记住了工具的名称，但等到自己去实际使用时，却不知道如何下手。这也是这个系列文章存在的意义，希望能通过实际例子去使用工具，从而能掌握工具基本的使用，之后在实际开发中，通过经常使用来达到得心应手的地步。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>作者最近刚接手一个新项目，在首页列表滑动时就感到有点不顺畅，特别是在滑动到有 ViewPager 部分的时候，如果是熟悉的项目，可能会第一时间会去检查代码，但前面说到这个是刚接手的项目，同时首页的代码逻辑比较复杂，不花点时间熟悉下代码可能很难找出问题来，那在这种情况下，我们就只能通过外部工具来检查，快速定位问题。</p>\n<p>Android Studio 提供了一个非常好用的工具：Android Profiler，基本可以满足大部分的场景了。所以下面的分析我们都基于 Android Profiler。</p>\n<p>为了更直观的观察问题，我创建了个 Demo，里面包含了问题代码，首先我们先通过两个 gif 图来看下，没有问题代码之前和加了问题代码之后的运行情况：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/source.gif\" alt=\"正常\" title=\"\">\n                </div>\n                <div class=\"image-caption\">正常</div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/low.gif\" alt=\"问题代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">问题代码</div>\n            </figure>\n<p>上面的 gif 图中，我们先开启了 <a href=\"https://github.com/LinXiaoTao/notes/blob/master/android/topic/performance/rendering/profile-gpu.md\" target=\"_blank\" rel=\"noopener\">GPU 呈现模式分析</a> 后面的文章中我们会说到这个，现在只需要了解横坐标表示应用绘制渲染的每一帧，纵坐标表示每一帧绘制渲染的时间，绿线表示 16.6 ms，也就是要想保持应用能够流畅使用，我们应该让页面绘制渲染时间尽量位于绿线之下。</p>\n<p>从第一张动图中可以看到页面每一帧的绘制渲染时间都基本处于绿线之下，而第二章动图加了问题代码之后，出现了不少帧出现了绘制渲染时间过长的情况。</p>\n<p>接下来，我们可以使用 Android Profiler 来对应用进行分析，在这个例子中，我们只使用 <a href=\"https://developer.android.com/studio/profile/cpu-profiler.html\" target=\"_blank\" rel=\"noopener\">cpu-profiler</a> 功能。具体介绍可以看官方文档，下面就官方提供的图片简单说下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/cpu_profiler_L2-2X.png\" alt=\"cpu-profiler\" title=\"\">\n                </div>\n                <div class=\"image-caption\">cpu-profiler</div>\n            </figure>\n<p>这是 cpu-profiler 的主界面，具体各个部分的说明可以阅读官方文档，我们只需要知道这里记录了各个线程的活动状态：</p>\n<ul>\n<li>绿色：表示线程处于活动状态或准备使用 CPU。 即，它正在“运行中”或处于“可运行”状态。</li>\n<li>黄色：表示线程处于活动状态，但它正在等待一个 I/O 操作（如磁盘或网络 I/O），然后才能完成它的工作。</li>\n<li>灰色：表示线程正在休眠且没有消耗任何 CPU 时间。 当线程需要访问尚不可用的资源时偶尔会发生这种情况。 线程进入自主休眠或内核将此线程置于休眠状态，直到所需的资源可用。</li>\n</ul>\n<p>可以看到标记 5 为一个记录按钮，用于开始和停止记录<a href=\"https://developer.android.com/studio/profile/cpu-profiler.html#method_traces\" target=\"_blank\" rel=\"noopener\">函数跟踪</a>。这个是我们这篇文章所要着重讲的功能，接下来我们看下函数跟踪的功能面板，图片同样来源于官方文档：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/cpu_profiler_L3-2X.png\" alt=\"method-traces\" title=\"\">\n                </div>\n                <div class=\"image-caption\">method-traces</div>\n            </figure>\n<p>使用方式很简单，先点击记录按钮，接着在应用上操作一小会，接着再次按下按钮，结束记录。上图则是记录后的面版：</p>\n<ul>\n<li>标记 1和标记 2 表示这次函数跟踪的时间段</li>\n<li>标记 3 表示函数跟踪的结果，具体展示跟标记 4 所选的展示标签有关</li>\n<li>标记 4 则是不同的展示标签</li>\n<li>标记 5 则是函数调用的时间信息：<ul>\n<li>Wall clock time: 壁钟时间信息表示实际经过的时间</li>\n<li>Thread time: 线程时间信息表示实际经过的时间减去线程没有消耗 CPU 资源的任意时间部分。 对于任何给定函数，其线程时间始终少于或等于其壁钟时间。 使用线程时间可以让您更好地了解线程的实际 CPU 使用率中有多少是给定函数消耗的</li>\n</ul>\n</li>\n</ul>\n<p>标记 4 中包含的标签包括：Call Chart、Flame Chart、Top Down 和 Bottom Up，具体的含义可以阅读<a href=\"https://developer.android.com/studio/profile/cpu-profiler.html#method_traces\" target=\"_blank\" rel=\"noopener\">官方文档</a>，这里我们同样只是简单解释下：</p>\n<ul>\n<li><p>Call Chart：函数调用情况的图形化界面。从上至下表示父函数和子函数的调用情况。</p>\n<blockquote>\n<p>这里我们的父函数指的是，调用其他函数的函数，而被调用的函数称为该父函数的子函数。</p>\n</blockquote>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/call-chart.png\" alt=\"call-chart\"></p>\n<p>可以看到，应用的执行开始于 <code>ZygoteInit.main()</code> 其中系统 API 的调用表示为橙色，第三方 API 包括 Java 的调用表示为蓝色，应用自有函数的调用表示为绿色。</p>\n</li>\n<li><p>Flame Chart：提供一个倒置的调用图表，其汇总相同的调用堆栈，简单来说就是将 Call Chart 倒置过来</p>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/flame-chart.png\" alt=\"flame-chart\"></p>\n</li>\n<li><p>Top Down：显示一个函数调用列表，在该列表中展开函数节点会被调用的子函数</p>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/top-down.png\" alt=\"top-down\"></p>\n</li>\n<li><p>Bottom Up：显示一个函数调用列表，在该列表中展开函数节点将显示函数的父函数</p>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/bottom-up.png\" alt=\"bottom-up\"></p>\n</li>\n</ul>\n<p>简单了解每个选项的功能后，我们针对上面的 demo 来实践下，这里我们选择 bottom up 选项，从上面图看出，每个函数所展示的信息有：Total（函数总共花费的时间）、%（所占的百分比）、Self（函数自身花费的时间）、%（所占的百分比）、Children（函数所调用的子函数花费的时间），%（所占百分比）。可以看到 <code>main()</code> <code>run()</code> 这些方法的时间主要都是花费在调用子函数上。那么我们先找出本身最耗时的方法，使用 Self 进行排序：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/max-self-method.png\" alt=\"max-self-method\" title=\"\">\n                </div>\n                <div class=\"image-caption\">max-self-method</div>\n            </figure>\n<p>很清楚的看出， <code>setConfiguration()</code> 函数是除了 <code>nativePollOnce()</code> 之外最耗时的函数，而 <code>nativePollOnce()</code> 是系统函数，是 Handle 用于阻塞获取栈中下一个执行的消息，具体可以看另外一篇文章，<a href=\"https://linxiaotao.github.io/2018/03/23/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler/\">Android消息机制-Handler</a> 所以这个函数我们这里不需要关心它，所以我们打开 <code>setConfiguration()</code> 的父函数调用链，可以发现最终指到我们应用自身的函数，即 <code>MainActivity.getResources()</code> 这时候，我们就可以找到对应的类和函数，也可以使用快捷跳转方式：    <strong>Jump To Source</strong>，我们看下具体的函数实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                     </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resources <span class=\"title\">getResources</span><span class=\"params\">()</span> </span>&#123;                             </span><br><span class=\"line\">    Resources res = <span class=\"keyword\">super</span>.getResources();                     </span><br><span class=\"line\">    Configuration config = <span class=\"keyword\">new</span> Configuration();               </span><br><span class=\"line\">    config.setToDefaults();                                   </span><br><span class=\"line\">    res.updateConfiguration(config, res.getDisplayMetrics()); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码中可以看出，耗时函数就出在 <code>res.updateConfiguration()</code>，而 <code>getResources()</code> 会在比如 View 的构造函数中或者 inflate 布局时候被调用，我们上面的例子实现的是，使用 ViewPager 去实现图片滑动浏览的效果，ViewPager 在滑动的时候会调用 <code>instantiateItem()</code> 函数去生成新的 item：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                                                         </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">instantiateItem</span><span class=\"params\">(@NonNull ViewGroup container, <span class=\"keyword\">int</span> position)</span> </span>&#123;                                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> TextView childView = (TextView) View.inflate(container.getContext(), R.layout.item_image, <span class=\"keyword\">null</span>);       </span><br><span class=\"line\">    childView.setText(String.valueOf(position));                                                                 </span><br><span class=\"line\">    container.addView(childView);                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> childView;                                                                                            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里会调用 <code>inflate()</code> 从 xml 布局文件中构建 View，而这个函数又会调用 <code>getResources()</code> 函数，最终调用到 <code>setConfiguration()</code> 上，这也是我们之所以在滑动的时候，会出现卡顿的原因。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在上面的例子上，我们不需要去纠结为什么要重载 <code>getResources()</code> 而是通过这个例子达到能简单使用 cpu-profiler 的目的。</p>\n<p>当然你也可以使用其他工具来检查，比如 <a href=\"https://developer.android.com/studio/profile/am-methodtrace.html\" target=\"_blank\" rel=\"noopener\">method-trace</a> 等等，但最终目的是一样的，找到耗时函数，从而去优化它。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"https://developer.android.com/studio/profile/cpu-profiler.html\" target=\"_blank\" rel=\"noopener\">cpu-profiler</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于有一定 Android 应用开发经验的同学来说，性能优化是避不开的话题，一般来说，Android 上我们常说的性能优化包括，内存优化和界面优化，当然还有电量优化、网络优化等等。性能优化知识的学习是一个长期的过程，也不可能通过一两篇文章就能说的清楚，需要在具有相关的理论知识的前提下，同时在日常开发中加以实践，才能在这方面的工作中得心应手。</p>\n<p>同时作者也并不是这方面的大牛，还处于入门学习的阶段，所以也会遇到初学者经常碰到的问题，其中，我个人认为阻碍初学者在这方面深入学习的一个原因是，大部分的文章都偏向于理论知识和工具使用说明，很多同学包括作者在看完这些文章，都有着似懂非懂的感觉，只记住了工具的名称，但等到自己去实际使用时，却不知道如何下手。这也是这个系列文章存在的意义，希望能通过实际例子去使用工具，从而能掌握工具基本的使用，之后在实际开发中，通过经常使用来达到得心应手的地步。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>作者最近刚接手一个新项目，在首页列表滑动时就感到有点不顺畅，特别是在滑动到有 ViewPager 部分的时候，如果是熟悉的项目，可能会第一时间会去检查代码，但前面说到这个是刚接手的项目，同时首页的代码逻辑比较复杂，不花点时间熟悉下代码可能很难找出问题来，那在这种情况下，我们就只能通过外部工具来检查，快速定位问题。</p>\n<p>Android Studio 提供了一个非常好用的工具：Android Profiler，基本可以满足大部分的场景了。所以下面的分析我们都基于 Android Profiler。</p>\n<p>为了更直观的观察问题，我创建了个 Demo，里面包含了问题代码，首先我们先通过两个 gif 图来看下，没有问题代码之前和加了问题代码之后的运行情况：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/source.gif\" alt=\"正常\" title=\"\">\n                </div>\n                <div class=\"image-caption\">正常</div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/low.gif\" alt=\"问题代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">问题代码</div>\n            </figure>\n<p>上面的 gif 图中，我们先开启了 <a href=\"https://github.com/LinXiaoTao/notes/blob/master/android/topic/performance/rendering/profile-gpu.md\" target=\"_blank\" rel=\"noopener\">GPU 呈现模式分析</a> 后面的文章中我们会说到这个，现在只需要了解横坐标表示应用绘制渲染的每一帧，纵坐标表示每一帧绘制渲染的时间，绿线表示 16.6 ms，也就是要想保持应用能够流畅使用，我们应该让页面绘制渲染时间尽量位于绿线之下。</p>\n<p>从第一张动图中可以看到页面每一帧的绘制渲染时间都基本处于绿线之下，而第二章动图加了问题代码之后，出现了不少帧出现了绘制渲染时间过长的情况。</p>\n<p>接下来，我们可以使用 Android Profiler 来对应用进行分析，在这个例子中，我们只使用 <a href=\"https://developer.android.com/studio/profile/cpu-profiler.html\" target=\"_blank\" rel=\"noopener\">cpu-profiler</a> 功能。具体介绍可以看官方文档，下面就官方提供的图片简单说下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/cpu_profiler_L2-2X.png\" alt=\"cpu-profiler\" title=\"\">\n                </div>\n                <div class=\"image-caption\">cpu-profiler</div>\n            </figure>\n<p>这是 cpu-profiler 的主界面，具体各个部分的说明可以阅读官方文档，我们只需要知道这里记录了各个线程的活动状态：</p>\n<ul>\n<li>绿色：表示线程处于活动状态或准备使用 CPU。 即，它正在“运行中”或处于“可运行”状态。</li>\n<li>黄色：表示线程处于活动状态，但它正在等待一个 I/O 操作（如磁盘或网络 I/O），然后才能完成它的工作。</li>\n<li>灰色：表示线程正在休眠且没有消耗任何 CPU 时间。 当线程需要访问尚不可用的资源时偶尔会发生这种情况。 线程进入自主休眠或内核将此线程置于休眠状态，直到所需的资源可用。</li>\n</ul>\n<p>可以看到标记 5 为一个记录按钮，用于开始和停止记录<a href=\"https://developer.android.com/studio/profile/cpu-profiler.html#method_traces\" target=\"_blank\" rel=\"noopener\">函数跟踪</a>。这个是我们这篇文章所要着重讲的功能，接下来我们看下函数跟踪的功能面板，图片同样来源于官方文档：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/cpu_profiler_L3-2X.png\" alt=\"method-traces\" title=\"\">\n                </div>\n                <div class=\"image-caption\">method-traces</div>\n            </figure>\n<p>使用方式很简单，先点击记录按钮，接着在应用上操作一小会，接着再次按下按钮，结束记录。上图则是记录后的面版：</p>\n<ul>\n<li>标记 1和标记 2 表示这次函数跟踪的时间段</li>\n<li>标记 3 表示函数跟踪的结果，具体展示跟标记 4 所选的展示标签有关</li>\n<li>标记 4 则是不同的展示标签</li>\n<li>标记 5 则是函数调用的时间信息：<ul>\n<li>Wall clock time: 壁钟时间信息表示实际经过的时间</li>\n<li>Thread time: 线程时间信息表示实际经过的时间减去线程没有消耗 CPU 资源的任意时间部分。 对于任何给定函数，其线程时间始终少于或等于其壁钟时间。 使用线程时间可以让您更好地了解线程的实际 CPU 使用率中有多少是给定函数消耗的</li>\n</ul>\n</li>\n</ul>\n<p>标记 4 中包含的标签包括：Call Chart、Flame Chart、Top Down 和 Bottom Up，具体的含义可以阅读<a href=\"https://developer.android.com/studio/profile/cpu-profiler.html#method_traces\" target=\"_blank\" rel=\"noopener\">官方文档</a>，这里我们同样只是简单解释下：</p>\n<ul>\n<li><p>Call Chart：函数调用情况的图形化界面。从上至下表示父函数和子函数的调用情况。</p>\n<blockquote>\n<p>这里我们的父函数指的是，调用其他函数的函数，而被调用的函数称为该父函数的子函数。</p>\n</blockquote>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/call-chart.png\" alt=\"call-chart\"></p>\n<p>可以看到，应用的执行开始于 <code>ZygoteInit.main()</code> 其中系统 API 的调用表示为橙色，第三方 API 包括 Java 的调用表示为蓝色，应用自有函数的调用表示为绿色。</p>\n</li>\n<li><p>Flame Chart：提供一个倒置的调用图表，其汇总相同的调用堆栈，简单来说就是将 Call Chart 倒置过来</p>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/flame-chart.png\" alt=\"flame-chart\"></p>\n</li>\n<li><p>Top Down：显示一个函数调用列表，在该列表中展开函数节点会被调用的子函数</p>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/top-down.png\" alt=\"top-down\"></p>\n</li>\n<li><p>Bottom Up：显示一个函数调用列表，在该列表中展开函数节点将显示函数的父函数</p>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/bottom-up.png\" alt=\"bottom-up\"></p>\n</li>\n</ul>\n<p>简单了解每个选项的功能后，我们针对上面的 demo 来实践下，这里我们选择 bottom up 选项，从上面图看出，每个函数所展示的信息有：Total（函数总共花费的时间）、%（所占的百分比）、Self（函数自身花费的时间）、%（所占的百分比）、Children（函数所调用的子函数花费的时间），%（所占百分比）。可以看到 <code>main()</code> <code>run()</code> 这些方法的时间主要都是花费在调用子函数上。那么我们先找出本身最耗时的方法，使用 Self 进行排序：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/max-self-method.png\" alt=\"max-self-method\" title=\"\">\n                </div>\n                <div class=\"image-caption\">max-self-method</div>\n            </figure>\n<p>很清楚的看出， <code>setConfiguration()</code> 函数是除了 <code>nativePollOnce()</code> 之外最耗时的函数，而 <code>nativePollOnce()</code> 是系统函数，是 Handle 用于阻塞获取栈中下一个执行的消息，具体可以看另外一篇文章，<a href=\"https://linxiaotao.github.io/2018/03/23/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler/\">Android消息机制-Handler</a> 所以这个函数我们这里不需要关心它，所以我们打开 <code>setConfiguration()</code> 的父函数调用链，可以发现最终指到我们应用自身的函数，即 <code>MainActivity.getResources()</code> 这时候，我们就可以找到对应的类和函数，也可以使用快捷跳转方式：    <strong>Jump To Source</strong>，我们看下具体的函数实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                     </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resources <span class=\"title\">getResources</span><span class=\"params\">()</span> </span>&#123;                             </span><br><span class=\"line\">    Resources res = <span class=\"keyword\">super</span>.getResources();                     </span><br><span class=\"line\">    Configuration config = <span class=\"keyword\">new</span> Configuration();               </span><br><span class=\"line\">    config.setToDefaults();                                   </span><br><span class=\"line\">    res.updateConfiguration(config, res.getDisplayMetrics()); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码中可以看出，耗时函数就出在 <code>res.updateConfiguration()</code>，而 <code>getResources()</code> 会在比如 View 的构造函数中或者 inflate 布局时候被调用，我们上面的例子实现的是，使用 ViewPager 去实现图片滑动浏览的效果，ViewPager 在滑动的时候会调用 <code>instantiateItem()</code> 函数去生成新的 item：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                                                         </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">instantiateItem</span><span class=\"params\">(@NonNull ViewGroup container, <span class=\"keyword\">int</span> position)</span> </span>&#123;                                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> TextView childView = (TextView) View.inflate(container.getContext(), R.layout.item_image, <span class=\"keyword\">null</span>);       </span><br><span class=\"line\">    childView.setText(String.valueOf(position));                                                                 </span><br><span class=\"line\">    container.addView(childView);                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> childView;                                                                                            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里会调用 <code>inflate()</code> 从 xml 布局文件中构建 View，而这个函数又会调用 <code>getResources()</code> 函数，最终调用到 <code>setConfiguration()</code> 上，这也是我们之所以在滑动的时候，会出现卡顿的原因。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在上面的例子上，我们不需要去纠结为什么要重载 <code>getResources()</code> 而是通过这个例子达到能简单使用 cpu-profiler 的目的。</p>\n<p>当然你也可以使用其他工具来检查，比如 <a href=\"https://developer.android.com/studio/profile/am-methodtrace.html\" target=\"_blank\" rel=\"noopener\">method-trace</a> 等等，但最终目的是一样的，找到耗时函数，从而去优化它。</p>\n"},{"title":"触摸事件实践之路","date":"2018-04-03T01:17:20.000Z","_content":"\n## 前言\n\n最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。\n\n## 触摸事件简单回顾\n\n我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。\n\n![TouchEvent](http://oy017242u.bkt.clouddn.com/TouchEvent.png?time=123)\n\n上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 `dispatchTouchEvent` 开始分发，先判断 ViewGroup 的 `onInterceptTouchEvent` 是否拦截，同时这里也可以调用 ViewGroup 的 `requestDisallowInterceptTouchEvent` 让 ViewGroup 不调用 `onInterceptTouchEvent`，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 `dispatchTouchEvent`，反之，则调用子视图的 `dispatchTouchEvent`，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 `dispatchTouchEvent`。\n\n最终都会调用到 View 的 `onTouchEvent` 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。\n\n## 手势判定\n\n上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。\n\n当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：\n\nScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 `onInterceptTouchEvent`\n\n> 因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。\n>\n> 源码部分基于 Android 26\n\n### onInterceptTouchEvent\n\n``` java\nif ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {\n    return true;\n}\n```\n\n用 `mIsBeingDragged` 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 `ACTION_MOVE`，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。\n\n#### TOUCH_DOWN\n\n``` java\nif (!inChild((int) ev.getX(), (int) y)) {\n    mIsBeingDragged = false;\n    recycleVelocityTracker();\n    break;\n}\n```\n\n这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。\n\n``` java\nmLastMotionY = y;\nmActivePointerId = ev.getPointerId(0);\ninitOrResetVelocityTracker();\nmVelocityTracker.addMovement(ev);\n\nmScroller.computeScrollOffset();\nmIsBeingDragged = !mScroller.isFinished();\n\nstartNestedScroll(SCROLL_AXIS_VERTICAL);\n```\n\n这段代码主要是用于初始化判定之前的资源，比如 `mLastMotionY` 记录按下时的坐标信息，`mActivePointerId` 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，`initOrResetVelocityTracker` 初始化速度跟踪器，同时使用 `addMovement` 记录当前触摸事件信息，`mScroller` 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，`startNestedScroll` 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。\n\n#### TOUCH_MOVE\n\n```java\nfinal int activePointerId = mActivePointerId;\nif (activePointerId == INVALID_POINTER) {\n    break;\n}\nfinal int pointerIndex = ev.findPointerIndex(activePointerId);\nif (pointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(pointerIndex);\nfinal int yDiff = Math.abs(y - mLastMotionY);\nif (yDiff > mTouchSlop && (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {\n    mIsBeingDragged = true;\n    mLastMotionY = y;\n    initVelocityTrackerIfNotExists();\n    mVelocityTracker.addMovement(ev);\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n```\n\n这段代码先使用我们在 `TOUCH_DOWN` 中记录的  `mActivePointerId` 进行是否为有效的判断，如果有效，则通过 `findPointerIndex` 获取作用手指 id 的下标，记录为  `pointerIndex` ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。`yDiff` 是滑动的距离，`mTouchSlop` 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 `getScaledTouchSlop` 获取，如果大于这个值，我们可以认为开始了拖动的手势。 `getNestedScrollAxes` 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，`mIsBeingDragged` 标记为 `true`，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 `requestDisallowInterceptTouchEvent`，防止父视图拦截了事件，即 `onInterceptTouchEvent`\n\n#### TOUCH_CANCEL && TOUCH_UP\n\n``` java\nmIsBeingDragged = false;\nmActivePointerId = INVALID_POINTER;\nrecycleVelocityTracker();\nstopNestedScroll();\n```\n\n一般我们都会在 `TOUCH_CANCEL` 和 `TOUCH_UP` 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 `mIsBeingDragged` 设置为 `false`，释放速度跟踪器等等 \n\n> `TOUCH_UP` 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 `TOUCH_CANCEL` 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 `TOUCH_DOWN`，即在这个事件分发时，向父视图传递了 `true` 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 `ACTION_MOVE` 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 `onInterceptTouch` 中返回了 `true`，那么在 ViewGroup 的 `dispatchTouchEvent` 中会给已经确认消费事件的子视图分发一个 `TOUCH_CANCEL` 的事件，具体可以阅读源码。\n\n#### ACTION_POINTER_UP\n\n这个为多指触摸时，某个手指抬起时分发的事件。\n\n``` java\nfinal int pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >>\n                MotionEvent.ACTION_POINTER_INDEX_SHIFT;\nfinal int pointerId = ev.getPointerId(pointerIndex);\nif (pointerId == mActivePointerId) {\n    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n    mLastMotionY = (int) ev.getY(newPointerIndex);\n    mActivePointerId = ev.getPointerId(newPointerIndex);\n    if (mVelocityTracker != null) {\n        mVelocityTracker.clear();\n    }\n}\n```\n\n这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源\n\n#### 小结\n\n我们可以简单总结下，`onInterceptTouchEvent` 所进行的处理，即在 `TOUCH_DOWN` 资源初始化，`TOUCH_MOVE` 判断是否开始拖动手势，`TOUCH_CANCEL` && `TOUCH_UP` 中进行资源释放。这里涉及了多指触摸的处理。\n\n### onTouchEvent\n\n`onTouchEvent` 要比 `onInterceptTouch` 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。\n\n#### TOUCH_DOWN\n\n``` java\nif (getChildCount() == 0) {\n    return false;\n}\nif ((mIsBeingDragged = !mScroller.isFinished())) {\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n\nif (!mScroller.isFinished()) {\n    mScroller.abortAnimation();\n}\n\nmLastMotionY = (int) ev.getY();\nmActivePointerId = ev.getPointerId(0);\n```\n\n同样的，`onTouchEvent` 在 `TOUCH_DOWN` 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 `abortAnimation`，如果 Scroller 还没结束 fling 计算，则中止处理。\n\n#### TOUCH_MOVE\n\n``` java\nfinal int activePointerIndex = ev.findPointerIndex(mActivePointerId);\nif (activePointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(activePointerIndex);\nint deltaY = mLastMotionY - y;\nif (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {\n    // 嵌套滚动处理\n    deltaY -= mScrollConsumed[1];\n    vtev.offsetLocation(0, mScrollOffset[1]);\n    mNestedYOffset += mScrollOffset[1];\n}\n    if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {\n        final ViewParent parent = getParent();\n        if (parent != null) {\n            parent.requestDisallowInterceptTouchEvent(true);\n        }\n        mIsBeingDragged = true;\n        if (deltaY > 0) {\n            deltaY -= mTouchSlop;\n        } else {\n            deltaY += mTouchSlop;\n        }\n    }\n    \n    if (mIsBeingDragged) {\n        /// 业务逻辑\n    }\n```\n\n这段代码同样会进行多指处理，获取指定手指的触摸事件信息。`mIsBeingDragged` 为 `false`，同时会再进行一次拖动手势的判定，判定逻辑和 `onInterceptTouchEvent` 中类似，如果 `mIsBeingDragged` 为 `true`，则开始进行真正的逻辑处理。\n\n> EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码\n\n#### TOUCH_UP\n\n``` java\nif (mIsBeingDragged) {\n    final VelocityTracker velocityTracker = mVelocityTracker;\n\tvelocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n    int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);\n    \n    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {\n    \tflingWithNestedDispatch(-initialVelocity);\n    }\n    \n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 `getYVelocity` 获取速度，在判断是否可以作为 fling 手势处理，`mMaximumVelocity` 是处理的最大速度，`mMinimumVelocity` 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 `getScaledMaximumFlingVelocity` 和 `getScaledMinimumFlingVelocity` 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：\n\n``` java\nint height = getHeight() - mPaddingBottom - mPaddingTop;\nint bottom = getChildAt(0).getHeight();\n\nmScroller.fling(mScrollX, mScrollY, 0, velocityY, 0, 0, 0,\n                    Math.max(0, bottom - height), 0, height/2);\n\npostInvalidateOnAnimation();\n```\n\n通过传递当前拖动手势速度值来调用 `fling` 进行处理，然后在 `computeScrollOffset` 方法中，进行真正的滚动处理：\n\n``` java\npublic void computeScroll() {\n    if (mScroller.computeScrollOffset()) {\n      \t// 逻辑处理\n        int x = mScroller.getCurrX();\n        int y = mScroller.getCurrY();\n        postInvalidateOnAnimation();\n    }\n}\n```\n\n首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 `computeScrollOffset` 进行计算，如果返回 `true`，表示计算还没结束，然后通过 `getCurrX` 或 `getCurrY` 获取计算后的值，最后进行真正的滚动处理，比如调用 `scrollTo` 等等，这里需要注意的是，需要调用 `invalidate` 来确保进行下一次的 `computeScroll` 调用，这里使用的 `postInvalidateOnAnimation` 其作用是类似的。\n\n#### TOUCH_CANCEL\n\n``` java\nif (mIsBeingDragged && getChildCount() > 0) {\n    if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {\n        postInvalidateOnAnimation();\n    }\n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n同样的，一般我们都会在 `TOUCH_CANCEL` 中释放资源。\n\n#### ACTION_POINTER_DOWN\n\n当有新的手指按下时分发的事件\n\n``` java\nfinal int index = ev.getActionIndex();\nmLastMotionY = (int) ev.getY(index);\nmActivePointerId = ev.getPointerId(index);\n```\n\n以新按下的手指的信息重新计算\n\n#### ACTION_POINTER_UP\n\n这里的处理和 `onInterceptTouch` 一致\n\n#### 小结\n\n`onTouchEvent` 和 `onInterceptTouchEvent` 处理有些相似，主要是在 `TOUCH_MOVE` 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 `TOUCH_UP` 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。\n\n### 总结\n\n在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 `NestedScrollView`、`RecyclerView`  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 `ViewDragHelper` ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。\n\n## 实战\n\n理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：\n\n![WheelView](https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim)\n\n![TapeView](http://oy017242u.bkt.clouddn.com/more.gif)\n\n详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是[滚轮控件](https://github.com/LinXiaoTao/WheelView)，第二个是之前参加活动的仿薄荷健康的[卷尺控件](https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md)。在这里我们只分析部分代码：\n\n### 滚轮控件\n\n在前面手势判定中的分析中，我们提到在 `onTouchEvent` 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：\n\n``` java\nif (mIsBeingDragged) {\n    mDistanceY += mLastY - moveY;\n    postInvalidateOnAnimation();\n}\n```\n\n在每次 `TOUCH_MOVE` 事件分发时，计算与 `TOUCH_DOWN` 时记录的位置信息的差值，保存为 `mDistanceY`，并且在 `onDraw` 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。\n\n### 卷尺控件\n\n拖动距离的计算与滚轮控件一样，只是记录为 `mOffsetLeft` 而已，同时两个控件都有在 `onTouchEvent` 的 `ACTION_UP` 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。\n\n## 结语\n\n文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。\n\n但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：\n\n* 最基本的拖动手势处理\n* fling 效果实现\n* 如果可以，再实现边缘效果\n\n感谢大家的阅读。\n\n\n\n","source":"_posts/触摸事件实践之路.md","raw":"---\ntitle: 触摸事件实践之路\ndate: 2018-04-03 09:17:20\ncategories: Android Application\ntags: \n---\n\n## 前言\n\n最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。\n\n## 触摸事件简单回顾\n\n我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。\n\n![TouchEvent](http://oy017242u.bkt.clouddn.com/TouchEvent.png?time=123)\n\n上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 `dispatchTouchEvent` 开始分发，先判断 ViewGroup 的 `onInterceptTouchEvent` 是否拦截，同时这里也可以调用 ViewGroup 的 `requestDisallowInterceptTouchEvent` 让 ViewGroup 不调用 `onInterceptTouchEvent`，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 `dispatchTouchEvent`，反之，则调用子视图的 `dispatchTouchEvent`，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 `dispatchTouchEvent`。\n\n最终都会调用到 View 的 `onTouchEvent` 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。\n\n## 手势判定\n\n上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。\n\n当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：\n\nScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 `onInterceptTouchEvent`\n\n> 因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。\n>\n> 源码部分基于 Android 26\n\n### onInterceptTouchEvent\n\n``` java\nif ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {\n    return true;\n}\n```\n\n用 `mIsBeingDragged` 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 `ACTION_MOVE`，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。\n\n#### TOUCH_DOWN\n\n``` java\nif (!inChild((int) ev.getX(), (int) y)) {\n    mIsBeingDragged = false;\n    recycleVelocityTracker();\n    break;\n}\n```\n\n这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。\n\n``` java\nmLastMotionY = y;\nmActivePointerId = ev.getPointerId(0);\ninitOrResetVelocityTracker();\nmVelocityTracker.addMovement(ev);\n\nmScroller.computeScrollOffset();\nmIsBeingDragged = !mScroller.isFinished();\n\nstartNestedScroll(SCROLL_AXIS_VERTICAL);\n```\n\n这段代码主要是用于初始化判定之前的资源，比如 `mLastMotionY` 记录按下时的坐标信息，`mActivePointerId` 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，`initOrResetVelocityTracker` 初始化速度跟踪器，同时使用 `addMovement` 记录当前触摸事件信息，`mScroller` 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，`startNestedScroll` 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。\n\n#### TOUCH_MOVE\n\n```java\nfinal int activePointerId = mActivePointerId;\nif (activePointerId == INVALID_POINTER) {\n    break;\n}\nfinal int pointerIndex = ev.findPointerIndex(activePointerId);\nif (pointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(pointerIndex);\nfinal int yDiff = Math.abs(y - mLastMotionY);\nif (yDiff > mTouchSlop && (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {\n    mIsBeingDragged = true;\n    mLastMotionY = y;\n    initVelocityTrackerIfNotExists();\n    mVelocityTracker.addMovement(ev);\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n```\n\n这段代码先使用我们在 `TOUCH_DOWN` 中记录的  `mActivePointerId` 进行是否为有效的判断，如果有效，则通过 `findPointerIndex` 获取作用手指 id 的下标，记录为  `pointerIndex` ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。`yDiff` 是滑动的距离，`mTouchSlop` 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 `getScaledTouchSlop` 获取，如果大于这个值，我们可以认为开始了拖动的手势。 `getNestedScrollAxes` 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，`mIsBeingDragged` 标记为 `true`，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 `requestDisallowInterceptTouchEvent`，防止父视图拦截了事件，即 `onInterceptTouchEvent`\n\n#### TOUCH_CANCEL && TOUCH_UP\n\n``` java\nmIsBeingDragged = false;\nmActivePointerId = INVALID_POINTER;\nrecycleVelocityTracker();\nstopNestedScroll();\n```\n\n一般我们都会在 `TOUCH_CANCEL` 和 `TOUCH_UP` 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 `mIsBeingDragged` 设置为 `false`，释放速度跟踪器等等 \n\n> `TOUCH_UP` 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 `TOUCH_CANCEL` 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 `TOUCH_DOWN`，即在这个事件分发时，向父视图传递了 `true` 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 `ACTION_MOVE` 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 `onInterceptTouch` 中返回了 `true`，那么在 ViewGroup 的 `dispatchTouchEvent` 中会给已经确认消费事件的子视图分发一个 `TOUCH_CANCEL` 的事件，具体可以阅读源码。\n\n#### ACTION_POINTER_UP\n\n这个为多指触摸时，某个手指抬起时分发的事件。\n\n``` java\nfinal int pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >>\n                MotionEvent.ACTION_POINTER_INDEX_SHIFT;\nfinal int pointerId = ev.getPointerId(pointerIndex);\nif (pointerId == mActivePointerId) {\n    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n    mLastMotionY = (int) ev.getY(newPointerIndex);\n    mActivePointerId = ev.getPointerId(newPointerIndex);\n    if (mVelocityTracker != null) {\n        mVelocityTracker.clear();\n    }\n}\n```\n\n这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源\n\n#### 小结\n\n我们可以简单总结下，`onInterceptTouchEvent` 所进行的处理，即在 `TOUCH_DOWN` 资源初始化，`TOUCH_MOVE` 判断是否开始拖动手势，`TOUCH_CANCEL` && `TOUCH_UP` 中进行资源释放。这里涉及了多指触摸的处理。\n\n### onTouchEvent\n\n`onTouchEvent` 要比 `onInterceptTouch` 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。\n\n#### TOUCH_DOWN\n\n``` java\nif (getChildCount() == 0) {\n    return false;\n}\nif ((mIsBeingDragged = !mScroller.isFinished())) {\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n\nif (!mScroller.isFinished()) {\n    mScroller.abortAnimation();\n}\n\nmLastMotionY = (int) ev.getY();\nmActivePointerId = ev.getPointerId(0);\n```\n\n同样的，`onTouchEvent` 在 `TOUCH_DOWN` 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 `abortAnimation`，如果 Scroller 还没结束 fling 计算，则中止处理。\n\n#### TOUCH_MOVE\n\n``` java\nfinal int activePointerIndex = ev.findPointerIndex(mActivePointerId);\nif (activePointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(activePointerIndex);\nint deltaY = mLastMotionY - y;\nif (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {\n    // 嵌套滚动处理\n    deltaY -= mScrollConsumed[1];\n    vtev.offsetLocation(0, mScrollOffset[1]);\n    mNestedYOffset += mScrollOffset[1];\n}\n    if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {\n        final ViewParent parent = getParent();\n        if (parent != null) {\n            parent.requestDisallowInterceptTouchEvent(true);\n        }\n        mIsBeingDragged = true;\n        if (deltaY > 0) {\n            deltaY -= mTouchSlop;\n        } else {\n            deltaY += mTouchSlop;\n        }\n    }\n    \n    if (mIsBeingDragged) {\n        /// 业务逻辑\n    }\n```\n\n这段代码同样会进行多指处理，获取指定手指的触摸事件信息。`mIsBeingDragged` 为 `false`，同时会再进行一次拖动手势的判定，判定逻辑和 `onInterceptTouchEvent` 中类似，如果 `mIsBeingDragged` 为 `true`，则开始进行真正的逻辑处理。\n\n> EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码\n\n#### TOUCH_UP\n\n``` java\nif (mIsBeingDragged) {\n    final VelocityTracker velocityTracker = mVelocityTracker;\n\tvelocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n    int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);\n    \n    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {\n    \tflingWithNestedDispatch(-initialVelocity);\n    }\n    \n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 `getYVelocity` 获取速度，在判断是否可以作为 fling 手势处理，`mMaximumVelocity` 是处理的最大速度，`mMinimumVelocity` 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 `getScaledMaximumFlingVelocity` 和 `getScaledMinimumFlingVelocity` 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：\n\n``` java\nint height = getHeight() - mPaddingBottom - mPaddingTop;\nint bottom = getChildAt(0).getHeight();\n\nmScroller.fling(mScrollX, mScrollY, 0, velocityY, 0, 0, 0,\n                    Math.max(0, bottom - height), 0, height/2);\n\npostInvalidateOnAnimation();\n```\n\n通过传递当前拖动手势速度值来调用 `fling` 进行处理，然后在 `computeScrollOffset` 方法中，进行真正的滚动处理：\n\n``` java\npublic void computeScroll() {\n    if (mScroller.computeScrollOffset()) {\n      \t// 逻辑处理\n        int x = mScroller.getCurrX();\n        int y = mScroller.getCurrY();\n        postInvalidateOnAnimation();\n    }\n}\n```\n\n首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 `computeScrollOffset` 进行计算，如果返回 `true`，表示计算还没结束，然后通过 `getCurrX` 或 `getCurrY` 获取计算后的值，最后进行真正的滚动处理，比如调用 `scrollTo` 等等，这里需要注意的是，需要调用 `invalidate` 来确保进行下一次的 `computeScroll` 调用，这里使用的 `postInvalidateOnAnimation` 其作用是类似的。\n\n#### TOUCH_CANCEL\n\n``` java\nif (mIsBeingDragged && getChildCount() > 0) {\n    if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {\n        postInvalidateOnAnimation();\n    }\n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n同样的，一般我们都会在 `TOUCH_CANCEL` 中释放资源。\n\n#### ACTION_POINTER_DOWN\n\n当有新的手指按下时分发的事件\n\n``` java\nfinal int index = ev.getActionIndex();\nmLastMotionY = (int) ev.getY(index);\nmActivePointerId = ev.getPointerId(index);\n```\n\n以新按下的手指的信息重新计算\n\n#### ACTION_POINTER_UP\n\n这里的处理和 `onInterceptTouch` 一致\n\n#### 小结\n\n`onTouchEvent` 和 `onInterceptTouchEvent` 处理有些相似，主要是在 `TOUCH_MOVE` 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 `TOUCH_UP` 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。\n\n### 总结\n\n在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 `NestedScrollView`、`RecyclerView`  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 `ViewDragHelper` ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。\n\n## 实战\n\n理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：\n\n![WheelView](https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim)\n\n![TapeView](http://oy017242u.bkt.clouddn.com/more.gif)\n\n详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是[滚轮控件](https://github.com/LinXiaoTao/WheelView)，第二个是之前参加活动的仿薄荷健康的[卷尺控件](https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md)。在这里我们只分析部分代码：\n\n### 滚轮控件\n\n在前面手势判定中的分析中，我们提到在 `onTouchEvent` 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：\n\n``` java\nif (mIsBeingDragged) {\n    mDistanceY += mLastY - moveY;\n    postInvalidateOnAnimation();\n}\n```\n\n在每次 `TOUCH_MOVE` 事件分发时，计算与 `TOUCH_DOWN` 时记录的位置信息的差值，保存为 `mDistanceY`，并且在 `onDraw` 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。\n\n### 卷尺控件\n\n拖动距离的计算与滚轮控件一样，只是记录为 `mOffsetLeft` 而已，同时两个控件都有在 `onTouchEvent` 的 `ACTION_UP` 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。\n\n## 结语\n\n文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。\n\n但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：\n\n* 最基本的拖动手势处理\n* fling 效果实现\n* 如果可以，再实现边缘效果\n\n感谢大家的阅读。\n\n\n\n","slug":"触摸事件实践之路","published":1,"updated":"2018-04-11T14:05:30.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjs0htaa000kero61n0c9ti5","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。</p>\n<h2 id=\"触摸事件简单回顾\"><a href=\"#触摸事件简单回顾\" class=\"headerlink\" title=\"触摸事件简单回顾\"></a>触摸事件简单回顾</h2><p>我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/TouchEvent.png?time=123\" alt=\"TouchEvent\" title=\"\">\n                </div>\n                <div class=\"image-caption\">TouchEvent</div>\n            </figure>\n<p>上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 <code>dispatchTouchEvent</code> 开始分发，先判断 ViewGroup 的 <code>onInterceptTouchEvent</code> 是否拦截，同时这里也可以调用 ViewGroup 的 <code>requestDisallowInterceptTouchEvent</code> 让 ViewGroup 不调用 <code>onInterceptTouchEvent</code>，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 <code>dispatchTouchEvent</code>，反之，则调用子视图的 <code>dispatchTouchEvent</code>，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 <code>dispatchTouchEvent</code>。</p>\n<p>最终都会调用到 View 的 <code>onTouchEvent</code> 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。</p>\n<h2 id=\"手势判定\"><a href=\"#手势判定\" class=\"headerlink\" title=\"手势判定\"></a>手势判定</h2><p>上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。</p>\n<p>当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：</p>\n<p>ScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 <code>onInterceptTouchEvent</code></p>\n<blockquote>\n<p>因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。</p>\n<p>源码部分基于 Android 26</p>\n</blockquote>\n<h3 id=\"onInterceptTouchEvent\"><a href=\"#onInterceptTouchEvent\" class=\"headerlink\" title=\"onInterceptTouchEvent\"></a>onInterceptTouchEvent</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 <code>mIsBeingDragged</code> 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 <code>ACTION_MOVE</code>，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。</p>\n<h4 id=\"TOUCH-DOWN\"><a href=\"#TOUCH-DOWN\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!inChild((<span class=\"keyword\">int</span>) ev.getX(), (<span class=\"keyword\">int</span>) y)) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    recycleVelocityTracker();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mLastMotionY = y;</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br><span class=\"line\">initOrResetVelocityTracker();</span><br><span class=\"line\">mVelocityTracker.addMovement(ev);</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.computeScrollOffset();</span><br><span class=\"line\">mIsBeingDragged = !mScroller.isFinished();</span><br><span class=\"line\"></span><br><span class=\"line\">startNestedScroll(SCROLL_AXIS_VERTICAL);</span><br></pre></td></tr></table></figure>\n<p>这段代码主要是用于初始化判定之前的资源，比如 <code>mLastMotionY</code> 记录按下时的坐标信息，<code>mActivePointerId</code> 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，<code>initOrResetVelocityTracker</code> 初始化速度跟踪器，同时使用 <code>addMovement</code> 记录当前触摸事件信息，<code>mScroller</code> 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，<code>startNestedScroll</code> 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。</p>\n<h4 id=\"TOUCH-MOVE\"><a href=\"#TOUCH-MOVE\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerId = mActivePointerId;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerId == INVALID_POINTER) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = ev.findPointerIndex(activePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> yDiff = Math.abs(y - mLastMotionY);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mLastMotionY = y;</span><br><span class=\"line\">    initVelocityTrackerIfNotExists();</span><br><span class=\"line\">    mVelocityTracker.addMovement(ev);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码先使用我们在 <code>TOUCH_DOWN</code> 中记录的  <code>mActivePointerId</code> 进行是否为有效的判断，如果有效，则通过 <code>findPointerIndex</code> 获取作用手指 id 的下标，记录为  <code>pointerIndex</code> ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。<code>yDiff</code> 是滑动的距离，<code>mTouchSlop</code> 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 <code>getScaledTouchSlop</code> 获取，如果大于这个值，我们可以认为开始了拖动的手势。 <code>getNestedScrollAxes</code> 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，<code>mIsBeingDragged</code> 标记为 <code>true</code>，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 <code>requestDisallowInterceptTouchEvent</code>，防止父视图拦截了事件，即 <code>onInterceptTouchEvent</code></p>\n<h4 id=\"TOUCH-CANCEL-amp-amp-TOUCH-UP\"><a href=\"#TOUCH-CANCEL-amp-amp-TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_CANCEL &amp;&amp; TOUCH_UP\"></a>TOUCH_CANCEL &amp;&amp; TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">recycleVelocityTracker();</span><br><span class=\"line\">stopNestedScroll();</span><br></pre></td></tr></table></figure>\n<p>一般我们都会在 <code>TOUCH_CANCEL</code> 和 <code>TOUCH_UP</code> 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 <code>mIsBeingDragged</code> 设置为 <code>false</code>，释放速度跟踪器等等 </p>\n<blockquote>\n<p><code>TOUCH_UP</code> 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 <code>TOUCH_CANCEL</code> 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 <code>TOUCH_DOWN</code>，即在这个事件分发时，向父视图传递了 <code>true</code> 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 <code>ACTION_MOVE</code> 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 <code>onInterceptTouch</code> 中返回了 <code>true</code>，那么在 ViewGroup 的 <code>dispatchTouchEvent</code> 中会给已经确认消费事件的子视图分发一个 <code>TOUCH_CANCEL</code> 的事件，具体可以阅读源码。</p>\n</blockquote>\n<h4 id=\"ACTION-POINTER-UP\"><a href=\"#ACTION-POINTER-UP\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这个为多指触摸时，某个手指抬起时分发的事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;</span><br><span class=\"line\">                MotionEvent.ACTION_POINTER_INDEX_SHIFT;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerId = ev.getPointerId(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerId == mActivePointerId) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> newPointerIndex = pointerIndex == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">    mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(newPointerIndex);</span><br><span class=\"line\">    mActivePointerId = ev.getPointerId(newPointerIndex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mVelocityTracker != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mVelocityTracker.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>我们可以简单总结下，<code>onInterceptTouchEvent</code> 所进行的处理，即在 <code>TOUCH_DOWN</code> 资源初始化，<code>TOUCH_MOVE</code> 判断是否开始拖动手势，<code>TOUCH_CANCEL</code> &amp;&amp; <code>TOUCH_UP</code> 中进行资源释放。这里涉及了多指触摸的处理。</p>\n<h3 id=\"onTouchEvent\"><a href=\"#onTouchEvent\" class=\"headerlink\" title=\"onTouchEvent\"></a>onTouchEvent</h3><p><code>onTouchEvent</code> 要比 <code>onInterceptTouch</code> 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。</p>\n<h4 id=\"TOUCH-DOWN-1\"><a href=\"#TOUCH-DOWN-1\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (getChildCount() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((mIsBeingDragged = !mScroller.isFinished())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!mScroller.isFinished()) &#123;</span><br><span class=\"line\">    mScroller.abortAnimation();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY();</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>同样的，<code>onTouchEvent</code> 在 <code>TOUCH_DOWN</code> 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 <code>abortAnimation</code>，如果 Scroller 还没结束 fling 计算，则中止处理。</p>\n<h4 id=\"TOUCH-MOVE-1\"><a href=\"#TOUCH-MOVE-1\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerIndex = ev.findPointerIndex(mActivePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(activePointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">int</span> deltaY = mLastMotionY - y;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (dispatchNestedPreScroll(<span class=\"number\">0</span>, deltaY, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 嵌套滚动处理</span></span><br><span class=\"line\">    deltaY -= mScrollConsumed[<span class=\"number\">1</span>];</span><br><span class=\"line\">    vtev.offsetLocation(<span class=\"number\">0</span>, mScrollOffset[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    mNestedYOffset += mScrollOffset[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mIsBeingDragged &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (deltaY &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            deltaY -= mTouchSlop;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            deltaY += mTouchSlop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码同样会进行多指处理，获取指定手指的触摸事件信息。<code>mIsBeingDragged</code> 为 <code>false</code>，同时会再进行一次拖动手势的判定，判定逻辑和 <code>onInterceptTouchEvent</code> 中类似，如果 <code>mIsBeingDragged</code> 为 <code>true</code>，则开始进行真正的逻辑处理。</p>\n<blockquote>\n<p>EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码</p>\n</blockquote>\n<h4 id=\"TOUCH-UP\"><a href=\"#TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_UP\"></a>TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> VelocityTracker velocityTracker = mVelocityTracker;</span><br><span class=\"line\">\tvelocityTracker.computeCurrentVelocity(<span class=\"number\">1000</span>, mMaximumVelocity);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> initialVelocity = (<span class=\"keyword\">int</span>) velocityTracker.getYVelocity(mActivePointerId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((Math.abs(initialVelocity) &gt; mMinimumVelocity)) &#123;</span><br><span class=\"line\">    \tflingWithNestedDispatch(-initialVelocity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 <code>getYVelocity</code> 获取速度，在判断是否可以作为 fling 手势处理，<code>mMaximumVelocity</code> 是处理的最大速度，<code>mMinimumVelocity</code> 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 <code>getScaledMaximumFlingVelocity</code> 和 <code>getScaledMinimumFlingVelocity</code> 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> height = getHeight() - mPaddingBottom - mPaddingTop;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bottom = getChildAt(<span class=\"number\">0</span>).getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.fling(mScrollX, mScrollY, <span class=\"number\">0</span>, velocityY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                    Math.max(<span class=\"number\">0</span>, bottom - height), <span class=\"number\">0</span>, height/<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">postInvalidateOnAnimation();</span><br></pre></td></tr></table></figure>\n<p>通过传递当前拖动手势速度值来调用 <code>fling</code> 进行处理，然后在 <code>computeScrollOffset</code> 方法中，进行真正的滚动处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 逻辑处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = mScroller.getCurrX();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = mScroller.getCurrY();</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 <code>computeScrollOffset</code> 进行计算，如果返回 <code>true</code>，表示计算还没结束，然后通过 <code>getCurrX</code> 或 <code>getCurrY</code> 获取计算后的值，最后进行真正的滚动处理，比如调用 <code>scrollTo</code> 等等，这里需要注意的是，需要调用 <code>invalidate</code> 来确保进行下一次的 <code>computeScroll</code> 调用，这里使用的 <code>postInvalidateOnAnimation</code> 其作用是类似的。</p>\n<h4 id=\"TOUCH-CANCEL\"><a href=\"#TOUCH-CANCEL\" class=\"headerlink\" title=\"TOUCH_CANCEL\"></a>TOUCH_CANCEL</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged &amp;&amp; getChildCount() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.springBack(mScrollX, mScrollY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, getScrollRange())) &#123;</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的，一般我们都会在 <code>TOUCH_CANCEL</code> 中释放资源。</p>\n<h4 id=\"ACTION-POINTER-DOWN\"><a href=\"#ACTION-POINTER-DOWN\" class=\"headerlink\" title=\"ACTION_POINTER_DOWN\"></a>ACTION_POINTER_DOWN</h4><p>当有新的手指按下时分发的事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = ev.getActionIndex();</span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(index);</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(index);</span><br></pre></td></tr></table></figure>\n<p>以新按下的手指的信息重新计算</p>\n<h4 id=\"ACTION-POINTER-UP-1\"><a href=\"#ACTION-POINTER-UP-1\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这里的处理和 <code>onInterceptTouch</code> 一致</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><code>onTouchEvent</code> 和 <code>onInterceptTouchEvent</code> 处理有些相似，主要是在 <code>TOUCH_MOVE</code> 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 <code>TOUCH_UP</code> 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 <code>NestedScrollView</code>、<code>RecyclerView</code>  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 <code>ViewDragHelper</code> ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim\" alt=\"WheelView\" title=\"\">\n                </div>\n                <div class=\"image-caption\">WheelView</div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/more.gif\" alt=\"TapeView\" title=\"\">\n                </div>\n                <div class=\"image-caption\">TapeView</div>\n            </figure>\n<p>详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是<a href=\"https://github.com/LinXiaoTao/WheelView\" target=\"_blank\" rel=\"noopener\">滚轮控件</a>，第二个是之前参加活动的仿薄荷健康的<a href=\"https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md\" target=\"_blank\" rel=\"noopener\">卷尺控件</a>。在这里我们只分析部分代码：</p>\n<h3 id=\"滚轮控件\"><a href=\"#滚轮控件\" class=\"headerlink\" title=\"滚轮控件\"></a>滚轮控件</h3><p>在前面手势判定中的分析中，我们提到在 <code>onTouchEvent</code> 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    mDistanceY += mLastY - moveY;</span><br><span class=\"line\">    postInvalidateOnAnimation();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在每次 <code>TOUCH_MOVE</code> 事件分发时，计算与 <code>TOUCH_DOWN</code> 时记录的位置信息的差值，保存为 <code>mDistanceY</code>，并且在 <code>onDraw</code> 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。</p>\n<h3 id=\"卷尺控件\"><a href=\"#卷尺控件\" class=\"headerlink\" title=\"卷尺控件\"></a>卷尺控件</h3><p>拖动距离的计算与滚轮控件一样，只是记录为 <code>mOffsetLeft</code> 而已，同时两个控件都有在 <code>onTouchEvent</code> 的 <code>ACTION_UP</code> 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。</p>\n<p>但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：</p>\n<ul>\n<li>最基本的拖动手势处理</li>\n<li>fling 效果实现</li>\n<li>如果可以，再实现边缘效果</li>\n</ul>\n<p>感谢大家的阅读。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。</p>\n<h2 id=\"触摸事件简单回顾\"><a href=\"#触摸事件简单回顾\" class=\"headerlink\" title=\"触摸事件简单回顾\"></a>触摸事件简单回顾</h2><p>我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/TouchEvent.png?time=123\" alt=\"TouchEvent\" title=\"\">\n                </div>\n                <div class=\"image-caption\">TouchEvent</div>\n            </figure>\n<p>上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 <code>dispatchTouchEvent</code> 开始分发，先判断 ViewGroup 的 <code>onInterceptTouchEvent</code> 是否拦截，同时这里也可以调用 ViewGroup 的 <code>requestDisallowInterceptTouchEvent</code> 让 ViewGroup 不调用 <code>onInterceptTouchEvent</code>，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 <code>dispatchTouchEvent</code>，反之，则调用子视图的 <code>dispatchTouchEvent</code>，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 <code>dispatchTouchEvent</code>。</p>\n<p>最终都会调用到 View 的 <code>onTouchEvent</code> 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。</p>\n<h2 id=\"手势判定\"><a href=\"#手势判定\" class=\"headerlink\" title=\"手势判定\"></a>手势判定</h2><p>上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。</p>\n<p>当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：</p>\n<p>ScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 <code>onInterceptTouchEvent</code></p>\n<blockquote>\n<p>因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。</p>\n<p>源码部分基于 Android 26</p>\n</blockquote>\n<h3 id=\"onInterceptTouchEvent\"><a href=\"#onInterceptTouchEvent\" class=\"headerlink\" title=\"onInterceptTouchEvent\"></a>onInterceptTouchEvent</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 <code>mIsBeingDragged</code> 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 <code>ACTION_MOVE</code>，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。</p>\n<h4 id=\"TOUCH-DOWN\"><a href=\"#TOUCH-DOWN\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!inChild((<span class=\"keyword\">int</span>) ev.getX(), (<span class=\"keyword\">int</span>) y)) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    recycleVelocityTracker();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mLastMotionY = y;</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br><span class=\"line\">initOrResetVelocityTracker();</span><br><span class=\"line\">mVelocityTracker.addMovement(ev);</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.computeScrollOffset();</span><br><span class=\"line\">mIsBeingDragged = !mScroller.isFinished();</span><br><span class=\"line\"></span><br><span class=\"line\">startNestedScroll(SCROLL_AXIS_VERTICAL);</span><br></pre></td></tr></table></figure>\n<p>这段代码主要是用于初始化判定之前的资源，比如 <code>mLastMotionY</code> 记录按下时的坐标信息，<code>mActivePointerId</code> 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，<code>initOrResetVelocityTracker</code> 初始化速度跟踪器，同时使用 <code>addMovement</code> 记录当前触摸事件信息，<code>mScroller</code> 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，<code>startNestedScroll</code> 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。</p>\n<h4 id=\"TOUCH-MOVE\"><a href=\"#TOUCH-MOVE\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerId = mActivePointerId;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerId == INVALID_POINTER) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = ev.findPointerIndex(activePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> yDiff = Math.abs(y - mLastMotionY);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mLastMotionY = y;</span><br><span class=\"line\">    initVelocityTrackerIfNotExists();</span><br><span class=\"line\">    mVelocityTracker.addMovement(ev);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码先使用我们在 <code>TOUCH_DOWN</code> 中记录的  <code>mActivePointerId</code> 进行是否为有效的判断，如果有效，则通过 <code>findPointerIndex</code> 获取作用手指 id 的下标，记录为  <code>pointerIndex</code> ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。<code>yDiff</code> 是滑动的距离，<code>mTouchSlop</code> 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 <code>getScaledTouchSlop</code> 获取，如果大于这个值，我们可以认为开始了拖动的手势。 <code>getNestedScrollAxes</code> 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，<code>mIsBeingDragged</code> 标记为 <code>true</code>，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 <code>requestDisallowInterceptTouchEvent</code>，防止父视图拦截了事件，即 <code>onInterceptTouchEvent</code></p>\n<h4 id=\"TOUCH-CANCEL-amp-amp-TOUCH-UP\"><a href=\"#TOUCH-CANCEL-amp-amp-TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_CANCEL &amp;&amp; TOUCH_UP\"></a>TOUCH_CANCEL &amp;&amp; TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">recycleVelocityTracker();</span><br><span class=\"line\">stopNestedScroll();</span><br></pre></td></tr></table></figure>\n<p>一般我们都会在 <code>TOUCH_CANCEL</code> 和 <code>TOUCH_UP</code> 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 <code>mIsBeingDragged</code> 设置为 <code>false</code>，释放速度跟踪器等等 </p>\n<blockquote>\n<p><code>TOUCH_UP</code> 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 <code>TOUCH_CANCEL</code> 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 <code>TOUCH_DOWN</code>，即在这个事件分发时，向父视图传递了 <code>true</code> 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 <code>ACTION_MOVE</code> 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 <code>onInterceptTouch</code> 中返回了 <code>true</code>，那么在 ViewGroup 的 <code>dispatchTouchEvent</code> 中会给已经确认消费事件的子视图分发一个 <code>TOUCH_CANCEL</code> 的事件，具体可以阅读源码。</p>\n</blockquote>\n<h4 id=\"ACTION-POINTER-UP\"><a href=\"#ACTION-POINTER-UP\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这个为多指触摸时，某个手指抬起时分发的事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;</span><br><span class=\"line\">                MotionEvent.ACTION_POINTER_INDEX_SHIFT;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerId = ev.getPointerId(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerId == mActivePointerId) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> newPointerIndex = pointerIndex == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">    mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(newPointerIndex);</span><br><span class=\"line\">    mActivePointerId = ev.getPointerId(newPointerIndex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mVelocityTracker != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mVelocityTracker.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>我们可以简单总结下，<code>onInterceptTouchEvent</code> 所进行的处理，即在 <code>TOUCH_DOWN</code> 资源初始化，<code>TOUCH_MOVE</code> 判断是否开始拖动手势，<code>TOUCH_CANCEL</code> &amp;&amp; <code>TOUCH_UP</code> 中进行资源释放。这里涉及了多指触摸的处理。</p>\n<h3 id=\"onTouchEvent\"><a href=\"#onTouchEvent\" class=\"headerlink\" title=\"onTouchEvent\"></a>onTouchEvent</h3><p><code>onTouchEvent</code> 要比 <code>onInterceptTouch</code> 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。</p>\n<h4 id=\"TOUCH-DOWN-1\"><a href=\"#TOUCH-DOWN-1\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (getChildCount() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((mIsBeingDragged = !mScroller.isFinished())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!mScroller.isFinished()) &#123;</span><br><span class=\"line\">    mScroller.abortAnimation();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY();</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>同样的，<code>onTouchEvent</code> 在 <code>TOUCH_DOWN</code> 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 <code>abortAnimation</code>，如果 Scroller 还没结束 fling 计算，则中止处理。</p>\n<h4 id=\"TOUCH-MOVE-1\"><a href=\"#TOUCH-MOVE-1\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerIndex = ev.findPointerIndex(mActivePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(activePointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">int</span> deltaY = mLastMotionY - y;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (dispatchNestedPreScroll(<span class=\"number\">0</span>, deltaY, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 嵌套滚动处理</span></span><br><span class=\"line\">    deltaY -= mScrollConsumed[<span class=\"number\">1</span>];</span><br><span class=\"line\">    vtev.offsetLocation(<span class=\"number\">0</span>, mScrollOffset[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    mNestedYOffset += mScrollOffset[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mIsBeingDragged &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (deltaY &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            deltaY -= mTouchSlop;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            deltaY += mTouchSlop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码同样会进行多指处理，获取指定手指的触摸事件信息。<code>mIsBeingDragged</code> 为 <code>false</code>，同时会再进行一次拖动手势的判定，判定逻辑和 <code>onInterceptTouchEvent</code> 中类似，如果 <code>mIsBeingDragged</code> 为 <code>true</code>，则开始进行真正的逻辑处理。</p>\n<blockquote>\n<p>EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码</p>\n</blockquote>\n<h4 id=\"TOUCH-UP\"><a href=\"#TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_UP\"></a>TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> VelocityTracker velocityTracker = mVelocityTracker;</span><br><span class=\"line\">\tvelocityTracker.computeCurrentVelocity(<span class=\"number\">1000</span>, mMaximumVelocity);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> initialVelocity = (<span class=\"keyword\">int</span>) velocityTracker.getYVelocity(mActivePointerId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((Math.abs(initialVelocity) &gt; mMinimumVelocity)) &#123;</span><br><span class=\"line\">    \tflingWithNestedDispatch(-initialVelocity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 <code>getYVelocity</code> 获取速度，在判断是否可以作为 fling 手势处理，<code>mMaximumVelocity</code> 是处理的最大速度，<code>mMinimumVelocity</code> 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 <code>getScaledMaximumFlingVelocity</code> 和 <code>getScaledMinimumFlingVelocity</code> 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> height = getHeight() - mPaddingBottom - mPaddingTop;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bottom = getChildAt(<span class=\"number\">0</span>).getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.fling(mScrollX, mScrollY, <span class=\"number\">0</span>, velocityY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                    Math.max(<span class=\"number\">0</span>, bottom - height), <span class=\"number\">0</span>, height/<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">postInvalidateOnAnimation();</span><br></pre></td></tr></table></figure>\n<p>通过传递当前拖动手势速度值来调用 <code>fling</code> 进行处理，然后在 <code>computeScrollOffset</code> 方法中，进行真正的滚动处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 逻辑处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = mScroller.getCurrX();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = mScroller.getCurrY();</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 <code>computeScrollOffset</code> 进行计算，如果返回 <code>true</code>，表示计算还没结束，然后通过 <code>getCurrX</code> 或 <code>getCurrY</code> 获取计算后的值，最后进行真正的滚动处理，比如调用 <code>scrollTo</code> 等等，这里需要注意的是，需要调用 <code>invalidate</code> 来确保进行下一次的 <code>computeScroll</code> 调用，这里使用的 <code>postInvalidateOnAnimation</code> 其作用是类似的。</p>\n<h4 id=\"TOUCH-CANCEL\"><a href=\"#TOUCH-CANCEL\" class=\"headerlink\" title=\"TOUCH_CANCEL\"></a>TOUCH_CANCEL</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged &amp;&amp; getChildCount() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.springBack(mScrollX, mScrollY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, getScrollRange())) &#123;</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的，一般我们都会在 <code>TOUCH_CANCEL</code> 中释放资源。</p>\n<h4 id=\"ACTION-POINTER-DOWN\"><a href=\"#ACTION-POINTER-DOWN\" class=\"headerlink\" title=\"ACTION_POINTER_DOWN\"></a>ACTION_POINTER_DOWN</h4><p>当有新的手指按下时分发的事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = ev.getActionIndex();</span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(index);</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(index);</span><br></pre></td></tr></table></figure>\n<p>以新按下的手指的信息重新计算</p>\n<h4 id=\"ACTION-POINTER-UP-1\"><a href=\"#ACTION-POINTER-UP-1\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这里的处理和 <code>onInterceptTouch</code> 一致</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><code>onTouchEvent</code> 和 <code>onInterceptTouchEvent</code> 处理有些相似，主要是在 <code>TOUCH_MOVE</code> 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 <code>TOUCH_UP</code> 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 <code>NestedScrollView</code>、<code>RecyclerView</code>  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 <code>ViewDragHelper</code> ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim\" alt=\"WheelView\" title=\"\">\n                </div>\n                <div class=\"image-caption\">WheelView</div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/more.gif\" alt=\"TapeView\" title=\"\">\n                </div>\n                <div class=\"image-caption\">TapeView</div>\n            </figure>\n<p>详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是<a href=\"https://github.com/LinXiaoTao/WheelView\" target=\"_blank\" rel=\"noopener\">滚轮控件</a>，第二个是之前参加活动的仿薄荷健康的<a href=\"https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md\" target=\"_blank\" rel=\"noopener\">卷尺控件</a>。在这里我们只分析部分代码：</p>\n<h3 id=\"滚轮控件\"><a href=\"#滚轮控件\" class=\"headerlink\" title=\"滚轮控件\"></a>滚轮控件</h3><p>在前面手势判定中的分析中，我们提到在 <code>onTouchEvent</code> 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    mDistanceY += mLastY - moveY;</span><br><span class=\"line\">    postInvalidateOnAnimation();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在每次 <code>TOUCH_MOVE</code> 事件分发时，计算与 <code>TOUCH_DOWN</code> 时记录的位置信息的差值，保存为 <code>mDistanceY</code>，并且在 <code>onDraw</code> 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。</p>\n<h3 id=\"卷尺控件\"><a href=\"#卷尺控件\" class=\"headerlink\" title=\"卷尺控件\"></a>卷尺控件</h3><p>拖动距离的计算与滚轮控件一样，只是记录为 <code>mOffsetLeft</code> 而已，同时两个控件都有在 <code>onTouchEvent</code> 的 <code>ACTION_UP</code> 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。</p>\n<p>但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：</p>\n<ul>\n<li>最基本的拖动手势处理</li>\n<li>fling 效果实现</li>\n<li>如果可以，再实现边缘效果</li>\n</ul>\n<p>感谢大家的阅读。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjjs0ht980000ero6nhxg55hz","category_id":"cjjs0ht9d0002ero64c26r5k6","_id":"cjjs0ht9i0006ero65otrrjkx"},{"post_id":"cjjs0ht9b0001ero6132qybb4","category_id":"cjjs0ht9d0002ero64c26r5k6","_id":"cjjs0ht9j0007ero6dkwcw0i2"},{"post_id":"cjjs0ht9f0003ero6zh7wpamw","category_id":"cjjs0ht9i0005ero6gy1ou4tn","_id":"cjjs0ht9k0008ero663hdzoig"},{"post_id":"cjjs0ht9y0009ero6s7f755f3","category_id":"cjjs0ht9d0002ero64c26r5k6","_id":"cjjs0hta5000gero685r7xu5c"},{"post_id":"cjjs0hta3000dero6trx8463k","category_id":"cjjs0ht9i0005ero6gy1ou4tn","_id":"cjjs0hta9000jero67qwc2d13"},{"post_id":"cjjs0hta5000fero6sxjwef8m","category_id":"cjjs0ht9i0005ero6gy1ou4tn","_id":"cjjs0htac000lero6kpnpd6t8"},{"post_id":"cjjs0hta6000hero60l6ktu1y","category_id":"cjjs0ht9d0002ero64c26r5k6","_id":"cjjs0htac000nero637x5w27s"},{"post_id":"cjjs0hta1000bero6n48k01ax","category_id":"cjjs0hta4000eero634axbl3t","_id":"cjjs0htad000oero6by0nmgiy"},{"post_id":"cjjs0hta8000iero6q14j1nyz","category_id":"cjjs0htac000mero68lp7s40t","_id":"cjjs0htae000qero6cvyrsen9"},{"post_id":"cjjs0htaa000kero61n0c9ti5","category_id":"cjjs0htac000mero68lp7s40t","_id":"cjjs0htaf000rero66zqwjwmm"}],"PostTag":[],"Tag":[]}}