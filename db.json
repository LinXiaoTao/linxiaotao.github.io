{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.min.js","path":"js/main.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.min.js","path":"js/search.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/avatar.jpeg","path":"img/avatar.jpeg","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/indigo/.editorconfig","hash":"9b0445427777519defe360ea38c61729d847b3d3","modified":1523781680546},{"_id":"source/.DS_Store","hash":"a5ec53f807bed802ada202a3f875b754dd03d784","modified":1523781976360},{"_id":"themes/indigo/.DS_Store","hash":"30b3ff43c6e17eb995ea3569864173f5440e0fd9","modified":1523782100337},{"_id":"themes/indigo/README.md","hash":"b188fb95a9c16eb188eeffa6caa0895a14676338","modified":1523781680546},{"_id":"themes/indigo/LICENSE","hash":"24944bf7920108f5a4790e6071c32e9102760c37","modified":1523781680546},{"_id":"themes/indigo/_config.yml","hash":"2d06bb9bfcea000e1690f11b5cd36852f88f935b","modified":1523782808547},{"_id":"themes/indigo/package.json","hash":"c795e3100ae3655bfa8b39adcca7333a7925b47f","modified":1523781680562},{"_id":"source/_posts/hello-world.md","hash":"7d143ea20eb8fe54463dd464d7fe7f6856e9d616","modified":1523455530096},{"_id":"source/_posts/触摸事件实践之路.md","hash":"6617b8ffa54e16f1d9c2c4209ac7a3643fbf041a","modified":1523455530096},{"_id":"source/_posts/Android消息机制-Handler.md","hash":"9d208a44a9bedbeca071851197d362ed52e1d594","modified":1523455530096},{"_id":"source/categories/index.md","hash":"01aaad46196103db69d1d2545e486453d0c4cafb","modified":1523782008143},{"_id":"source/categories/.DS_Store","hash":"45673a8ec47535550c1655fb6f129816c4bf94f9","modified":1523782076525},{"_id":"source/_posts/Activity启动流程-基于Android26.md","hash":"9f2b191ddc0e4be48b2a37a3a7ec567bfb973aa6","modified":1523455530095},{"_id":"source/_posts/熟悉又陌生的Context.md","hash":"9a91a3a1092ebea4aad313b4550741b71dfc4e9f","modified":1523783415952},{"_id":"source/tags/index.md","hash":"758576e3a3061215a1c02f147bd5e8572df4f3a5","modified":1523781921246},{"_id":"themes/indigo/.git/HEAD","hash":"da237e0de55301608e7c572e119ab5c4e43c0e85","modified":1523781680542},{"_id":"themes/indigo/.git/config","hash":"1096da7405bf0751ed8d5e91f24910015fb6928f","modified":1523781680545},{"_id":"themes/indigo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1523781665066},{"_id":"themes/indigo/.git/index","hash":"70ed09603d6e8f763c20fcd102fd4241b36a46ac","modified":1523781680596},{"_id":"themes/indigo/.git/packed-refs","hash":"ad6dbb03312c6630891efb65bb07292a5f3d1b10","modified":1523781680538},{"_id":"themes/indigo/languages/ja.yml","hash":"74fd480874bf5e773ba7f9d2a94697cda979091f","modified":1523781680547},{"_id":"themes/indigo/languages/en.yml","hash":"1957d2bfc3a4cef299f4f169b431e9b1128ba162","modified":1523781680547},{"_id":"themes/indigo/languages/nl-NL","hash":"9085c04491f93066f2369911cc2175b59ae596ad","modified":1523781680548},{"_id":"themes/indigo/languages/zh-CN.yml","hash":"7dc6ae434dde390b6768d244132e23cc78c33817","modified":1523781680548},{"_id":"themes/indigo/languages/zh-TW.yml","hash":"6a9e820be66eb12ae746f2527e0dc1adf927c685","modified":1523781680548},{"_id":"themes/indigo/layout/archive.ejs","hash":"d039719e21f6a6fa2925b00aaa623a180a78c818","modified":1523781680559},{"_id":"themes/indigo/layout/categories.ejs","hash":"41783d2069d5080566a99e6312aa2113105f8b41","modified":1523781680560},{"_id":"themes/indigo/layout/category.ejs","hash":"7ea26a8a935886963eda82f41c7bd5270cf780d9","modified":1523781680560},{"_id":"themes/indigo/layout/index.ejs","hash":"39477807b98b2d2df78f3b82498a11e90be8222c","modified":1523781680560},{"_id":"themes/indigo/layout/layout.ejs","hash":"d52f43fa9572d70cae834e4887c8897b43744805","modified":1523781680560},{"_id":"themes/indigo/layout/page.ejs","hash":"afb98face24d39a21ebbbde6592a9afc98572aa4","modified":1523781680561},{"_id":"themes/indigo/layout/post.ejs","hash":"afbf8532dc8d148ca4dff2ca127a3382907cf2f5","modified":1523781680561},{"_id":"themes/indigo/layout/tag.ejs","hash":"36786a3de7f6cad58209603f7d84ba23addea174","modified":1523781680561},{"_id":"themes/indigo/layout/tags.ejs","hash":"20466446c41409d14a3d42ccaec24a65a045efef","modified":1523781680561},{"_id":"themes/indigo/scripts/plugins.js","hash":"e439d717513616bedeed37ba9b05117470809b21","modified":1523781680562},{"_id":"themes/indigo/source/.DS_Store","hash":"51d25a487a6d46b9b303f04a5053f9e5384461da","modified":1523782100336},{"_id":"themes/indigo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1523781665067},{"_id":"themes/indigo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1523781665068},{"_id":"themes/indigo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1523781665070},{"_id":"themes/indigo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1523781665070},{"_id":"themes/indigo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1523781665068},{"_id":"themes/indigo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1523781665071},{"_id":"themes/indigo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1523781665069},{"_id":"themes/indigo/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1523781665067},{"_id":"themes/indigo/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1523781665070},{"_id":"themes/indigo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1523781665065},{"_id":"themes/indigo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1523781665071},{"_id":"themes/indigo/.git/logs/HEAD","hash":"4ee0a0b0e9325595ae704467630510fad0804387","modified":1523781680543},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"9ac30b9439fab69973cf4722dbf2945a18fd3804","modified":1523781680548},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"55cd81ef9183426d6d99fd91550fce0a9cc92aa0","modified":1523781680548},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"e1a71a30a1c7a664ddf3ba3e7eb3a5b90bc4b33c","modified":1523781680549},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"02a95a88774cc50dbcc32242b6c8ac7e9d9028bb","modified":1523781680550},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"6156bf20791e46fc1c5872113276c1c1f5c13773","modified":1523781680551},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"ec7b3ec79bbbead9c7e43e2e6c6b5c8bef509410","modified":1523781680551},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1523781680552},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"d39afaad6b0dd2a3ae27e6db3e9a6cd6014622fa","modified":1523781680552},{"_id":"themes/indigo/layout/_partial/paginator.ejs","hash":"dc27242927890f130a64400596b9b7ad5fca8972","modified":1523781680552},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"a87d9b0485b3bf4cdfdad890e5974c43dbaa8240","modified":1523781680555},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"439d6315a1b16e32b77a68c3f0cb2961d581086a","modified":1523781680558},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"c2091c621b5480ef1e69d72027028cec8e929892","modified":1523781680559},{"_id":"themes/indigo/layout/_partial/tags-bar.ejs","hash":"19eff4876d31080a427644f7a43fe172d0c008c6","modified":1523781680559},{"_id":"themes/indigo/source/css/style.less","hash":"f22d4146e0bdb4485d33f20080c67ba05724afea","modified":1523781680592},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1523781680593},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1523781680593},{"_id":"themes/indigo/source/img/.DS_Store","hash":"6c945c5d78570646cab1a4ba22bbe41796fa1fdd","modified":1523782121372},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1523781680594},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1523781680593},{"_id":"themes/indigo/source/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1523781680595},{"_id":"themes/indigo/source/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1523781680596},{"_id":"themes/indigo/source/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1523781680596},{"_id":"themes/indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1523781680596},{"_id":"themes/indigo/source/img/avatar.jpeg","hash":"77063730fe1097a71fa19fcaf6da54ee9c0aad9f","modified":1523782057215},{"_id":"themes/indigo/.git/refs/heads/card","hash":"a859d813953007224502c15cda787c7e4af02d24","modified":1523781680543},{"_id":"themes/indigo/.git/objects/pack/pack-06672d2a3f5380de64b0ee5e339bcb27592cb892.idx","hash":"e4aa41b91f617f28c951231eb4b1311c9d91143f","modified":1523781680261},{"_id":"themes/indigo/layout/_partial/plugins/disqus.ejs","hash":"4a0c01e4195f685f9825fcd016d01249dbdd52ca","modified":1523781680553},{"_id":"themes/indigo/layout/_partial/plugins/baidu.ejs","hash":"e44d526029f122e9c2c74f3a647c35002c818cbe","modified":1523781680553},{"_id":"themes/indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"23c101d45911eb0846533aaa2d409c43aa5e899a","modified":1523781680553},{"_id":"themes/indigo/layout/_partial/plugins/gitment.ejs","hash":"5723d507eca4390e8e5d18c0770e7953b8c22f5a","modified":1523781680553},{"_id":"themes/indigo/layout/_partial/plugins/google-analytics.ejs","hash":"a947f4076b54b48d4df5baf2d5b3c39b632c7576","modified":1523781680553},{"_id":"themes/indigo/layout/_partial/plugins/hyper-comments.ejs","hash":"e5a83acc7c2e385b0c9abf428e86e8fdfd3a5202","modified":1523781680554},{"_id":"themes/indigo/layout/_partial/plugins/mathjax.ejs","hash":"ea603a057196de53bd6afab1fddb93d11f27eb81","modified":1523781680554},{"_id":"themes/indigo/layout/_partial/plugins/page-visit.ejs","hash":"2decb77bf3c1a064ea6ce1d4e78892c434d9c884","modified":1523781680554},{"_id":"themes/indigo/layout/_partial/plugins/site-visit.ejs","hash":"8fbd0910828f1ab6eba728bdecc9811d623baae2","modified":1523781680554},{"_id":"themes/indigo/layout/_partial/plugins/tajs.ejs","hash":"97b48fe10be1c71d4ff25ccec3bd92d97466c9c5","modified":1523781680555},{"_id":"themes/indigo/layout/_partial/plugins/uyan.ejs","hash":"e370bd04ea5cf1c83e0c20516aff7ba3ca8b2d0b","modified":1523781680555},{"_id":"themes/indigo/layout/_partial/plugins/valine.ejs","hash":"a976ca36bd09aeb2902bf94fcc7a59975ea25148","modified":1523781680555},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c7476165721a3a5e34d00d8c5c07e1e5474cd800","modified":1523781680556},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"bcc3bd7a9023d71778f15e98c88552335ae69a69","modified":1523781680556},{"_id":"themes/indigo/layout/_partial/post/copyright.ejs","hash":"5305ed30ee35cf50f87656737d0ffe85f5bfc16b","modified":1523781680556},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"ea85b46e12d3b9c3612eef7aa76289a663fbc096","modified":1523781680556},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"b0c680ce5b8aaf461a6731b1ff1287bd140c168a","modified":1523781680556},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"11e7d504f7c7a3c4c052da13cfa8ea4862c9383e","modified":1523781680556},{"_id":"themes/indigo/layout/_partial/post/reward-btn.ejs","hash":"41c242fe3159dc68cec8dd00ab6d2663f5a51179","modified":1523781680556},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"23719e09689b3afbb19214c6603eb02f896cb9ba","modified":1523781680557},{"_id":"themes/indigo/layout/_partial/post/share-fab.ejs","hash":"93482ad7d1e01b966f5ee1c5d12b88564e02b349","modified":1523781680557},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"8df0d7bf6f8e106cdbdac2dd10a97367aa0695f8","modified":1523781680557},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"b3dc38652c4a018a37418136478dcd522fc49f79","modified":1523781680557},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"062d56cb88ae2be3a6616b911d4ebeffcbfe3cff","modified":1523781680557},{"_id":"themes/indigo/layout/_partial/post/toc.ejs","hash":"ad287a70724eb7cd8cd2a03a45b68032ee99973d","modified":1523781680558},{"_id":"themes/indigo/layout/_partial/post/updated.ejs","hash":"5caa71745aa340ce57938a930f3b898ee7518d74","modified":1523781680558},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"7d2a6886265386c640e94ffca3f042675f701a35","modified":1523781680563},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"d476cd3537bcd8a02d055cc223f5c805b8638cc2","modified":1523781680564},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1523781680565},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"90f0948a9182c14b1dac1e9dbed3c883543266f9","modified":1523781680565},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"58492b7cdb45fe09b026b2f34e8ae69c2ddb8228","modified":1523781680565},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"4390ed22abad59c8b28ed1a479a52f15b5f9cf4a","modified":1523781680566},{"_id":"themes/indigo/source/css/_partial/lightbox.less","hash":"9b961eb1d70e7658f42cf2ca895fa5e35a6b6541","modified":1523781680566},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"f9d06a1e24fb4857fd18d7a0bfbb3a0ab2d1c742","modified":1523781680566},{"_id":"themes/indigo/source/css/_partial/page.less","hash":"e92ccb53e6ac73a51498c6a9672db9d0d2bc7f1a","modified":1523781680567},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"4857f90bb57fc22ca3f942d8934d86d5e9e82c1e","modified":1523781680567},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"1c041bf91106808e5480c60d9ece45431bb503b3","modified":1523781680567},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1523781680567},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"1d6641ae7568a0153d24beba9fd9704d2b155f6c","modified":1523781680568},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"27d80bcc96a53dd1e7eaa9a7d746e4b212357302","modified":1523781680568},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"959f4373fda6e45f6a4041a995ed3ea8a05a5170","modified":1523781680568},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"082896b966ed25b39c74e7b007b4f54c235685a4","modified":1523781680569},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"77bfd0b373b0469eb0176167fb076ccda4edf2a7","modified":1523781680569},{"_id":"themes/indigo/source/css/_plugin/valine.less","hash":"ddbb7647d83f732f9b0d5d817d40a748006949cc","modified":1523781680569},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"ca30b732d2efbb0cd55a272ecdabc97f895aee78","modified":1523781680565},{"_id":"themes/indigo/.git/logs/refs/heads/card","hash":"4ee0a0b0e9325595ae704467630510fad0804387","modified":1523781680544},{"_id":"themes/indigo/.git/refs/remotes/origin/HEAD","hash":"7f141be72288af81f8e55d94df5da3f87101e8f1","modified":1523781680542},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1523781680580},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1523781680581},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1523781680582},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1523781680583},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1523781680584},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1523781680585},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1523781680585},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1523781680586},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1523781680587},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1523781680587},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1523781680589},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1523781680589},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1523781680590},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1523781680591},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1523781680591},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1523781680579},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1523781680579},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1523781680581},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1523781680584},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1523781680586},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1523781680588},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1523781680590},{"_id":"themes/indigo/.git/logs/refs/remotes/origin/HEAD","hash":"4ee0a0b0e9325595ae704467630510fad0804387","modified":1523781680542},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1523781680571},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1523781680572},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1523781680578},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1523781680576},{"_id":"themes/indigo/.git/objects/pack/pack-06672d2a3f5380de64b0ee5e339bcb27592cb892.pack","hash":"7cab58970aeb136db823cb84b13f6c471348bcbc","modified":1523781680256},{"_id":"public/atom.xml","hash":"28b0b56ec5abcf855ada31a5bd37c4d025fae7ee","modified":1523783425040},{"_id":"public/content.json","hash":"0fa1624fee82fbdaa25f9387a80506d29d77508f","modified":1523783425203},{"_id":"public/2018/04/03/触摸事件实践之路/index.html","hash":"6a9d202212508180b0fd1d2cc10010a61415b40a","modified":1523782816612},{"_id":"public/2018/03/27/Activity启动流程-基于Android26/index.html","hash":"8e409a24d853eb3ae447013d44e5ec2911f9aa49","modified":1523782816612},{"_id":"public/2018/03/23/Android消息机制-Handler/index.html","hash":"3f648cb489879e42c4c83f544ed1d599e5a2d7e3","modified":1523782816612},{"_id":"public/categories/index.html","hash":"412efcfc4e2dbf189413b43734b0ba2b286ba37e","modified":1523783425210},{"_id":"public/archives/index.html","hash":"33886b57f8c5f2bcf05cebdea0b56637f9baec30","modified":1523783425210},{"_id":"public/archives/2018/index.html","hash":"23c810f9022d022f0b33166ff05d73efcf2c53b5","modified":1523783425210},{"_id":"public/archives/2018/03/index.html","hash":"085e4b4cf3c5b1ba8c73bb6af8327c57109ee132","modified":1523782816612},{"_id":"public/archives/2018/04/index.html","hash":"19f15d2785d6adf5d17501b4bb42dc4b0e22f288","modified":1523783425210},{"_id":"public/categories/随笔/index.html","hash":"569ed1af75dfd97337153f81d7a6b3a16b43f921","modified":1523782816612},{"_id":"public/categories/Android-Framework/index.html","hash":"c61f019105366f24901f692998d20aa7f1f5cfca","modified":1523783425210},{"_id":"public/categories/Android-Application/index.html","hash":"c43fc75857c73376c276c5475b8a069f7b8cbdae","modified":1523782816612},{"_id":"public/index.html","hash":"bac26c58b83056c062cce5063adeb3215d9dc3d8","modified":1523783425210},{"_id":"public/2018/04/11/hello-world/index.html","hash":"66629c2ff40f4ebb2daa99d0b2dbf42118ec42ed","modified":1523782850847},{"_id":"public/tags/index.html","hash":"5ade26cf0c28208fed8fd1ee5f496ad36979eca1","modified":1523783425210},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1523782638646},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1523782638646},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1523782638646},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1523782638647},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1523782638647},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1523782638647},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1523782638647},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1523782638647},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1523782638647},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1523782638647},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1523782638648},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1523782638648},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1523782638648},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1523782638648},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1523782638648},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1523782638648},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1523782638649},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1523782638649},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1523782638649},{"_id":"public/img/avatar.jpeg","hash":"77063730fe1097a71fa19fcaf6da54ee9c0aad9f","modified":1523782638671},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1523782638671},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1523782638671},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1523782638671},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1523782638671},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1523782638672},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1523782638672},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1523782638672},{"_id":"public/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1523782638676},{"_id":"public/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1523782638676},{"_id":"public/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1523782638676},{"_id":"public/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1523782638676},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1523782638676},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1523782638677},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1523782638677},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1523782638686},{"_id":"public/css/style.css","hash":"c546dbb3a076ab2d97115ae273f653769b073068","modified":1523782638952},{"_id":"public/tags/Android-Framework/index.html","hash":"2d172dcd47196f663ef879dfa45aef5f79863996","modified":1523782850848},{"_id":"public/2018/04/12/熟悉又陌生的Context/index.html","hash":"a6d9e5b41e29d3cb8e1ba9dea79ab05b9b1c3b96","modified":1523783425211}],"Category":[{"name":"随笔","_id":"cjg0ku8a60004hio6yqsdklrd"},{"name":"Android Framework","_id":"cjg0ku8ac0007hio6bgamiqcl"},{"name":"Android Application","_id":"cjg0ku8ad0009hio6dr3eovci"}],"Data":[],"Page":[{"title":"categories","date":"2018-04-15T08:45:33.000Z","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-04-15 16:45:33\nlayout: categories\ncomments: false\n---\n","updated":"2018-04-15T08:46:48.143Z","path":"categories/index.html","_id":"cjg0ku8a20001hio61m4w7072","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","layout":"tags","comments":0,"date":"2018-04-15T08:44:13.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\nlayout: tags\ncomments: false\ndate: 2018-04-15 16:44:13\n---\n","updated":"2018-04-15T08:45:21.246Z","path":"tags/index.html","_id":"cjg0ku8a50003hio631ri9d0c","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"## 面朝大海，春暖花开\n\n从明天起，做一个幸福的人\n\n喂马、劈柴、周游世界\n\n从明天起，关心粮食和蔬菜\n\n我有一所房子，面朝大海，春暖花开\n\n\n\n从明天起，和每一个亲人通信\n\n告诉他们我的幸福\n\n那幸福的闪电告诉我的\n\n我将告诉每一个人\n\n\n\n给每一条河每一座山取一个温暖的名字\n\n陌生人，我也为你祝福\n\n愿你有一个灿烂的前程\n\n愿你有情人总成眷属\n\n愿你在尘世获得幸福\n\n我只愿面朝大海，春暖花开\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategories: 随笔\n---\n## 面朝大海，春暖花开\n\n从明天起，做一个幸福的人\n\n喂马、劈柴、周游世界\n\n从明天起，关心粮食和蔬菜\n\n我有一所房子，面朝大海，春暖花开\n\n\n\n从明天起，和每一个亲人通信\n\n告诉他们我的幸福\n\n那幸福的闪电告诉我的\n\n我将告诉每一个人\n\n\n\n给每一条河每一座山取一个温暖的名字\n\n陌生人，我也为你祝福\n\n愿你有一个灿烂的前程\n\n愿你有情人总成眷属\n\n愿你在尘世获得幸福\n\n我只愿面朝大海，春暖花开\n","slug":"hello-world","published":1,"date":"2018-04-11T14:05:30.096Z","updated":"2018-04-11T14:05:30.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg0ku89y0000hio644mhx1tq","content":"<h2 id=\"面朝大海，春暖花开\"><a href=\"#面朝大海，春暖花开\" class=\"headerlink\" title=\"面朝大海，春暖花开\"></a>面朝大海，春暖花开</h2><p>从明天起，做一个幸福的人</p>\n<p>喂马、劈柴、周游世界</p>\n<p>从明天起，关心粮食和蔬菜</p>\n<p>我有一所房子，面朝大海，春暖花开</p>\n<p>从明天起，和每一个亲人通信</p>\n<p>告诉他们我的幸福</p>\n<p>那幸福的闪电告诉我的</p>\n<p>我将告诉每一个人</p>\n<p>给每一条河每一座山取一个温暖的名字</p>\n<p>陌生人，我也为你祝福</p>\n<p>愿你有一个灿烂的前程</p>\n<p>愿你有情人总成眷属</p>\n<p>愿你在尘世获得幸福</p>\n<p>我只愿面朝大海，春暖花开</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"面朝大海，春暖花开\"><a href=\"#面朝大海，春暖花开\" class=\"headerlink\" title=\"面朝大海，春暖花开\"></a>面朝大海，春暖花开</h2><p>从明天起，做一个幸福的人</p>\n<p>喂马、劈柴、周游世界</p>\n<p>从明天起，关心粮食和蔬菜</p>\n<p>我有一所房子，面朝大海，春暖花开</p>\n<p>从明天起，和每一个亲人通信</p>\n<p>告诉他们我的幸福</p>\n<p>那幸福的闪电告诉我的</p>\n<p>我将告诉每一个人</p>\n<p>给每一条河每一座山取一个温暖的名字</p>\n<p>陌生人，我也为你祝福</p>\n<p>愿你有一个灿烂的前程</p>\n<p>愿你有情人总成眷属</p>\n<p>愿你在尘世获得幸福</p>\n<p>我只愿面朝大海，春暖花开</p>\n"},{"title":"Android消息机制-Handler","date":"2018-03-23T12:29:21.000Z","_content":"\n### 参考\n\n[Android消息机制1-Handler(Java层)](http://gityuan.com/2015/12/26/handler-message-framework/)\n\n[Android消息机制2-Handler(Native层)](http://gityuan.com/2015/12/27/handler-message-native/)\n\n[Android应用程序消息处理机制（Looper、Handler）分析](http://blog.csdn.net/luoshengyang/article/details/6817933)\n\n[管道(Unix)](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix))\n\n[Epoll](https://zh.wikipedia.org/zh-hans/Epoll)\n\n[文件描述符](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)\n\nHandler 机制主要由四个部分组成：\n\n* Looper\n* MessageQueue\n* Message\n* Handler\n\n### 典型用法\n\n``` java\nclass LooperThread extends Thread {\n    public Handler mHandler;\n    \n    public void run() {\n        Looper.prepare();\n        \n        mHandler = new Handler() {\n            public void handleMessage(Message msg) {\n                // process incoming messages here\n            }\n        };\n        \n        Looper.loop();\n    }\n}\n```\n\n### Looper\n\n不断循环执行 `Looper.loop`，按分发机制将消息分发给目标处理者\n\n``` java\nprivate static void prepare(boolean quitAllowed) {\n    if(sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    // 构建 Looper 存储到 ThreadLocal\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n`sThreadLocal` 是一个 ThreadLocal 类型的静态变量\n\n> ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域\n\n``` java\nprivate Looper(boolean quitAllowed) {\n    // Looper 中创建 MessageQueue\n    mQueue = new MessageQueue(quitAllowed);\n    mThread = Thread.currentThread();\n}\n```\n\n``` java\npublic static void loop() {                                                                     \n    final Looper me = myLooper();                                                               \n    if (me == null) {                                                                           \n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }                                                                                           \n    final MessageQueue queue = me.mQueue;                                                       \n                                                                                                \n    // Make sure the identity of this thread is that of the local process,                      \n    // and keep track of what that identity token actually is.                                  \n    Binder.clearCallingIdentity();                                                              \n    final long ident = Binder.clearCallingIdentity();                                           \n                                                                                                \n    for (;;) {                                                                                  \n        Message msg = queue.next(); // 获取下一条 Message，可能会阻塞                                              \n        if (msg == null) {                                                                      \n            // No message indicates that the message queue is quitting.                         \n            return;                                                                             \n        }                                                                                       \n                                                                                                \n        // This must be in a local variable, in case a UI event sets the logger                 \n        final Printer logging = me.mLogging;                                                    \n        if (logging != null) {                                                                  \n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +                        \n                    msg.callback + \": \" + msg.what);                                            \n        }                                                                                       \n                                                                                                \n        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       \n                                                                                                \n        //省略\n        \n        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();     \n        final long end;                                                                         \n        try {\n            // 分发 Message\n            msg.target.dispatchMessage(msg);                                                    \n            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();              \n        } finally {                                                                             \n            if (traceTag != 0) {                                                                \n                Trace.traceEnd(traceTag);                                                       \n            }                                                                                   \n        }                                                                                       \n        if (slowDispatchThresholdMs > 0) {                                                      \n            final long time = end - start;                                                      \n            if (time > slowDispatchThresholdMs) {                                               \n                Slog.w(TAG, \"Dispatch took \" + time + \"ms on \"                                  \n                        + Thread.currentThread().getName() + \", h=\" +                           \n                        msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what);               \n            }                                                                                   \n        }                                                                                       \n                                                                                                \n        if (logging != null) {                                                                  \n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);            \n        }                                                                                       \n                                                                                                \n        // Make sure that during the course of dispatching the                                  \n        // identity of the thread wasn't corrupted.                                             \n        final long newIdent = Binder.clearCallingIdentity();                                    \n        if (ident != newIdent) {                                                                \n            Log.wtf(TAG, \"Thread identity changed from 0x\"                                      \n                    + Long.toHexString(ident) + \" to 0x\"                                        \n                    + Long.toHexString(newIdent) + \" while dispatching to \"                     \n                    + msg.target.getClass().getName() + \" \"                                     \n                    + msg.callback + \" what=\" + msg.what);                                      \n        }                                                                                       \n         \n        // 释放 Message\n        msg.recycleUnchecked();                                                                 \n    }                                                                                           \n}                                                                                               \n```\n\n``` java\n// Looper.quit 最终调用的都是 MessageQueue.quit\npublic void quit() {\n    mQueue.quit(false); // 移除消息\n}\n\npublic void quitSafely() {\n    mQueue.quit(true); // 安全移除消息\n}\n```\n\nMessageQueue 在构造方法中，会调用 native 方法 `nativeInit` 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper\n\n``` cpp\n// frameworks/base/libs\nLooper::Looper(bool allowNonCallbacks) :  \n    mAllowNonCallbacks(allowNonCallbacks),  \n    mResponseIndex(0) {\n    // 管道机制\n    int wakeFds[2];  \n    int result = pipe(wakeFds);  \n    ......  \n  \n    mWakeReadPipeFd = wakeFds[0];  \n    mWakeWritePipeFd = wakeFds[1];  \n  \t\n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    // 分配新的 epoll 实例同时注册唤醒管道\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  \n    ......  \n  \n    struct epoll_event eventItem;  \n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    // 观察 EPOLLIN 事件\n    eventItem.events = EPOLLIN;  \n    eventItem.data.fd = mWakeReadPipeFd;  \n    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem);  \n    ......  \n#else  \n    ......  \n#endif  \n  \n    ......  \n}  \n```\n\n> 管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。\n>\n> epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。\n\npipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。\n\n以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。\n\n### Handler\n\n``` java\npublic Handler(Callback callback, boolean async) {                                                  \n    if (FIND_POTENTIAL_LEAKS) {                                                                     \n        final Class<? extends Handler> klass = getClass();                                          \n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&          \n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            // 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +      \n                klass.getCanonicalName());                                                          \n        }                                                                                           \n    }                                                                                               \n    // 默认使用当前线程的 Looper                                                                                                \n    mLooper = Looper.myLooper();                                                                    \n    if (mLooper == null) {                                                                          \n        throw new RuntimeException(                                                                 \n            \"Can't create handler inside thread that has not called Looper.prepare()\");             \n    }                                                                                               \n    mQueue = mLooper.mQueue;                                                                        \n    mCallback = callback;\n    // 是否为异步处理\n    mAsynchronous = async;                                                                          \n}                                                                                                   \n```\n\n在 `Looper.loop` 中，当存在 Message 需要处理时，会调用 `dispatchMessage` 来进行分发：\n\n``` java\npublic void dispatchMessage(Message msg) {      \n    if (msg.callback != null) {\n        // 先调用 callback\n        handleCallback(msg);                    \n    } else {                                    \n        if (mCallback != null) {\n            // 接着检查通过构造方法传进来的 Callback\n            if (mCallback.handleMessage(msg)) { \n                return;                         \n            }                                   \n        }\n        // 最后调用 handleMessage\n        handleMessage(msg);                     \n    }                                           \n}                                               \n```\n\n通过 Handler 发送消息：\n\n![发送消息调用链](http://gityuan.com/images/handler/java_sendmessage.png)\n\n最终所有的方法都会调用到 `MessageQueue.enqueueMessage`\n\n### MessageQueue\n\n> 消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理\n\n``` java\nMessageQueue(boolean quitAllowed) { \n    mQuitAllowed = quitAllowed;\n    // used by native code\n    mPtr = nativeInit();            \n}                                   \n```\n\nMessageQueue 的初始化工作主要由 native 方法来执行\n\n``` cpp\n//frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {\n    // 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();  \n    if (! nativeMessageQueue) {  \n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");  \n        return;  \n    }  \n  \t\n    // 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量\n    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  \n}  \n```\n\n`nativeInit` 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 `mPtr`，关联了 NativeMessageQueue 和 MessageQueue\n\n``` java\nMessage next() {                                                                              \n    // messsage loop has already quit                                                              \n    final long ptr = mPtr;                                                                    \n    if (ptr == 0) {                                                                           \n        return null;                                                                          \n    }                                                                                         \n                                                                                              \n    int pendingIdleHandlerCount = -1; // -1 only during first iteration                       \n    int nextPollTimeoutMillis = 0;                                                            \n    for (;;) {                                                                                \n        if (nextPollTimeoutMillis != 0) {                                                     \n            Binder.flushPendingCommands();                                                    \n        }                                                                                     \n        // 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回\n        // ptr 是在 JNI 层创建的 NativeMessageQueue\n        nativePollOnce(ptr, nextPollTimeoutMillis);                                           \n        \n        // 当前 nativePollOnce 返回后，查看消息队列中是否存在消息\n        synchronized (this) {                                                                 \n            // 尝试检索下一条消息，如果找到则返回                            \n            final long now = SystemClock.uptimeMillis();                                      \n            Message prevMsg = null;                                                           \n            Message msg = mMessages;                                                          \n            if (msg != null && msg.target == null) {                                          \n                // 找到下一条异步消息或者没有消息了，则退出循环\n                do {                                                                          \n                    prevMsg = msg;                                                            \n                    msg = msg.next;                                                           \n                } while (msg != null && !msg.isAsynchronous());                               \n            }                                                                                 \n            if (msg != null) {                                                                \n                if (now < msg.when) {                                                         \n                    // 下一个消息还没准备好，重新设置唤醒超时时间\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {                                                                      \n                    // 获取一条消息                                                         \n                    mBlocked = false;\n                    if (prevMsg != null) {                                                    \n                        prevMsg.next = msg.next;                                              \n                    } else {                                                                  \n                        mMessages = msg.next;                                                 \n                    }                                                                         \n                    msg.next = null;                                                          \n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    // 标记当前消息已使用\n                    msg.markInUse();                                                          \n                    return msg;                                                               \n                }                                                                             \n            } else {                                                                          \n                // 当前还没有消息，设置为 -1，无限等待中                                                     \n                nextPollTimeoutMillis = -1;                                                   \n            }                                                                                 \n                                                                                              \n            // Process the quit message now that all pending messages have been handled.      \n            if (mQuitting) {                                                                  \n                dispose();                                                                    \n                return null;                                                                  \n            }                                                                                 \n                                                                                              \n            // queue is empty or if the first message\n            // get pending idle handler count\n            if (pendingIdleHandlerCount < 0                                                   \n                    && (mMessages == null || now < mMessages.when)) {                         \n                pendingIdleHandlerCount = mIdleHandlers.size();                               \n            }                                                                                 \n            if (pendingIdleHandlerCount <= 0) {                                               \n                // 没有 idle handlers 需要运行，循环继续等待                        \n                mBlocked = true;                                                              \n                continue;                                                                     \n            }                                                                                 \n                                                                                              \n            if (mPendingIdleHandlers == null) {                                               \n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; \n            }                                                                                 \n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               \n        }                                                                                     \n                                                                                              \n        // Run the idle handlers.                                                        \n        // We only ever reach this code block during the first iteration                    \n        for (int i = 0; i < pendingIdleHandlerCount; i++) {                                   \n            final IdleHandler idler = mPendingIdleHandlers[i];                                \n            mPendingIdleHandlers[i] = null;           \n                                                                                              \n            boolean keep = false;                                                             \n            try {                                                                             \n                keep = idler.queueIdle();                                                     \n            } catch (Throwable t) {                                                           \n                Log.wtf(TAG, \"IdleHandler threw exception\", t);                               \n            }                                                                                 \n                                                                                              \n            if (!keep) {                                                                      \n                synchronized (this) {\n                    mIdleHandlers.remove(idler);                                              \n                }                                                                             \n            }                                                                                 \n        }                                                                                     \n                                                                                              \n        // Reset the idle handler count to 0 so we do not run them again.                     \n        pendingIdleHandlerCount = 0;                                                          \n                                                                                              \n        //不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                \n        nextPollTimeoutMillis = 0;                                                            \n    }                                                                                         \n}                                                                                             \n```\n\n在 `next` 方法中，`nativePollOnce` 是阻塞操作，其中 `nextPollTimeoutMillis` 代表下一个消息到来之前，还需要等待的时长；`nextPollTimeoutMillis == -1` 表示当前没有更多消息。`nativePollOnce` 调用结束后，从 `mMessages` 中提取一个消息\n\n当处于空闲时，执行 `IdleHandler` 中的回调方法。\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,  \n        jint ptr, jint timeoutMillis) {\n    // 通过前面设置的 mPrt 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr); \n    // 调用 NativeMessageQueue.pollOnce 进行轮询\n    nativeMessageQueue->pollOnce(timeoutMillis);  \n}  \n```\n\n``` cpp\nvoid NativeMessageQueue::pollOnce(int timeoutMillis) {\n    // 将调用转发给了 JNI 层的 Looper\n    mLooper->pollOnce(timeoutMillis);  \n} \n```\n\n`pollOnce` 会调用 `pollnner` 来进一步操作，如果 `pollnner` 返回值不等于 0，则返回\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nint Looper::pollInner(int timeoutMillis) {  \n    ......  \n  \n    int result = ALOOPER_POLL_WAKE;  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis\n    // 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件\n    // 如果检查成功或者超时，则结束等待\n    // 处于 Idle 状态\n    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    bool acquiredLock = false;  \n#else  \n    ......  \n#endif  \n    \n    // eventCount < 0 可能出错了\n    if (eventCount < 0) {  \n        if (errno == EINTR) {  \n            goto Done;  \n        }  \n  \n        LOGW(\"Poll failed with an unexpected error, errno=%d\", errno);  \n        result = ALOOPER_POLL_ERROR;  \n        goto Done;  \n    }  \n  \t\n    // eventCount == 0 超时\n    if (eventCount == 0) {  \n        ......  \n        result = ALOOPER_POLL_TIMEOUT;  \n        goto Done;  \n    }  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL\n    // eventCount > 0 存在事件\n    for (int i = 0; i < eventCount; i++) {  \n        int fd = eventItems[i].data.fd;  \n        uint32_t epollEvents = eventItems[i].events;  \n        if (fd == mWakeReadPipeFd) {  \n            if (epollEvents & EPOLLIN) {\n                // Looper 中使用 epoll 监听的 EPOLLIN 事件\n                awoken();  \n            } else {  \n                LOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents);  \n            }  \n        } else {  \n            ......  \n        }  \n    }  \n    if (acquiredLock) {  \n        mLock.unlock();  \n    }  \nDone: ;  \n#else  \n    ......  \n#endif  \n  \n    ......  \n  \n    return result;  \n} \n```\n\n``` cpp\nvoid Looper::awoken() {  \n    ......  \n  \n    char buffer[16];  \n    ssize_t nRead;  \n    do {  \n        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));  \n    } while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));  \n}  \n```\n\n总结上面的代码，Looper 通过 `loop` 调用 MessageQueue 的 `next`，`next` 中又会调用到 native 方法 `nativePollOnce`，在这个方法中，会调用到 NativeMessageQueue 的 `pollInner`，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 `awoken`，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。\n\n``` java\nboolean enqueueMessage(Message msg, long when) {                                         \n    if (msg.target == null) {                                                            \n        throw new IllegalArgumentException(\"Message must have a target.\");               \n    }                                                                                    \n    if (msg.isInUse()) {                                                                 \n        throw new IllegalStateException(msg + \" This message is already in use.\");       \n    }                                                                                    \n                                                                                         \n    synchronized (this) {                                                                \n        if (mQuitting) {                                                                 \n            IllegalStateException e = new IllegalStateException(                         \n                    msg.target + \" sending message to a Handler on a dead thread\");      \n            Log.w(TAG, e.getMessage(), e);                                               \n            msg.recycle();                                                               \n            return false;                                                                \n        }                                                                                \n                                                                                         \n        msg.markInUse();                                                                 \n        msg.when = when;                                                                 \n        Message p = mMessages;                                                           \n        boolean needWake;                                                                \n        if (p == null || when == 0 || when < p.when) {                                   \n            // 不存在头部消息或立即执行或执行时机快于头部消息\n            // 将处理的消息作为新的头部消息\n            msg.next = p;                                                                \n            mMessages = msg;                                                             \n            needWake = mBlocked;                                                         \n        } else {                                                                         \n            // 将处理的消息插入到队列的尾部\n            // 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();             \n            Message prev;                                                                \n            for (;;) {                                                                   \n                prev = p;                                                                \n                p = p.next;                                                              \n                if (p == null || when < p.when) {                                        \n                    break;                                                               \n                }                                                                        \n                if (needWake && p.isAsynchronous()) {                                    \n                    needWake = false;                                                    \n                }                                                                        \n            }                                                                            \n            msg.next = p; // invariant: p == prev.next                                   \n            prev.next = msg;                                                             \n        }                                                                                \n                                                                                         \n        // We can assume mPtr != 0 because mQuitting is false.                           \n        if (needWake) {                                                                  \n            nativeWake(mPtr);                                                            \n        }                                                                                \n    }                                                                                    \n    return true;                                                                         \n}                                                                                        \n```\n\n`MessageQueue` 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。\n\n如果当前线程处于空闲等待状态，那么还需要调用 `nativeWake` 来唤醒：\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj, jint ptr) {\n    // ptr 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);  \n    return nativeMessageQueue->wake();  \n}  \n```\n\n这里将唤醒请求转发到 Looper `wake`：\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nvoid Looper::wake() {  \n    ......  \n  \n    ssize_t nWrite;  \n    do {\n        // 先管道中写入 \"W\n        nWrite = write(mWakeWritePipeFd, \"W\", 1);  \n    } while (nWrite == -1 && errno == EINTR);  \n  \n    .......  \n}  \n```\n\n往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 `polllnner` 中调用 `epoll_wait` 进入\n\n``` java\nvoid removeMessages(Handler h, int what, Object object) {     \n    if (h == null) {                                          \n        return;                                               \n    }                                                         \n                                                              \n    synchronized (this) {                                     \n        Message p = mMessages;                                \n                                                              \n        // 从队列头部开始，移除连续的所有符合条件的消息                     \n        while (p != null && p.target == h && p.what == what   \n               && (object == null || p.obj == object)) {      \n            Message n = p.next;                               \n            mMessages = n;\n            // 找到对应的消息，释放它\n            p.recycleUnchecked();                             \n            p = n;                                            \n        }                                                     \n                                                              \n        //  从新的队列头部开始，移除全部符合条件的消息                  \n        while (p != null) {                                   \n            Message n = p.next;                               \n            if (n != null) {                                  \n                if (n.target == h && n.what == what           \n                    && (object == null || n.obj == object)) { \n                    Message nn = n.next;                      \n                    n.recycleUnchecked();                     \n                    p.next = nn;                              \n                    continue;                                 \n                }                                             \n            }                                                 \n            p = n;                                            \n        }                                                     \n    }                                                         \n}                                                             \n```\n\n`postSyncBarrier` 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 `removeSyncBarrier`\n\n当 MessageQueue 退出时，需要 `dispose`：\n\n``` java\n// Disposes of the underlying message queue.                 \n// Must only be called on the looper thread or the finalizer.\nprivate void dispose() {                                     \n    if (mPtr != 0) {\n        // native 方法\n        nativeDestroy(mPtr);\n        // mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量\n        mPtr = 0;                                            \n    }                                                        \n}                                                            \n```\n\n`nativeDestroy` 最终会调用 RefBase 的 `decStrong`：\n\n``` cpp\nvoid RefBase::decStrong(const void* id) const\n{\n    weakref_impl* const refs = mRefs;\n    refs->removeStrongRef(id); //移除强引用\n    const int32_t c = android_atomic_dec(&refs->mStrong);\n    if (c == 1) {\n        refs->mBase->onLastStrongRef(id);\n        if ((refs->mFlags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {\n            delete this;\n        }\n    }\n    refs->decWeak(id); // 移除弱引用\n}\n```\n\n### Message\n\n``` java\nvoid recycleUnchecked() {                 \n    // 标记为使用状态，清除其他状态     \n    flags = FLAG_IN_USE;                  \n    what = 0;                             \n    arg1 = 0;                             \n    arg2 = 0;                             \n    obj = null;                           \n    replyTo = null;                       \n    sendingUid = -1;                      \n    when = 0;                             \n    target = null;                        \n    callback = null;                      \n    data = null;                          \n                                          \n    synchronized (sPoolSync) {\n        // 消息缓存\n        if (sPoolSize < MAX_POOL_SIZE) {  \n            next = sPool;                 \n            sPool = this;                 \n            sPoolSize++;                  \n        }                                 \n    }                                     \n}                                         \n```\n\n``` java\npublic static Message obtain() {             \n    synchronized (sPoolSync) {               \n        if (sPool != null) {\n            // 从缓存中获取\n            Message m = sPool;               \n            sPool = m.next;                  \n            m.next = null;                   \n            m.flags = 0; // clear in-use flag\n            sPoolSize--;                     \n            return m;                        \n        }                                    \n    }                                        \n    return new Message();                    \n}                                            \n```\n\n### 总结\n\n![消息机制](http://gityuan.com/images/handler/handler_java.jpg)\n\nJava 层：\n\n* Handler 通过 `sendMessage`，将 Message 通过 `MessageQueue.enqueueMessage` 添加到队列中\n* Looper 通过 `loop` 提取需要执行的 Message，并交与 `Message.target` 的 Handler 进行 `dispatchMessage` 分发\n*  将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler \n\nJNI 层：\n\n* 线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态\n* 通过 epoll 机制监听 `EPOLLIN` 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程\n\n消息分发的优先级：\n\n1. `Message.callback.run()`\n2. `Handler.mCallback.handleMessage()`\n3. `Handler.handleMessage()`\n\n> EPOLL：Linux 内核的可扩展 I/O 事件通知机制\n>\n> PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入\n>\n> 文件描述符(File descriptor)：用于表述指向[文件](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6)的引用的抽象化概念","source":"_posts/Android消息机制-Handler.md","raw":"---\ntitle: Android消息机制-Handler\ndate: 2018-03-23 20:29:21\ncategories: Android Framework\n---\n\n### 参考\n\n[Android消息机制1-Handler(Java层)](http://gityuan.com/2015/12/26/handler-message-framework/)\n\n[Android消息机制2-Handler(Native层)](http://gityuan.com/2015/12/27/handler-message-native/)\n\n[Android应用程序消息处理机制（Looper、Handler）分析](http://blog.csdn.net/luoshengyang/article/details/6817933)\n\n[管道(Unix)](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix))\n\n[Epoll](https://zh.wikipedia.org/zh-hans/Epoll)\n\n[文件描述符](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)\n\nHandler 机制主要由四个部分组成：\n\n* Looper\n* MessageQueue\n* Message\n* Handler\n\n### 典型用法\n\n``` java\nclass LooperThread extends Thread {\n    public Handler mHandler;\n    \n    public void run() {\n        Looper.prepare();\n        \n        mHandler = new Handler() {\n            public void handleMessage(Message msg) {\n                // process incoming messages here\n            }\n        };\n        \n        Looper.loop();\n    }\n}\n```\n\n### Looper\n\n不断循环执行 `Looper.loop`，按分发机制将消息分发给目标处理者\n\n``` java\nprivate static void prepare(boolean quitAllowed) {\n    if(sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    // 构建 Looper 存储到 ThreadLocal\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n`sThreadLocal` 是一个 ThreadLocal 类型的静态变量\n\n> ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域\n\n``` java\nprivate Looper(boolean quitAllowed) {\n    // Looper 中创建 MessageQueue\n    mQueue = new MessageQueue(quitAllowed);\n    mThread = Thread.currentThread();\n}\n```\n\n``` java\npublic static void loop() {                                                                     \n    final Looper me = myLooper();                                                               \n    if (me == null) {                                                                           \n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }                                                                                           \n    final MessageQueue queue = me.mQueue;                                                       \n                                                                                                \n    // Make sure the identity of this thread is that of the local process,                      \n    // and keep track of what that identity token actually is.                                  \n    Binder.clearCallingIdentity();                                                              \n    final long ident = Binder.clearCallingIdentity();                                           \n                                                                                                \n    for (;;) {                                                                                  \n        Message msg = queue.next(); // 获取下一条 Message，可能会阻塞                                              \n        if (msg == null) {                                                                      \n            // No message indicates that the message queue is quitting.                         \n            return;                                                                             \n        }                                                                                       \n                                                                                                \n        // This must be in a local variable, in case a UI event sets the logger                 \n        final Printer logging = me.mLogging;                                                    \n        if (logging != null) {                                                                  \n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +                        \n                    msg.callback + \": \" + msg.what);                                            \n        }                                                                                       \n                                                                                                \n        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       \n                                                                                                \n        //省略\n        \n        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();     \n        final long end;                                                                         \n        try {\n            // 分发 Message\n            msg.target.dispatchMessage(msg);                                                    \n            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();              \n        } finally {                                                                             \n            if (traceTag != 0) {                                                                \n                Trace.traceEnd(traceTag);                                                       \n            }                                                                                   \n        }                                                                                       \n        if (slowDispatchThresholdMs > 0) {                                                      \n            final long time = end - start;                                                      \n            if (time > slowDispatchThresholdMs) {                                               \n                Slog.w(TAG, \"Dispatch took \" + time + \"ms on \"                                  \n                        + Thread.currentThread().getName() + \", h=\" +                           \n                        msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what);               \n            }                                                                                   \n        }                                                                                       \n                                                                                                \n        if (logging != null) {                                                                  \n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);            \n        }                                                                                       \n                                                                                                \n        // Make sure that during the course of dispatching the                                  \n        // identity of the thread wasn't corrupted.                                             \n        final long newIdent = Binder.clearCallingIdentity();                                    \n        if (ident != newIdent) {                                                                \n            Log.wtf(TAG, \"Thread identity changed from 0x\"                                      \n                    + Long.toHexString(ident) + \" to 0x\"                                        \n                    + Long.toHexString(newIdent) + \" while dispatching to \"                     \n                    + msg.target.getClass().getName() + \" \"                                     \n                    + msg.callback + \" what=\" + msg.what);                                      \n        }                                                                                       \n         \n        // 释放 Message\n        msg.recycleUnchecked();                                                                 \n    }                                                                                           \n}                                                                                               \n```\n\n``` java\n// Looper.quit 最终调用的都是 MessageQueue.quit\npublic void quit() {\n    mQueue.quit(false); // 移除消息\n}\n\npublic void quitSafely() {\n    mQueue.quit(true); // 安全移除消息\n}\n```\n\nMessageQueue 在构造方法中，会调用 native 方法 `nativeInit` 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper\n\n``` cpp\n// frameworks/base/libs\nLooper::Looper(bool allowNonCallbacks) :  \n    mAllowNonCallbacks(allowNonCallbacks),  \n    mResponseIndex(0) {\n    // 管道机制\n    int wakeFds[2];  \n    int result = pipe(wakeFds);  \n    ......  \n  \n    mWakeReadPipeFd = wakeFds[0];  \n    mWakeWritePipeFd = wakeFds[1];  \n  \t\n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    // 分配新的 epoll 实例同时注册唤醒管道\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  \n    ......  \n  \n    struct epoll_event eventItem;  \n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    // 观察 EPOLLIN 事件\n    eventItem.events = EPOLLIN;  \n    eventItem.data.fd = mWakeReadPipeFd;  \n    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem);  \n    ......  \n#else  \n    ......  \n#endif  \n  \n    ......  \n}  \n```\n\n> 管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。\n>\n> epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。\n\npipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。\n\n以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。\n\n### Handler\n\n``` java\npublic Handler(Callback callback, boolean async) {                                                  \n    if (FIND_POTENTIAL_LEAKS) {                                                                     \n        final Class<? extends Handler> klass = getClass();                                          \n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&          \n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            // 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +      \n                klass.getCanonicalName());                                                          \n        }                                                                                           \n    }                                                                                               \n    // 默认使用当前线程的 Looper                                                                                                \n    mLooper = Looper.myLooper();                                                                    \n    if (mLooper == null) {                                                                          \n        throw new RuntimeException(                                                                 \n            \"Can't create handler inside thread that has not called Looper.prepare()\");             \n    }                                                                                               \n    mQueue = mLooper.mQueue;                                                                        \n    mCallback = callback;\n    // 是否为异步处理\n    mAsynchronous = async;                                                                          \n}                                                                                                   \n```\n\n在 `Looper.loop` 中，当存在 Message 需要处理时，会调用 `dispatchMessage` 来进行分发：\n\n``` java\npublic void dispatchMessage(Message msg) {      \n    if (msg.callback != null) {\n        // 先调用 callback\n        handleCallback(msg);                    \n    } else {                                    \n        if (mCallback != null) {\n            // 接着检查通过构造方法传进来的 Callback\n            if (mCallback.handleMessage(msg)) { \n                return;                         \n            }                                   \n        }\n        // 最后调用 handleMessage\n        handleMessage(msg);                     \n    }                                           \n}                                               \n```\n\n通过 Handler 发送消息：\n\n![发送消息调用链](http://gityuan.com/images/handler/java_sendmessage.png)\n\n最终所有的方法都会调用到 `MessageQueue.enqueueMessage`\n\n### MessageQueue\n\n> 消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理\n\n``` java\nMessageQueue(boolean quitAllowed) { \n    mQuitAllowed = quitAllowed;\n    // used by native code\n    mPtr = nativeInit();            \n}                                   \n```\n\nMessageQueue 的初始化工作主要由 native 方法来执行\n\n``` cpp\n//frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {\n    // 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();  \n    if (! nativeMessageQueue) {  \n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");  \n        return;  \n    }  \n  \t\n    // 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量\n    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  \n}  \n```\n\n`nativeInit` 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 `mPtr`，关联了 NativeMessageQueue 和 MessageQueue\n\n``` java\nMessage next() {                                                                              \n    // messsage loop has already quit                                                              \n    final long ptr = mPtr;                                                                    \n    if (ptr == 0) {                                                                           \n        return null;                                                                          \n    }                                                                                         \n                                                                                              \n    int pendingIdleHandlerCount = -1; // -1 only during first iteration                       \n    int nextPollTimeoutMillis = 0;                                                            \n    for (;;) {                                                                                \n        if (nextPollTimeoutMillis != 0) {                                                     \n            Binder.flushPendingCommands();                                                    \n        }                                                                                     \n        // 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回\n        // ptr 是在 JNI 层创建的 NativeMessageQueue\n        nativePollOnce(ptr, nextPollTimeoutMillis);                                           \n        \n        // 当前 nativePollOnce 返回后，查看消息队列中是否存在消息\n        synchronized (this) {                                                                 \n            // 尝试检索下一条消息，如果找到则返回                            \n            final long now = SystemClock.uptimeMillis();                                      \n            Message prevMsg = null;                                                           \n            Message msg = mMessages;                                                          \n            if (msg != null && msg.target == null) {                                          \n                // 找到下一条异步消息或者没有消息了，则退出循环\n                do {                                                                          \n                    prevMsg = msg;                                                            \n                    msg = msg.next;                                                           \n                } while (msg != null && !msg.isAsynchronous());                               \n            }                                                                                 \n            if (msg != null) {                                                                \n                if (now < msg.when) {                                                         \n                    // 下一个消息还没准备好，重新设置唤醒超时时间\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {                                                                      \n                    // 获取一条消息                                                         \n                    mBlocked = false;\n                    if (prevMsg != null) {                                                    \n                        prevMsg.next = msg.next;                                              \n                    } else {                                                                  \n                        mMessages = msg.next;                                                 \n                    }                                                                         \n                    msg.next = null;                                                          \n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    // 标记当前消息已使用\n                    msg.markInUse();                                                          \n                    return msg;                                                               \n                }                                                                             \n            } else {                                                                          \n                // 当前还没有消息，设置为 -1，无限等待中                                                     \n                nextPollTimeoutMillis = -1;                                                   \n            }                                                                                 \n                                                                                              \n            // Process the quit message now that all pending messages have been handled.      \n            if (mQuitting) {                                                                  \n                dispose();                                                                    \n                return null;                                                                  \n            }                                                                                 \n                                                                                              \n            // queue is empty or if the first message\n            // get pending idle handler count\n            if (pendingIdleHandlerCount < 0                                                   \n                    && (mMessages == null || now < mMessages.when)) {                         \n                pendingIdleHandlerCount = mIdleHandlers.size();                               \n            }                                                                                 \n            if (pendingIdleHandlerCount <= 0) {                                               \n                // 没有 idle handlers 需要运行，循环继续等待                        \n                mBlocked = true;                                                              \n                continue;                                                                     \n            }                                                                                 \n                                                                                              \n            if (mPendingIdleHandlers == null) {                                               \n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; \n            }                                                                                 \n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               \n        }                                                                                     \n                                                                                              \n        // Run the idle handlers.                                                        \n        // We only ever reach this code block during the first iteration                    \n        for (int i = 0; i < pendingIdleHandlerCount; i++) {                                   \n            final IdleHandler idler = mPendingIdleHandlers[i];                                \n            mPendingIdleHandlers[i] = null;           \n                                                                                              \n            boolean keep = false;                                                             \n            try {                                                                             \n                keep = idler.queueIdle();                                                     \n            } catch (Throwable t) {                                                           \n                Log.wtf(TAG, \"IdleHandler threw exception\", t);                               \n            }                                                                                 \n                                                                                              \n            if (!keep) {                                                                      \n                synchronized (this) {\n                    mIdleHandlers.remove(idler);                                              \n                }                                                                             \n            }                                                                                 \n        }                                                                                     \n                                                                                              \n        // Reset the idle handler count to 0 so we do not run them again.                     \n        pendingIdleHandlerCount = 0;                                                          \n                                                                                              \n        //不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                \n        nextPollTimeoutMillis = 0;                                                            \n    }                                                                                         \n}                                                                                             \n```\n\n在 `next` 方法中，`nativePollOnce` 是阻塞操作，其中 `nextPollTimeoutMillis` 代表下一个消息到来之前，还需要等待的时长；`nextPollTimeoutMillis == -1` 表示当前没有更多消息。`nativePollOnce` 调用结束后，从 `mMessages` 中提取一个消息\n\n当处于空闲时，执行 `IdleHandler` 中的回调方法。\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,  \n        jint ptr, jint timeoutMillis) {\n    // 通过前面设置的 mPrt 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr); \n    // 调用 NativeMessageQueue.pollOnce 进行轮询\n    nativeMessageQueue->pollOnce(timeoutMillis);  \n}  \n```\n\n``` cpp\nvoid NativeMessageQueue::pollOnce(int timeoutMillis) {\n    // 将调用转发给了 JNI 层的 Looper\n    mLooper->pollOnce(timeoutMillis);  \n} \n```\n\n`pollOnce` 会调用 `pollnner` 来进一步操作，如果 `pollnner` 返回值不等于 0，则返回\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nint Looper::pollInner(int timeoutMillis) {  \n    ......  \n  \n    int result = ALOOPER_POLL_WAKE;  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis\n    // 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件\n    // 如果检查成功或者超时，则结束等待\n    // 处于 Idle 状态\n    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    bool acquiredLock = false;  \n#else  \n    ......  \n#endif  \n    \n    // eventCount < 0 可能出错了\n    if (eventCount < 0) {  \n        if (errno == EINTR) {  \n            goto Done;  \n        }  \n  \n        LOGW(\"Poll failed with an unexpected error, errno=%d\", errno);  \n        result = ALOOPER_POLL_ERROR;  \n        goto Done;  \n    }  \n  \t\n    // eventCount == 0 超时\n    if (eventCount == 0) {  \n        ......  \n        result = ALOOPER_POLL_TIMEOUT;  \n        goto Done;  \n    }  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL\n    // eventCount > 0 存在事件\n    for (int i = 0; i < eventCount; i++) {  \n        int fd = eventItems[i].data.fd;  \n        uint32_t epollEvents = eventItems[i].events;  \n        if (fd == mWakeReadPipeFd) {  \n            if (epollEvents & EPOLLIN) {\n                // Looper 中使用 epoll 监听的 EPOLLIN 事件\n                awoken();  \n            } else {  \n                LOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents);  \n            }  \n        } else {  \n            ......  \n        }  \n    }  \n    if (acquiredLock) {  \n        mLock.unlock();  \n    }  \nDone: ;  \n#else  \n    ......  \n#endif  \n  \n    ......  \n  \n    return result;  \n} \n```\n\n``` cpp\nvoid Looper::awoken() {  \n    ......  \n  \n    char buffer[16];  \n    ssize_t nRead;  \n    do {  \n        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));  \n    } while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));  \n}  \n```\n\n总结上面的代码，Looper 通过 `loop` 调用 MessageQueue 的 `next`，`next` 中又会调用到 native 方法 `nativePollOnce`，在这个方法中，会调用到 NativeMessageQueue 的 `pollInner`，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 `awoken`，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。\n\n``` java\nboolean enqueueMessage(Message msg, long when) {                                         \n    if (msg.target == null) {                                                            \n        throw new IllegalArgumentException(\"Message must have a target.\");               \n    }                                                                                    \n    if (msg.isInUse()) {                                                                 \n        throw new IllegalStateException(msg + \" This message is already in use.\");       \n    }                                                                                    \n                                                                                         \n    synchronized (this) {                                                                \n        if (mQuitting) {                                                                 \n            IllegalStateException e = new IllegalStateException(                         \n                    msg.target + \" sending message to a Handler on a dead thread\");      \n            Log.w(TAG, e.getMessage(), e);                                               \n            msg.recycle();                                                               \n            return false;                                                                \n        }                                                                                \n                                                                                         \n        msg.markInUse();                                                                 \n        msg.when = when;                                                                 \n        Message p = mMessages;                                                           \n        boolean needWake;                                                                \n        if (p == null || when == 0 || when < p.when) {                                   \n            // 不存在头部消息或立即执行或执行时机快于头部消息\n            // 将处理的消息作为新的头部消息\n            msg.next = p;                                                                \n            mMessages = msg;                                                             \n            needWake = mBlocked;                                                         \n        } else {                                                                         \n            // 将处理的消息插入到队列的尾部\n            // 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();             \n            Message prev;                                                                \n            for (;;) {                                                                   \n                prev = p;                                                                \n                p = p.next;                                                              \n                if (p == null || when < p.when) {                                        \n                    break;                                                               \n                }                                                                        \n                if (needWake && p.isAsynchronous()) {                                    \n                    needWake = false;                                                    \n                }                                                                        \n            }                                                                            \n            msg.next = p; // invariant: p == prev.next                                   \n            prev.next = msg;                                                             \n        }                                                                                \n                                                                                         \n        // We can assume mPtr != 0 because mQuitting is false.                           \n        if (needWake) {                                                                  \n            nativeWake(mPtr);                                                            \n        }                                                                                \n    }                                                                                    \n    return true;                                                                         \n}                                                                                        \n```\n\n`MessageQueue` 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。\n\n如果当前线程处于空闲等待状态，那么还需要调用 `nativeWake` 来唤醒：\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj, jint ptr) {\n    // ptr 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);  \n    return nativeMessageQueue->wake();  \n}  \n```\n\n这里将唤醒请求转发到 Looper `wake`：\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nvoid Looper::wake() {  \n    ......  \n  \n    ssize_t nWrite;  \n    do {\n        // 先管道中写入 \"W\n        nWrite = write(mWakeWritePipeFd, \"W\", 1);  \n    } while (nWrite == -1 && errno == EINTR);  \n  \n    .......  \n}  \n```\n\n往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 `polllnner` 中调用 `epoll_wait` 进入\n\n``` java\nvoid removeMessages(Handler h, int what, Object object) {     \n    if (h == null) {                                          \n        return;                                               \n    }                                                         \n                                                              \n    synchronized (this) {                                     \n        Message p = mMessages;                                \n                                                              \n        // 从队列头部开始，移除连续的所有符合条件的消息                     \n        while (p != null && p.target == h && p.what == what   \n               && (object == null || p.obj == object)) {      \n            Message n = p.next;                               \n            mMessages = n;\n            // 找到对应的消息，释放它\n            p.recycleUnchecked();                             \n            p = n;                                            \n        }                                                     \n                                                              \n        //  从新的队列头部开始，移除全部符合条件的消息                  \n        while (p != null) {                                   \n            Message n = p.next;                               \n            if (n != null) {                                  \n                if (n.target == h && n.what == what           \n                    && (object == null || n.obj == object)) { \n                    Message nn = n.next;                      \n                    n.recycleUnchecked();                     \n                    p.next = nn;                              \n                    continue;                                 \n                }                                             \n            }                                                 \n            p = n;                                            \n        }                                                     \n    }                                                         \n}                                                             \n```\n\n`postSyncBarrier` 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 `removeSyncBarrier`\n\n当 MessageQueue 退出时，需要 `dispose`：\n\n``` java\n// Disposes of the underlying message queue.                 \n// Must only be called on the looper thread or the finalizer.\nprivate void dispose() {                                     \n    if (mPtr != 0) {\n        // native 方法\n        nativeDestroy(mPtr);\n        // mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量\n        mPtr = 0;                                            \n    }                                                        \n}                                                            \n```\n\n`nativeDestroy` 最终会调用 RefBase 的 `decStrong`：\n\n``` cpp\nvoid RefBase::decStrong(const void* id) const\n{\n    weakref_impl* const refs = mRefs;\n    refs->removeStrongRef(id); //移除强引用\n    const int32_t c = android_atomic_dec(&refs->mStrong);\n    if (c == 1) {\n        refs->mBase->onLastStrongRef(id);\n        if ((refs->mFlags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {\n            delete this;\n        }\n    }\n    refs->decWeak(id); // 移除弱引用\n}\n```\n\n### Message\n\n``` java\nvoid recycleUnchecked() {                 \n    // 标记为使用状态，清除其他状态     \n    flags = FLAG_IN_USE;                  \n    what = 0;                             \n    arg1 = 0;                             \n    arg2 = 0;                             \n    obj = null;                           \n    replyTo = null;                       \n    sendingUid = -1;                      \n    when = 0;                             \n    target = null;                        \n    callback = null;                      \n    data = null;                          \n                                          \n    synchronized (sPoolSync) {\n        // 消息缓存\n        if (sPoolSize < MAX_POOL_SIZE) {  \n            next = sPool;                 \n            sPool = this;                 \n            sPoolSize++;                  \n        }                                 \n    }                                     \n}                                         \n```\n\n``` java\npublic static Message obtain() {             \n    synchronized (sPoolSync) {               \n        if (sPool != null) {\n            // 从缓存中获取\n            Message m = sPool;               \n            sPool = m.next;                  \n            m.next = null;                   \n            m.flags = 0; // clear in-use flag\n            sPoolSize--;                     \n            return m;                        \n        }                                    \n    }                                        \n    return new Message();                    \n}                                            \n```\n\n### 总结\n\n![消息机制](http://gityuan.com/images/handler/handler_java.jpg)\n\nJava 层：\n\n* Handler 通过 `sendMessage`，将 Message 通过 `MessageQueue.enqueueMessage` 添加到队列中\n* Looper 通过 `loop` 提取需要执行的 Message，并交与 `Message.target` 的 Handler 进行 `dispatchMessage` 分发\n*  将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler \n\nJNI 层：\n\n* 线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态\n* 通过 epoll 机制监听 `EPOLLIN` 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程\n\n消息分发的优先级：\n\n1. `Message.callback.run()`\n2. `Handler.mCallback.handleMessage()`\n3. `Handler.handleMessage()`\n\n> EPOLL：Linux 内核的可扩展 I/O 事件通知机制\n>\n> PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入\n>\n> 文件描述符(File descriptor)：用于表述指向[文件](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6)的引用的抽象化概念","slug":"Android消息机制-Handler","published":1,"updated":"2018-04-11T14:05:30.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg0ku8a30002hio6snmfub19","content":"<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://gityuan.com/2015/12/26/handler-message-framework/\" target=\"_blank\" rel=\"noopener\">Android消息机制1-Handler(Java层)</a></p>\n<p><a href=\"http://gityuan.com/2015/12/27/handler-message-native/\" target=\"_blank\" rel=\"noopener\">Android消息机制2-Handler(Native层)</a></p>\n<p><a href=\"http://blog.csdn.net/luoshengyang/article/details/6817933\" target=\"_blank\" rel=\"noopener\">Android应用程序消息处理机制（Looper、Handler）分析</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix\" target=\"_blank\" rel=\"noopener\">管道(Unix)</a>)</p>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/Epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">文件描述符</a></p>\n<p>Handler 机制主要由四个部分组成：</p>\n<ul>\n<li>Looper</li>\n<li>MessageQueue</li>\n<li>Message</li>\n<li>Handler</li>\n</ul>\n<h3 id=\"典型用法\"><a href=\"#典型用法\" class=\"headerlink\" title=\"典型用法\"></a>典型用法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        </span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>不断循环执行 <code>Looper.loop</code>，按分发机制将消息分发给目标处理者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构建 Looper 存储到 ThreadLocal</span></span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>sThreadLocal</code> 是一个 ThreadLocal 类型的静态变量</p>\n<blockquote>\n<p>ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Looper 中创建 MessageQueue</span></span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,                      </span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.                                  </span></span><br><span class=\"line\">    Binder.clearCallingIdentity();                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();                                           </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                  </span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// 获取下一条 Message，可能会阻塞                                              </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;                                                                      </span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.                         </span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger                 </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Printer logging = me.mLogging;                                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +                        </span><br><span class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);                                            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">//省略</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> end;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 分发 Message</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);                                                    </span><br><span class=\"line\">            end = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();              </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;                                                                             </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;                                                                </span><br><span class=\"line\">                Trace.traceEnd(traceTag);                                                       </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>) &#123;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> time = end - start;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; slowDispatchThresholdMs) &#123;                                               </span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Dispatch took \"</span> + time + <span class=\"string\">\"ms on \"</span>                                  </span><br><span class=\"line\">                        + Thread.currentThread().getName() + <span class=\"string\">\", h=\"</span> +                           </span><br><span class=\"line\">                        msg.target + <span class=\"string\">\" cb=\"</span> + msg.callback + <span class=\"string\">\" msg=\"</span> + msg.what);               </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the                                  </span></span><br><span class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.                                             </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;                                                                </span><br><span class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span>                                      </span><br><span class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span>                                        </span><br><span class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span>                     </span><br><span class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span>                                     </span><br><span class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);                                      </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"comment\">// 释放 Message</span></span><br><span class=\"line\">        msg.recycleUnchecked();                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Looper.quit 最终调用的都是 MessageQueue.quit</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">false</span>); <span class=\"comment\">// 移除消息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quitSafely</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">true</span>); <span class=\"comment\">// 安全移除消息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 在构造方法中，会调用 native 方法 <code>nativeInit</code> 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs</span></span><br><span class=\"line\">Looper::Looper(<span class=\"keyword\">bool</span> allowNonCallbacks) :  </span><br><span class=\"line\">    mAllowNonCallbacks(allowNonCallbacks),  </span><br><span class=\"line\">    mResponseIndex(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 管道机制</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> wakeFds[<span class=\"number\">2</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = pipe(wakeFds);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    mWakeReadPipeFd = wakeFds[<span class=\"number\">0</span>];  </span><br><span class=\"line\">    mWakeWritePipeFd = wakeFds[<span class=\"number\">1</span>];  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"comment\">// 分配新的 epoll 实例同时注册唤醒管道</span></span><br><span class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItem</span>;</span>  </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp; eventItem, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(epoll_event)); <span class=\"comment\">// zero out unused members of data field union</span></span><br><span class=\"line\">    <span class=\"comment\">// 观察 EPOLLIN 事件</span></span><br><span class=\"line\">    eventItem.events = EPOLLIN;  </span><br><span class=\"line\">    eventItem.data.fd = mWakeReadPipeFd;  </span><br><span class=\"line\">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。</p>\n<p>epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p>\n</blockquote>\n<p>pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。</p>\n<p>以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;                                                                     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();                                          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;          </span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏</span></span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +      </span><br><span class=\"line\">                klass.getCanonicalName());                                                          </span><br><span class=\"line\">        &#125;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    <span class=\"comment\">// 默认使用当前线程的 Looper                                                                                                </span></span><br><span class=\"line\">    mLooper = Looper.myLooper();                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(                                                                 </span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread that has not called Looper.prepare()\"</span>);             </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    mQueue = mLooper.mQueue;                                                                        </span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    <span class=\"comment\">// 是否为异步处理</span></span><br><span class=\"line\">    mAsynchronous = async;                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>Looper.loop</code> 中，当存在 Message 需要处理时，会调用 <code>dispatchMessage</code> 来进行分发：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用 callback</span></span><br><span class=\"line\">        handleCallback(msg);                    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接着检查通过构造方法传进来的 Callback</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123; </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;                         </span><br><span class=\"line\">            &#125;                                   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 最后调用 handleMessage</span></span><br><span class=\"line\">        handleMessage(msg);                     </span><br><span class=\"line\">    &#125;                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 Handler 发送消息：</p>\n<p><img src=\"http://gityuan.com/images/handler/java_sendmessage.png\" alt=\"发送消息调用链\"></p>\n<p>最终所有的方法都会调用到 <code>MessageQueue.enqueueMessage</code></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><blockquote>\n<p>消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123; </span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    <span class=\"comment\">// used by native code</span></span><br><span class=\"line\">    mPtr = nativeInit();            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 的初始化工作主要由 native 方法来执行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> NativeMessageQueue();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! nativeMessageQueue) &#123;  </span><br><span class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Unable to allocate native queue\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量</span></span><br><span class=\"line\">    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeInit</code> 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 <code>mPtr</code>，关联了 NativeMessageQueue 和 MessageQueue</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// messsage loop has already quit                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                          </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration                       </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;                                                     </span><br><span class=\"line\">            Binder.flushPendingCommands();                                                    </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class=\"line\">        <span class=\"comment\">// ptr 是在 JNI 层创建的 NativeMessageQueue</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);                                           </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 当前 nativePollOnce 返回后，查看消息队列中是否存在消息</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                 </span><br><span class=\"line\">            <span class=\"comment\">// 尝试检索下一条消息，如果找到则返回                            </span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();                                      </span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">            Message msg = mMessages;                                                          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">                <span class=\"comment\">// 找到下一条异步消息或者没有消息了，则退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;                                                                          </span><br><span class=\"line\">                    prevMsg = msg;                                                            </span><br><span class=\"line\">                    msg = msg.next;                                                           </span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;                                                                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;                                                         </span><br><span class=\"line\">                    <span class=\"comment\">// 下一个消息还没准备好，重新设置唤醒超时时间</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;                                                                      </span><br><span class=\"line\">                    <span class=\"comment\">// 获取一条消息                                                         </span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;                                                    </span><br><span class=\"line\">                        prevMsg.next = msg.next;                                              </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;                                                                  </span><br><span class=\"line\">                        mMessages = msg.next;                                                 </span><br><span class=\"line\">                    &#125;                                                                         </span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"Returning message: \"</span> + msg);</span><br><span class=\"line\">                    <span class=\"comment\">// 标记当前消息已使用</span></span><br><span class=\"line\">                    msg.markInUse();                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;                                                               </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;                                                                          </span><br><span class=\"line\">                <span class=\"comment\">// 当前还没有消息，设置为 -1，无限等待中                                                     </span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;                                                   </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.      </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                  </span><br><span class=\"line\">                dispose();                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                  </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// get pending idle handler count</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span>                                                   </span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;                         </span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">                <span class=\"comment\">// 没有 idle handlers 需要运行，循环继续等待                        </span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                                                                     </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;                                               </span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)]; </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.                                                        </span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration                    </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;                                   </span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];                                </span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>;           </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;                                                             </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;                                                                             </span><br><span class=\"line\">                keep = idler.queueIdle();                                                     </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;                                                           </span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;                                                                      </span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);                                              </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.                     </span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;                                                          </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">//不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                </span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>next</code> 方法中，<code>nativePollOnce</code> 是阻塞操作，其中 <code>nextPollTimeoutMillis</code> 代表下一个消息到来之前，还需要等待的时长；<code>nextPollTimeoutMillis == -1</code> 表示当前没有更多消息。<code>nativePollOnce</code> 调用结束后，从 <code>mMessages</code> 中提取一个消息</p>\n<p>当处于空闲时，执行 <code>IdleHandler</code> 中的回调方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jint ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过前面设置的 mPrt 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr); </span><br><span class=\"line\">    <span class=\"comment\">// 调用 NativeMessageQueue.pollOnce 进行轮询</span></span><br><span class=\"line\">    nativeMessageQueue-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> NativeMessageQueue::pollOnce(<span class=\"keyword\">int</span> timeoutMillis) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将调用转发给了 JNI 层的 Looper</span></span><br><span class=\"line\">    mLooper-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>pollOnce</code> 会调用 <code>pollnner</code> 来进一步操作，如果 <code>pollnner</code> 返回值不等于 0，则返回</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Looper::pollInner(<span class=\"keyword\">int</span> timeoutMillis) &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = ALOOPER_POLL_WAKE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItems</span>[<span class=\"title\">EPOLL_MAX_EVENTS</span>];</span></span><br><span class=\"line\">    <span class=\"comment\">// 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis</span></span><br><span class=\"line\">    <span class=\"comment\">// 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果检查成功或者超时，则结束等待</span></span><br><span class=\"line\">    <span class=\"comment\">// 处于 Idle 状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> acquiredLock = <span class=\"literal\">false</span>;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// eventCount &lt; 0 可能出错了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        LOGW(<span class=\"string\">\"Poll failed with an unexpected error, errno=%d\"</span>, errno);  </span><br><span class=\"line\">        result = ALOOPER_POLL_ERROR;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// eventCount == 0 超时</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        ......  </span><br><span class=\"line\">        result = ALOOPER_POLL_TIMEOUT;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL</span></span><br><span class=\"line\">    <span class=\"comment\">// eventCount &gt; 0 存在事件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd = eventItems[i].data.fd;  </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Looper 中使用 epoll 监听的 EPOLLIN 事件</span></span><br><span class=\"line\">                awoken();  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                LOGW(<span class=\"string\">\"Ignoring unexpected epoll events 0x%x on wake read pipe.\"</span>, epollEvents);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            ......  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquiredLock) &#123;  </span><br><span class=\"line\">        mLock.unlock();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">Done: ;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::awoken() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">16</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nRead;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">        nRead = read(mWakeReadPipeFd, buffer, <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((nRead == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结上面的代码，Looper 通过 <code>loop</code> 调用 MessageQueue 的 <code>next</code>，<code>next</code> 中又会调用到 native 方法 <code>nativePollOnce</code>，在这个方法中，会调用到 NativeMessageQueue 的 <code>pollInner</code>，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 <code>awoken</code>，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;                                                            </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Message must have a target.\"</span>);               </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">\" This message is already in use.\"</span>);       </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                 </span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(                         </span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);      </span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);                                               </span><br><span class=\"line\">            msg.recycle();                                                               </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        msg.markInUse();                                                                 </span><br><span class=\"line\">        msg.when = when;                                                                 </span><br><span class=\"line\">        Message p = mMessages;                                                           </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;                                   </span><br><span class=\"line\">            <span class=\"comment\">// 不存在头部消息或立即执行或执行时机快于头部消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息作为新的头部消息</span></span><br><span class=\"line\">            msg.next = p;                                                                </span><br><span class=\"line\">            mMessages = msg;                                                             </span><br><span class=\"line\">            needWake = mBlocked;                                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                                         </span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息插入到队列的尾部</span></span><br><span class=\"line\">            <span class=\"comment\">// 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();             </span><br><span class=\"line\">            Message prev;                                                                </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;                                                                   </span><br><span class=\"line\">                prev = p;                                                                </span><br><span class=\"line\">                p = p.next;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;                                        </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                               </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;                                    </span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;                                                    </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">            &#125;                                                                            </span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next                                   </span></span><br><span class=\"line\">            prev.next = msg;                                                             </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.                           </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;                                                                  </span><br><span class=\"line\">            nativeWake(mPtr);                                                            </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MessageQueue</code> 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。</p>\n<p>如果当前线程处于空闲等待状态，那么还需要调用 <code>nativeWake</code> 来唤醒：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jobject obj, jint ptr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ptr 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nativeMessageQueue-&gt;wake();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将唤醒请求转发到 Looper <code>wake</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Looper::wake() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nWrite;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先管道中写入 \"W</span></span><br><span class=\"line\">        nWrite = write(mWakeWritePipeFd, <span class=\"string\">\"W\"</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (nWrite == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    .......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 <code>polllnner</code> 中调用 <code>epoll_wait</code> 进入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, <span class=\"keyword\">int</span> what, Object object)</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                               </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                     </span><br><span class=\"line\">        Message p = mMessages;                                </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">// 从队列头部开始，移除连续的所有符合条件的消息                     </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what   </span><br><span class=\"line\">               &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;      </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            <span class=\"comment\">// 找到对应的消息，释放它</span></span><br><span class=\"line\">            p.recycleUnchecked();                             </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">//  从新的队列头部开始，移除全部符合条件的消息                  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;                                   </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;                                  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.what == what           </span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123; </span><br><span class=\"line\">                    Message nn = n.next;                      </span><br><span class=\"line\">                    n.recycleUnchecked();                     </span><br><span class=\"line\">                    p.next = nn;                              </span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;                                 </span><br><span class=\"line\">                &#125;                                             </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSyncBarrier</code> 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 <code>removeSyncBarrier</code></p>\n<p>当 MessageQueue 退出时，需要 <code>dispose</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposes of the underlying message queue.                 </span></span><br><span class=\"line\"><span class=\"comment\">// Must only be called on the looper thread or the finalizer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPtr != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// native 方法</span></span><br><span class=\"line\">        nativeDestroy(mPtr);</span><br><span class=\"line\">        <span class=\"comment\">// mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量</span></span><br><span class=\"line\">        mPtr = <span class=\"number\">0</span>;                                            </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeDestroy</code> 最终会调用 RefBase 的 <code>decStrong</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> RefBase::decStrong(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* id) <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weakref_impl* <span class=\"keyword\">const</span> refs = mRefs;</span><br><span class=\"line\">    refs-&gt;removeStrongRef(id); <span class=\"comment\">//移除强引用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs-&gt;decWeak(id); <span class=\"comment\">// 移除弱引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycleUnchecked</span><span class=\"params\">()</span> </span>&#123;                 </span><br><span class=\"line\">    <span class=\"comment\">// 标记为使用状态，清除其他状态     </span></span><br><span class=\"line\">    flags = FLAG_IN_USE;                  </span><br><span class=\"line\">    what = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg1 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg2 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    obj = <span class=\"keyword\">null</span>;                           </span><br><span class=\"line\">    replyTo = <span class=\"keyword\">null</span>;                       </span><br><span class=\"line\">    sendingUid = -<span class=\"number\">1</span>;                      </span><br><span class=\"line\">    when = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    target = <span class=\"keyword\">null</span>;                        </span><br><span class=\"line\">    callback = <span class=\"keyword\">null</span>;                      </span><br><span class=\"line\">    data = <span class=\"keyword\">null</span>;                          </span><br><span class=\"line\">                                          </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;  </span><br><span class=\"line\">            next = sPool;                 </span><br><span class=\"line\">            sPool = <span class=\"keyword\">this</span>;                 </span><br><span class=\"line\">            sPoolSize++;                  </span><br><span class=\"line\">        &#125;                                 </span><br><span class=\"line\">    &#125;                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;             </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从缓存中获取</span></span><br><span class=\"line\">            Message m = sPool;               </span><br><span class=\"line\">            sPool = m.next;                  </span><br><span class=\"line\">            m.next = <span class=\"keyword\">null</span>;                   </span><br><span class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></span><br><span class=\"line\">            sPoolSize--;                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;                        </span><br><span class=\"line\">        &#125;                                    </span><br><span class=\"line\">    &#125;                                        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"http://gityuan.com/images/handler/handler_java.jpg\" alt=\"消息机制\"></p>\n<p>Java 层：</p>\n<ul>\n<li>Handler 通过 <code>sendMessage</code>，将 Message 通过 <code>MessageQueue.enqueueMessage</code> 添加到队列中</li>\n<li>Looper 通过 <code>loop</code> 提取需要执行的 Message，并交与 <code>Message.target</code> 的 Handler 进行 <code>dispatchMessage</code> 分发</li>\n<li>将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler </li>\n</ul>\n<p>JNI 层：</p>\n<ul>\n<li>线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态</li>\n<li>通过 epoll 机制监听 <code>EPOLLIN</code> 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程</li>\n</ul>\n<p>消息分发的优先级：</p>\n<ol>\n<li><code>Message.callback.run()</code></li>\n<li><code>Handler.mCallback.handleMessage()</code></li>\n<li><code>Handler.handleMessage()</code></li>\n</ol>\n<blockquote>\n<p>EPOLL：Linux 内核的可扩展 I/O 事件通知机制</p>\n<p>PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入</p>\n<p>文件描述符(File descriptor)：用于表述指向<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">文件</a>的引用的抽象化概念</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://gityuan.com/2015/12/26/handler-message-framework/\" target=\"_blank\" rel=\"noopener\">Android消息机制1-Handler(Java层)</a></p>\n<p><a href=\"http://gityuan.com/2015/12/27/handler-message-native/\" target=\"_blank\" rel=\"noopener\">Android消息机制2-Handler(Native层)</a></p>\n<p><a href=\"http://blog.csdn.net/luoshengyang/article/details/6817933\" target=\"_blank\" rel=\"noopener\">Android应用程序消息处理机制（Looper、Handler）分析</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix\" target=\"_blank\" rel=\"noopener\">管道(Unix)</a>)</p>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/Epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">文件描述符</a></p>\n<p>Handler 机制主要由四个部分组成：</p>\n<ul>\n<li>Looper</li>\n<li>MessageQueue</li>\n<li>Message</li>\n<li>Handler</li>\n</ul>\n<h3 id=\"典型用法\"><a href=\"#典型用法\" class=\"headerlink\" title=\"典型用法\"></a>典型用法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        </span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>不断循环执行 <code>Looper.loop</code>，按分发机制将消息分发给目标处理者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构建 Looper 存储到 ThreadLocal</span></span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>sThreadLocal</code> 是一个 ThreadLocal 类型的静态变量</p>\n<blockquote>\n<p>ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Looper 中创建 MessageQueue</span></span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,                      </span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.                                  </span></span><br><span class=\"line\">    Binder.clearCallingIdentity();                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();                                           </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                  </span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// 获取下一条 Message，可能会阻塞                                              </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;                                                                      </span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.                         </span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger                 </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Printer logging = me.mLogging;                                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +                        </span><br><span class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);                                            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">//省略</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> end;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 分发 Message</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);                                                    </span><br><span class=\"line\">            end = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();              </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;                                                                             </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;                                                                </span><br><span class=\"line\">                Trace.traceEnd(traceTag);                                                       </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>) &#123;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> time = end - start;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; slowDispatchThresholdMs) &#123;                                               </span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Dispatch took \"</span> + time + <span class=\"string\">\"ms on \"</span>                                  </span><br><span class=\"line\">                        + Thread.currentThread().getName() + <span class=\"string\">\", h=\"</span> +                           </span><br><span class=\"line\">                        msg.target + <span class=\"string\">\" cb=\"</span> + msg.callback + <span class=\"string\">\" msg=\"</span> + msg.what);               </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the                                  </span></span><br><span class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.                                             </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;                                                                </span><br><span class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span>                                      </span><br><span class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span>                                        </span><br><span class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span>                     </span><br><span class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span>                                     </span><br><span class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);                                      </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"comment\">// 释放 Message</span></span><br><span class=\"line\">        msg.recycleUnchecked();                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Looper.quit 最终调用的都是 MessageQueue.quit</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">false</span>); <span class=\"comment\">// 移除消息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quitSafely</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">true</span>); <span class=\"comment\">// 安全移除消息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 在构造方法中，会调用 native 方法 <code>nativeInit</code> 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs</span></span><br><span class=\"line\">Looper::Looper(<span class=\"keyword\">bool</span> allowNonCallbacks) :  </span><br><span class=\"line\">    mAllowNonCallbacks(allowNonCallbacks),  </span><br><span class=\"line\">    mResponseIndex(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 管道机制</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> wakeFds[<span class=\"number\">2</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = pipe(wakeFds);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    mWakeReadPipeFd = wakeFds[<span class=\"number\">0</span>];  </span><br><span class=\"line\">    mWakeWritePipeFd = wakeFds[<span class=\"number\">1</span>];  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"comment\">// 分配新的 epoll 实例同时注册唤醒管道</span></span><br><span class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItem</span>;</span>  </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp; eventItem, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(epoll_event)); <span class=\"comment\">// zero out unused members of data field union</span></span><br><span class=\"line\">    <span class=\"comment\">// 观察 EPOLLIN 事件</span></span><br><span class=\"line\">    eventItem.events = EPOLLIN;  </span><br><span class=\"line\">    eventItem.data.fd = mWakeReadPipeFd;  </span><br><span class=\"line\">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。</p>\n<p>epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p>\n</blockquote>\n<p>pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。</p>\n<p>以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;                                                                     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();                                          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;          </span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏</span></span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +      </span><br><span class=\"line\">                klass.getCanonicalName());                                                          </span><br><span class=\"line\">        &#125;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    <span class=\"comment\">// 默认使用当前线程的 Looper                                                                                                </span></span><br><span class=\"line\">    mLooper = Looper.myLooper();                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(                                                                 </span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread that has not called Looper.prepare()\"</span>);             </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    mQueue = mLooper.mQueue;                                                                        </span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    <span class=\"comment\">// 是否为异步处理</span></span><br><span class=\"line\">    mAsynchronous = async;                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>Looper.loop</code> 中，当存在 Message 需要处理时，会调用 <code>dispatchMessage</code> 来进行分发：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用 callback</span></span><br><span class=\"line\">        handleCallback(msg);                    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接着检查通过构造方法传进来的 Callback</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123; </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;                         </span><br><span class=\"line\">            &#125;                                   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 最后调用 handleMessage</span></span><br><span class=\"line\">        handleMessage(msg);                     </span><br><span class=\"line\">    &#125;                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 Handler 发送消息：</p>\n<p><img src=\"http://gityuan.com/images/handler/java_sendmessage.png\" alt=\"发送消息调用链\"></p>\n<p>最终所有的方法都会调用到 <code>MessageQueue.enqueueMessage</code></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><blockquote>\n<p>消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123; </span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    <span class=\"comment\">// used by native code</span></span><br><span class=\"line\">    mPtr = nativeInit();            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 的初始化工作主要由 native 方法来执行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> NativeMessageQueue();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! nativeMessageQueue) &#123;  </span><br><span class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Unable to allocate native queue\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量</span></span><br><span class=\"line\">    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeInit</code> 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 <code>mPtr</code>，关联了 NativeMessageQueue 和 MessageQueue</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// messsage loop has already quit                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                          </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration                       </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;                                                     </span><br><span class=\"line\">            Binder.flushPendingCommands();                                                    </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class=\"line\">        <span class=\"comment\">// ptr 是在 JNI 层创建的 NativeMessageQueue</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);                                           </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 当前 nativePollOnce 返回后，查看消息队列中是否存在消息</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                 </span><br><span class=\"line\">            <span class=\"comment\">// 尝试检索下一条消息，如果找到则返回                            </span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();                                      </span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">            Message msg = mMessages;                                                          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">                <span class=\"comment\">// 找到下一条异步消息或者没有消息了，则退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;                                                                          </span><br><span class=\"line\">                    prevMsg = msg;                                                            </span><br><span class=\"line\">                    msg = msg.next;                                                           </span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;                                                                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;                                                         </span><br><span class=\"line\">                    <span class=\"comment\">// 下一个消息还没准备好，重新设置唤醒超时时间</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;                                                                      </span><br><span class=\"line\">                    <span class=\"comment\">// 获取一条消息                                                         </span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;                                                    </span><br><span class=\"line\">                        prevMsg.next = msg.next;                                              </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;                                                                  </span><br><span class=\"line\">                        mMessages = msg.next;                                                 </span><br><span class=\"line\">                    &#125;                                                                         </span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"Returning message: \"</span> + msg);</span><br><span class=\"line\">                    <span class=\"comment\">// 标记当前消息已使用</span></span><br><span class=\"line\">                    msg.markInUse();                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;                                                               </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;                                                                          </span><br><span class=\"line\">                <span class=\"comment\">// 当前还没有消息，设置为 -1，无限等待中                                                     </span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;                                                   </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.      </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                  </span><br><span class=\"line\">                dispose();                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                  </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// get pending idle handler count</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span>                                                   </span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;                         </span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">                <span class=\"comment\">// 没有 idle handlers 需要运行，循环继续等待                        </span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                                                                     </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;                                               </span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)]; </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.                                                        </span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration                    </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;                                   </span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];                                </span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>;           </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;                                                             </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;                                                                             </span><br><span class=\"line\">                keep = idler.queueIdle();                                                     </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;                                                           </span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;                                                                      </span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);                                              </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.                     </span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;                                                          </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">//不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                </span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>next</code> 方法中，<code>nativePollOnce</code> 是阻塞操作，其中 <code>nextPollTimeoutMillis</code> 代表下一个消息到来之前，还需要等待的时长；<code>nextPollTimeoutMillis == -1</code> 表示当前没有更多消息。<code>nativePollOnce</code> 调用结束后，从 <code>mMessages</code> 中提取一个消息</p>\n<p>当处于空闲时，执行 <code>IdleHandler</code> 中的回调方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jint ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过前面设置的 mPrt 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr); </span><br><span class=\"line\">    <span class=\"comment\">// 调用 NativeMessageQueue.pollOnce 进行轮询</span></span><br><span class=\"line\">    nativeMessageQueue-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> NativeMessageQueue::pollOnce(<span class=\"keyword\">int</span> timeoutMillis) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将调用转发给了 JNI 层的 Looper</span></span><br><span class=\"line\">    mLooper-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>pollOnce</code> 会调用 <code>pollnner</code> 来进一步操作，如果 <code>pollnner</code> 返回值不等于 0，则返回</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Looper::pollInner(<span class=\"keyword\">int</span> timeoutMillis) &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = ALOOPER_POLL_WAKE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItems</span>[<span class=\"title\">EPOLL_MAX_EVENTS</span>];</span></span><br><span class=\"line\">    <span class=\"comment\">// 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis</span></span><br><span class=\"line\">    <span class=\"comment\">// 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果检查成功或者超时，则结束等待</span></span><br><span class=\"line\">    <span class=\"comment\">// 处于 Idle 状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> acquiredLock = <span class=\"literal\">false</span>;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// eventCount &lt; 0 可能出错了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        LOGW(<span class=\"string\">\"Poll failed with an unexpected error, errno=%d\"</span>, errno);  </span><br><span class=\"line\">        result = ALOOPER_POLL_ERROR;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// eventCount == 0 超时</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        ......  </span><br><span class=\"line\">        result = ALOOPER_POLL_TIMEOUT;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL</span></span><br><span class=\"line\">    <span class=\"comment\">// eventCount &gt; 0 存在事件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd = eventItems[i].data.fd;  </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Looper 中使用 epoll 监听的 EPOLLIN 事件</span></span><br><span class=\"line\">                awoken();  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                LOGW(<span class=\"string\">\"Ignoring unexpected epoll events 0x%x on wake read pipe.\"</span>, epollEvents);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            ......  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquiredLock) &#123;  </span><br><span class=\"line\">        mLock.unlock();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">Done: ;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::awoken() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">16</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nRead;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">        nRead = read(mWakeReadPipeFd, buffer, <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((nRead == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结上面的代码，Looper 通过 <code>loop</code> 调用 MessageQueue 的 <code>next</code>，<code>next</code> 中又会调用到 native 方法 <code>nativePollOnce</code>，在这个方法中，会调用到 NativeMessageQueue 的 <code>pollInner</code>，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 <code>awoken</code>，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;                                                            </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Message must have a target.\"</span>);               </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">\" This message is already in use.\"</span>);       </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                 </span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(                         </span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);      </span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);                                               </span><br><span class=\"line\">            msg.recycle();                                                               </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        msg.markInUse();                                                                 </span><br><span class=\"line\">        msg.when = when;                                                                 </span><br><span class=\"line\">        Message p = mMessages;                                                           </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;                                   </span><br><span class=\"line\">            <span class=\"comment\">// 不存在头部消息或立即执行或执行时机快于头部消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息作为新的头部消息</span></span><br><span class=\"line\">            msg.next = p;                                                                </span><br><span class=\"line\">            mMessages = msg;                                                             </span><br><span class=\"line\">            needWake = mBlocked;                                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                                         </span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息插入到队列的尾部</span></span><br><span class=\"line\">            <span class=\"comment\">// 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();             </span><br><span class=\"line\">            Message prev;                                                                </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;                                                                   </span><br><span class=\"line\">                prev = p;                                                                </span><br><span class=\"line\">                p = p.next;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;                                        </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                               </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;                                    </span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;                                                    </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">            &#125;                                                                            </span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next                                   </span></span><br><span class=\"line\">            prev.next = msg;                                                             </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.                           </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;                                                                  </span><br><span class=\"line\">            nativeWake(mPtr);                                                            </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MessageQueue</code> 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。</p>\n<p>如果当前线程处于空闲等待状态，那么还需要调用 <code>nativeWake</code> 来唤醒：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jobject obj, jint ptr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ptr 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nativeMessageQueue-&gt;wake();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将唤醒请求转发到 Looper <code>wake</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Looper::wake() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nWrite;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先管道中写入 \"W</span></span><br><span class=\"line\">        nWrite = write(mWakeWritePipeFd, <span class=\"string\">\"W\"</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (nWrite == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    .......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 <code>polllnner</code> 中调用 <code>epoll_wait</code> 进入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, <span class=\"keyword\">int</span> what, Object object)</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                               </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                     </span><br><span class=\"line\">        Message p = mMessages;                                </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">// 从队列头部开始，移除连续的所有符合条件的消息                     </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what   </span><br><span class=\"line\">               &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;      </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            <span class=\"comment\">// 找到对应的消息，释放它</span></span><br><span class=\"line\">            p.recycleUnchecked();                             </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">//  从新的队列头部开始，移除全部符合条件的消息                  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;                                   </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;                                  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.what == what           </span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123; </span><br><span class=\"line\">                    Message nn = n.next;                      </span><br><span class=\"line\">                    n.recycleUnchecked();                     </span><br><span class=\"line\">                    p.next = nn;                              </span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;                                 </span><br><span class=\"line\">                &#125;                                             </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSyncBarrier</code> 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 <code>removeSyncBarrier</code></p>\n<p>当 MessageQueue 退出时，需要 <code>dispose</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposes of the underlying message queue.                 </span></span><br><span class=\"line\"><span class=\"comment\">// Must only be called on the looper thread or the finalizer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPtr != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// native 方法</span></span><br><span class=\"line\">        nativeDestroy(mPtr);</span><br><span class=\"line\">        <span class=\"comment\">// mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量</span></span><br><span class=\"line\">        mPtr = <span class=\"number\">0</span>;                                            </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeDestroy</code> 最终会调用 RefBase 的 <code>decStrong</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> RefBase::decStrong(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* id) <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weakref_impl* <span class=\"keyword\">const</span> refs = mRefs;</span><br><span class=\"line\">    refs-&gt;removeStrongRef(id); <span class=\"comment\">//移除强引用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs-&gt;decWeak(id); <span class=\"comment\">// 移除弱引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycleUnchecked</span><span class=\"params\">()</span> </span>&#123;                 </span><br><span class=\"line\">    <span class=\"comment\">// 标记为使用状态，清除其他状态     </span></span><br><span class=\"line\">    flags = FLAG_IN_USE;                  </span><br><span class=\"line\">    what = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg1 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg2 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    obj = <span class=\"keyword\">null</span>;                           </span><br><span class=\"line\">    replyTo = <span class=\"keyword\">null</span>;                       </span><br><span class=\"line\">    sendingUid = -<span class=\"number\">1</span>;                      </span><br><span class=\"line\">    when = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    target = <span class=\"keyword\">null</span>;                        </span><br><span class=\"line\">    callback = <span class=\"keyword\">null</span>;                      </span><br><span class=\"line\">    data = <span class=\"keyword\">null</span>;                          </span><br><span class=\"line\">                                          </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;  </span><br><span class=\"line\">            next = sPool;                 </span><br><span class=\"line\">            sPool = <span class=\"keyword\">this</span>;                 </span><br><span class=\"line\">            sPoolSize++;                  </span><br><span class=\"line\">        &#125;                                 </span><br><span class=\"line\">    &#125;                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;             </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从缓存中获取</span></span><br><span class=\"line\">            Message m = sPool;               </span><br><span class=\"line\">            sPool = m.next;                  </span><br><span class=\"line\">            m.next = <span class=\"keyword\">null</span>;                   </span><br><span class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></span><br><span class=\"line\">            sPoolSize--;                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;                        </span><br><span class=\"line\">        &#125;                                    </span><br><span class=\"line\">    &#125;                                        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"http://gityuan.com/images/handler/handler_java.jpg\" alt=\"消息机制\"></p>\n<p>Java 层：</p>\n<ul>\n<li>Handler 通过 <code>sendMessage</code>，将 Message 通过 <code>MessageQueue.enqueueMessage</code> 添加到队列中</li>\n<li>Looper 通过 <code>loop</code> 提取需要执行的 Message，并交与 <code>Message.target</code> 的 Handler 进行 <code>dispatchMessage</code> 分发</li>\n<li>将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler </li>\n</ul>\n<p>JNI 层：</p>\n<ul>\n<li>线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态</li>\n<li>通过 epoll 机制监听 <code>EPOLLIN</code> 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程</li>\n</ul>\n<p>消息分发的优先级：</p>\n<ol>\n<li><code>Message.callback.run()</code></li>\n<li><code>Handler.mCallback.handleMessage()</code></li>\n<li><code>Handler.handleMessage()</code></li>\n</ol>\n<blockquote>\n<p>EPOLL：Linux 内核的可扩展 I/O 事件通知机制</p>\n<p>PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入</p>\n<p>文件描述符(File descriptor)：用于表述指向<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">文件</a>的引用的抽象化概念</p>\n</blockquote>\n"},{"title":"触摸事件实践之路","date":"2018-04-03T01:17:20.000Z","_content":"\n## 前言\n\n最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。\n\n## 触摸事件简单回顾\n\n我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。\n\n![TouchEvent](http://oy017242u.bkt.clouddn.com/TouchEvent.png?time=123)\n\n上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 `dispatchTouchEvent` 开始分发，先判断 ViewGroup 的 `onInterceptTouchEvent` 是否拦截，同时这里也可以调用 ViewGroup 的 `requestDisallowInterceptTouchEvent` 让 ViewGroup 不调用 `onInterceptTouchEvent`，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 `dispatchTouchEvent`，反之，则调用子视图的 `dispatchTouchEvent`，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 `dispatchTouchEvent`。\n\n最终都会调用到 View 的 `onTouchEvent` 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。\n\n## 手势判定\n\n上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。\n\n当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：\n\nScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 `onInterceptTouchEvent`\n\n> 因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。\n>\n> 源码部分基于 Android 26\n\n### onInterceptTouchEvent\n\n``` java\nif ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {\n    return true;\n}\n```\n\n用 `mIsBeingDragged` 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 `ACTION_MOVE`，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。\n\n#### TOUCH_DOWN\n\n``` java\nif (!inChild((int) ev.getX(), (int) y)) {\n    mIsBeingDragged = false;\n    recycleVelocityTracker();\n    break;\n}\n```\n\n这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。\n\n``` java\nmLastMotionY = y;\nmActivePointerId = ev.getPointerId(0);\ninitOrResetVelocityTracker();\nmVelocityTracker.addMovement(ev);\n\nmScroller.computeScrollOffset();\nmIsBeingDragged = !mScroller.isFinished();\n\nstartNestedScroll(SCROLL_AXIS_VERTICAL);\n```\n\n这段代码主要是用于初始化判定之前的资源，比如 `mLastMotionY` 记录按下时的坐标信息，`mActivePointerId` 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，`initOrResetVelocityTracker` 初始化速度跟踪器，同时使用 `addMovement` 记录当前触摸事件信息，`mScroller` 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，`startNestedScroll` 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。\n\n#### TOUCH_MOVE\n\n```java\nfinal int activePointerId = mActivePointerId;\nif (activePointerId == INVALID_POINTER) {\n    break;\n}\nfinal int pointerIndex = ev.findPointerIndex(activePointerId);\nif (pointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(pointerIndex);\nfinal int yDiff = Math.abs(y - mLastMotionY);\nif (yDiff > mTouchSlop && (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {\n    mIsBeingDragged = true;\n    mLastMotionY = y;\n    initVelocityTrackerIfNotExists();\n    mVelocityTracker.addMovement(ev);\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n```\n\n这段代码先使用我们在 `TOUCH_DOWN` 中记录的  `mActivePointerId` 进行是否为有效的判断，如果有效，则通过 `findPointerIndex` 获取作用手指 id 的下标，记录为  `pointerIndex` ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。`yDiff` 是滑动的距离，`mTouchSlop` 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 `getScaledTouchSlop` 获取，如果大于这个值，我们可以认为开始了拖动的手势。 `getNestedScrollAxes` 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，`mIsBeingDragged` 标记为 `true`，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 `requestDisallowInterceptTouchEvent`，防止父视图拦截了事件，即 `onInterceptTouchEvent`\n\n#### TOUCH_CANCEL && TOUCH_UP\n\n``` java\nmIsBeingDragged = false;\nmActivePointerId = INVALID_POINTER;\nrecycleVelocityTracker();\nstopNestedScroll();\n```\n\n一般我们都会在 `TOUCH_CANCEL` 和 `TOUCH_UP` 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 `mIsBeingDragged` 设置为 `false`，释放速度跟踪器等等 \n\n> `TOUCH_UP` 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 `TOUCH_CANCEL` 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 `TOUCH_DOWN`，即在这个事件分发时，向父视图传递了 `true` 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 `ACTION_MOVE` 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 `onInterceptTouch` 中返回了 `true`，那么在 ViewGroup 的 `dispatchTouchEvent` 中会给已经确认消费事件的子视图分发一个 `TOUCH_CANCEL` 的事件，具体可以阅读源码。\n\n#### ACTION_POINTER_UP\n\n这个为多指触摸时，某个手指抬起时分发的事件。\n\n``` java\nfinal int pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >>\n                MotionEvent.ACTION_POINTER_INDEX_SHIFT;\nfinal int pointerId = ev.getPointerId(pointerIndex);\nif (pointerId == mActivePointerId) {\n    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n    mLastMotionY = (int) ev.getY(newPointerIndex);\n    mActivePointerId = ev.getPointerId(newPointerIndex);\n    if (mVelocityTracker != null) {\n        mVelocityTracker.clear();\n    }\n}\n```\n\n这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源\n\n#### 小结\n\n我们可以简单总结下，`onInterceptTouchEvent` 所进行的处理，即在 `TOUCH_DOWN` 资源初始化，`TOUCH_MOVE` 判断是否开始拖动手势，`TOUCH_CANCEL` && `TOUCH_UP` 中进行资源释放。这里涉及了多指触摸的处理。\n\n### onTouchEvent\n\n`onTouchEvent` 要比 `onInterceptTouch` 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。\n\n#### TOUCH_DOWN\n\n``` java\nif (getChildCount() == 0) {\n    return false;\n}\nif ((mIsBeingDragged = !mScroller.isFinished())) {\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n\nif (!mScroller.isFinished()) {\n    mScroller.abortAnimation();\n}\n\nmLastMotionY = (int) ev.getY();\nmActivePointerId = ev.getPointerId(0);\n```\n\n同样的，`onTouchEvent` 在 `TOUCH_DOWN` 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 `abortAnimation`，如果 Scroller 还没结束 fling 计算，则中止处理。\n\n#### TOUCH_MOVE\n\n``` java\nfinal int activePointerIndex = ev.findPointerIndex(mActivePointerId);\nif (activePointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(activePointerIndex);\nint deltaY = mLastMotionY - y;\nif (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {\n    // 嵌套滚动处理\n    deltaY -= mScrollConsumed[1];\n    vtev.offsetLocation(0, mScrollOffset[1]);\n    mNestedYOffset += mScrollOffset[1];\n}\n    if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {\n        final ViewParent parent = getParent();\n        if (parent != null) {\n            parent.requestDisallowInterceptTouchEvent(true);\n        }\n        mIsBeingDragged = true;\n        if (deltaY > 0) {\n            deltaY -= mTouchSlop;\n        } else {\n            deltaY += mTouchSlop;\n        }\n    }\n    \n    if (mIsBeingDragged) {\n        /// 业务逻辑\n    }\n```\n\n这段代码同样会进行多指处理，获取指定手指的触摸事件信息。`mIsBeingDragged` 为 `false`，同时会再进行一次拖动手势的判定，判定逻辑和 `onInterceptTouchEvent` 中类似，如果 `mIsBeingDragged` 为 `true`，则开始进行真正的逻辑处理。\n\n> EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码\n\n#### TOUCH_UP\n\n``` java\nif (mIsBeingDragged) {\n    final VelocityTracker velocityTracker = mVelocityTracker;\n\tvelocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n    int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);\n    \n    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {\n    \tflingWithNestedDispatch(-initialVelocity);\n    }\n    \n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 `getYVelocity` 获取速度，在判断是否可以作为 fling 手势处理，`mMaximumVelocity` 是处理的最大速度，`mMinimumVelocity` 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 `getScaledMaximumFlingVelocity` 和 `getScaledMinimumFlingVelocity` 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：\n\n``` java\nint height = getHeight() - mPaddingBottom - mPaddingTop;\nint bottom = getChildAt(0).getHeight();\n\nmScroller.fling(mScrollX, mScrollY, 0, velocityY, 0, 0, 0,\n                    Math.max(0, bottom - height), 0, height/2);\n\npostInvalidateOnAnimation();\n```\n\n通过传递当前拖动手势速度值来调用 `fling` 进行处理，然后在 `computeScrollOffset` 方法中，进行真正的滚动处理：\n\n``` java\npublic void computeScroll() {\n    if (mScroller.computeScrollOffset()) {\n      \t// 逻辑处理\n        int x = mScroller.getCurrX();\n        int y = mScroller.getCurrY();\n        postInvalidateOnAnimation();\n    }\n}\n```\n\n首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 `computeScrollOffset` 进行计算，如果返回 `true`，表示计算还没结束，然后通过 `getCurrX` 或 `getCurrY` 获取计算后的值，最后进行真正的滚动处理，比如调用 `scrollTo` 等等，这里需要注意的是，需要调用 `invalidate` 来确保进行下一次的 `computeScroll` 调用，这里使用的 `postInvalidateOnAnimation` 其作用是类似的。\n\n#### TOUCH_CANCEL\n\n``` java\nif (mIsBeingDragged && getChildCount() > 0) {\n    if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {\n        postInvalidateOnAnimation();\n    }\n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n同样的，一般我们都会在 `TOUCH_CANCEL` 中释放资源。\n\n#### ACTION_POINTER_DOWN\n\n当有新的手指按下时分发的事件\n\n``` java\nfinal int index = ev.getActionIndex();\nmLastMotionY = (int) ev.getY(index);\nmActivePointerId = ev.getPointerId(index);\n```\n\n以新按下的手指的信息重新计算\n\n#### ACTION_POINTER_UP\n\n这里的处理和 `onInterceptTouch` 一致\n\n#### 小结\n\n`onTouchEvent` 和 `onInterceptTouchEvent` 处理有些相似，主要是在 `TOUCH_MOVE` 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 `TOUCH_UP` 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。\n\n### 总结\n\n在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 `NestedScrollView`、`RecyclerView`  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 `ViewDragHelper` ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。\n\n## 实战\n\n理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：\n\n![WheelView](https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim)\n\n![TapeView](http://oy017242u.bkt.clouddn.com/more.gif)\n\n详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是[滚轮控件](https://github.com/LinXiaoTao/WheelView)，第二个是之前参加活动的仿薄荷健康的[卷尺控件](https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md)。在这里我们只分析部分代码：\n\n### 滚轮控件\n\n在前面手势判定中的分析中，我们提到在 `onTouchEvent` 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：\n\n``` java\nif (mIsBeingDragged) {\n    mDistanceY += mLastY - moveY;\n    postInvalidateOnAnimation();\n}\n```\n\n在每次 `TOUCH_MOVE` 事件分发时，计算与 `TOUCH_DOWN` 时记录的位置信息的差值，保存为 `mDistanceY`，并且在 `onDraw` 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。\n\n### 卷尺控件\n\n拖动距离的计算与滚轮控件一样，只是记录为 `mOffsetLeft` 而已，同时两个控件都有在 `onTouchEvent` 的 `ACTION_UP` 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。\n\n## 结语\n\n文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。\n\n但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：\n\n* 最基本的拖动手势处理\n* fling 效果实现\n* 如果可以，再实现边缘效果\n\n感谢大家的阅读。\n\n\n\n","source":"_posts/触摸事件实践之路.md","raw":"---\ntitle: 触摸事件实践之路\ndate: 2018-04-03 09:17:20\ncategories: Android Application\ntags: \n---\n\n## 前言\n\n最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。\n\n## 触摸事件简单回顾\n\n我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。\n\n![TouchEvent](http://oy017242u.bkt.clouddn.com/TouchEvent.png?time=123)\n\n上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 `dispatchTouchEvent` 开始分发，先判断 ViewGroup 的 `onInterceptTouchEvent` 是否拦截，同时这里也可以调用 ViewGroup 的 `requestDisallowInterceptTouchEvent` 让 ViewGroup 不调用 `onInterceptTouchEvent`，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 `dispatchTouchEvent`，反之，则调用子视图的 `dispatchTouchEvent`，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 `dispatchTouchEvent`。\n\n最终都会调用到 View 的 `onTouchEvent` 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。\n\n## 手势判定\n\n上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。\n\n当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：\n\nScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 `onInterceptTouchEvent`\n\n> 因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。\n>\n> 源码部分基于 Android 26\n\n### onInterceptTouchEvent\n\n``` java\nif ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {\n    return true;\n}\n```\n\n用 `mIsBeingDragged` 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 `ACTION_MOVE`，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。\n\n#### TOUCH_DOWN\n\n``` java\nif (!inChild((int) ev.getX(), (int) y)) {\n    mIsBeingDragged = false;\n    recycleVelocityTracker();\n    break;\n}\n```\n\n这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。\n\n``` java\nmLastMotionY = y;\nmActivePointerId = ev.getPointerId(0);\ninitOrResetVelocityTracker();\nmVelocityTracker.addMovement(ev);\n\nmScroller.computeScrollOffset();\nmIsBeingDragged = !mScroller.isFinished();\n\nstartNestedScroll(SCROLL_AXIS_VERTICAL);\n```\n\n这段代码主要是用于初始化判定之前的资源，比如 `mLastMotionY` 记录按下时的坐标信息，`mActivePointerId` 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，`initOrResetVelocityTracker` 初始化速度跟踪器，同时使用 `addMovement` 记录当前触摸事件信息，`mScroller` 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，`startNestedScroll` 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。\n\n#### TOUCH_MOVE\n\n```java\nfinal int activePointerId = mActivePointerId;\nif (activePointerId == INVALID_POINTER) {\n    break;\n}\nfinal int pointerIndex = ev.findPointerIndex(activePointerId);\nif (pointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(pointerIndex);\nfinal int yDiff = Math.abs(y - mLastMotionY);\nif (yDiff > mTouchSlop && (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {\n    mIsBeingDragged = true;\n    mLastMotionY = y;\n    initVelocityTrackerIfNotExists();\n    mVelocityTracker.addMovement(ev);\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n```\n\n这段代码先使用我们在 `TOUCH_DOWN` 中记录的  `mActivePointerId` 进行是否为有效的判断，如果有效，则通过 `findPointerIndex` 获取作用手指 id 的下标，记录为  `pointerIndex` ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。`yDiff` 是滑动的距离，`mTouchSlop` 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 `getScaledTouchSlop` 获取，如果大于这个值，我们可以认为开始了拖动的手势。 `getNestedScrollAxes` 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，`mIsBeingDragged` 标记为 `true`，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 `requestDisallowInterceptTouchEvent`，防止父视图拦截了事件，即 `onInterceptTouchEvent`\n\n#### TOUCH_CANCEL && TOUCH_UP\n\n``` java\nmIsBeingDragged = false;\nmActivePointerId = INVALID_POINTER;\nrecycleVelocityTracker();\nstopNestedScroll();\n```\n\n一般我们都会在 `TOUCH_CANCEL` 和 `TOUCH_UP` 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 `mIsBeingDragged` 设置为 `false`，释放速度跟踪器等等 \n\n> `TOUCH_UP` 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 `TOUCH_CANCEL` 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 `TOUCH_DOWN`，即在这个事件分发时，向父视图传递了 `true` 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 `ACTION_MOVE` 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 `onInterceptTouch` 中返回了 `true`，那么在 ViewGroup 的 `dispatchTouchEvent` 中会给已经确认消费事件的子视图分发一个 `TOUCH_CANCEL` 的事件，具体可以阅读源码。\n\n#### ACTION_POINTER_UP\n\n这个为多指触摸时，某个手指抬起时分发的事件。\n\n``` java\nfinal int pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >>\n                MotionEvent.ACTION_POINTER_INDEX_SHIFT;\nfinal int pointerId = ev.getPointerId(pointerIndex);\nif (pointerId == mActivePointerId) {\n    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n    mLastMotionY = (int) ev.getY(newPointerIndex);\n    mActivePointerId = ev.getPointerId(newPointerIndex);\n    if (mVelocityTracker != null) {\n        mVelocityTracker.clear();\n    }\n}\n```\n\n这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源\n\n#### 小结\n\n我们可以简单总结下，`onInterceptTouchEvent` 所进行的处理，即在 `TOUCH_DOWN` 资源初始化，`TOUCH_MOVE` 判断是否开始拖动手势，`TOUCH_CANCEL` && `TOUCH_UP` 中进行资源释放。这里涉及了多指触摸的处理。\n\n### onTouchEvent\n\n`onTouchEvent` 要比 `onInterceptTouch` 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。\n\n#### TOUCH_DOWN\n\n``` java\nif (getChildCount() == 0) {\n    return false;\n}\nif ((mIsBeingDragged = !mScroller.isFinished())) {\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n\nif (!mScroller.isFinished()) {\n    mScroller.abortAnimation();\n}\n\nmLastMotionY = (int) ev.getY();\nmActivePointerId = ev.getPointerId(0);\n```\n\n同样的，`onTouchEvent` 在 `TOUCH_DOWN` 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 `abortAnimation`，如果 Scroller 还没结束 fling 计算，则中止处理。\n\n#### TOUCH_MOVE\n\n``` java\nfinal int activePointerIndex = ev.findPointerIndex(mActivePointerId);\nif (activePointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(activePointerIndex);\nint deltaY = mLastMotionY - y;\nif (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {\n    // 嵌套滚动处理\n    deltaY -= mScrollConsumed[1];\n    vtev.offsetLocation(0, mScrollOffset[1]);\n    mNestedYOffset += mScrollOffset[1];\n}\n    if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {\n        final ViewParent parent = getParent();\n        if (parent != null) {\n            parent.requestDisallowInterceptTouchEvent(true);\n        }\n        mIsBeingDragged = true;\n        if (deltaY > 0) {\n            deltaY -= mTouchSlop;\n        } else {\n            deltaY += mTouchSlop;\n        }\n    }\n    \n    if (mIsBeingDragged) {\n        /// 业务逻辑\n    }\n```\n\n这段代码同样会进行多指处理，获取指定手指的触摸事件信息。`mIsBeingDragged` 为 `false`，同时会再进行一次拖动手势的判定，判定逻辑和 `onInterceptTouchEvent` 中类似，如果 `mIsBeingDragged` 为 `true`，则开始进行真正的逻辑处理。\n\n> EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码\n\n#### TOUCH_UP\n\n``` java\nif (mIsBeingDragged) {\n    final VelocityTracker velocityTracker = mVelocityTracker;\n\tvelocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n    int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);\n    \n    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {\n    \tflingWithNestedDispatch(-initialVelocity);\n    }\n    \n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 `getYVelocity` 获取速度，在判断是否可以作为 fling 手势处理，`mMaximumVelocity` 是处理的最大速度，`mMinimumVelocity` 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 `getScaledMaximumFlingVelocity` 和 `getScaledMinimumFlingVelocity` 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：\n\n``` java\nint height = getHeight() - mPaddingBottom - mPaddingTop;\nint bottom = getChildAt(0).getHeight();\n\nmScroller.fling(mScrollX, mScrollY, 0, velocityY, 0, 0, 0,\n                    Math.max(0, bottom - height), 0, height/2);\n\npostInvalidateOnAnimation();\n```\n\n通过传递当前拖动手势速度值来调用 `fling` 进行处理，然后在 `computeScrollOffset` 方法中，进行真正的滚动处理：\n\n``` java\npublic void computeScroll() {\n    if (mScroller.computeScrollOffset()) {\n      \t// 逻辑处理\n        int x = mScroller.getCurrX();\n        int y = mScroller.getCurrY();\n        postInvalidateOnAnimation();\n    }\n}\n```\n\n首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 `computeScrollOffset` 进行计算，如果返回 `true`，表示计算还没结束，然后通过 `getCurrX` 或 `getCurrY` 获取计算后的值，最后进行真正的滚动处理，比如调用 `scrollTo` 等等，这里需要注意的是，需要调用 `invalidate` 来确保进行下一次的 `computeScroll` 调用，这里使用的 `postInvalidateOnAnimation` 其作用是类似的。\n\n#### TOUCH_CANCEL\n\n``` java\nif (mIsBeingDragged && getChildCount() > 0) {\n    if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {\n        postInvalidateOnAnimation();\n    }\n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n同样的，一般我们都会在 `TOUCH_CANCEL` 中释放资源。\n\n#### ACTION_POINTER_DOWN\n\n当有新的手指按下时分发的事件\n\n``` java\nfinal int index = ev.getActionIndex();\nmLastMotionY = (int) ev.getY(index);\nmActivePointerId = ev.getPointerId(index);\n```\n\n以新按下的手指的信息重新计算\n\n#### ACTION_POINTER_UP\n\n这里的处理和 `onInterceptTouch` 一致\n\n#### 小结\n\n`onTouchEvent` 和 `onInterceptTouchEvent` 处理有些相似，主要是在 `TOUCH_MOVE` 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 `TOUCH_UP` 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。\n\n### 总结\n\n在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 `NestedScrollView`、`RecyclerView`  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 `ViewDragHelper` ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。\n\n## 实战\n\n理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：\n\n![WheelView](https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim)\n\n![TapeView](http://oy017242u.bkt.clouddn.com/more.gif)\n\n详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是[滚轮控件](https://github.com/LinXiaoTao/WheelView)，第二个是之前参加活动的仿薄荷健康的[卷尺控件](https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md)。在这里我们只分析部分代码：\n\n### 滚轮控件\n\n在前面手势判定中的分析中，我们提到在 `onTouchEvent` 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：\n\n``` java\nif (mIsBeingDragged) {\n    mDistanceY += mLastY - moveY;\n    postInvalidateOnAnimation();\n}\n```\n\n在每次 `TOUCH_MOVE` 事件分发时，计算与 `TOUCH_DOWN` 时记录的位置信息的差值，保存为 `mDistanceY`，并且在 `onDraw` 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。\n\n### 卷尺控件\n\n拖动距离的计算与滚轮控件一样，只是记录为 `mOffsetLeft` 而已，同时两个控件都有在 `onTouchEvent` 的 `ACTION_UP` 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。\n\n## 结语\n\n文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。\n\n但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：\n\n* 最基本的拖动手势处理\n* fling 效果实现\n* 如果可以，再实现边缘效果\n\n感谢大家的阅读。\n\n\n\n","slug":"触摸事件实践之路","published":1,"updated":"2018-04-11T14:05:30.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg0ku8a80005hio67cgcwf35","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。</p>\n<h2 id=\"触摸事件简单回顾\"><a href=\"#触摸事件简单回顾\" class=\"headerlink\" title=\"触摸事件简单回顾\"></a>触摸事件简单回顾</h2><p>我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。</p>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/TouchEvent.png?time=123\" alt=\"TouchEvent\"></p>\n<p>上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 <code>dispatchTouchEvent</code> 开始分发，先判断 ViewGroup 的 <code>onInterceptTouchEvent</code> 是否拦截，同时这里也可以调用 ViewGroup 的 <code>requestDisallowInterceptTouchEvent</code> 让 ViewGroup 不调用 <code>onInterceptTouchEvent</code>，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 <code>dispatchTouchEvent</code>，反之，则调用子视图的 <code>dispatchTouchEvent</code>，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 <code>dispatchTouchEvent</code>。</p>\n<p>最终都会调用到 View 的 <code>onTouchEvent</code> 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。</p>\n<h2 id=\"手势判定\"><a href=\"#手势判定\" class=\"headerlink\" title=\"手势判定\"></a>手势判定</h2><p>上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。</p>\n<p>当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：</p>\n<p>ScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 <code>onInterceptTouchEvent</code></p>\n<blockquote>\n<p>因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。</p>\n<p>源码部分基于 Android 26</p>\n</blockquote>\n<h3 id=\"onInterceptTouchEvent\"><a href=\"#onInterceptTouchEvent\" class=\"headerlink\" title=\"onInterceptTouchEvent\"></a>onInterceptTouchEvent</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 <code>mIsBeingDragged</code> 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 <code>ACTION_MOVE</code>，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。</p>\n<h4 id=\"TOUCH-DOWN\"><a href=\"#TOUCH-DOWN\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!inChild((<span class=\"keyword\">int</span>) ev.getX(), (<span class=\"keyword\">int</span>) y)) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    recycleVelocityTracker();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mLastMotionY = y;</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br><span class=\"line\">initOrResetVelocityTracker();</span><br><span class=\"line\">mVelocityTracker.addMovement(ev);</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.computeScrollOffset();</span><br><span class=\"line\">mIsBeingDragged = !mScroller.isFinished();</span><br><span class=\"line\"></span><br><span class=\"line\">startNestedScroll(SCROLL_AXIS_VERTICAL);</span><br></pre></td></tr></table></figure>\n<p>这段代码主要是用于初始化判定之前的资源，比如 <code>mLastMotionY</code> 记录按下时的坐标信息，<code>mActivePointerId</code> 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，<code>initOrResetVelocityTracker</code> 初始化速度跟踪器，同时使用 <code>addMovement</code> 记录当前触摸事件信息，<code>mScroller</code> 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，<code>startNestedScroll</code> 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。</p>\n<h4 id=\"TOUCH-MOVE\"><a href=\"#TOUCH-MOVE\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerId = mActivePointerId;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerId == INVALID_POINTER) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = ev.findPointerIndex(activePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> yDiff = Math.abs(y - mLastMotionY);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mLastMotionY = y;</span><br><span class=\"line\">    initVelocityTrackerIfNotExists();</span><br><span class=\"line\">    mVelocityTracker.addMovement(ev);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码先使用我们在 <code>TOUCH_DOWN</code> 中记录的  <code>mActivePointerId</code> 进行是否为有效的判断，如果有效，则通过 <code>findPointerIndex</code> 获取作用手指 id 的下标，记录为  <code>pointerIndex</code> ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。<code>yDiff</code> 是滑动的距离，<code>mTouchSlop</code> 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 <code>getScaledTouchSlop</code> 获取，如果大于这个值，我们可以认为开始了拖动的手势。 <code>getNestedScrollAxes</code> 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，<code>mIsBeingDragged</code> 标记为 <code>true</code>，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 <code>requestDisallowInterceptTouchEvent</code>，防止父视图拦截了事件，即 <code>onInterceptTouchEvent</code></p>\n<h4 id=\"TOUCH-CANCEL-amp-amp-TOUCH-UP\"><a href=\"#TOUCH-CANCEL-amp-amp-TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_CANCEL &amp;&amp; TOUCH_UP\"></a>TOUCH_CANCEL &amp;&amp; TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">recycleVelocityTracker();</span><br><span class=\"line\">stopNestedScroll();</span><br></pre></td></tr></table></figure>\n<p>一般我们都会在 <code>TOUCH_CANCEL</code> 和 <code>TOUCH_UP</code> 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 <code>mIsBeingDragged</code> 设置为 <code>false</code>，释放速度跟踪器等等 </p>\n<blockquote>\n<p><code>TOUCH_UP</code> 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 <code>TOUCH_CANCEL</code> 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 <code>TOUCH_DOWN</code>，即在这个事件分发时，向父视图传递了 <code>true</code> 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 <code>ACTION_MOVE</code> 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 <code>onInterceptTouch</code> 中返回了 <code>true</code>，那么在 ViewGroup 的 <code>dispatchTouchEvent</code> 中会给已经确认消费事件的子视图分发一个 <code>TOUCH_CANCEL</code> 的事件，具体可以阅读源码。</p>\n</blockquote>\n<h4 id=\"ACTION-POINTER-UP\"><a href=\"#ACTION-POINTER-UP\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这个为多指触摸时，某个手指抬起时分发的事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;</span><br><span class=\"line\">                MotionEvent.ACTION_POINTER_INDEX_SHIFT;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerId = ev.getPointerId(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerId == mActivePointerId) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> newPointerIndex = pointerIndex == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">    mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(newPointerIndex);</span><br><span class=\"line\">    mActivePointerId = ev.getPointerId(newPointerIndex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mVelocityTracker != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mVelocityTracker.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>我们可以简单总结下，<code>onInterceptTouchEvent</code> 所进行的处理，即在 <code>TOUCH_DOWN</code> 资源初始化，<code>TOUCH_MOVE</code> 判断是否开始拖动手势，<code>TOUCH_CANCEL</code> &amp;&amp; <code>TOUCH_UP</code> 中进行资源释放。这里涉及了多指触摸的处理。</p>\n<h3 id=\"onTouchEvent\"><a href=\"#onTouchEvent\" class=\"headerlink\" title=\"onTouchEvent\"></a>onTouchEvent</h3><p><code>onTouchEvent</code> 要比 <code>onInterceptTouch</code> 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。</p>\n<h4 id=\"TOUCH-DOWN-1\"><a href=\"#TOUCH-DOWN-1\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (getChildCount() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((mIsBeingDragged = !mScroller.isFinished())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!mScroller.isFinished()) &#123;</span><br><span class=\"line\">    mScroller.abortAnimation();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY();</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>同样的，<code>onTouchEvent</code> 在 <code>TOUCH_DOWN</code> 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 <code>abortAnimation</code>，如果 Scroller 还没结束 fling 计算，则中止处理。</p>\n<h4 id=\"TOUCH-MOVE-1\"><a href=\"#TOUCH-MOVE-1\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerIndex = ev.findPointerIndex(mActivePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(activePointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">int</span> deltaY = mLastMotionY - y;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (dispatchNestedPreScroll(<span class=\"number\">0</span>, deltaY, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 嵌套滚动处理</span></span><br><span class=\"line\">    deltaY -= mScrollConsumed[<span class=\"number\">1</span>];</span><br><span class=\"line\">    vtev.offsetLocation(<span class=\"number\">0</span>, mScrollOffset[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    mNestedYOffset += mScrollOffset[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mIsBeingDragged &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (deltaY &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            deltaY -= mTouchSlop;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            deltaY += mTouchSlop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码同样会进行多指处理，获取指定手指的触摸事件信息。<code>mIsBeingDragged</code> 为 <code>false</code>，同时会再进行一次拖动手势的判定，判定逻辑和 <code>onInterceptTouchEvent</code> 中类似，如果 <code>mIsBeingDragged</code> 为 <code>true</code>，则开始进行真正的逻辑处理。</p>\n<blockquote>\n<p>EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码</p>\n</blockquote>\n<h4 id=\"TOUCH-UP\"><a href=\"#TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_UP\"></a>TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> VelocityTracker velocityTracker = mVelocityTracker;</span><br><span class=\"line\">\tvelocityTracker.computeCurrentVelocity(<span class=\"number\">1000</span>, mMaximumVelocity);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> initialVelocity = (<span class=\"keyword\">int</span>) velocityTracker.getYVelocity(mActivePointerId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((Math.abs(initialVelocity) &gt; mMinimumVelocity)) &#123;</span><br><span class=\"line\">    \tflingWithNestedDispatch(-initialVelocity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 <code>getYVelocity</code> 获取速度，在判断是否可以作为 fling 手势处理，<code>mMaximumVelocity</code> 是处理的最大速度，<code>mMinimumVelocity</code> 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 <code>getScaledMaximumFlingVelocity</code> 和 <code>getScaledMinimumFlingVelocity</code> 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> height = getHeight() - mPaddingBottom - mPaddingTop;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bottom = getChildAt(<span class=\"number\">0</span>).getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.fling(mScrollX, mScrollY, <span class=\"number\">0</span>, velocityY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                    Math.max(<span class=\"number\">0</span>, bottom - height), <span class=\"number\">0</span>, height/<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">postInvalidateOnAnimation();</span><br></pre></td></tr></table></figure>\n<p>通过传递当前拖动手势速度值来调用 <code>fling</code> 进行处理，然后在 <code>computeScrollOffset</code> 方法中，进行真正的滚动处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 逻辑处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = mScroller.getCurrX();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = mScroller.getCurrY();</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 <code>computeScrollOffset</code> 进行计算，如果返回 <code>true</code>，表示计算还没结束，然后通过 <code>getCurrX</code> 或 <code>getCurrY</code> 获取计算后的值，最后进行真正的滚动处理，比如调用 <code>scrollTo</code> 等等，这里需要注意的是，需要调用 <code>invalidate</code> 来确保进行下一次的 <code>computeScroll</code> 调用，这里使用的 <code>postInvalidateOnAnimation</code> 其作用是类似的。</p>\n<h4 id=\"TOUCH-CANCEL\"><a href=\"#TOUCH-CANCEL\" class=\"headerlink\" title=\"TOUCH_CANCEL\"></a>TOUCH_CANCEL</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged &amp;&amp; getChildCount() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.springBack(mScrollX, mScrollY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, getScrollRange())) &#123;</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的，一般我们都会在 <code>TOUCH_CANCEL</code> 中释放资源。</p>\n<h4 id=\"ACTION-POINTER-DOWN\"><a href=\"#ACTION-POINTER-DOWN\" class=\"headerlink\" title=\"ACTION_POINTER_DOWN\"></a>ACTION_POINTER_DOWN</h4><p>当有新的手指按下时分发的事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = ev.getActionIndex();</span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(index);</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(index);</span><br></pre></td></tr></table></figure>\n<p>以新按下的手指的信息重新计算</p>\n<h4 id=\"ACTION-POINTER-UP-1\"><a href=\"#ACTION-POINTER-UP-1\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这里的处理和 <code>onInterceptTouch</code> 一致</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><code>onTouchEvent</code> 和 <code>onInterceptTouchEvent</code> 处理有些相似，主要是在 <code>TOUCH_MOVE</code> 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 <code>TOUCH_UP</code> 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 <code>NestedScrollView</code>、<code>RecyclerView</code>  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 <code>ViewDragHelper</code> ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim\" alt=\"WheelView\"></p>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/more.gif\" alt=\"TapeView\"></p>\n<p>详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是<a href=\"https://github.com/LinXiaoTao/WheelView\" target=\"_blank\" rel=\"noopener\">滚轮控件</a>，第二个是之前参加活动的仿薄荷健康的<a href=\"https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md\" target=\"_blank\" rel=\"noopener\">卷尺控件</a>。在这里我们只分析部分代码：</p>\n<h3 id=\"滚轮控件\"><a href=\"#滚轮控件\" class=\"headerlink\" title=\"滚轮控件\"></a>滚轮控件</h3><p>在前面手势判定中的分析中，我们提到在 <code>onTouchEvent</code> 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    mDistanceY += mLastY - moveY;</span><br><span class=\"line\">    postInvalidateOnAnimation();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在每次 <code>TOUCH_MOVE</code> 事件分发时，计算与 <code>TOUCH_DOWN</code> 时记录的位置信息的差值，保存为 <code>mDistanceY</code>，并且在 <code>onDraw</code> 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。</p>\n<h3 id=\"卷尺控件\"><a href=\"#卷尺控件\" class=\"headerlink\" title=\"卷尺控件\"></a>卷尺控件</h3><p>拖动距离的计算与滚轮控件一样，只是记录为 <code>mOffsetLeft</code> 而已，同时两个控件都有在 <code>onTouchEvent</code> 的 <code>ACTION_UP</code> 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。</p>\n<p>但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：</p>\n<ul>\n<li>最基本的拖动手势处理</li>\n<li>fling 效果实现</li>\n<li>如果可以，再实现边缘效果</li>\n</ul>\n<p>感谢大家的阅读。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。</p>\n<h2 id=\"触摸事件简单回顾\"><a href=\"#触摸事件简单回顾\" class=\"headerlink\" title=\"触摸事件简单回顾\"></a>触摸事件简单回顾</h2><p>我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。</p>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/TouchEvent.png?time=123\" alt=\"TouchEvent\"></p>\n<p>上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 <code>dispatchTouchEvent</code> 开始分发，先判断 ViewGroup 的 <code>onInterceptTouchEvent</code> 是否拦截，同时这里也可以调用 ViewGroup 的 <code>requestDisallowInterceptTouchEvent</code> 让 ViewGroup 不调用 <code>onInterceptTouchEvent</code>，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 <code>dispatchTouchEvent</code>，反之，则调用子视图的 <code>dispatchTouchEvent</code>，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 <code>dispatchTouchEvent</code>。</p>\n<p>最终都会调用到 View 的 <code>onTouchEvent</code> 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。</p>\n<h2 id=\"手势判定\"><a href=\"#手势判定\" class=\"headerlink\" title=\"手势判定\"></a>手势判定</h2><p>上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。</p>\n<p>当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：</p>\n<p>ScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 <code>onInterceptTouchEvent</code></p>\n<blockquote>\n<p>因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。</p>\n<p>源码部分基于 Android 26</p>\n</blockquote>\n<h3 id=\"onInterceptTouchEvent\"><a href=\"#onInterceptTouchEvent\" class=\"headerlink\" title=\"onInterceptTouchEvent\"></a>onInterceptTouchEvent</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 <code>mIsBeingDragged</code> 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 <code>ACTION_MOVE</code>，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。</p>\n<h4 id=\"TOUCH-DOWN\"><a href=\"#TOUCH-DOWN\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!inChild((<span class=\"keyword\">int</span>) ev.getX(), (<span class=\"keyword\">int</span>) y)) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    recycleVelocityTracker();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mLastMotionY = y;</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br><span class=\"line\">initOrResetVelocityTracker();</span><br><span class=\"line\">mVelocityTracker.addMovement(ev);</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.computeScrollOffset();</span><br><span class=\"line\">mIsBeingDragged = !mScroller.isFinished();</span><br><span class=\"line\"></span><br><span class=\"line\">startNestedScroll(SCROLL_AXIS_VERTICAL);</span><br></pre></td></tr></table></figure>\n<p>这段代码主要是用于初始化判定之前的资源，比如 <code>mLastMotionY</code> 记录按下时的坐标信息，<code>mActivePointerId</code> 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，<code>initOrResetVelocityTracker</code> 初始化速度跟踪器，同时使用 <code>addMovement</code> 记录当前触摸事件信息，<code>mScroller</code> 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，<code>startNestedScroll</code> 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。</p>\n<h4 id=\"TOUCH-MOVE\"><a href=\"#TOUCH-MOVE\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerId = mActivePointerId;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerId == INVALID_POINTER) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = ev.findPointerIndex(activePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> yDiff = Math.abs(y - mLastMotionY);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mLastMotionY = y;</span><br><span class=\"line\">    initVelocityTrackerIfNotExists();</span><br><span class=\"line\">    mVelocityTracker.addMovement(ev);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码先使用我们在 <code>TOUCH_DOWN</code> 中记录的  <code>mActivePointerId</code> 进行是否为有效的判断，如果有效，则通过 <code>findPointerIndex</code> 获取作用手指 id 的下标，记录为  <code>pointerIndex</code> ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。<code>yDiff</code> 是滑动的距离，<code>mTouchSlop</code> 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 <code>getScaledTouchSlop</code> 获取，如果大于这个值，我们可以认为开始了拖动的手势。 <code>getNestedScrollAxes</code> 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，<code>mIsBeingDragged</code> 标记为 <code>true</code>，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 <code>requestDisallowInterceptTouchEvent</code>，防止父视图拦截了事件，即 <code>onInterceptTouchEvent</code></p>\n<h4 id=\"TOUCH-CANCEL-amp-amp-TOUCH-UP\"><a href=\"#TOUCH-CANCEL-amp-amp-TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_CANCEL &amp;&amp; TOUCH_UP\"></a>TOUCH_CANCEL &amp;&amp; TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">recycleVelocityTracker();</span><br><span class=\"line\">stopNestedScroll();</span><br></pre></td></tr></table></figure>\n<p>一般我们都会在 <code>TOUCH_CANCEL</code> 和 <code>TOUCH_UP</code> 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 <code>mIsBeingDragged</code> 设置为 <code>false</code>，释放速度跟踪器等等 </p>\n<blockquote>\n<p><code>TOUCH_UP</code> 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 <code>TOUCH_CANCEL</code> 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 <code>TOUCH_DOWN</code>，即在这个事件分发时，向父视图传递了 <code>true</code> 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 <code>ACTION_MOVE</code> 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 <code>onInterceptTouch</code> 中返回了 <code>true</code>，那么在 ViewGroup 的 <code>dispatchTouchEvent</code> 中会给已经确认消费事件的子视图分发一个 <code>TOUCH_CANCEL</code> 的事件，具体可以阅读源码。</p>\n</blockquote>\n<h4 id=\"ACTION-POINTER-UP\"><a href=\"#ACTION-POINTER-UP\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这个为多指触摸时，某个手指抬起时分发的事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;</span><br><span class=\"line\">                MotionEvent.ACTION_POINTER_INDEX_SHIFT;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerId = ev.getPointerId(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerId == mActivePointerId) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> newPointerIndex = pointerIndex == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">    mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(newPointerIndex);</span><br><span class=\"line\">    mActivePointerId = ev.getPointerId(newPointerIndex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mVelocityTracker != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mVelocityTracker.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>我们可以简单总结下，<code>onInterceptTouchEvent</code> 所进行的处理，即在 <code>TOUCH_DOWN</code> 资源初始化，<code>TOUCH_MOVE</code> 判断是否开始拖动手势，<code>TOUCH_CANCEL</code> &amp;&amp; <code>TOUCH_UP</code> 中进行资源释放。这里涉及了多指触摸的处理。</p>\n<h3 id=\"onTouchEvent\"><a href=\"#onTouchEvent\" class=\"headerlink\" title=\"onTouchEvent\"></a>onTouchEvent</h3><p><code>onTouchEvent</code> 要比 <code>onInterceptTouch</code> 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。</p>\n<h4 id=\"TOUCH-DOWN-1\"><a href=\"#TOUCH-DOWN-1\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (getChildCount() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((mIsBeingDragged = !mScroller.isFinished())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!mScroller.isFinished()) &#123;</span><br><span class=\"line\">    mScroller.abortAnimation();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY();</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>同样的，<code>onTouchEvent</code> 在 <code>TOUCH_DOWN</code> 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 <code>abortAnimation</code>，如果 Scroller 还没结束 fling 计算，则中止处理。</p>\n<h4 id=\"TOUCH-MOVE-1\"><a href=\"#TOUCH-MOVE-1\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerIndex = ev.findPointerIndex(mActivePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(activePointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">int</span> deltaY = mLastMotionY - y;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (dispatchNestedPreScroll(<span class=\"number\">0</span>, deltaY, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 嵌套滚动处理</span></span><br><span class=\"line\">    deltaY -= mScrollConsumed[<span class=\"number\">1</span>];</span><br><span class=\"line\">    vtev.offsetLocation(<span class=\"number\">0</span>, mScrollOffset[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    mNestedYOffset += mScrollOffset[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mIsBeingDragged &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (deltaY &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            deltaY -= mTouchSlop;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            deltaY += mTouchSlop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码同样会进行多指处理，获取指定手指的触摸事件信息。<code>mIsBeingDragged</code> 为 <code>false</code>，同时会再进行一次拖动手势的判定，判定逻辑和 <code>onInterceptTouchEvent</code> 中类似，如果 <code>mIsBeingDragged</code> 为 <code>true</code>，则开始进行真正的逻辑处理。</p>\n<blockquote>\n<p>EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码</p>\n</blockquote>\n<h4 id=\"TOUCH-UP\"><a href=\"#TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_UP\"></a>TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> VelocityTracker velocityTracker = mVelocityTracker;</span><br><span class=\"line\">\tvelocityTracker.computeCurrentVelocity(<span class=\"number\">1000</span>, mMaximumVelocity);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> initialVelocity = (<span class=\"keyword\">int</span>) velocityTracker.getYVelocity(mActivePointerId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((Math.abs(initialVelocity) &gt; mMinimumVelocity)) &#123;</span><br><span class=\"line\">    \tflingWithNestedDispatch(-initialVelocity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 <code>getYVelocity</code> 获取速度，在判断是否可以作为 fling 手势处理，<code>mMaximumVelocity</code> 是处理的最大速度，<code>mMinimumVelocity</code> 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 <code>getScaledMaximumFlingVelocity</code> 和 <code>getScaledMinimumFlingVelocity</code> 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> height = getHeight() - mPaddingBottom - mPaddingTop;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bottom = getChildAt(<span class=\"number\">0</span>).getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.fling(mScrollX, mScrollY, <span class=\"number\">0</span>, velocityY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                    Math.max(<span class=\"number\">0</span>, bottom - height), <span class=\"number\">0</span>, height/<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">postInvalidateOnAnimation();</span><br></pre></td></tr></table></figure>\n<p>通过传递当前拖动手势速度值来调用 <code>fling</code> 进行处理，然后在 <code>computeScrollOffset</code> 方法中，进行真正的滚动处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 逻辑处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = mScroller.getCurrX();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = mScroller.getCurrY();</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 <code>computeScrollOffset</code> 进行计算，如果返回 <code>true</code>，表示计算还没结束，然后通过 <code>getCurrX</code> 或 <code>getCurrY</code> 获取计算后的值，最后进行真正的滚动处理，比如调用 <code>scrollTo</code> 等等，这里需要注意的是，需要调用 <code>invalidate</code> 来确保进行下一次的 <code>computeScroll</code> 调用，这里使用的 <code>postInvalidateOnAnimation</code> 其作用是类似的。</p>\n<h4 id=\"TOUCH-CANCEL\"><a href=\"#TOUCH-CANCEL\" class=\"headerlink\" title=\"TOUCH_CANCEL\"></a>TOUCH_CANCEL</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged &amp;&amp; getChildCount() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.springBack(mScrollX, mScrollY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, getScrollRange())) &#123;</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的，一般我们都会在 <code>TOUCH_CANCEL</code> 中释放资源。</p>\n<h4 id=\"ACTION-POINTER-DOWN\"><a href=\"#ACTION-POINTER-DOWN\" class=\"headerlink\" title=\"ACTION_POINTER_DOWN\"></a>ACTION_POINTER_DOWN</h4><p>当有新的手指按下时分发的事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = ev.getActionIndex();</span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(index);</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(index);</span><br></pre></td></tr></table></figure>\n<p>以新按下的手指的信息重新计算</p>\n<h4 id=\"ACTION-POINTER-UP-1\"><a href=\"#ACTION-POINTER-UP-1\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这里的处理和 <code>onInterceptTouch</code> 一致</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><code>onTouchEvent</code> 和 <code>onInterceptTouchEvent</code> 处理有些相似，主要是在 <code>TOUCH_MOVE</code> 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 <code>TOUCH_UP</code> 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 <code>NestedScrollView</code>、<code>RecyclerView</code>  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 <code>ViewDragHelper</code> ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim\" alt=\"WheelView\"></p>\n<p><img src=\"http://oy017242u.bkt.clouddn.com/more.gif\" alt=\"TapeView\"></p>\n<p>详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是<a href=\"https://github.com/LinXiaoTao/WheelView\" target=\"_blank\" rel=\"noopener\">滚轮控件</a>，第二个是之前参加活动的仿薄荷健康的<a href=\"https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md\" target=\"_blank\" rel=\"noopener\">卷尺控件</a>。在这里我们只分析部分代码：</p>\n<h3 id=\"滚轮控件\"><a href=\"#滚轮控件\" class=\"headerlink\" title=\"滚轮控件\"></a>滚轮控件</h3><p>在前面手势判定中的分析中，我们提到在 <code>onTouchEvent</code> 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    mDistanceY += mLastY - moveY;</span><br><span class=\"line\">    postInvalidateOnAnimation();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在每次 <code>TOUCH_MOVE</code> 事件分发时，计算与 <code>TOUCH_DOWN</code> 时记录的位置信息的差值，保存为 <code>mDistanceY</code>，并且在 <code>onDraw</code> 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。</p>\n<h3 id=\"卷尺控件\"><a href=\"#卷尺控件\" class=\"headerlink\" title=\"卷尺控件\"></a>卷尺控件</h3><p>拖动距离的计算与滚轮控件一样，只是记录为 <code>mOffsetLeft</code> 而已，同时两个控件都有在 <code>onTouchEvent</code> 的 <code>ACTION_UP</code> 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。</p>\n<p>但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：</p>\n<ul>\n<li>最基本的拖动手势处理</li>\n<li>fling 效果实现</li>\n<li>如果可以，再实现边缘效果</li>\n</ul>\n<p>感谢大家的阅读。</p>\n"},{"title":"Activity启动流程(基于Android26)","date":"2018-03-27T01:54:17.000Z","_content":"\n> 基于 Android 26，分析 Android Activity 启动流程\n\n## 参考\n\n[startActivity启动过程分析](http://gityuan.com/2016/03/12/start-activity/)\n\n## 源码\n\n**源码篇幅可能过长，所以会省略一下不必要的代码和注释**\n\n### Activity\n\n``` java\n@Override                                    \npublic void startActivity() {   \n    this.startActivity(intent, null);        \n}\n\n@Override                                                           \npublic void startActivity() {\n    if (options != null) {                                          \n        startActivityForResult(intent, -1, options);                \n    } else {                                                        \n        startActivityForResult(intent, -1);                         \n    }                                                               \n}                                                                   \n```\n\n最终都会调用到 `startActivityForResult`：\n\n``` java\npublic void startActivityForResult() {                                                             \n    if (mParent == null) {\n        // 转场动画的处理\n        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      \n        if (ar != null) {                                                                       \n            mMainThread.sendActivityResult();                                                                                                             \n        }                                                                                       \n        if (requestCode >= 0) {                                                                                        \n            mStartedActivity = true;                                                            \n        }                                                                                                                                                                             \n    } else {                                                                                    \n        // 如果存在 Parent Activity 则交由它处理                                                                                    \n    }                                                                                           \n}                                                                                               \n```\n\n可以知道 Activity 启动委托给了 Instrumentation 进行实现\n\n### Instrumentation\n\n``` java\npublic ActivityResult execStartActivity() {\n    // 由 ActivityThread.getApplicationThread 提供的 ApplicationThread\n    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                \n    if (mActivityMonitors != null) {                                       \n        synchronized (mSync) {                                             \n            final int N = mActivityMonitors.size();                        \n            for (int i=0; i<N; i++) {                                      \n                final ActivityMonitor am = mActivityMonitors.get(i);       \n                ActivityResult result = null;                              \n                if (am.ignoreMatchingSpecificIntents()) {\n                    // true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 \n                    result = am.onStartActivity(intent);                   \n                }                                                          \n                if (result != null) {                                      \n                    am.mHits++;                                            \n                    return result;                                         \n                } else if (am.match(who, null, intent)) {\n                    // match 使用 IntentFilter 和 类名 进行匹配\n                    am.mHits++;                                            \n                    if (am.isBlocking()) {\n                        // 当前监视器阻止 Activity 启动\n                        return requestCode >= 0 ? am.getResult() : null;   \n                    }                                                      \n                    break;                                                 \n                }                                                          \n            }                                                              \n        }                                                                  \n    }                                                                      \n    try {\n        // 委托为 ActivityManagerService(AMS) 去处理\n        int result = ActivityManager.getService().startActivity();                          \n        // 检查 AMS 的处理结果\n        checkStartActivityResult(result, intent);                          \n    } catch (RemoteException e) {                                          \n        throw new RuntimeException(\"Failure from system\", e);              \n    }                                                                      \n    return null;                                                           \n}                                                                          \n```\n\n可以通过最后的调用委托给了`ActivityManager.getService`，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现\n\n> 相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC\n\n``` java\npublic static IActivityManager getService() {\n    return IActivityManagerSingleton.get();  \n}\n\nprivate static final Singleton<IActivityManager> IActivityManagerSingleton =          \n        new Singleton<IActivityManager>() {                                           \n            @Override                                                                 \n            protected IActivityManager create() {                                     \n                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);\n                final IActivityManager am = IActivityManager.Stub.asInterface(b);     \n                return am;                                                            \n            }                                                                         \n        };                                                                            \n```\n\n### ActivityManagerService\n\n``` java\n@Override                                                                                       \npublic final int startActivity() {                           \n    return startActivityAsUser();                                                     \n}\n\n@Override                                                                                                                          \npublic final int startActivityAsUser() {                                                                                                                                   \n    return mActivityStarter.startActivityMayWait();                                                                                                \n}                                                                                                                                  \n```\n\n这里将启动请求又委托给了 ActivityStarter\n\n### ActivityStarter\n\n``` java\nfinal int startActivityMayWait() {                                                \n    // Intent 的响应\n    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           \n    // Intent 的 Activity 信息                                                               \n    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        \n        final ActivityRecord[] outRecord = new ActivityRecord[1];\n    \t// 调用 startActivityLocked\n        int res = startActivityLocked(outRecord);                                                                                                                          \n        return res;                                                                                                       \n    }                                                                                                                     \n}                                                                                                                         \n```\n\n``` java\nprivate int startActivity() {\n    // 源 Activity 记录，即在哪个 Activity 进行 startActivity\n    ActivityRecord sourceRecord = null;\n    // 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity\n    ActivityRecord resultRecord = null;                                                                       \n    if (resultTo != null) {\n        // 获取 Activity Stack 中已经存在的源 Activity 记录\n        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 \n        if (sourceRecord != null) {                                                                           \n            if (requestCode >= 0 && !sourceRecord.finishing) {\n                // requestCode >= 0，源 Activity 同时为 结果 Activity\n                resultRecord = sourceRecord;                                                                  \n            }                                                                                                 \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    final int launchFlags = intent.getFlags();                                                                \n                                                                                                              \n    if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {                   \n        // 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity\n        // 比如：A -> B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A\n        if (requestCode >= 0) {\n            // 不允许有 requestCode\n            ActivityOptions.abort(options);                                                                   \n            return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        \n        }\n        // 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity\n        resultRecord = sourceRecord.resultTo;                                                                 \n        if (resultRecord != null && !resultRecord.isInStackLocked()) {                                        \n            resultRecord = null;                                                                              \n        }\n        // requestCode 处理\n        resultWho = sourceRecord.resultWho;                                                                   \n        requestCode = sourceRecord.requestCode;                                                               \n        sourceRecord.resultTo = null;                                                                         \n        if (resultRecord != null) {\n            // 删除源 Activity 记录\n            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           \n        }                                                                                                                                                                                         \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {                              \n        // component 找不到                                                                         \n        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && aInfo == null) {                                              \n        // ActivityInfo 找不到                                                                         \n        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && sourceRecord != null                                          \n            && sourceRecord.getTask().voiceSession != null) {                                                 \n        // 语音启动 Activity，检查是否符合                                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && voiceSession != null) {                                       \n        // 启动语音会话                                                       \n    }                                                                                                         \n                                                                                                              \n    final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack();                  \n                                                                                                              \n    if (err != START_SUCCESS) {\n        // 启动 Activity 失败\n        if (resultRecord != null) {\n            // 发送取消通知\n            resultStack.sendActivityResultLocked(                                                             \n                    -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);                         \n        }                                                                                                     \n        ActivityOptions.abort(options);                                                                       \n        return err;                                                                                           \n    }                                                                                                         \n                                                                                                              \n    // 进行一些权限检查，判断是否终止                                                              \n    if (abort) {\n        // 如果需要终止 Activity\n        if (resultRecord != null) {                                                                           \n            resultStack.sendActivityResultLocked();                                                                   \n        }                                                                                                     \n        // 返回启动成功，实际终止                                                                \n        ActivityOptions.abort(options);                                                                       \n        return START_SUCCESS;                                                                                 \n    }                                                                                                         \n                                                                                                              \n    // 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             \n                                                                                                              \n    // 处理 ephemeral app                                                                    \n    \n    // 构造一个 ActivityRecord\n    ActivityRecord r = new ActivityRecord();                                                   \n                                                                                                     \n    final ActivityStack stack = mSupervisor.mFocusedStack;                                                    \n    if (voiceSession == null && (stack.mResumedActivity == null                                               \n            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) {\n        // 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换\n        if (!mService.checkAppSwitchAllowedLocked() {                                          \n            PendingActivityLaunch pal =  new PendingActivityLaunch();                                              \n            mPendingActivityLaunches.add(pal);                                                                \n            ActivityOptions.abort(options);\n            // 切换 app 失败\n            return ActivityManager.START_SWITCHES_CANCELED;                                                   \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    if (mService.mDidAppSwitch) {                                                                             \n        // 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            \n        mService.mAppSwitchesAllowedTime = 0;                                                                 \n    } else {                                                                                                  \n        mService.mDidAppSwitch = true;                                                                        \n    }                                                                                                         \n    \n    // 执行因为不允许 app 切换，而加到等待启动的 Activity\n    doPendingActivityLaunchesLocked(false);                                                                   \n                                                                                                              \n    return startActivity();                                                                    \n}                                                                                                             \n```\n\n``` java\nprivate int startActivity() {                                                        \n    int result = START_CANCELED;                                                               \n    try {                                                                                      \n        mService.mWindowManager.deferSurfaceLayout();\n        // 下一步流程\n        result = startActivityUnchecked();                           \n    } finally {                                                                                \n        // 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      \n        if (!ActivityManager.isStartResultSuccessful(result)                                   \n                && mStartActivity.getTask() != null) {                                         \n            mStartActivity.getTask().removeActivity(mStartActivity);                           \n        }                                                                                      \n        mService.mWindowManager.continueSurfaceLayout();                                       \n    }                                                                                          \n                                                                                               \n    postStartActivityProcessing();                                                                     \n                                                                                               \n    return result;                                                                             \n}                                                                                              \n```\n\n``` java\nprivate int startActivityUnchecked() {\n\t\n    // 设置一些初始化状态\n    setInitialState();\n    // 计算 launch flags\n    computeLaunchingTaskFlags();\n    // 计算源 Task，源 Task 是否存在等\n    computeSourceStack();\n    // 获取是否存在可以复用的 Activity，根据 flags 和 launchMode\n    ActivityRecord reusedActivity = getReusableIntentActivity();\n    if (reusedActivity != null) {\n    \t// 存在可复用的 Activity，复用它\n        // 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置\n    }\n    if (mStartActivity.packageName == null) {\n    \treturn START_CLASS_NOT_FOUND;\n    }\n    // 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity\n    final boolean dontStart = top != null && mStartActivity.resultTo == null\n                && top.realActivity.equals(mStartActivity.realActivity)\n                && top.userId == mStartActivity.userId\n                && top.app != null && top.app.thread != null\n                && ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0\n                || mLaunchSingleTop || mLaunchSingleTask);\n    if(dontStart){\n        // 传递一个新的 Intent 到 onNewIntent \n        top.deliverNewIntentLocked();\n        return START_DELIVERED_TO_TOP;\n    }\n    \n    // 获取 mTargetStack\n    if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask\n                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n    \tnewTask = true;\n        // 需要创建新的 Task\n        result = setTaskFromReuseOrCreateNewTask();\n    } else if (mSourceRecord != null) {\n        // 从源 Activity 中获取 Task\n    \tresult = setTaskFromSourceRecord();\n    } else if (mInTask != null) {\n        // 从 InTask 中获取 Task\n    \tresult = setTaskFromInTask();\n    } else {\n        // 可能创建新的 Task 或使用当前 Task，一般不会发生\n    \tsetTaskToCurrentTopOrCreateNewTask();\n    }\n    \n    // 使用 mTargetStack 启动 Activity \n    mTargetStack.startActivityLocked();\n    \n    if (mDoResume) {\n        if (!mTargetStack.isFocusable()\n                    || (topTaskActivity != null && topTaskActivity.mTaskOverlay\n                    && mStartActivity != topTaskActivity)) {\n        \t// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity\n            // 那么我们不恢复目标 Task，只需要确保它可见即可\n            mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        }\n    } else {\n        if (mTargetStack.isFocusable() && !mSupervisor.isFocusedStack(mTargetStack)) {\n        \t// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台\n            mTargetStack.moveToFront(\"startActivityUnchecked\");\n        }\n        // 恢复目标 Task\n        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,\n                        mOptions);\n    } else {\n        // 如果不需要恢复，那么加到\"最近活动\"中\n        mTargetStack.addRecentActivityLocked(mStartActivity);\n    }\n    \n    return START_SUCCESS;\n}\n\nprivate void setInitialState(){\n    // 获取 DisplayId\n    mSourceDisplayId = getSourceDisplayId();\n    // 获取用于启动 Activity 的范围，Rect\n    mLaunchBounds = getOerrideBounds();\n    // launchMode\n    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;\n    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;\n    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;\n    // Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主\n    // 如果 requestCode >= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity\n    sendNewTaskResultRequestIfNeeded();\n}\n\nprivate void computeLaunchingTaskFlags(){\n    if (mSourceRecord == null && mInTask != null && mInTask.getStack() != null){\n        // 如果不存在源 Activity\n        final Intent baseIntent = mInTask.getBaseIntent();\n        final ActivityRecord root = mInTask.getRootActivity();\n        if (baseIntent == null){\n            throw new IllegalArgumentException();\n        }\n        if (mLaunchSingleInstance || mLaunchSingleTask) {\n            // 如果设置了 SingleInstacne 或 SingleTask\n        \tif (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent())){\n                // Task 不符合\n                throw new IllegalArgumentException();\n            }\n            \n            if(root != null){\n                // 已经存在 Task 根 Activity\n                throw new IllegalArgumentException();\n            }\n        }\n        \n        if (root == null) {\n        \t// 如果不存在根 Activity，重新设置 launch flags\n            mAddingToTask = true;\n        }else if ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n             mAddingToTask = false;\n        }else {\n            mAddingToTask = true;\n        }\n    }else {\n                     if ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) && mSourceRecord != null\n                    && mSourceRecord.isFreeform())  {\n                         // 如果使用 ResolverActivity 启动或者 noDisplay\n                mAddingToTask = true;\n            }\n    }\n    \n    if(mInTask == null){\n        if (mSourceRecord == null) {\n        \tif ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) == 0 && mInTask == null) {\n                // 不存在 Task，并且不存在源 Activity\n            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n            }\n        }else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) {\n        \t// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }else if (mLaunchSingleInstance || mLaunchSingleTask) {\n        \t// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }\n    }\n    \n}\n```\n\nActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity\n\n### ActivityStack\n\n``` java\nfinal void startActivityLocked(){\n    if(!newTask) {\n      // 如果从已存在的 Task 中启动 Activity\n      boolean startIt = true;\n      for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {\n      \ttask = mTaskHistory.get(taskNdx);\n          if (task.getTopActivity() == null){\n              // 如果 task 不存在 Activity\n              continue;\n          }\n          if (task == rTask) {\n          \t// 找到对应的 task\n            if (!startIt) {\n            \t// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动\n                r.createWindowContainer();\n                ActivityOptions.abort(options);\n                return;\n            }\n          } else if (task.numFullscreen > 0) {\n              startIt = false;\n          }\n      }\n    }\n    \n    // 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调\n    if (task == activityTask && mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) {\n        mStackSupervisor.mUserLeaving = false;\n    }\n    \n    if (!isHomeOrRecentsStack() || numActivities() > 0) {\n    \t// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0\n        \n        // 处理 动画\n        \n        if (newTask) {\n            if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {\n            // 如果设置了重置的标记\n            resetTaskIfNeededLocked(r, r);\n            doShow = topRunningNonDelayedActivityLocked(null) == r;\n            } else if (options != null && options.getAnimationType()\n                    == ActivityOptions.ANIM_SCENE_TRANSITION) {\n                // 需要进行转场动画\n                doShow = false;\n        }\n    }\n        \n        \n        if (r.mLaunchTaskBehind) {\n        \t// 如果为 true，那么不开启 window，但要确保 Activity 是可见的\n            r.setVisibility(true);\n            ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        } else if (SHOW_APP_STARTING_PREVIEW && doShow) {\n            TaskRecord prevTask = r.getTask();\n            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();\n            if (prev != null) {\n                // 以下两种情况不展示之前的 Activity 预览\n            \tif (prev.getTask() != prevTask) {\n                    // 之前的 Activity 在不同的 Task\n                \tprev = null;\n                } else if (prev.nowVisible) {\n                    // 现在可见\n                \t prev = null;\n                }\n            }\n            // 显示启动 Activity 的 Window\n        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));\n        } else {\n            // 当前为栈顶 Activity\n            ActivityOptions.abort(options);\n        }\n    \n}\n```\n\n`ActivityStack.startActivityLocked` 主要是创建 WindowContainer，同时显示 Window\n\n### ActivityStackSupervisor\n\n``` java\nboolean resumeFocusedStackTopActivityLocked(){\n    if (targetStack != null && isFocusedStack(targetStack)) {\n        // 存在 targetStack\n    \treturn targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);\n    }\n    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();\n    if (r == null || r.state != RESUMED) {\n        // 恢复聚焦 task\n    \tmFocusedStack.resumeTopActivityUncheckedLocked(null, null);\n    } else if (r.state == RESUMED) {\n        // 执行应用转场动画\n    \tmFocusedStack.executeAppTransition(targetOptions);\n    }\n}\n```\n\n### ActivityStack\n\n``` java\nboolean resumeTopActivityUncheckedLocked() {\n    if (mStackSupervisor.inResumeTopActivity) {\n        // 防止递归\n    \treturn false;\n    }\n    try {\n        // 设置恢复标记\n        mStackSupervisor.inResumeTopActivity = true;\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        mStackSupervisor.inResumeTopActivity = false;\n    }\n    // 在恢复过程中，确保必要的暂停逻辑\n    mStackSupervisor.checkReadyForSleepLocked();\n}\n```\n\n``` java\nprivate boolean resumeTopActivityInnerLocked() {\n    \n    // 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦\n    final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);\n    final boolean hasRunningActivity = next != null;\n    final ActivityRecord parent = mActivityContainer.mParentActivity;\n    final boolean isParentNotResumed = parent != null && parent.state != ActivityState.RESUMED;\n    if (hasRunningActivity\n                && (isParentNotResumed || !mActivityContainer.isAttachedLocked())) {\n           // 如果父 Activity 不是恢复状态，则不恢复当前 Activity\n            return false;\n        }\n    \n    if (!hasRunningActivity) {\n        // 当前 Task 没有需要恢复的 Activity\n    \treturn resumeTopActivityInNextFocusableStack(prev, options, \"noMoreActivities\");\n    }\n    \n    if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                    mStackSupervisor.allResumedActivitiesComplete()) {\n        // 如果 Activity 已经是恢复状态\n        // 确保已经执行了所有等待的转场\n        executeAppTransition(options);\n    \treturn false;\n    }\n    \n    if (mService.isSleepingOrShuttingDownLocked()\n                && mLastPausedActivity == next\n                && mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果系统处于休眠状态，当前 Activity 处于暂停状态\n        // 确保转场执行\n        executeAppTransition(options);\n        return false;\n    }\n    \n    if (!mService.mUserController.hasStartedUserState(next.userId)) {\n        // 如果拥有该 Activity 的用户没有启动\n    \treturn false;\n    }\n    \n    if (!mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果存在暂停 Activity 的操作未完成\n        return false;\n    }\n    \n    boolean lastResumedCanPip = false;\n    final ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();\n    if (lastFocusedStack != null && lastFocusedStack != this) {\n    \tfinal ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;\n        // 最后一个恢复的 Activity 是否可以 画中画\n        lastResumedCanPip = lastResumed != null && lastResumed.checkEnterPictureInPictureState(\n                    \"resumeTopActivity\", true /* noThrow */, userLeaving /* beforeStopping */);\n    }\n    \n    // 是否需要可以在上一个 Activity 暂停时进行恢复\n    final boolean resumeWhilePausing = (next.info.flags & FLAG_RESUME_WHILE_PAUSING) != 0\n                && !lastResumedCanPip;\n    // 是否暂停了回退的 task\n    boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);\n    \n    if (mResumedActivity != null) {\n        // 暂停上一个恢复状态的 Activity\n    \tpausing |= startPausingLocked(userLeaving, false, next, false);\n    }\n    \n    if (pausing && !resumeWhilePausing) {\n    \t// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity\n        if (next.app != null && next.app.thread != null) {\n            // hosting application，一般不执行\n            // 让当前 Activity 放在 Lru 的顶部，避免早早杀死\n        \tmService.updateLruProcessLocked(next.app, true, null);\n        }\n        return true;\n    } else if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                mStackSupervisor.allResumedActivitiesComplete()) {\n    \t// 当前需要恢复的 Activity 已经是恢复状态\n        // 确保执行转场\n        executeAppTransition(options);\n        return true;\n    }\n    \n    if (mService.isSleepingLocked() && mLastNoHistoryActivity != null &&\n                !mLastNoHistoryActivity.finishing) {\n        // 结束因为系统休眠而还没结束的 Activity\n    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,\n                    null, \"resume-no-history\", false);\n        mLastNoHistoryActivity = null;\n    }\n    \n    if (prev != null && prev != next) {\n    \tif (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)\n                    && next != null && !next.nowVisible) {\n        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);\n        } else {\n            // 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity\n            if (prev.finishing) {\n            \tprev.setVisibility(false);\n            } else {\n                \n            }\n        }\n    }\n    \n    // Activity 转场处理\n    \n    ActivityStack lastStack = mStackSupervisor.getLastStack();\n    if (next.app != null && next.app.thread != null) {\n        // 上一个 Activity 是否为透明\n    \tfinal boolean lastActivityTranslucent = lastStack != null\n                    && (!lastStack.mFullscreen\n                    || (lastStack.mLastPausedActivity != null\n                    && !lastStack.mLastPausedActivity.fullscreen));\n        \n        if (!next.visible || next.stopped || lastActivityTranslucent) {\n            // 前一个 Activity 为透明，并且当前 Activity 还没显示\n            // 设置为显示状态\n            next.setVisibility(true);\n        }\n        \n        // 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向\n    boolean notUpdated = true;\n    if (mStackSupervisor.isFocusedStack(this)) {\n    \tfinal Configuration config = mWindowManager.updateOrientationFromAppTokens(\n                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),\n                        next.mayFreezeScreenLocked(next.app) ? next.appToken : null, mDisplayId);\n        \n        if (config != null) {\n    \tnext.frozenBeforeDestroy = true;\n        }\n        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,\n                        false /* deferResume */, mDisplayId);\n    }\n    \n     if (notUpdated) {\n         // 配置发生更新无法保持已经存在的 Activity 实例\n         // 重新获取需要恢复的 Activity\n         ActivityRecord nextNext = topRunningActivityLocked();\n         // 确保 Activity 仍然保持在栈顶，同时安排另外一次执行\n         if (nextNext != next) {\n         \tmStackSupervisor.scheduleResumeTopActivities();\n         }\n         if (!next.visible || next.stopped) {\n         \tnext.setVisibility(true);\n         }\n         next.completeResumeLocked();\n         return true;\n     }\n    \n    try {\n        // 传递所有等待的结果\n        \n        if (next.newIntents != null){\n            next.app.thread.scheduleNewIntent(\n                            next.newIntents, next.appToken, false /* andPause */);\n        }\n        \n        next.notifyAppResumed(next.stopped);\n        \n        // 准备恢复 Activity\n        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,\n                        mService.isNextTransitionForward(), resumeAnimOptions);\n    } catch (Exception e){\n        // 发生异常，重新启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, false);\n        return true;\n    }\n        \n        try {\n            next.completeResumeLocked();\n        } catch(Exception e){\n            // 发生异常，结束 Activity\n            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null,\n                        \"resume-exception\", true);\n            return true;\n        }\n        \n    } else {\n        // 需要启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\n    }\n    \n    return true;\n\n}\n```\n\n如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：\n\n### ActivityStackSupervisor\n\n``` java\nvoid startSpecificActivityLocked() {\n    // 获取应用进程信息\n    ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n                r.info.applicationInfo.uid, true);\n    \n    if (app != null && app.thread != null) {\n    \t// 如果进程已经启动\n        try {\n            realStartActivityLocked(r, app, andResume, checkConfig);\n            return;\n        }catch (RemoteException e){\n            \n        }\n    }\n    \n    // 启动应用进程\n    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n}\n```\n\n``` java\nfinal boolean realStartActivityLocked() {\n    // 冻结屏幕\n    r.startFreezingScreenLocked(app, 0);\n    if (checkConfig) {\n    \t// 根据新的 Activity 顺序重新评估屏幕的方向\n    }\n    \n    int idx = app.activities.indexOf(r);\n    if (idx < 0) {\n        // 将 Activity 添加到应用进程中\n        app.activities.add(r);\n    }\n    \n    try {\n        app.thread.scheduleLaunchActivity();\n    }catch(RemoteException e){\n        // 发生异常，结束 Activity\n        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,\n                        \"2nd-crash\", false);\n        return false;\n    }\n    \n    return true;\n}\n```\n\n启动流程最后还是回到了 ApplicationThread\n\n### ApplicationThread\n\n``` java\npublic final void scheduleLaunchActivity() {\n    // 通过 Handler 发送 LAUNCH_ACTIVITY\n    sendMessage(H.LAUNCH_ACTIVITY, r);\n}\n```\n\n我们单独把 LAUNCH_ACTIVITY 的处理拿出来：\n\n``` java\nfinal ActivityClientRecord r = (ActivityClientRecord) msg.obj;\nr.packageInfo = getPackageInfoNoCheck(\n                            r.activityInfo.applicationInfo, r.compatInfo);\nhandleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n```\n\n### ActivityThread\n\n``` java\nprivate void handleLaunchActivity() {\n    // 执行启动 Activity\n    Activity a = performLaunchActivity(r, customIntent);\n    if (a != null) {\n        // resume activity\n        handleResumeActivity(r.token, false, r.isForward,\n                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);\n    } else {\n        \n    }\n}\n```\n\n``` java\nprivate performLaunchActivity() {\n    // Activity 信息初始化\n    \n    // 创建 context\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        // 构建 Activity\n        activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n    }catch(Exception e){\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        if(activity != null){\n        \tactivity.attach();\n            \n            // 通过 Instrumentation 执行 Activity onCreate\n            if (r.isPersistable()) {\n                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            }else {\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            \n            if (!r.activity.mFinished) {\n                // Activity onStart\n            \tactivity.performStart();\n            }\n            \n            // 通过 Instrumentation 执行 Activity onRestoreInstanceState\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                \tif (r.state != null || r.persistentState != null) {\n                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,\n                                    r.persistentState);\n                    }\n                } else if (r.state != null) {\n                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);\n                }\n            }\n            \n             // 通过 Instrumentation 执行 Activity onPostCreeate\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state,\n                                r.persistentState);\n                }else {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state);\n                }\n            }       \n    }\n        \n    return activity;\n    \n}\n```\n\n``` java\nfinal void handleResumeActivity() {\n    r = performResumeActivity();\n    if(r != null) {\n        final Activity a = r.activity;\n        if (r.window == null && !a.mFinished && willBeVisible) {\n            r.window = r.activity.getWindow();\n            View decor = r.window.getDecorView();\n            decor.setVisibility(View.INVISIBLE);\n            ViewManager wm = a.getWindowManager();\n            if (a.mVisibleFromClient) {\n            \tif (!a.mWindowAdded) {\n                \ta.mWindowAdded = true;\n                    // window\n                    wm.addView(decor, l);\n                }\n            }\n        }\n    }\n}\n```\n\n``` java\npublic final ActivityClientRecord performResumeActivity() {\n \tif (r != null && !r.activity.mFinished) {\n    \ttry {\n            // 处理等待的 Intent\n            if (r.pendingIntents != null) {\n            \tdeliverNewIntents(r, r.pendingIntents);\n                r.pendingIntents = null;\n            }\n            // 处理等待的 result\n            if (r.pendingResults != null) {\n            \tdeliverResults(r, r.pendingResults);\n                r.pendingResults = null;\n            }\n            // 执行 resume\n            r.activity.performResume();\n        }\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic Activity newActivity(){\n    return (Activity)cl.loadClass(className).newInstance();\n}\n```\n\n``` java\nprivate void callActivityOnCreate(){\n    prePerformCreate(activity);\n    activity.performCreate(icicle);\n    postPerformCreate(activity);\n}\n```\n\n### Activity\n\n``` java\nfinal void performCreate() {\n    restoreHasCurrentPermissionRequest(icicle);\n    // 调用 onCreate\n    onCreate(icicle);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n```\n\n``` java\nfinal void performStart() {\n    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());\n    mInstrumentation.callActivityOnStart(this);\n    mActivityTransitionState.enterReady(this);\n}\n```\n\n``` java\nfinal void performResume() {\n    // 执行 restart\n    performRestart();\n    mInstrumentation.callActivityOnResume(this);\n}\n```\n\n``` java\nfinal void performRestart() {\n    if (mStopped) {\n        mStopped = false;\n        mInstrumentation.callActivityOnRestart(this);\n        // 执行 start\n        performStart();\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic void callActivityOnStart() {\n    activity.onStart();\n}\n```\n\n``` java\npublic void callActivityOnResume() {\n     activity.mResumed = true;\n    activity.onResume();\n}\n```\n\n``` java\npublic void callActivityOnRestart() {\n    activity.onRestart();\n}\n```\n\n## 总结\n\n简单总结下 Activity 的启动流程：\n\n1. 从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信\n2. ActivityManagerService 用于管理所有的 Activity 活动\n   * 当接受到启动 Activity 的调用时，使用 `resolveActivity` ，查询系统中符合要求的 Activity\n   * 创建使用合适的  ActivityStack 和 launch flags 来启动 Activity\n   * 如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity\n   * 如果不存在应用进程，先创建应用进程\n3. 最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行\n   * 使用 Instrumentation 去通过反射构建 Activity 实例\n   * 使用 Handler 机制调用 Activity 的生命周期\n\n下面的图例来自[博客](http://gityuan.com/2016/03/12/start-activity/)：\n\n![启动流程](http://gityuan.com/images/activity/start_activity_process.jpg)\n\n### 时序图\n\n![Android启动流程](http://oy017242u.bkt.clouddn.com/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png)\n\n","source":"_posts/Activity启动流程-基于Android26.md","raw":"---\ntitle: Activity启动流程(基于Android26)\ndate: 2018-03-27 09:54:17\ncategories: Android Framework\ntags:\n---\n\n> 基于 Android 26，分析 Android Activity 启动流程\n\n## 参考\n\n[startActivity启动过程分析](http://gityuan.com/2016/03/12/start-activity/)\n\n## 源码\n\n**源码篇幅可能过长，所以会省略一下不必要的代码和注释**\n\n### Activity\n\n``` java\n@Override                                    \npublic void startActivity() {   \n    this.startActivity(intent, null);        \n}\n\n@Override                                                           \npublic void startActivity() {\n    if (options != null) {                                          \n        startActivityForResult(intent, -1, options);                \n    } else {                                                        \n        startActivityForResult(intent, -1);                         \n    }                                                               \n}                                                                   \n```\n\n最终都会调用到 `startActivityForResult`：\n\n``` java\npublic void startActivityForResult() {                                                             \n    if (mParent == null) {\n        // 转场动画的处理\n        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      \n        if (ar != null) {                                                                       \n            mMainThread.sendActivityResult();                                                                                                             \n        }                                                                                       \n        if (requestCode >= 0) {                                                                                        \n            mStartedActivity = true;                                                            \n        }                                                                                                                                                                             \n    } else {                                                                                    \n        // 如果存在 Parent Activity 则交由它处理                                                                                    \n    }                                                                                           \n}                                                                                               \n```\n\n可以知道 Activity 启动委托给了 Instrumentation 进行实现\n\n### Instrumentation\n\n``` java\npublic ActivityResult execStartActivity() {\n    // 由 ActivityThread.getApplicationThread 提供的 ApplicationThread\n    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                \n    if (mActivityMonitors != null) {                                       \n        synchronized (mSync) {                                             \n            final int N = mActivityMonitors.size();                        \n            for (int i=0; i<N; i++) {                                      \n                final ActivityMonitor am = mActivityMonitors.get(i);       \n                ActivityResult result = null;                              \n                if (am.ignoreMatchingSpecificIntents()) {\n                    // true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 \n                    result = am.onStartActivity(intent);                   \n                }                                                          \n                if (result != null) {                                      \n                    am.mHits++;                                            \n                    return result;                                         \n                } else if (am.match(who, null, intent)) {\n                    // match 使用 IntentFilter 和 类名 进行匹配\n                    am.mHits++;                                            \n                    if (am.isBlocking()) {\n                        // 当前监视器阻止 Activity 启动\n                        return requestCode >= 0 ? am.getResult() : null;   \n                    }                                                      \n                    break;                                                 \n                }                                                          \n            }                                                              \n        }                                                                  \n    }                                                                      \n    try {\n        // 委托为 ActivityManagerService(AMS) 去处理\n        int result = ActivityManager.getService().startActivity();                          \n        // 检查 AMS 的处理结果\n        checkStartActivityResult(result, intent);                          \n    } catch (RemoteException e) {                                          \n        throw new RuntimeException(\"Failure from system\", e);              \n    }                                                                      \n    return null;                                                           \n}                                                                          \n```\n\n可以通过最后的调用委托给了`ActivityManager.getService`，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现\n\n> 相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC\n\n``` java\npublic static IActivityManager getService() {\n    return IActivityManagerSingleton.get();  \n}\n\nprivate static final Singleton<IActivityManager> IActivityManagerSingleton =          \n        new Singleton<IActivityManager>() {                                           \n            @Override                                                                 \n            protected IActivityManager create() {                                     \n                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);\n                final IActivityManager am = IActivityManager.Stub.asInterface(b);     \n                return am;                                                            \n            }                                                                         \n        };                                                                            \n```\n\n### ActivityManagerService\n\n``` java\n@Override                                                                                       \npublic final int startActivity() {                           \n    return startActivityAsUser();                                                     \n}\n\n@Override                                                                                                                          \npublic final int startActivityAsUser() {                                                                                                                                   \n    return mActivityStarter.startActivityMayWait();                                                                                                \n}                                                                                                                                  \n```\n\n这里将启动请求又委托给了 ActivityStarter\n\n### ActivityStarter\n\n``` java\nfinal int startActivityMayWait() {                                                \n    // Intent 的响应\n    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           \n    // Intent 的 Activity 信息                                                               \n    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        \n        final ActivityRecord[] outRecord = new ActivityRecord[1];\n    \t// 调用 startActivityLocked\n        int res = startActivityLocked(outRecord);                                                                                                                          \n        return res;                                                                                                       \n    }                                                                                                                     \n}                                                                                                                         \n```\n\n``` java\nprivate int startActivity() {\n    // 源 Activity 记录，即在哪个 Activity 进行 startActivity\n    ActivityRecord sourceRecord = null;\n    // 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity\n    ActivityRecord resultRecord = null;                                                                       \n    if (resultTo != null) {\n        // 获取 Activity Stack 中已经存在的源 Activity 记录\n        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 \n        if (sourceRecord != null) {                                                                           \n            if (requestCode >= 0 && !sourceRecord.finishing) {\n                // requestCode >= 0，源 Activity 同时为 结果 Activity\n                resultRecord = sourceRecord;                                                                  \n            }                                                                                                 \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    final int launchFlags = intent.getFlags();                                                                \n                                                                                                              \n    if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {                   \n        // 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity\n        // 比如：A -> B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A\n        if (requestCode >= 0) {\n            // 不允许有 requestCode\n            ActivityOptions.abort(options);                                                                   \n            return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        \n        }\n        // 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity\n        resultRecord = sourceRecord.resultTo;                                                                 \n        if (resultRecord != null && !resultRecord.isInStackLocked()) {                                        \n            resultRecord = null;                                                                              \n        }\n        // requestCode 处理\n        resultWho = sourceRecord.resultWho;                                                                   \n        requestCode = sourceRecord.requestCode;                                                               \n        sourceRecord.resultTo = null;                                                                         \n        if (resultRecord != null) {\n            // 删除源 Activity 记录\n            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           \n        }                                                                                                                                                                                         \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {                              \n        // component 找不到                                                                         \n        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && aInfo == null) {                                              \n        // ActivityInfo 找不到                                                                         \n        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && sourceRecord != null                                          \n            && sourceRecord.getTask().voiceSession != null) {                                                 \n        // 语音启动 Activity，检查是否符合                                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && voiceSession != null) {                                       \n        // 启动语音会话                                                       \n    }                                                                                                         \n                                                                                                              \n    final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack();                  \n                                                                                                              \n    if (err != START_SUCCESS) {\n        // 启动 Activity 失败\n        if (resultRecord != null) {\n            // 发送取消通知\n            resultStack.sendActivityResultLocked(                                                             \n                    -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);                         \n        }                                                                                                     \n        ActivityOptions.abort(options);                                                                       \n        return err;                                                                                           \n    }                                                                                                         \n                                                                                                              \n    // 进行一些权限检查，判断是否终止                                                              \n    if (abort) {\n        // 如果需要终止 Activity\n        if (resultRecord != null) {                                                                           \n            resultStack.sendActivityResultLocked();                                                                   \n        }                                                                                                     \n        // 返回启动成功，实际终止                                                                \n        ActivityOptions.abort(options);                                                                       \n        return START_SUCCESS;                                                                                 \n    }                                                                                                         \n                                                                                                              \n    // 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             \n                                                                                                              \n    // 处理 ephemeral app                                                                    \n    \n    // 构造一个 ActivityRecord\n    ActivityRecord r = new ActivityRecord();                                                   \n                                                                                                     \n    final ActivityStack stack = mSupervisor.mFocusedStack;                                                    \n    if (voiceSession == null && (stack.mResumedActivity == null                                               \n            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) {\n        // 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换\n        if (!mService.checkAppSwitchAllowedLocked() {                                          \n            PendingActivityLaunch pal =  new PendingActivityLaunch();                                              \n            mPendingActivityLaunches.add(pal);                                                                \n            ActivityOptions.abort(options);\n            // 切换 app 失败\n            return ActivityManager.START_SWITCHES_CANCELED;                                                   \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    if (mService.mDidAppSwitch) {                                                                             \n        // 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            \n        mService.mAppSwitchesAllowedTime = 0;                                                                 \n    } else {                                                                                                  \n        mService.mDidAppSwitch = true;                                                                        \n    }                                                                                                         \n    \n    // 执行因为不允许 app 切换，而加到等待启动的 Activity\n    doPendingActivityLaunchesLocked(false);                                                                   \n                                                                                                              \n    return startActivity();                                                                    \n}                                                                                                             \n```\n\n``` java\nprivate int startActivity() {                                                        \n    int result = START_CANCELED;                                                               \n    try {                                                                                      \n        mService.mWindowManager.deferSurfaceLayout();\n        // 下一步流程\n        result = startActivityUnchecked();                           \n    } finally {                                                                                \n        // 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      \n        if (!ActivityManager.isStartResultSuccessful(result)                                   \n                && mStartActivity.getTask() != null) {                                         \n            mStartActivity.getTask().removeActivity(mStartActivity);                           \n        }                                                                                      \n        mService.mWindowManager.continueSurfaceLayout();                                       \n    }                                                                                          \n                                                                                               \n    postStartActivityProcessing();                                                                     \n                                                                                               \n    return result;                                                                             \n}                                                                                              \n```\n\n``` java\nprivate int startActivityUnchecked() {\n\t\n    // 设置一些初始化状态\n    setInitialState();\n    // 计算 launch flags\n    computeLaunchingTaskFlags();\n    // 计算源 Task，源 Task 是否存在等\n    computeSourceStack();\n    // 获取是否存在可以复用的 Activity，根据 flags 和 launchMode\n    ActivityRecord reusedActivity = getReusableIntentActivity();\n    if (reusedActivity != null) {\n    \t// 存在可复用的 Activity，复用它\n        // 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置\n    }\n    if (mStartActivity.packageName == null) {\n    \treturn START_CLASS_NOT_FOUND;\n    }\n    // 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity\n    final boolean dontStart = top != null && mStartActivity.resultTo == null\n                && top.realActivity.equals(mStartActivity.realActivity)\n                && top.userId == mStartActivity.userId\n                && top.app != null && top.app.thread != null\n                && ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0\n                || mLaunchSingleTop || mLaunchSingleTask);\n    if(dontStart){\n        // 传递一个新的 Intent 到 onNewIntent \n        top.deliverNewIntentLocked();\n        return START_DELIVERED_TO_TOP;\n    }\n    \n    // 获取 mTargetStack\n    if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask\n                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n    \tnewTask = true;\n        // 需要创建新的 Task\n        result = setTaskFromReuseOrCreateNewTask();\n    } else if (mSourceRecord != null) {\n        // 从源 Activity 中获取 Task\n    \tresult = setTaskFromSourceRecord();\n    } else if (mInTask != null) {\n        // 从 InTask 中获取 Task\n    \tresult = setTaskFromInTask();\n    } else {\n        // 可能创建新的 Task 或使用当前 Task，一般不会发生\n    \tsetTaskToCurrentTopOrCreateNewTask();\n    }\n    \n    // 使用 mTargetStack 启动 Activity \n    mTargetStack.startActivityLocked();\n    \n    if (mDoResume) {\n        if (!mTargetStack.isFocusable()\n                    || (topTaskActivity != null && topTaskActivity.mTaskOverlay\n                    && mStartActivity != topTaskActivity)) {\n        \t// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity\n            // 那么我们不恢复目标 Task，只需要确保它可见即可\n            mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        }\n    } else {\n        if (mTargetStack.isFocusable() && !mSupervisor.isFocusedStack(mTargetStack)) {\n        \t// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台\n            mTargetStack.moveToFront(\"startActivityUnchecked\");\n        }\n        // 恢复目标 Task\n        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,\n                        mOptions);\n    } else {\n        // 如果不需要恢复，那么加到\"最近活动\"中\n        mTargetStack.addRecentActivityLocked(mStartActivity);\n    }\n    \n    return START_SUCCESS;\n}\n\nprivate void setInitialState(){\n    // 获取 DisplayId\n    mSourceDisplayId = getSourceDisplayId();\n    // 获取用于启动 Activity 的范围，Rect\n    mLaunchBounds = getOerrideBounds();\n    // launchMode\n    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;\n    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;\n    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;\n    // Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主\n    // 如果 requestCode >= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity\n    sendNewTaskResultRequestIfNeeded();\n}\n\nprivate void computeLaunchingTaskFlags(){\n    if (mSourceRecord == null && mInTask != null && mInTask.getStack() != null){\n        // 如果不存在源 Activity\n        final Intent baseIntent = mInTask.getBaseIntent();\n        final ActivityRecord root = mInTask.getRootActivity();\n        if (baseIntent == null){\n            throw new IllegalArgumentException();\n        }\n        if (mLaunchSingleInstance || mLaunchSingleTask) {\n            // 如果设置了 SingleInstacne 或 SingleTask\n        \tif (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent())){\n                // Task 不符合\n                throw new IllegalArgumentException();\n            }\n            \n            if(root != null){\n                // 已经存在 Task 根 Activity\n                throw new IllegalArgumentException();\n            }\n        }\n        \n        if (root == null) {\n        \t// 如果不存在根 Activity，重新设置 launch flags\n            mAddingToTask = true;\n        }else if ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n             mAddingToTask = false;\n        }else {\n            mAddingToTask = true;\n        }\n    }else {\n                     if ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) && mSourceRecord != null\n                    && mSourceRecord.isFreeform())  {\n                         // 如果使用 ResolverActivity 启动或者 noDisplay\n                mAddingToTask = true;\n            }\n    }\n    \n    if(mInTask == null){\n        if (mSourceRecord == null) {\n        \tif ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) == 0 && mInTask == null) {\n                // 不存在 Task，并且不存在源 Activity\n            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n            }\n        }else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) {\n        \t// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }else if (mLaunchSingleInstance || mLaunchSingleTask) {\n        \t// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }\n    }\n    \n}\n```\n\nActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity\n\n### ActivityStack\n\n``` java\nfinal void startActivityLocked(){\n    if(!newTask) {\n      // 如果从已存在的 Task 中启动 Activity\n      boolean startIt = true;\n      for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {\n      \ttask = mTaskHistory.get(taskNdx);\n          if (task.getTopActivity() == null){\n              // 如果 task 不存在 Activity\n              continue;\n          }\n          if (task == rTask) {\n          \t// 找到对应的 task\n            if (!startIt) {\n            \t// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动\n                r.createWindowContainer();\n                ActivityOptions.abort(options);\n                return;\n            }\n          } else if (task.numFullscreen > 0) {\n              startIt = false;\n          }\n      }\n    }\n    \n    // 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调\n    if (task == activityTask && mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) {\n        mStackSupervisor.mUserLeaving = false;\n    }\n    \n    if (!isHomeOrRecentsStack() || numActivities() > 0) {\n    \t// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0\n        \n        // 处理 动画\n        \n        if (newTask) {\n            if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {\n            // 如果设置了重置的标记\n            resetTaskIfNeededLocked(r, r);\n            doShow = topRunningNonDelayedActivityLocked(null) == r;\n            } else if (options != null && options.getAnimationType()\n                    == ActivityOptions.ANIM_SCENE_TRANSITION) {\n                // 需要进行转场动画\n                doShow = false;\n        }\n    }\n        \n        \n        if (r.mLaunchTaskBehind) {\n        \t// 如果为 true，那么不开启 window，但要确保 Activity 是可见的\n            r.setVisibility(true);\n            ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        } else if (SHOW_APP_STARTING_PREVIEW && doShow) {\n            TaskRecord prevTask = r.getTask();\n            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();\n            if (prev != null) {\n                // 以下两种情况不展示之前的 Activity 预览\n            \tif (prev.getTask() != prevTask) {\n                    // 之前的 Activity 在不同的 Task\n                \tprev = null;\n                } else if (prev.nowVisible) {\n                    // 现在可见\n                \t prev = null;\n                }\n            }\n            // 显示启动 Activity 的 Window\n        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));\n        } else {\n            // 当前为栈顶 Activity\n            ActivityOptions.abort(options);\n        }\n    \n}\n```\n\n`ActivityStack.startActivityLocked` 主要是创建 WindowContainer，同时显示 Window\n\n### ActivityStackSupervisor\n\n``` java\nboolean resumeFocusedStackTopActivityLocked(){\n    if (targetStack != null && isFocusedStack(targetStack)) {\n        // 存在 targetStack\n    \treturn targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);\n    }\n    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();\n    if (r == null || r.state != RESUMED) {\n        // 恢复聚焦 task\n    \tmFocusedStack.resumeTopActivityUncheckedLocked(null, null);\n    } else if (r.state == RESUMED) {\n        // 执行应用转场动画\n    \tmFocusedStack.executeAppTransition(targetOptions);\n    }\n}\n```\n\n### ActivityStack\n\n``` java\nboolean resumeTopActivityUncheckedLocked() {\n    if (mStackSupervisor.inResumeTopActivity) {\n        // 防止递归\n    \treturn false;\n    }\n    try {\n        // 设置恢复标记\n        mStackSupervisor.inResumeTopActivity = true;\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        mStackSupervisor.inResumeTopActivity = false;\n    }\n    // 在恢复过程中，确保必要的暂停逻辑\n    mStackSupervisor.checkReadyForSleepLocked();\n}\n```\n\n``` java\nprivate boolean resumeTopActivityInnerLocked() {\n    \n    // 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦\n    final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);\n    final boolean hasRunningActivity = next != null;\n    final ActivityRecord parent = mActivityContainer.mParentActivity;\n    final boolean isParentNotResumed = parent != null && parent.state != ActivityState.RESUMED;\n    if (hasRunningActivity\n                && (isParentNotResumed || !mActivityContainer.isAttachedLocked())) {\n           // 如果父 Activity 不是恢复状态，则不恢复当前 Activity\n            return false;\n        }\n    \n    if (!hasRunningActivity) {\n        // 当前 Task 没有需要恢复的 Activity\n    \treturn resumeTopActivityInNextFocusableStack(prev, options, \"noMoreActivities\");\n    }\n    \n    if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                    mStackSupervisor.allResumedActivitiesComplete()) {\n        // 如果 Activity 已经是恢复状态\n        // 确保已经执行了所有等待的转场\n        executeAppTransition(options);\n    \treturn false;\n    }\n    \n    if (mService.isSleepingOrShuttingDownLocked()\n                && mLastPausedActivity == next\n                && mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果系统处于休眠状态，当前 Activity 处于暂停状态\n        // 确保转场执行\n        executeAppTransition(options);\n        return false;\n    }\n    \n    if (!mService.mUserController.hasStartedUserState(next.userId)) {\n        // 如果拥有该 Activity 的用户没有启动\n    \treturn false;\n    }\n    \n    if (!mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果存在暂停 Activity 的操作未完成\n        return false;\n    }\n    \n    boolean lastResumedCanPip = false;\n    final ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();\n    if (lastFocusedStack != null && lastFocusedStack != this) {\n    \tfinal ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;\n        // 最后一个恢复的 Activity 是否可以 画中画\n        lastResumedCanPip = lastResumed != null && lastResumed.checkEnterPictureInPictureState(\n                    \"resumeTopActivity\", true /* noThrow */, userLeaving /* beforeStopping */);\n    }\n    \n    // 是否需要可以在上一个 Activity 暂停时进行恢复\n    final boolean resumeWhilePausing = (next.info.flags & FLAG_RESUME_WHILE_PAUSING) != 0\n                && !lastResumedCanPip;\n    // 是否暂停了回退的 task\n    boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);\n    \n    if (mResumedActivity != null) {\n        // 暂停上一个恢复状态的 Activity\n    \tpausing |= startPausingLocked(userLeaving, false, next, false);\n    }\n    \n    if (pausing && !resumeWhilePausing) {\n    \t// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity\n        if (next.app != null && next.app.thread != null) {\n            // hosting application，一般不执行\n            // 让当前 Activity 放在 Lru 的顶部，避免早早杀死\n        \tmService.updateLruProcessLocked(next.app, true, null);\n        }\n        return true;\n    } else if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                mStackSupervisor.allResumedActivitiesComplete()) {\n    \t// 当前需要恢复的 Activity 已经是恢复状态\n        // 确保执行转场\n        executeAppTransition(options);\n        return true;\n    }\n    \n    if (mService.isSleepingLocked() && mLastNoHistoryActivity != null &&\n                !mLastNoHistoryActivity.finishing) {\n        // 结束因为系统休眠而还没结束的 Activity\n    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,\n                    null, \"resume-no-history\", false);\n        mLastNoHistoryActivity = null;\n    }\n    \n    if (prev != null && prev != next) {\n    \tif (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)\n                    && next != null && !next.nowVisible) {\n        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);\n        } else {\n            // 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity\n            if (prev.finishing) {\n            \tprev.setVisibility(false);\n            } else {\n                \n            }\n        }\n    }\n    \n    // Activity 转场处理\n    \n    ActivityStack lastStack = mStackSupervisor.getLastStack();\n    if (next.app != null && next.app.thread != null) {\n        // 上一个 Activity 是否为透明\n    \tfinal boolean lastActivityTranslucent = lastStack != null\n                    && (!lastStack.mFullscreen\n                    || (lastStack.mLastPausedActivity != null\n                    && !lastStack.mLastPausedActivity.fullscreen));\n        \n        if (!next.visible || next.stopped || lastActivityTranslucent) {\n            // 前一个 Activity 为透明，并且当前 Activity 还没显示\n            // 设置为显示状态\n            next.setVisibility(true);\n        }\n        \n        // 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向\n    boolean notUpdated = true;\n    if (mStackSupervisor.isFocusedStack(this)) {\n    \tfinal Configuration config = mWindowManager.updateOrientationFromAppTokens(\n                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),\n                        next.mayFreezeScreenLocked(next.app) ? next.appToken : null, mDisplayId);\n        \n        if (config != null) {\n    \tnext.frozenBeforeDestroy = true;\n        }\n        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,\n                        false /* deferResume */, mDisplayId);\n    }\n    \n     if (notUpdated) {\n         // 配置发生更新无法保持已经存在的 Activity 实例\n         // 重新获取需要恢复的 Activity\n         ActivityRecord nextNext = topRunningActivityLocked();\n         // 确保 Activity 仍然保持在栈顶，同时安排另外一次执行\n         if (nextNext != next) {\n         \tmStackSupervisor.scheduleResumeTopActivities();\n         }\n         if (!next.visible || next.stopped) {\n         \tnext.setVisibility(true);\n         }\n         next.completeResumeLocked();\n         return true;\n     }\n    \n    try {\n        // 传递所有等待的结果\n        \n        if (next.newIntents != null){\n            next.app.thread.scheduleNewIntent(\n                            next.newIntents, next.appToken, false /* andPause */);\n        }\n        \n        next.notifyAppResumed(next.stopped);\n        \n        // 准备恢复 Activity\n        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,\n                        mService.isNextTransitionForward(), resumeAnimOptions);\n    } catch (Exception e){\n        // 发生异常，重新启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, false);\n        return true;\n    }\n        \n        try {\n            next.completeResumeLocked();\n        } catch(Exception e){\n            // 发生异常，结束 Activity\n            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null,\n                        \"resume-exception\", true);\n            return true;\n        }\n        \n    } else {\n        // 需要启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\n    }\n    \n    return true;\n\n}\n```\n\n如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：\n\n### ActivityStackSupervisor\n\n``` java\nvoid startSpecificActivityLocked() {\n    // 获取应用进程信息\n    ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n                r.info.applicationInfo.uid, true);\n    \n    if (app != null && app.thread != null) {\n    \t// 如果进程已经启动\n        try {\n            realStartActivityLocked(r, app, andResume, checkConfig);\n            return;\n        }catch (RemoteException e){\n            \n        }\n    }\n    \n    // 启动应用进程\n    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n}\n```\n\n``` java\nfinal boolean realStartActivityLocked() {\n    // 冻结屏幕\n    r.startFreezingScreenLocked(app, 0);\n    if (checkConfig) {\n    \t// 根据新的 Activity 顺序重新评估屏幕的方向\n    }\n    \n    int idx = app.activities.indexOf(r);\n    if (idx < 0) {\n        // 将 Activity 添加到应用进程中\n        app.activities.add(r);\n    }\n    \n    try {\n        app.thread.scheduleLaunchActivity();\n    }catch(RemoteException e){\n        // 发生异常，结束 Activity\n        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,\n                        \"2nd-crash\", false);\n        return false;\n    }\n    \n    return true;\n}\n```\n\n启动流程最后还是回到了 ApplicationThread\n\n### ApplicationThread\n\n``` java\npublic final void scheduleLaunchActivity() {\n    // 通过 Handler 发送 LAUNCH_ACTIVITY\n    sendMessage(H.LAUNCH_ACTIVITY, r);\n}\n```\n\n我们单独把 LAUNCH_ACTIVITY 的处理拿出来：\n\n``` java\nfinal ActivityClientRecord r = (ActivityClientRecord) msg.obj;\nr.packageInfo = getPackageInfoNoCheck(\n                            r.activityInfo.applicationInfo, r.compatInfo);\nhandleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n```\n\n### ActivityThread\n\n``` java\nprivate void handleLaunchActivity() {\n    // 执行启动 Activity\n    Activity a = performLaunchActivity(r, customIntent);\n    if (a != null) {\n        // resume activity\n        handleResumeActivity(r.token, false, r.isForward,\n                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);\n    } else {\n        \n    }\n}\n```\n\n``` java\nprivate performLaunchActivity() {\n    // Activity 信息初始化\n    \n    // 创建 context\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        // 构建 Activity\n        activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n    }catch(Exception e){\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        if(activity != null){\n        \tactivity.attach();\n            \n            // 通过 Instrumentation 执行 Activity onCreate\n            if (r.isPersistable()) {\n                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            }else {\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            \n            if (!r.activity.mFinished) {\n                // Activity onStart\n            \tactivity.performStart();\n            }\n            \n            // 通过 Instrumentation 执行 Activity onRestoreInstanceState\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                \tif (r.state != null || r.persistentState != null) {\n                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,\n                                    r.persistentState);\n                    }\n                } else if (r.state != null) {\n                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);\n                }\n            }\n            \n             // 通过 Instrumentation 执行 Activity onPostCreeate\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state,\n                                r.persistentState);\n                }else {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state);\n                }\n            }       \n    }\n        \n    return activity;\n    \n}\n```\n\n``` java\nfinal void handleResumeActivity() {\n    r = performResumeActivity();\n    if(r != null) {\n        final Activity a = r.activity;\n        if (r.window == null && !a.mFinished && willBeVisible) {\n            r.window = r.activity.getWindow();\n            View decor = r.window.getDecorView();\n            decor.setVisibility(View.INVISIBLE);\n            ViewManager wm = a.getWindowManager();\n            if (a.mVisibleFromClient) {\n            \tif (!a.mWindowAdded) {\n                \ta.mWindowAdded = true;\n                    // window\n                    wm.addView(decor, l);\n                }\n            }\n        }\n    }\n}\n```\n\n``` java\npublic final ActivityClientRecord performResumeActivity() {\n \tif (r != null && !r.activity.mFinished) {\n    \ttry {\n            // 处理等待的 Intent\n            if (r.pendingIntents != null) {\n            \tdeliverNewIntents(r, r.pendingIntents);\n                r.pendingIntents = null;\n            }\n            // 处理等待的 result\n            if (r.pendingResults != null) {\n            \tdeliverResults(r, r.pendingResults);\n                r.pendingResults = null;\n            }\n            // 执行 resume\n            r.activity.performResume();\n        }\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic Activity newActivity(){\n    return (Activity)cl.loadClass(className).newInstance();\n}\n```\n\n``` java\nprivate void callActivityOnCreate(){\n    prePerformCreate(activity);\n    activity.performCreate(icicle);\n    postPerformCreate(activity);\n}\n```\n\n### Activity\n\n``` java\nfinal void performCreate() {\n    restoreHasCurrentPermissionRequest(icicle);\n    // 调用 onCreate\n    onCreate(icicle);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n```\n\n``` java\nfinal void performStart() {\n    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());\n    mInstrumentation.callActivityOnStart(this);\n    mActivityTransitionState.enterReady(this);\n}\n```\n\n``` java\nfinal void performResume() {\n    // 执行 restart\n    performRestart();\n    mInstrumentation.callActivityOnResume(this);\n}\n```\n\n``` java\nfinal void performRestart() {\n    if (mStopped) {\n        mStopped = false;\n        mInstrumentation.callActivityOnRestart(this);\n        // 执行 start\n        performStart();\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic void callActivityOnStart() {\n    activity.onStart();\n}\n```\n\n``` java\npublic void callActivityOnResume() {\n     activity.mResumed = true;\n    activity.onResume();\n}\n```\n\n``` java\npublic void callActivityOnRestart() {\n    activity.onRestart();\n}\n```\n\n## 总结\n\n简单总结下 Activity 的启动流程：\n\n1. 从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信\n2. ActivityManagerService 用于管理所有的 Activity 活动\n   * 当接受到启动 Activity 的调用时，使用 `resolveActivity` ，查询系统中符合要求的 Activity\n   * 创建使用合适的  ActivityStack 和 launch flags 来启动 Activity\n   * 如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity\n   * 如果不存在应用进程，先创建应用进程\n3. 最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行\n   * 使用 Instrumentation 去通过反射构建 Activity 实例\n   * 使用 Handler 机制调用 Activity 的生命周期\n\n下面的图例来自[博客](http://gityuan.com/2016/03/12/start-activity/)：\n\n![启动流程](http://gityuan.com/images/activity/start_activity_process.jpg)\n\n### 时序图\n\n![Android启动流程](http://oy017242u.bkt.clouddn.com/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png)\n\n","slug":"Activity启动流程-基于Android26","published":1,"updated":"2018-04-11T14:05:30.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg0ku8aa0006hio6nbgjsod4","content":"<blockquote>\n<p>基于 Android 26，分析 Android Activity 启动流程</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">startActivity启动过程分析</a></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><strong>源码篇幅可能过长，所以会省略一下不必要的代码和注释</strong></p>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.startActivity(intent, <span class=\"keyword\">null</span>);        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>, options);                </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                        </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>);                         </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终都会调用到 <code>startActivityForResult</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">()</span> </span>&#123;                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 转场动画的处理</span></span><br><span class=\"line\">        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;                                                                       </span><br><span class=\"line\">            mMainThread.sendActivityResult();                                                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;                                                                                        </span><br><span class=\"line\">            mStartedActivity = <span class=\"keyword\">true</span>;                                                            </span><br><span class=\"line\">        &#125;                                                                                                                                                                             </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                    </span><br><span class=\"line\">        <span class=\"comment\">// 如果存在 Parent Activity 则交由它处理                                                                                    </span></span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道 Activity 启动委托给了 Instrumentation 进行实现</p>\n<h3 id=\"Instrumentation\"><a href=\"#Instrumentation\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由 ActivityThread.getApplicationThread 提供的 ApplicationThread</span></span><br><span class=\"line\">    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActivityMonitors != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mSync) &#123;                                             </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = mActivityMonitors.size();                        </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;                                      </span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityMonitor am = mActivityMonitors.get(i);       </span><br><span class=\"line\">                ActivityResult result = <span class=\"keyword\">null</span>;                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 </span></span><br><span class=\"line\">                    result = am.onStartActivity(intent);                   </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;                                      </span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;                                         </span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (am.match(who, <span class=\"keyword\">null</span>, intent)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// match 使用 IntentFilter 和 类名 进行匹配</span></span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (am.isBlocking()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 当前监视器阻止 Activity 启动</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> requestCode &gt;= <span class=\"number\">0</span> ? am.getResult() : <span class=\"keyword\">null</span>;   </span><br><span class=\"line\">                    &#125;                                                      </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                 </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">            &#125;                                                              </span><br><span class=\"line\">        &#125;                                                                  </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 委托为 ActivityManagerService(AMS) 去处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ActivityManager.getService().startActivity();                          </span><br><span class=\"line\">        <span class=\"comment\">// 检查 AMS 的处理结果</span></span><br><span class=\"line\">        checkStartActivityResult(result, intent);                          </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Failure from system\"</span>, e);              </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以通过最后的调用委托给了<code>ActivityManager.getService</code>，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现</p>\n<blockquote>\n<p>相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IActivityManager <span class=\"title\">getService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> IActivityManagerSingleton.get();  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =          </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Singleton&lt;IActivityManager&gt;() &#123;                                           </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                                                 </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> IActivityManager <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">                <span class=\"keyword\">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);     </span><br><span class=\"line\">                <span class=\"keyword\">return</span> am;                                                            </span><br><span class=\"line\">            &#125;                                                                         </span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityManagerService\"><a href=\"#ActivityManagerService\" class=\"headerlink\" title=\"ActivityManagerService\"></a>ActivityManagerService</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                       </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                           </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivityAsUser();                                                     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">()</span> </span>&#123;                                                                                                                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mActivityStarter.startActivityMayWait();                                                                                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将启动请求又委托给了 ActivityStarter</p>\n<h3 id=\"ActivityStarter\"><a href=\"#ActivityStarter\" class=\"headerlink\" title=\"ActivityStarter\"></a>ActivityStarter</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityMayWait</span><span class=\"params\">()</span> </span>&#123;                                                </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的响应</span></span><br><span class=\"line\">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的 Activity 信息                                                               </span></span><br><span class=\"line\">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord[] outRecord = <span class=\"keyword\">new</span> ActivityRecord[<span class=\"number\">1</span>];</span><br><span class=\"line\">    \t<span class=\"comment\">// 调用 startActivityLocked</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = startActivityLocked(outRecord);                                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;                                                                                                       </span><br><span class=\"line\">    &#125;                                                                                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 源 Activity 记录，即在哪个 Activity 进行 startActivity</span></span><br><span class=\"line\">    ActivityRecord sourceRecord = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity</span></span><br><span class=\"line\">    ActivityRecord resultRecord = <span class=\"keyword\">null</span>;                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultTo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取 Activity Stack 中已经存在的源 Activity 记录</span></span><br><span class=\"line\">        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// requestCode &gt;= 0，源 Activity 同时为 结果 Activity</span></span><br><span class=\"line\">                resultRecord = sourceRecord;                                                                  </span><br><span class=\"line\">            &#125;                                                                                                 </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> launchFlags = intent.getFlags();                                                                </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class=\"number\">0</span> &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>) &#123;                   </span><br><span class=\"line\">        <span class=\"comment\">// 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity</span></span><br><span class=\"line\">        <span class=\"comment\">// 比如：A -&gt; B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不允许有 requestCode</span></span><br><span class=\"line\">            ActivityOptions.abort(options);                                                                   </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity</span></span><br><span class=\"line\">        resultRecord = sourceRecord.resultTo;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span> &amp;&amp; !resultRecord.isInStackLocked()) &#123;                                        </span><br><span class=\"line\">            resultRecord = <span class=\"keyword\">null</span>;                                                                              </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// requestCode 处理</span></span><br><span class=\"line\">        resultWho = sourceRecord.resultWho;                                                                   </span><br><span class=\"line\">        requestCode = sourceRecord.requestCode;                                                               </span><br><span class=\"line\">        sourceRecord.resultTo = <span class=\"keyword\">null</span>;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 删除源 Activity 记录</span></span><br><span class=\"line\">            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           </span><br><span class=\"line\">        &#125;                                                                                                                                                                                         </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class=\"keyword\">null</span>) &#123;                              </span><br><span class=\"line\">        <span class=\"comment\">// component 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class=\"keyword\">null</span>) &#123;                                              </span><br><span class=\"line\">        <span class=\"comment\">// ActivityInfo 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>                                          </span><br><span class=\"line\">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class=\"keyword\">null</span>) &#123;                                                 </span><br><span class=\"line\">        <span class=\"comment\">// 语音启动 Activity，检查是否符合                                                                      </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"comment\">// 启动语音会话                                                       </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack resultStack = resultRecord == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : resultRecord.getStack();                  </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err != START_SUCCESS) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 启动 Activity 失败</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发送取消通知</span></span><br><span class=\"line\">            resultStack.sendActivityResultLocked(                                                             </span><br><span class=\"line\">                    -<span class=\"number\">1</span>, resultRecord, resultWho, requestCode, RESULT_CANCELED, <span class=\"keyword\">null</span>);                         </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 进行一些权限检查，判断是否终止                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (abort) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果需要终止 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            resultStack.sendActivityResultLocked();                                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 返回启动成功，实际终止                                                                </span></span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_SUCCESS;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             </span></span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 处理 ephemeral app                                                                    </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造一个 ActivityRecord</span></span><br><span class=\"line\">    ActivityRecord r = <span class=\"keyword\">new</span> ActivityRecord();                                                   </span><br><span class=\"line\">                                                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack stack = mSupervisor.mFocusedStack;                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (voiceSession == <span class=\"keyword\">null</span> &amp;&amp; (stack.mResumedActivity == <span class=\"keyword\">null</span>                                               </span><br><span class=\"line\">            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mService.checkAppSwitchAllowedLocked() &#123;                                          </span><br><span class=\"line\">            PendingActivityLaunch pal =  <span class=\"keyword\">new</span> PendingActivityLaunch();                                              </span><br><span class=\"line\">            mPendingActivityLaunches.add(pal);                                                                </span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">            <span class=\"comment\">// 切换 app 失败</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_SWITCHES_CANCELED;                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.mDidAppSwitch) &#123;                                                                             </span><br><span class=\"line\">        <span class=\"comment\">// 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            </span></span><br><span class=\"line\">        mService.mAppSwitchesAllowedTime = <span class=\"number\">0</span>;                                                                 </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                                  </span><br><span class=\"line\">        mService.mDidAppSwitch = <span class=\"keyword\">true</span>;                                                                        </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 执行因为不允许 app 切换，而加到等待启动的 Activity</span></span><br><span class=\"line\">    doPendingActivityLaunchesLocked(<span class=\"keyword\">false</span>);                                                                   </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivity();                                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                                                        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = START_CANCELED;                                                               </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class=\"line\">        <span class=\"comment\">// 下一步流程</span></span><br><span class=\"line\">        result = startActivityUnchecked();                           </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ActivityManager.isStartResultSuccessful(result)                                   </span><br><span class=\"line\">                &amp;&amp; mStartActivity.getTask() != <span class=\"keyword\">null</span>) &#123;                                         </span><br><span class=\"line\">            mStartActivity.getTask().removeActivity(mStartActivity);                           </span><br><span class=\"line\">        &#125;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.continueSurfaceLayout();                                       </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    postStartActivityProcessing();                                                                     </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;                                                                             </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityUnchecked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 设置一些初始化状态</span></span><br><span class=\"line\">    setInitialState();</span><br><span class=\"line\">    <span class=\"comment\">// 计算 launch flags</span></span><br><span class=\"line\">    computeLaunchingTaskFlags();</span><br><span class=\"line\">    <span class=\"comment\">// 计算源 Task，源 Task 是否存在等</span></span><br><span class=\"line\">    computeSourceStack();</span><br><span class=\"line\">    <span class=\"comment\">// 获取是否存在可以复用的 Activity，根据 flags 和 launchMode</span></span><br><span class=\"line\">    ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reusedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 存在可复用的 Activity，复用它</span></span><br><span class=\"line\">        <span class=\"comment\">// 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.packageName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> START_CLASS_NOT_FOUND;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> dontStart = top != <span class=\"keyword\">null</span> &amp;&amp; mStartActivity.resultTo == <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class=\"line\">                &amp;&amp; top.userId == mStartActivity.userId</span><br><span class=\"line\">                &amp;&amp; top.app != <span class=\"keyword\">null</span> &amp;&amp; top.app.thread != <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != <span class=\"number\">0</span></span><br><span class=\"line\">                || mLaunchSingleTop || mLaunchSingleTask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dontStart)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递一个新的 Intent 到 onNewIntent </span></span><br><span class=\"line\">        top.deliverNewIntentLocked();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_DELIVERED_TO_TOP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取 mTargetStack</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.resultTo == <span class=\"keyword\">null</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span> &amp;&amp; !mAddingToTask</span><br><span class=\"line\">                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \tnewTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 需要创建新的 Task</span></span><br><span class=\"line\">        result = setTaskFromReuseOrCreateNewTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从源 Activity 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromSourceRecord();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mInTask != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 InTask 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromInTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可能创建新的 Task 或使用当前 Task，一般不会发生</span></span><br><span class=\"line\">    \tsetTaskToCurrentTopOrCreateNewTask();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用 mTargetStack 启动 Activity </span></span><br><span class=\"line\">    mTargetStack.startActivityLocked();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDoResume) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mTargetStack.isFocusable()</span><br><span class=\"line\">                    || (topTaskActivity != <span class=\"keyword\">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class=\"line\">                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity</span></span><br><span class=\"line\">            <span class=\"comment\">// 那么我们不恢复目标 Task，只需要确保它可见即可</span></span><br><span class=\"line\">            mTargetStack.ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台</span></span><br><span class=\"line\">            mTargetStack.moveToFront(<span class=\"string\">\"startActivityUnchecked\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复目标 Task</span></span><br><span class=\"line\">        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class=\"line\">                        mOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不需要恢复，那么加到\"最近活动\"中</span></span><br><span class=\"line\">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> START_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setInitialState</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 DisplayId</span></span><br><span class=\"line\">    mSourceDisplayId = getSourceDisplayId();</span><br><span class=\"line\">    <span class=\"comment\">// 获取用于启动 Activity 的范围，Rect</span></span><br><span class=\"line\">    mLaunchBounds = getOerrideBounds();</span><br><span class=\"line\">    <span class=\"comment\">// launchMode</span></span><br><span class=\"line\">    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;</span><br><span class=\"line\">    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;</span><br><span class=\"line\">    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;</span><br><span class=\"line\">    <span class=\"comment\">// Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 requestCode &gt;= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity</span></span><br><span class=\"line\">    sendNewTaskResultRequestIfNeeded();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">computeLaunchingTaskFlags</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span> &amp;&amp; mInTask != <span class=\"keyword\">null</span> &amp;&amp; mInTask.getStack() != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不存在源 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Intent baseIntent = mInTask.getBaseIntent();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord root = mInTask.getRootActivity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseIntent == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了 SingleInstacne 或 SingleTask</span></span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent()))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// Task 不符合</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 已经存在 Task 根 Activity</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果不存在根 Activity，重新设置 launch flags</span></span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">             mAddingToTask = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">if</span> ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) &amp;&amp; mSourceRecord != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; mSourceRecord.isFreeform())  &#123;</span><br><span class=\"line\">                         <span class=\"comment\">// 如果使用 ResolverActivity 启动或者 noDisplay</span></span><br><span class=\"line\">                mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mInTask == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 不存在 Task，并且不存在源 Activity</span></span><br><span class=\"line\">            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity</p>\n<h3 id=\"ActivityStack\"><a href=\"#ActivityStack\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!newTask) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果从已存在的 Task 中启动 Activity</span></span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> startIt = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> taskNdx = mTaskHistory.size() - <span class=\"number\">1</span>; taskNdx &gt;= <span class=\"number\">0</span>; --taskNdx) &#123;</span><br><span class=\"line\">      \ttask = mTaskHistory.get(taskNdx);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task.getTopActivity() == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果 task 不存在 Activity</span></span><br><span class=\"line\">              <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task == rTask) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// 找到对应的 task</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!startIt) &#123;</span><br><span class=\"line\">            \t<span class=\"comment\">// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动</span></span><br><span class=\"line\">                r.createWindowContainer();</span><br><span class=\"line\">                ActivityOptions.abort(options);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (task.numFullscreen &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              startIt = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == activityTask &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        mStackSupervisor.mUserLeaving = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHomeOrRecentsStack() || numActivities() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 处理 动画</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTask) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了重置的标记</span></span><br><span class=\"line\">            resetTaskIfNeededLocked(r, r);</span><br><span class=\"line\">            doShow = topRunningNonDelayedActivityLocked(<span class=\"keyword\">null</span>) == r;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span> &amp;&amp; options.getAnimationType()</span><br><span class=\"line\">                    == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 需要进行转场动画</span></span><br><span class=\"line\">                doShow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果为 true，那么不开启 window，但要确保 Activity 是可见的</span></span><br><span class=\"line\">            r.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class=\"line\">            TaskRecord prevTask = r.getTask();</span><br><span class=\"line\">            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 以下两种情况不展示之前的 Activity 预览</span></span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (prev.getTask() != prevTask) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 之前的 Activity 在不同的 Task</span></span><br><span class=\"line\">                \tprev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prev.nowVisible) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 现在可见</span></span><br><span class=\"line\">                \t prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 显示启动 Activity 的 Window</span></span><br><span class=\"line\">        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前为栈顶 Activity</span></span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ActivityStack.startActivityLocked</code> 主要是创建 WindowContainer，同时显示 Window</p>\n<h3 id=\"ActivityStackSupervisor\"><a href=\"#ActivityStackSupervisor\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeFocusedStackTopActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetStack != <span class=\"keyword\">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存在 targetStack</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"keyword\">null</span> || r.state != RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复聚焦 task</span></span><br><span class=\"line\">    \tmFocusedStack.resumeTopActivityUncheckedLocked(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state == RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行应用转场动画</span></span><br><span class=\"line\">    \tmFocusedStack.executeAppTransition(targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityStack-1\"><a href=\"#ActivityStack-1\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityUncheckedLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 防止递归</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置恢复标记</span></span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在恢复过程中，确保必要的暂停逻辑</span></span><br><span class=\"line\">    mStackSupervisor.checkReadyForSleepLocked();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityInnerLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord next = topRunningActivityLocked(<span class=\"keyword\">true</span> <span class=\"comment\">/* focusableOnly */</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasRunningActivity = next != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord parent = mActivityContainer.mParentActivity;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isParentNotResumed = parent != <span class=\"keyword\">null</span> &amp;&amp; parent.state != ActivityState.RESUMED;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasRunningActivity</span><br><span class=\"line\">                &amp;&amp; (isParentNotResumed || !mActivityContainer.isAttachedLocked())) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 如果父 Activity 不是恢复状态，则不恢复当前 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasRunningActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 Task 没有需要恢复的 Activity</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> resumeTopActivityInNextFocusableStack(prev, options, <span class=\"string\">\"noMoreActivities\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                    mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保已经执行了所有等待的转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingOrShuttingDownLocked()</span><br><span class=\"line\">                &amp;&amp; mLastPausedActivity == next</span><br><span class=\"line\">                &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果系统处于休眠状态，当前 Activity 处于暂停状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保转场执行</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mService.mUserController.hasStartedUserState(next.userId)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果拥有该 Activity 的用户没有启动</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果存在暂停 Activity 的操作未完成</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> lastResumedCanPip = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastFocusedStack != <span class=\"keyword\">null</span> &amp;&amp; lastFocusedStack != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class=\"line\">        <span class=\"comment\">// 最后一个恢复的 Activity 是否可以 画中画</span></span><br><span class=\"line\">        lastResumedCanPip = lastResumed != <span class=\"keyword\">null</span> &amp;&amp; lastResumed.checkEnterPictureInPictureState(</span><br><span class=\"line\">                    <span class=\"string\">\"resumeTopActivity\"</span>, <span class=\"keyword\">true</span> <span class=\"comment\">/* noThrow */</span>, userLeaving <span class=\"comment\">/* beforeStopping */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 是否需要可以在上一个 Activity 暂停时进行恢复</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; !lastResumedCanPip;</span><br><span class=\"line\">    <span class=\"comment\">// 是否暂停了回退的 task</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 暂停上一个恢复状态的 Activity</span></span><br><span class=\"line\">    \tpausing |= startPausingLocked(userLeaving, <span class=\"keyword\">false</span>, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hosting application，一般不执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 让当前 Activity 放在 Lru 的顶部，避免早早杀死</span></span><br><span class=\"line\">        \tmService.updateLruProcessLocked(next.app, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 当前需要恢复的 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保执行转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingLocked() &amp;&amp; mLastNoHistoryActivity != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                !mLastNoHistoryActivity.finishing) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 结束因为系统休眠而还没结束的 Activity</span></span><br><span class=\"line\">    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,</span><br><span class=\"line\">                    <span class=\"keyword\">null</span>, <span class=\"string\">\"resume-no-history\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        mLastNoHistoryActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span> &amp;&amp; prev != next) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class=\"line\">                    &amp;&amp; next != <span class=\"keyword\">null</span> &amp;&amp; !next.nowVisible) &#123;</span><br><span class=\"line\">        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev.finishing) &#123;</span><br><span class=\"line\">            \tprev.setVisibility(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity 转场处理</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 上一个 Activity 是否为透明</span></span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> lastActivityTranslucent = lastStack != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; (!lastStack.mFullscreen</span><br><span class=\"line\">                    || (lastStack.mLastPausedActivity != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; !lastStack.mLastPausedActivity.fullscreen));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!next.visible || next.stopped || lastActivityTranslucent) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 前一个 Activity 为透明，并且当前 Activity 还没显示</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置为显示状态</span></span><br><span class=\"line\">            next.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> notUpdated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.isFocusedStack(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> Configuration config = mWindowManager.updateOrientationFromAppTokens(</span><br><span class=\"line\">                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),</span><br><span class=\"line\">                        next.mayFreezeScreenLocked(next.app) ? next.appToken : <span class=\"keyword\">null</span>, mDisplayId);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tnext.frozenBeforeDestroy = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,</span><br><span class=\"line\">                        <span class=\"keyword\">false</span> <span class=\"comment\">/* deferResume */</span>, mDisplayId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (notUpdated) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 配置发生更新无法保持已经存在的 Activity 实例</span></span><br><span class=\"line\">         <span class=\"comment\">// 重新获取需要恢复的 Activity</span></span><br><span class=\"line\">         ActivityRecord nextNext = topRunningActivityLocked();</span><br><span class=\"line\">         <span class=\"comment\">// 确保 Activity 仍然保持在栈顶，同时安排另外一次执行</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (nextNext != next) &#123;</span><br><span class=\"line\">         \tmStackSupervisor.scheduleResumeTopActivities();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!next.visible || next.stopped) &#123;</span><br><span class=\"line\">         \tnext.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         next.completeResumeLocked();</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递所有等待的结果</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.newIntents != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            next.app.thread.scheduleNewIntent(</span><br><span class=\"line\">                            next.newIntents, next.appToken, <span class=\"keyword\">false</span> <span class=\"comment\">/* andPause */</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        next.notifyAppResumed(next.stopped);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 准备恢复 Activity</span></span><br><span class=\"line\">        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,</span><br><span class=\"line\">                        mService.isNextTransitionForward(), resumeAnimOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，重新启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            next.completeResumeLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"resume-exception\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 需要启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：</p>\n<h3 id=\"ActivityStackSupervisor-1\"><a href=\"#ActivityStackSupervisor-1\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取应用进程信息</span></span><br><span class=\"line\">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">                r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果进程已经启动</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (RemoteException e)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 启动应用进程</span></span><br><span class=\"line\">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 冻结屏幕</span></span><br><span class=\"line\">    r.startFreezingScreenLocked(app, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkConfig) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 根据新的 Activity 顺序重新评估屏幕的方向</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = app.activities.indexOf(r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将 Activity 添加到应用进程中</span></span><br><span class=\"line\">        app.activities.add(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        app.thread.scheduleLaunchActivity();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(RemoteException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"2nd-crash\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动流程最后还是回到了 ApplicationThread</p>\n<h3 id=\"ApplicationThread\"><a href=\"#ApplicationThread\" class=\"headerlink\" title=\"ApplicationThread\"></a>ApplicationThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 Handler 发送 LAUNCH_ACTIVITY</span></span><br><span class=\"line\">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们单独把 LAUNCH_ACTIVITY 的处理拿出来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\">r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">\"LAUNCH_ACTIVITY\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityThread\"><a href=\"#ActivityThread\" class=\"headerlink\" title=\"ActivityThread\"></a>ActivityThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行启动 Activity</span></span><br><span class=\"line\">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// resume activity</span></span><br><span class=\"line\">        handleResumeActivity(r.token, <span class=\"keyword\">false</span>, r.isForward,</span><br><span class=\"line\">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Activity 信息初始化</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 context</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        <span class=\"comment\">// 构建 Activity</span></span><br><span class=\"line\">        activity = mInstrumentation.newActivity(</span><br><span class=\"line\">                    cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(activity != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        \tactivity.attach();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onCreate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Activity onStart</span></span><br><span class=\"line\">            \tactivity.performStart();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onRestoreInstanceState</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                \t<span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span> || r.persistentState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class=\"line\">                                    r.persistentState);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">             <span class=\"comment\">// 通过 Instrumentation 执行 Activity onPostCreeate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class=\"line\">                                r.persistentState);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> activity;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    r = performResumeActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            r.window = r.activity.getWindow();</span><br><span class=\"line\">            View decor = r.window.getDecorView();</span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                \ta.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// window</span></span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span> &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 Intent</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingIntents != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverNewIntents(r, r.pendingIntents);</span><br><span class=\"line\">                r.pendingIntents = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 result</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingResults != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverResults(r, r.pendingResults);</span><br><span class=\"line\">                r.pendingResults = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 执行 resume</span></span><br><span class=\"line\">            r.activity.performResume();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-1\"><a href=\"#Instrumentation-1\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">newActivity</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    prePerformCreate(activity);</span><br><span class=\"line\">    activity.performCreate(icicle);</span><br><span class=\"line\">    postPerformCreate(activity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Activity-1\"><a href=\"#Activity-1\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class=\"line\">    <span class=\"comment\">// 调用 onCreate</span></span><br><span class=\"line\">    onCreate(icicle);</span><br><span class=\"line\">    mActivityTransitionState.readState(icicle);</span><br><span class=\"line\">    performCreateCommon();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mActivityTransitionState.setEnterActivityOptions(<span class=\"keyword\">this</span>, getActivityOptions());</span><br><span class=\"line\">    mInstrumentation.callActivityOnStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    mActivityTransitionState.enterReady(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行 restart</span></span><br><span class=\"line\">    performRestart();</span><br><span class=\"line\">    mInstrumentation.callActivityOnResume(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStopped) &#123;</span><br><span class=\"line\">        mStopped = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mInstrumentation.callActivityOnRestart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 执行 start</span></span><br><span class=\"line\">        performStart();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-2\"><a href=\"#Instrumentation-2\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onStart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     activity.mResumed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    activity.onResume();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onRestart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>简单总结下 Activity 的启动流程：</p>\n<ol>\n<li>从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信</li>\n<li>ActivityManagerService 用于管理所有的 Activity 活动<ul>\n<li>当接受到启动 Activity 的调用时，使用 <code>resolveActivity</code> ，查询系统中符合要求的 Activity</li>\n<li>创建使用合适的  ActivityStack 和 launch flags 来启动 Activity</li>\n<li>如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity</li>\n<li>如果不存在应用进程，先创建应用进程</li>\n</ul>\n</li>\n<li>最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行<ul>\n<li>使用 Instrumentation 去通过反射构建 Activity 实例</li>\n<li>使用 Handler 机制调用 Activity 的生命周期</li>\n</ul>\n</li>\n</ol>\n<p>下面的图例来自<a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">博客</a>：</p>\n<p><img src=\"http://gityuan.com/images/activity/start_activity_process.jpg\" alt=\"启动流程\"></p>\n<h3 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h3><p><img src=\"http://oy017242u.bkt.clouddn.com/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png\" alt=\"Android启动流程\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>基于 Android 26，分析 Android Activity 启动流程</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">startActivity启动过程分析</a></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><strong>源码篇幅可能过长，所以会省略一下不必要的代码和注释</strong></p>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.startActivity(intent, <span class=\"keyword\">null</span>);        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>, options);                </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                        </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>);                         </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终都会调用到 <code>startActivityForResult</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">()</span> </span>&#123;                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 转场动画的处理</span></span><br><span class=\"line\">        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;                                                                       </span><br><span class=\"line\">            mMainThread.sendActivityResult();                                                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;                                                                                        </span><br><span class=\"line\">            mStartedActivity = <span class=\"keyword\">true</span>;                                                            </span><br><span class=\"line\">        &#125;                                                                                                                                                                             </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                    </span><br><span class=\"line\">        <span class=\"comment\">// 如果存在 Parent Activity 则交由它处理                                                                                    </span></span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道 Activity 启动委托给了 Instrumentation 进行实现</p>\n<h3 id=\"Instrumentation\"><a href=\"#Instrumentation\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由 ActivityThread.getApplicationThread 提供的 ApplicationThread</span></span><br><span class=\"line\">    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActivityMonitors != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mSync) &#123;                                             </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = mActivityMonitors.size();                        </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;                                      </span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityMonitor am = mActivityMonitors.get(i);       </span><br><span class=\"line\">                ActivityResult result = <span class=\"keyword\">null</span>;                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 </span></span><br><span class=\"line\">                    result = am.onStartActivity(intent);                   </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;                                      </span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;                                         </span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (am.match(who, <span class=\"keyword\">null</span>, intent)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// match 使用 IntentFilter 和 类名 进行匹配</span></span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (am.isBlocking()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 当前监视器阻止 Activity 启动</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> requestCode &gt;= <span class=\"number\">0</span> ? am.getResult() : <span class=\"keyword\">null</span>;   </span><br><span class=\"line\">                    &#125;                                                      </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                 </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">            &#125;                                                              </span><br><span class=\"line\">        &#125;                                                                  </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 委托为 ActivityManagerService(AMS) 去处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ActivityManager.getService().startActivity();                          </span><br><span class=\"line\">        <span class=\"comment\">// 检查 AMS 的处理结果</span></span><br><span class=\"line\">        checkStartActivityResult(result, intent);                          </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Failure from system\"</span>, e);              </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以通过最后的调用委托给了<code>ActivityManager.getService</code>，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现</p>\n<blockquote>\n<p>相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IActivityManager <span class=\"title\">getService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> IActivityManagerSingleton.get();  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =          </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Singleton&lt;IActivityManager&gt;() &#123;                                           </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                                                 </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> IActivityManager <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">                <span class=\"keyword\">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);     </span><br><span class=\"line\">                <span class=\"keyword\">return</span> am;                                                            </span><br><span class=\"line\">            &#125;                                                                         </span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityManagerService\"><a href=\"#ActivityManagerService\" class=\"headerlink\" title=\"ActivityManagerService\"></a>ActivityManagerService</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                       </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                           </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivityAsUser();                                                     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">()</span> </span>&#123;                                                                                                                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mActivityStarter.startActivityMayWait();                                                                                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将启动请求又委托给了 ActivityStarter</p>\n<h3 id=\"ActivityStarter\"><a href=\"#ActivityStarter\" class=\"headerlink\" title=\"ActivityStarter\"></a>ActivityStarter</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityMayWait</span><span class=\"params\">()</span> </span>&#123;                                                </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的响应</span></span><br><span class=\"line\">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的 Activity 信息                                                               </span></span><br><span class=\"line\">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord[] outRecord = <span class=\"keyword\">new</span> ActivityRecord[<span class=\"number\">1</span>];</span><br><span class=\"line\">    \t<span class=\"comment\">// 调用 startActivityLocked</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = startActivityLocked(outRecord);                                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;                                                                                                       </span><br><span class=\"line\">    &#125;                                                                                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 源 Activity 记录，即在哪个 Activity 进行 startActivity</span></span><br><span class=\"line\">    ActivityRecord sourceRecord = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity</span></span><br><span class=\"line\">    ActivityRecord resultRecord = <span class=\"keyword\">null</span>;                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultTo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取 Activity Stack 中已经存在的源 Activity 记录</span></span><br><span class=\"line\">        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// requestCode &gt;= 0，源 Activity 同时为 结果 Activity</span></span><br><span class=\"line\">                resultRecord = sourceRecord;                                                                  </span><br><span class=\"line\">            &#125;                                                                                                 </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> launchFlags = intent.getFlags();                                                                </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class=\"number\">0</span> &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>) &#123;                   </span><br><span class=\"line\">        <span class=\"comment\">// 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity</span></span><br><span class=\"line\">        <span class=\"comment\">// 比如：A -&gt; B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不允许有 requestCode</span></span><br><span class=\"line\">            ActivityOptions.abort(options);                                                                   </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity</span></span><br><span class=\"line\">        resultRecord = sourceRecord.resultTo;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span> &amp;&amp; !resultRecord.isInStackLocked()) &#123;                                        </span><br><span class=\"line\">            resultRecord = <span class=\"keyword\">null</span>;                                                                              </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// requestCode 处理</span></span><br><span class=\"line\">        resultWho = sourceRecord.resultWho;                                                                   </span><br><span class=\"line\">        requestCode = sourceRecord.requestCode;                                                               </span><br><span class=\"line\">        sourceRecord.resultTo = <span class=\"keyword\">null</span>;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 删除源 Activity 记录</span></span><br><span class=\"line\">            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           </span><br><span class=\"line\">        &#125;                                                                                                                                                                                         </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class=\"keyword\">null</span>) &#123;                              </span><br><span class=\"line\">        <span class=\"comment\">// component 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class=\"keyword\">null</span>) &#123;                                              </span><br><span class=\"line\">        <span class=\"comment\">// ActivityInfo 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>                                          </span><br><span class=\"line\">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class=\"keyword\">null</span>) &#123;                                                 </span><br><span class=\"line\">        <span class=\"comment\">// 语音启动 Activity，检查是否符合                                                                      </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"comment\">// 启动语音会话                                                       </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack resultStack = resultRecord == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : resultRecord.getStack();                  </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err != START_SUCCESS) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 启动 Activity 失败</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发送取消通知</span></span><br><span class=\"line\">            resultStack.sendActivityResultLocked(                                                             </span><br><span class=\"line\">                    -<span class=\"number\">1</span>, resultRecord, resultWho, requestCode, RESULT_CANCELED, <span class=\"keyword\">null</span>);                         </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 进行一些权限检查，判断是否终止                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (abort) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果需要终止 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            resultStack.sendActivityResultLocked();                                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 返回启动成功，实际终止                                                                </span></span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_SUCCESS;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             </span></span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 处理 ephemeral app                                                                    </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造一个 ActivityRecord</span></span><br><span class=\"line\">    ActivityRecord r = <span class=\"keyword\">new</span> ActivityRecord();                                                   </span><br><span class=\"line\">                                                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack stack = mSupervisor.mFocusedStack;                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (voiceSession == <span class=\"keyword\">null</span> &amp;&amp; (stack.mResumedActivity == <span class=\"keyword\">null</span>                                               </span><br><span class=\"line\">            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mService.checkAppSwitchAllowedLocked() &#123;                                          </span><br><span class=\"line\">            PendingActivityLaunch pal =  <span class=\"keyword\">new</span> PendingActivityLaunch();                                              </span><br><span class=\"line\">            mPendingActivityLaunches.add(pal);                                                                </span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">            <span class=\"comment\">// 切换 app 失败</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_SWITCHES_CANCELED;                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.mDidAppSwitch) &#123;                                                                             </span><br><span class=\"line\">        <span class=\"comment\">// 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            </span></span><br><span class=\"line\">        mService.mAppSwitchesAllowedTime = <span class=\"number\">0</span>;                                                                 </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                                  </span><br><span class=\"line\">        mService.mDidAppSwitch = <span class=\"keyword\">true</span>;                                                                        </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 执行因为不允许 app 切换，而加到等待启动的 Activity</span></span><br><span class=\"line\">    doPendingActivityLaunchesLocked(<span class=\"keyword\">false</span>);                                                                   </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivity();                                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                                                        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = START_CANCELED;                                                               </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class=\"line\">        <span class=\"comment\">// 下一步流程</span></span><br><span class=\"line\">        result = startActivityUnchecked();                           </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ActivityManager.isStartResultSuccessful(result)                                   </span><br><span class=\"line\">                &amp;&amp; mStartActivity.getTask() != <span class=\"keyword\">null</span>) &#123;                                         </span><br><span class=\"line\">            mStartActivity.getTask().removeActivity(mStartActivity);                           </span><br><span class=\"line\">        &#125;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.continueSurfaceLayout();                                       </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    postStartActivityProcessing();                                                                     </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;                                                                             </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityUnchecked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 设置一些初始化状态</span></span><br><span class=\"line\">    setInitialState();</span><br><span class=\"line\">    <span class=\"comment\">// 计算 launch flags</span></span><br><span class=\"line\">    computeLaunchingTaskFlags();</span><br><span class=\"line\">    <span class=\"comment\">// 计算源 Task，源 Task 是否存在等</span></span><br><span class=\"line\">    computeSourceStack();</span><br><span class=\"line\">    <span class=\"comment\">// 获取是否存在可以复用的 Activity，根据 flags 和 launchMode</span></span><br><span class=\"line\">    ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reusedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 存在可复用的 Activity，复用它</span></span><br><span class=\"line\">        <span class=\"comment\">// 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.packageName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> START_CLASS_NOT_FOUND;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> dontStart = top != <span class=\"keyword\">null</span> &amp;&amp; mStartActivity.resultTo == <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class=\"line\">                &amp;&amp; top.userId == mStartActivity.userId</span><br><span class=\"line\">                &amp;&amp; top.app != <span class=\"keyword\">null</span> &amp;&amp; top.app.thread != <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != <span class=\"number\">0</span></span><br><span class=\"line\">                || mLaunchSingleTop || mLaunchSingleTask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dontStart)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递一个新的 Intent 到 onNewIntent </span></span><br><span class=\"line\">        top.deliverNewIntentLocked();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_DELIVERED_TO_TOP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取 mTargetStack</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.resultTo == <span class=\"keyword\">null</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span> &amp;&amp; !mAddingToTask</span><br><span class=\"line\">                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \tnewTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 需要创建新的 Task</span></span><br><span class=\"line\">        result = setTaskFromReuseOrCreateNewTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从源 Activity 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromSourceRecord();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mInTask != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 InTask 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromInTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可能创建新的 Task 或使用当前 Task，一般不会发生</span></span><br><span class=\"line\">    \tsetTaskToCurrentTopOrCreateNewTask();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用 mTargetStack 启动 Activity </span></span><br><span class=\"line\">    mTargetStack.startActivityLocked();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDoResume) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mTargetStack.isFocusable()</span><br><span class=\"line\">                    || (topTaskActivity != <span class=\"keyword\">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class=\"line\">                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity</span></span><br><span class=\"line\">            <span class=\"comment\">// 那么我们不恢复目标 Task，只需要确保它可见即可</span></span><br><span class=\"line\">            mTargetStack.ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台</span></span><br><span class=\"line\">            mTargetStack.moveToFront(<span class=\"string\">\"startActivityUnchecked\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复目标 Task</span></span><br><span class=\"line\">        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class=\"line\">                        mOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不需要恢复，那么加到\"最近活动\"中</span></span><br><span class=\"line\">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> START_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setInitialState</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 DisplayId</span></span><br><span class=\"line\">    mSourceDisplayId = getSourceDisplayId();</span><br><span class=\"line\">    <span class=\"comment\">// 获取用于启动 Activity 的范围，Rect</span></span><br><span class=\"line\">    mLaunchBounds = getOerrideBounds();</span><br><span class=\"line\">    <span class=\"comment\">// launchMode</span></span><br><span class=\"line\">    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;</span><br><span class=\"line\">    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;</span><br><span class=\"line\">    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;</span><br><span class=\"line\">    <span class=\"comment\">// Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 requestCode &gt;= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity</span></span><br><span class=\"line\">    sendNewTaskResultRequestIfNeeded();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">computeLaunchingTaskFlags</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span> &amp;&amp; mInTask != <span class=\"keyword\">null</span> &amp;&amp; mInTask.getStack() != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不存在源 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Intent baseIntent = mInTask.getBaseIntent();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord root = mInTask.getRootActivity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseIntent == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了 SingleInstacne 或 SingleTask</span></span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent()))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// Task 不符合</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 已经存在 Task 根 Activity</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果不存在根 Activity，重新设置 launch flags</span></span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">             mAddingToTask = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">if</span> ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) &amp;&amp; mSourceRecord != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; mSourceRecord.isFreeform())  &#123;</span><br><span class=\"line\">                         <span class=\"comment\">// 如果使用 ResolverActivity 启动或者 noDisplay</span></span><br><span class=\"line\">                mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mInTask == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 不存在 Task，并且不存在源 Activity</span></span><br><span class=\"line\">            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity</p>\n<h3 id=\"ActivityStack\"><a href=\"#ActivityStack\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!newTask) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果从已存在的 Task 中启动 Activity</span></span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> startIt = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> taskNdx = mTaskHistory.size() - <span class=\"number\">1</span>; taskNdx &gt;= <span class=\"number\">0</span>; --taskNdx) &#123;</span><br><span class=\"line\">      \ttask = mTaskHistory.get(taskNdx);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task.getTopActivity() == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果 task 不存在 Activity</span></span><br><span class=\"line\">              <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task == rTask) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// 找到对应的 task</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!startIt) &#123;</span><br><span class=\"line\">            \t<span class=\"comment\">// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动</span></span><br><span class=\"line\">                r.createWindowContainer();</span><br><span class=\"line\">                ActivityOptions.abort(options);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (task.numFullscreen &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              startIt = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == activityTask &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        mStackSupervisor.mUserLeaving = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHomeOrRecentsStack() || numActivities() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 处理 动画</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTask) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了重置的标记</span></span><br><span class=\"line\">            resetTaskIfNeededLocked(r, r);</span><br><span class=\"line\">            doShow = topRunningNonDelayedActivityLocked(<span class=\"keyword\">null</span>) == r;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span> &amp;&amp; options.getAnimationType()</span><br><span class=\"line\">                    == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 需要进行转场动画</span></span><br><span class=\"line\">                doShow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果为 true，那么不开启 window，但要确保 Activity 是可见的</span></span><br><span class=\"line\">            r.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class=\"line\">            TaskRecord prevTask = r.getTask();</span><br><span class=\"line\">            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 以下两种情况不展示之前的 Activity 预览</span></span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (prev.getTask() != prevTask) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 之前的 Activity 在不同的 Task</span></span><br><span class=\"line\">                \tprev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prev.nowVisible) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 现在可见</span></span><br><span class=\"line\">                \t prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 显示启动 Activity 的 Window</span></span><br><span class=\"line\">        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前为栈顶 Activity</span></span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ActivityStack.startActivityLocked</code> 主要是创建 WindowContainer，同时显示 Window</p>\n<h3 id=\"ActivityStackSupervisor\"><a href=\"#ActivityStackSupervisor\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeFocusedStackTopActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetStack != <span class=\"keyword\">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存在 targetStack</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"keyword\">null</span> || r.state != RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复聚焦 task</span></span><br><span class=\"line\">    \tmFocusedStack.resumeTopActivityUncheckedLocked(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state == RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行应用转场动画</span></span><br><span class=\"line\">    \tmFocusedStack.executeAppTransition(targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityStack-1\"><a href=\"#ActivityStack-1\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityUncheckedLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 防止递归</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置恢复标记</span></span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在恢复过程中，确保必要的暂停逻辑</span></span><br><span class=\"line\">    mStackSupervisor.checkReadyForSleepLocked();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityInnerLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord next = topRunningActivityLocked(<span class=\"keyword\">true</span> <span class=\"comment\">/* focusableOnly */</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasRunningActivity = next != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord parent = mActivityContainer.mParentActivity;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isParentNotResumed = parent != <span class=\"keyword\">null</span> &amp;&amp; parent.state != ActivityState.RESUMED;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasRunningActivity</span><br><span class=\"line\">                &amp;&amp; (isParentNotResumed || !mActivityContainer.isAttachedLocked())) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 如果父 Activity 不是恢复状态，则不恢复当前 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasRunningActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 Task 没有需要恢复的 Activity</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> resumeTopActivityInNextFocusableStack(prev, options, <span class=\"string\">\"noMoreActivities\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                    mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保已经执行了所有等待的转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingOrShuttingDownLocked()</span><br><span class=\"line\">                &amp;&amp; mLastPausedActivity == next</span><br><span class=\"line\">                &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果系统处于休眠状态，当前 Activity 处于暂停状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保转场执行</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mService.mUserController.hasStartedUserState(next.userId)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果拥有该 Activity 的用户没有启动</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果存在暂停 Activity 的操作未完成</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> lastResumedCanPip = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastFocusedStack != <span class=\"keyword\">null</span> &amp;&amp; lastFocusedStack != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class=\"line\">        <span class=\"comment\">// 最后一个恢复的 Activity 是否可以 画中画</span></span><br><span class=\"line\">        lastResumedCanPip = lastResumed != <span class=\"keyword\">null</span> &amp;&amp; lastResumed.checkEnterPictureInPictureState(</span><br><span class=\"line\">                    <span class=\"string\">\"resumeTopActivity\"</span>, <span class=\"keyword\">true</span> <span class=\"comment\">/* noThrow */</span>, userLeaving <span class=\"comment\">/* beforeStopping */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 是否需要可以在上一个 Activity 暂停时进行恢复</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; !lastResumedCanPip;</span><br><span class=\"line\">    <span class=\"comment\">// 是否暂停了回退的 task</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 暂停上一个恢复状态的 Activity</span></span><br><span class=\"line\">    \tpausing |= startPausingLocked(userLeaving, <span class=\"keyword\">false</span>, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hosting application，一般不执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 让当前 Activity 放在 Lru 的顶部，避免早早杀死</span></span><br><span class=\"line\">        \tmService.updateLruProcessLocked(next.app, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 当前需要恢复的 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保执行转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingLocked() &amp;&amp; mLastNoHistoryActivity != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                !mLastNoHistoryActivity.finishing) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 结束因为系统休眠而还没结束的 Activity</span></span><br><span class=\"line\">    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,</span><br><span class=\"line\">                    <span class=\"keyword\">null</span>, <span class=\"string\">\"resume-no-history\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        mLastNoHistoryActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span> &amp;&amp; prev != next) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class=\"line\">                    &amp;&amp; next != <span class=\"keyword\">null</span> &amp;&amp; !next.nowVisible) &#123;</span><br><span class=\"line\">        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev.finishing) &#123;</span><br><span class=\"line\">            \tprev.setVisibility(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity 转场处理</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 上一个 Activity 是否为透明</span></span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> lastActivityTranslucent = lastStack != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; (!lastStack.mFullscreen</span><br><span class=\"line\">                    || (lastStack.mLastPausedActivity != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; !lastStack.mLastPausedActivity.fullscreen));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!next.visible || next.stopped || lastActivityTranslucent) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 前一个 Activity 为透明，并且当前 Activity 还没显示</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置为显示状态</span></span><br><span class=\"line\">            next.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> notUpdated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.isFocusedStack(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> Configuration config = mWindowManager.updateOrientationFromAppTokens(</span><br><span class=\"line\">                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),</span><br><span class=\"line\">                        next.mayFreezeScreenLocked(next.app) ? next.appToken : <span class=\"keyword\">null</span>, mDisplayId);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tnext.frozenBeforeDestroy = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,</span><br><span class=\"line\">                        <span class=\"keyword\">false</span> <span class=\"comment\">/* deferResume */</span>, mDisplayId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (notUpdated) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 配置发生更新无法保持已经存在的 Activity 实例</span></span><br><span class=\"line\">         <span class=\"comment\">// 重新获取需要恢复的 Activity</span></span><br><span class=\"line\">         ActivityRecord nextNext = topRunningActivityLocked();</span><br><span class=\"line\">         <span class=\"comment\">// 确保 Activity 仍然保持在栈顶，同时安排另外一次执行</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (nextNext != next) &#123;</span><br><span class=\"line\">         \tmStackSupervisor.scheduleResumeTopActivities();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!next.visible || next.stopped) &#123;</span><br><span class=\"line\">         \tnext.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         next.completeResumeLocked();</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递所有等待的结果</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.newIntents != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            next.app.thread.scheduleNewIntent(</span><br><span class=\"line\">                            next.newIntents, next.appToken, <span class=\"keyword\">false</span> <span class=\"comment\">/* andPause */</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        next.notifyAppResumed(next.stopped);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 准备恢复 Activity</span></span><br><span class=\"line\">        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,</span><br><span class=\"line\">                        mService.isNextTransitionForward(), resumeAnimOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，重新启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            next.completeResumeLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"resume-exception\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 需要启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：</p>\n<h3 id=\"ActivityStackSupervisor-1\"><a href=\"#ActivityStackSupervisor-1\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取应用进程信息</span></span><br><span class=\"line\">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">                r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果进程已经启动</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (RemoteException e)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 启动应用进程</span></span><br><span class=\"line\">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 冻结屏幕</span></span><br><span class=\"line\">    r.startFreezingScreenLocked(app, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkConfig) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 根据新的 Activity 顺序重新评估屏幕的方向</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = app.activities.indexOf(r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将 Activity 添加到应用进程中</span></span><br><span class=\"line\">        app.activities.add(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        app.thread.scheduleLaunchActivity();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(RemoteException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"2nd-crash\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动流程最后还是回到了 ApplicationThread</p>\n<h3 id=\"ApplicationThread\"><a href=\"#ApplicationThread\" class=\"headerlink\" title=\"ApplicationThread\"></a>ApplicationThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 Handler 发送 LAUNCH_ACTIVITY</span></span><br><span class=\"line\">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们单独把 LAUNCH_ACTIVITY 的处理拿出来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\">r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">\"LAUNCH_ACTIVITY\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityThread\"><a href=\"#ActivityThread\" class=\"headerlink\" title=\"ActivityThread\"></a>ActivityThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行启动 Activity</span></span><br><span class=\"line\">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// resume activity</span></span><br><span class=\"line\">        handleResumeActivity(r.token, <span class=\"keyword\">false</span>, r.isForward,</span><br><span class=\"line\">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Activity 信息初始化</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 context</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        <span class=\"comment\">// 构建 Activity</span></span><br><span class=\"line\">        activity = mInstrumentation.newActivity(</span><br><span class=\"line\">                    cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(activity != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        \tactivity.attach();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onCreate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Activity onStart</span></span><br><span class=\"line\">            \tactivity.performStart();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onRestoreInstanceState</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                \t<span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span> || r.persistentState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class=\"line\">                                    r.persistentState);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">             <span class=\"comment\">// 通过 Instrumentation 执行 Activity onPostCreeate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class=\"line\">                                r.persistentState);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> activity;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    r = performResumeActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            r.window = r.activity.getWindow();</span><br><span class=\"line\">            View decor = r.window.getDecorView();</span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                \ta.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// window</span></span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span> &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 Intent</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingIntents != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverNewIntents(r, r.pendingIntents);</span><br><span class=\"line\">                r.pendingIntents = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 result</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingResults != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverResults(r, r.pendingResults);</span><br><span class=\"line\">                r.pendingResults = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 执行 resume</span></span><br><span class=\"line\">            r.activity.performResume();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-1\"><a href=\"#Instrumentation-1\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">newActivity</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    prePerformCreate(activity);</span><br><span class=\"line\">    activity.performCreate(icicle);</span><br><span class=\"line\">    postPerformCreate(activity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Activity-1\"><a href=\"#Activity-1\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class=\"line\">    <span class=\"comment\">// 调用 onCreate</span></span><br><span class=\"line\">    onCreate(icicle);</span><br><span class=\"line\">    mActivityTransitionState.readState(icicle);</span><br><span class=\"line\">    performCreateCommon();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mActivityTransitionState.setEnterActivityOptions(<span class=\"keyword\">this</span>, getActivityOptions());</span><br><span class=\"line\">    mInstrumentation.callActivityOnStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    mActivityTransitionState.enterReady(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行 restart</span></span><br><span class=\"line\">    performRestart();</span><br><span class=\"line\">    mInstrumentation.callActivityOnResume(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStopped) &#123;</span><br><span class=\"line\">        mStopped = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mInstrumentation.callActivityOnRestart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 执行 start</span></span><br><span class=\"line\">        performStart();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-2\"><a href=\"#Instrumentation-2\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onStart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     activity.mResumed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    activity.onResume();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onRestart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>简单总结下 Activity 的启动流程：</p>\n<ol>\n<li>从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信</li>\n<li>ActivityManagerService 用于管理所有的 Activity 活动<ul>\n<li>当接受到启动 Activity 的调用时，使用 <code>resolveActivity</code> ，查询系统中符合要求的 Activity</li>\n<li>创建使用合适的  ActivityStack 和 launch flags 来启动 Activity</li>\n<li>如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity</li>\n<li>如果不存在应用进程，先创建应用进程</li>\n</ul>\n</li>\n<li>最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行<ul>\n<li>使用 Instrumentation 去通过反射构建 Activity 实例</li>\n<li>使用 Handler 机制调用 Activity 的生命周期</li>\n</ul>\n</li>\n</ol>\n<p>下面的图例来自<a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">博客</a>：</p>\n<p><img src=\"http://gityuan.com/images/activity/start_activity_process.jpg\" alt=\"启动流程\"></p>\n<h3 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h3><p><img src=\"http://oy017242u.bkt.clouddn.com/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png\" alt=\"Android启动流程\"></p>\n"},{"title":"熟悉又陌生的Context","date":"2018-04-12T02:45:36.000Z","_content":"\n## 感谢\n\n[android-context](http://gityuan.com/2017/04/09/android_context/)\n\n## 概述\n\n> 本文中涉及的源码分析都是基于 Android 27\n\nContext 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 `getResources()` 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对于 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：\n\n![Context](http://oy017242u.bkt.clouddn.com/Context.png)\n\n其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：\n\n``` java\npublic ContextWrapper(Context base) {\n\tmBase = base;\n}\n\n@Override\npublic void startActivity(Intent intent) {\n    mBase.startActivity(intent);\n}\n```\n\n通过在构造函数中将 ContextImpl 实例赋值给 `mBase`，然后在比如 `startActivity` 等方法实现中，将调用转发给 `mBase`，至于 `mBase` 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。\n\n通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。\n\n## Context初始化\n\n### Activity\n\n在前面的 [Activity 启动分析](https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/)中，我们知道最终 Activity 启动方法是 `ActivityThread.performLaunchActivity()`\n\n``` java\nprivate void performLaunchActivity() {\n    // 初始化 LoadedApk\n    if (r.packageInfo == null) {\n    \tr.packageInfo = getPackageInfo();\n    }\n    \n    // 创建 ContextImpl 实例\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n    } catch (Exception e) {\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        appContext.setOuterContext(activity);\n        activity.attach();\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n首先获取 LoadedApk 实例，接着调用 `createBaseContextForActivity()` 创建 ContextImpl 实例，之前我们提到 ContextWraper 是将 Context 核心功能转发给 ContextImpl 实现的，在 Activity 启动流程中，是通过调用 `Activity.attach()` 实现，这个我们在后面的分析中可以知道。\n\n#### create \n\n``` java\nprivate ComtextImpl createBaseContextForActivity() {\n    final int displayId;\n    try {\n        displayId = ActivityManager.getService().getActivityDisplayId(r.token);\n    } catch (RemoteException e) {\n        \n    }\n    \n    ContextImpl appContext = ContextImpl.createActivityContext();\n}\n```\n\n``` java\nstatic ContextImpl createActivityContext() {\n    ContextImpl context = new ContextImpl();\n    \n    // Activity Resource\n    final ResourcesManager resourcesManager = ResourcesManager.getInstance();\n    context.setResources(resourcesManager.createBaseActivityResources(activityToken,\n                packageInfo.getResDir(),\n                splitDirs,\n                packageInfo.getOverlayDirs(),\n                packageInfo.getApplicationInfo().sharedLibraryFiles,\n                displayId,\n                overrideConfiguration,\n                compatInfo,\n                classLoader));\n    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,\n                context.getResources());\n}\n```\n\n#### attach\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n}\n```\n\n``` java\nprotected void attachBaseContext() {\n    super.attachBaseContext(newBase);\n}\n```\n\n这个步骤比较简单，最终也是调用 `ContextWrapper.attachBaseContext()`\n\n### Service\n\nService 的创建是在 `ActivityThread.handleCreateService()`\n\n``` java\n// 初始化 LoadedApk\nLoadedApk packageInfo = getPackageInfoNoCheck();\n\nService service = null;\ntry {\n    java.lang.ClassLoader cl = packageInfo.getClassLoader();\n    // 通过反射实例化 Service\n    service = (Service) cl.loadClass(data.info.name).newInstance();\n} catch (Exception e) {\n    \n}\n\ntry {\n    ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n    context.setOuterContext(service);\n    \n    Application app = packageInfo.makeApplication(false, mInstrumentation);\n    service.attach();\n} catch (Exception e) {\n    \n}\n```\n\nService 的 Context 初始化流程和 Activity 是差不多，相同的是 LoadedApk -> ContextImpl -> attach\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    // Service 的 Resources 相对于 Activity 是比较简单的\n    context.setResources(packageInfo.getResources());\n    return context;\n}\n```\n\n#### attach\n\n``` java\npublic final void attach() {\n    attachBaseContext(context);\n}\n```\n\nService 的 attach 和 Activity 相同，都是调用 `ContextWrapper.attachBaseContext()`\n\n### Application\n\nApplication 的创建是在 `LoadedApk.makeApplication()` \n\n``` java\npublic Application makeApplication() {\n    // 保持单例\n    if (mApplication != null) {\n    \treturn mApplication;\n    }\n    Application app = null;\n    String appClass = mApplicationInfo.className;\n    if (forceDefaultAppClass || (appClass == null)) {\n        // 如果强制使用默认 Application，或者没有实现自定义 Application\n    \tappClass = \"android.app.Application\";\n    }\n    try {\n        java.lang.ClassLoader cl = getClassLoader();\n        if (!mPackageName.equals(\"android\")) {\n            // 包名不是 \"android\"，即非系统进程\n        \tinitializeJavaContextClassLoader();\n        }\n        // 创建 ContextImpl 实例\n        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n        // 创建 Application 实例\n    \tapp = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n    \tappContext.setOuterContext(app);\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n咋一看好像 Application 的流程和其他两个不太相同，其实不是这样的，Application 的 attach 在 `Instrumentation.newApplication()`\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    context.setResources(packageInfo.getResources());\n}\n```\n\n#### attach\n\n``` java\npublic static Application newApplication() {\n    // 反射获取实例\n    Application app = (Application)clazz.newInstance();\n    app.attach(context);\n    return app;\n}\n```\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;\n}\n```\n\n### 小结\n\n通过我们对 Activity、Service、Application 的 Context 初始化流程的分析，首先创建 ContextImpl 实例，接着调用 `ContextWrapper.attachBaseContext()` 赋值给 `mBase`，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。\n\n## 实践\n\n通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。\n\n### View Context\n\n#### 问题\n\n我们知道可以通过调用 `View.getContext()` 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。\n\n#### 分析\n\n首先我们对 View 的 `mContext` 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。\n\n如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：\n\n``` java\nLayoutInflater mLayoutInflater = LayoutInflater.from(context);\nView view = mLayoutInflater.inflate(R.layout.xxx,null);\n```\n\n首先我们看下 `LayoutInflater.from()`：\n\n``` java\npublic static LayoutInflater from(Context context) {\n\tLayoutInflater LayoutInflater =(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    if (LayoutInflater == null) {\n        throw new AssertionError(\"LayoutInflater not found.\");\n    }\n    return LayoutInflater;\n}\n```\n\n在上文我们提到 Context 的核心方法都转发给 `mBase` 即 ContextImpl 实例\n\n``` java\npublic Object getSystemService(String name) {\n    return SystemServiceRegistry.getSystemService(this, name);\n}\n\npublic static Object getSystemService(ContextImpl ctx, String name) {\n    ServiceFetcher<?> fetcher = SYSTEM_SERVICE_FETCHERS.get(name);\n    return fetcher != null ? fetcher.getService(ctx) : null;\n}\n```\n\n最终的调用都转发给了 ServiceFetcher，而 `SYSTEM_SERVICE_FETCHERS` 存储着各个类型的 Fetcher 的实例\n\n``` java\n// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name->Fetcher\nprivate static final HashMap<String, ServiceFetcher<?>> SYSTEM_SERVICE_FETCHERS =\n            new HashMap<String, ServiceFetcher<?>>();\n// 存储 Class->Name\nprivate static final HashMap<Class<?>, String> SYSTEM_SERVICE_NAMES =\n            new HashMap<Class<?>, String>();\n\nprivate static <T> void registerService(String serviceName, Class<T> serviceClass,\n            ServiceFetcher<T> serviceFetcher) {\n    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);\n    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);\n}\n```\n\n`SYSTEM_SERVICE_FETCHERS` 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 `registerService()`，这里我们只关心 LayoutInflater 的注册：\n\n``` java\nregisterService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,\n        new CachedServiceFetcher<LayoutInflater>() {                  \n    @Override                                                         \n    public LayoutInflater createService(ContextImpl ctx) {            \n        return new PhoneLayoutInflater(ctx.getOuterContext());        \n    }});                                                              \n```\n\nLayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 实际并没有特殊的操作，基本逻辑都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 `CachedServiceFetcher.getService()`\n\n``` java\npublic final T getService(ContextImpl ctx) {\n    final Object[] cache = ctx.mServiceCache;\n    synchronized (cache) {\n        Object service = cache[mCacheIndex];\n        if (service == null) {\n            try {\n                service = createService(ctx);\n                cache[mCacheIndex] = service;\n            } catch (ServiceNotFoundException e) {\n                \n            }\n        }\n        return (T)service;\n    }\n}\n```\n\n注意到，Service 的缓存是存储在 `ContextImpl.mServiceCache` 并且该字段不是静态的，即**Service 的缓存是针对于相同的 Context 实例的**，如果不存在缓存，那么调用 `createService()`，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：\n\n```java\n// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application\nreturn new PhoneLayoutInflater(ctx.getOuterContext()); \n```\n\n而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：\n\n``` java\nprotected LayoutInflater(Context context) {\n    // 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到\n    mContext = context;\n}\n```\n\n接下来我们看下 `inflate()` 源码：\n\n``` java\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n```\n\n``` java\npublic View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n    synchronized (mConstructorArgs) {\n        // mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了\n        final Context inflaterContext = mContext;\n        final AttributeSet attrs = Xml.asAttributeSet(parser);\n    \tContext lastContext = (Context) mConstructorArgs[0];\n        mConstructorArgs[0] = inflaterContext;\n        View result = root;\n        \n        try {\n            // 解析 xml 中的节点\n            \n            final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n        } catch () {\n            \n        } finally {\n            mConstructorArgs[0] = lastContext;\n            mConstructorArgs[1] = null;\n        }\n        \n        return result;\n    }\n}\n    \n```\n\n`inflater()` 就是对 xml 布局进行解析，实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 `createViewFromTag()` 它是根据标签名称是实例化具体的 View 实例\n\n``` java\nView createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n            boolean ignoreThemeAttr) {\n    if (name.equals(\"view\")) {\n        // 如果我们使用 view 标签则从 class 属性中获取具体类名称\n        name = attrs.getAttributeValue(null, \"class\");\n    }\n    \n    if (!ignoreThemeAttr) {\n        // 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性\n        // 获取设置的 theme 属性值\n        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);\n    \tfinal int themeResId = ta.getResourceId(0, 0);\n        if (themeResId != 0) {\n            // 如果设置了，则将 context 包装成 ContextThemeWrapper\n            // 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性\n            context = new ContextThemeWrapper(context, themeResId);\n        }\n        ta.recycle();\n    }\n    \n    try {\n        View view;\n        \n        // Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView\n        if (mFactory2 != null) {\n        \tview = mFactory2.onCreateView(parent, name, context, attrs);\n        } else if (mFactory != null) {\n            view = mFactory.onCreateView(name, context, attrs);\n        } else {\n            view = null;\n        }\n        \n        if (view == null && mPrivateFactory != null) {\n        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);\n        }\n        \n        if (view == null) {\n            final Object lastContext = mConstructorArgs[0];\n            mConstructorArgs[0] = context;\n            try {\n                if (-1 == name.indexOf('.')) {\n                    // 系统控件\n                    view = onCreateView(parent, name, attrs);\n                } else {\n                    // 自定义控件\n                    view = createView(name, null, attrs);\n                }\n            } finally {\n                mConstructorArgs[0] = lastContext;\n            }\n        }\n        \n        return view;\n    } catch () {\n        \n    }\n}\n```\n\n不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 `createView()`\n\n``` java\npublic final View createView(String name, String prefix, AttributeSet attrs){\n\t// 缓存构造函数\n    Constructor<? extends View> constructor = sConstructorMap.get(name);\n    // 检查构造函数类加载器\n    if (constructor != null && !verifyClassLoader(constructor)){\n        constructor = null;\n        sConstructorMap.remove(name);\n    }\n    Class<? extends View> clazz = null;\n    try {\n        \n        // 获取 View 构造函数实例，并处理过滤情况\n        if (constructor == null) {\n        \tclazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n        \n            if (mFilter != null && clazz != null) {\n            // 检查是否过滤\n        \tboolean allowed = mFilter.onLoadClass(clazz);\n            if (!allowed) {\n                failNotAllowed(name, prefix, attrs);\n            }\n            }\n            constructor = clazz.getConstructor(mConstructorSignature);\n            constructor.setAccessible(true);\n            sConstructorMap.put(name, constructor);\n        } else {\n            if (mFilter != null) {\n                // 存在过滤器\n                Boolean allowedState = mFilterMap.get(name);\n                if (allowedState == null) {\n                    // 没有缓存过滤结果，新的类\n                    clazz = mContext.getClassLoader().loadClass(                            \n                    prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \tboolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                \tmFilterMap.put(name, allowed);\n                    if (!allowed) {\n                    \tfailNotAllowed(name, prefix, attrs);\n                    }\n                } else if (allowedState.equals(Boolean.FALSE)) {\n                    failNotAllowed(name, prefix, attrs);\n                } \n            }\n        }\n        \n        Object lastContext = mConstructorArgs[0];\n        if (mConstructorArgs[0] == null) {\n            // 如果还没设置 context 参数\n            mConstructorArgs[0] = mContext;\n        }\n        Object[] args = mConstructorArgs;\n        args[1] = attrs;\n        // 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知\n        final View view = constructor.newInstance(args); \n        if (view instanceof ViewStub) {\n            // 使用相同的 Context 处理 ViewStub\n            final ViewStub viewStub = (ViewStub) view;\n            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n        }\n        mConstructorArgs[0] = lastContext;\n        return view;\n    } catech () {\n        \n    }\n}\n```\n\n最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同地方，我们先通过一个例子来看下效果：\n\n``` java\nprotected void onCreate(Bundle savedInstanceState) {\n    // 使用两种 Context 创建两个 EditText\n    addEditText(this);                   \n\taddEditText(getApplicationContext());\n}\nprivate void addEditText(@Nullable Context context) { \n                                                      \n    if (mRootLayout == null) {                        \n        return;                                       \n    }                                                 \n                                                      \n    if (context == null) {                            \n        return;                                       \n    }                                                 \n                                                                                                       \n    EditText editText = new EditText(context);        \n    mRootLayout.addView(editText);                    \n    editText.setText(context.toString());                                                               \n}                                                     \n```\n\n代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题\n\n``` xml\n<Applicatin \n  android:theme=\"@style/AppTheme\">\n</Applicatin>\n\n<item name=\"colorAccent\">@color/colorAccent</item>\n<color name=\"colorAccent\">#FF4081</color>\n```\n\n![ActivityContextEditText](http://oy017242u.bkt.clouddn.com/ActivityContextEditText.png?time=123)\n\n![ApplicationContextEditText](http://oy017242u.bkt.clouddn.com/ApplicationContextEditText.png)\n\n我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：\n\n``` java\npublic Resources.Theme getTheme() {\n    if (mTheme != null) {\n        return mTheme;\n    }\n    if (mThemeResource == 0) {\n        mThemeResource = R.style.Theme_AppCompat_Light;\n    }\n    initializeTheme();\n    return mTheme;\n}\n\nprivate void initializeTheme() {\n    final boolean first = mTheme == null;\n    if (first) {\n        mTheme = getResources().newTheme();\n        Resources.Theme theme = getBaseContext().getTheme();\n        if (theme != null) {\n            mTheme.setTo(theme);\n        }\n    }\n    onApplyThemeResource(mTheme, mThemeResource, first);\n}\n\nprotected void onApplyThemeResource(Resources.Theme theme, int resid, boolean first) {\n    theme.applyStyle(resid, true);\n}\n```\n\n`mTheme` 和 `mThemeResource` 都可以通过构造方法和 set 方法进行赋值，假设没有给 `mTheme` 赋值，只给 `mThemeResource` 赋值，那么上面的代码将 `mThemeSource` 应用到 `ContextWrapper.getTheme()` 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 `ActivityThread.performLaunchActivity()` 中，其中涉及 Theme 的赋值是：\n\n``` java\nint theme = r.activityInfo.getThemeResource();\nif (theme != 0) {\n    activity.setTheme(theme);\n}\n```\n\n现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。\n\n#### 小结\n\n通过上面的源码分析，我们可以知道：\n\n1. 当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 `View(Context,AttributeSet)` 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。\n2. Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。\n\n### getApplication()和getApplicatinContext()\n\n**接下来的分析参考于 [android-context](http://gityuan.com/2017/04/09/android_context/)**\n\n绝大数情况下，这两个方法的返回值是一样。\n\n`getApplicationContext()` 的存在是 Android 历史原因，`getApplication()` 这两个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 `getApplicationContext()`。\n\n两者对比：\n\n1. 对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过\n2. BroadcastReceiver 只能通过 `getApplicationContext()` 获取 Application 实例\n3. ContentProvider 也只能通过 `getApplicationContext()` 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 `getApplicationContext()` 则会返回空。\n\n#### 小结\n\n绝大数情况下，`getApplication()` 和 `getApplicationContext()` 返回是一样的，但如果不是特别熟悉，最好对 `getApplicationContext()` 进行空值判断。\n\n### Dialog Context\n\n我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：\n\n```\nCaused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?\n```\n\n### start Activity\n\n通过调用 `startActivity()` 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 `startActivity()` 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：\n\n在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记的话，则会抛出以下异常：\n\n```\nCaused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?\n```\n\nAndroid 26 上 ContextImpl 的相关代码如下：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n\n    }\n}\n```\n\n只要没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记就会抛异常。\n\n而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0\n        && options != null && ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n    }\n}\n```\n\n只有在指定了 `options` 同时其中没有指定 LaunchTaskId 才会抛异常。\n\n## 总结\n\n上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。\n\n不管如何谨慎小心，怀着诚惶诚恐的心态，毕竟作者的水平有限，如果有说的不对的地方，敬请指出，先行感谢。","source":"_posts/熟悉又陌生的Context.md","raw":"---\ntitle: 熟悉又陌生的Context\ndate: 2018-04-12 10:45:36\ncategories: Android Framework\n---\n\n## 感谢\n\n[android-context](http://gityuan.com/2017/04/09/android_context/)\n\n## 概述\n\n> 本文中涉及的源码分析都是基于 Android 27\n\nContext 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 `getResources()` 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对于 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：\n\n![Context](http://oy017242u.bkt.clouddn.com/Context.png)\n\n其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：\n\n``` java\npublic ContextWrapper(Context base) {\n\tmBase = base;\n}\n\n@Override\npublic void startActivity(Intent intent) {\n    mBase.startActivity(intent);\n}\n```\n\n通过在构造函数中将 ContextImpl 实例赋值给 `mBase`，然后在比如 `startActivity` 等方法实现中，将调用转发给 `mBase`，至于 `mBase` 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。\n\n通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。\n\n## Context初始化\n\n### Activity\n\n在前面的 [Activity 启动分析](https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/)中，我们知道最终 Activity 启动方法是 `ActivityThread.performLaunchActivity()`\n\n``` java\nprivate void performLaunchActivity() {\n    // 初始化 LoadedApk\n    if (r.packageInfo == null) {\n    \tr.packageInfo = getPackageInfo();\n    }\n    \n    // 创建 ContextImpl 实例\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n    } catch (Exception e) {\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        appContext.setOuterContext(activity);\n        activity.attach();\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n首先获取 LoadedApk 实例，接着调用 `createBaseContextForActivity()` 创建 ContextImpl 实例，之前我们提到 ContextWraper 是将 Context 核心功能转发给 ContextImpl 实现的，在 Activity 启动流程中，是通过调用 `Activity.attach()` 实现，这个我们在后面的分析中可以知道。\n\n#### create \n\n``` java\nprivate ComtextImpl createBaseContextForActivity() {\n    final int displayId;\n    try {\n        displayId = ActivityManager.getService().getActivityDisplayId(r.token);\n    } catch (RemoteException e) {\n        \n    }\n    \n    ContextImpl appContext = ContextImpl.createActivityContext();\n}\n```\n\n``` java\nstatic ContextImpl createActivityContext() {\n    ContextImpl context = new ContextImpl();\n    \n    // Activity Resource\n    final ResourcesManager resourcesManager = ResourcesManager.getInstance();\n    context.setResources(resourcesManager.createBaseActivityResources(activityToken,\n                packageInfo.getResDir(),\n                splitDirs,\n                packageInfo.getOverlayDirs(),\n                packageInfo.getApplicationInfo().sharedLibraryFiles,\n                displayId,\n                overrideConfiguration,\n                compatInfo,\n                classLoader));\n    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,\n                context.getResources());\n}\n```\n\n#### attach\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n}\n```\n\n``` java\nprotected void attachBaseContext() {\n    super.attachBaseContext(newBase);\n}\n```\n\n这个步骤比较简单，最终也是调用 `ContextWrapper.attachBaseContext()`\n\n### Service\n\nService 的创建是在 `ActivityThread.handleCreateService()`\n\n``` java\n// 初始化 LoadedApk\nLoadedApk packageInfo = getPackageInfoNoCheck();\n\nService service = null;\ntry {\n    java.lang.ClassLoader cl = packageInfo.getClassLoader();\n    // 通过反射实例化 Service\n    service = (Service) cl.loadClass(data.info.name).newInstance();\n} catch (Exception e) {\n    \n}\n\ntry {\n    ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n    context.setOuterContext(service);\n    \n    Application app = packageInfo.makeApplication(false, mInstrumentation);\n    service.attach();\n} catch (Exception e) {\n    \n}\n```\n\nService 的 Context 初始化流程和 Activity 是差不多，相同的是 LoadedApk -> ContextImpl -> attach\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    // Service 的 Resources 相对于 Activity 是比较简单的\n    context.setResources(packageInfo.getResources());\n    return context;\n}\n```\n\n#### attach\n\n``` java\npublic final void attach() {\n    attachBaseContext(context);\n}\n```\n\nService 的 attach 和 Activity 相同，都是调用 `ContextWrapper.attachBaseContext()`\n\n### Application\n\nApplication 的创建是在 `LoadedApk.makeApplication()` \n\n``` java\npublic Application makeApplication() {\n    // 保持单例\n    if (mApplication != null) {\n    \treturn mApplication;\n    }\n    Application app = null;\n    String appClass = mApplicationInfo.className;\n    if (forceDefaultAppClass || (appClass == null)) {\n        // 如果强制使用默认 Application，或者没有实现自定义 Application\n    \tappClass = \"android.app.Application\";\n    }\n    try {\n        java.lang.ClassLoader cl = getClassLoader();\n        if (!mPackageName.equals(\"android\")) {\n            // 包名不是 \"android\"，即非系统进程\n        \tinitializeJavaContextClassLoader();\n        }\n        // 创建 ContextImpl 实例\n        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n        // 创建 Application 实例\n    \tapp = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n    \tappContext.setOuterContext(app);\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n咋一看好像 Application 的流程和其他两个不太相同，其实不是这样的，Application 的 attach 在 `Instrumentation.newApplication()`\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    context.setResources(packageInfo.getResources());\n}\n```\n\n#### attach\n\n``` java\npublic static Application newApplication() {\n    // 反射获取实例\n    Application app = (Application)clazz.newInstance();\n    app.attach(context);\n    return app;\n}\n```\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;\n}\n```\n\n### 小结\n\n通过我们对 Activity、Service、Application 的 Context 初始化流程的分析，首先创建 ContextImpl 实例，接着调用 `ContextWrapper.attachBaseContext()` 赋值给 `mBase`，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。\n\n## 实践\n\n通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。\n\n### View Context\n\n#### 问题\n\n我们知道可以通过调用 `View.getContext()` 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。\n\n#### 分析\n\n首先我们对 View 的 `mContext` 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。\n\n如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：\n\n``` java\nLayoutInflater mLayoutInflater = LayoutInflater.from(context);\nView view = mLayoutInflater.inflate(R.layout.xxx,null);\n```\n\n首先我们看下 `LayoutInflater.from()`：\n\n``` java\npublic static LayoutInflater from(Context context) {\n\tLayoutInflater LayoutInflater =(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    if (LayoutInflater == null) {\n        throw new AssertionError(\"LayoutInflater not found.\");\n    }\n    return LayoutInflater;\n}\n```\n\n在上文我们提到 Context 的核心方法都转发给 `mBase` 即 ContextImpl 实例\n\n``` java\npublic Object getSystemService(String name) {\n    return SystemServiceRegistry.getSystemService(this, name);\n}\n\npublic static Object getSystemService(ContextImpl ctx, String name) {\n    ServiceFetcher<?> fetcher = SYSTEM_SERVICE_FETCHERS.get(name);\n    return fetcher != null ? fetcher.getService(ctx) : null;\n}\n```\n\n最终的调用都转发给了 ServiceFetcher，而 `SYSTEM_SERVICE_FETCHERS` 存储着各个类型的 Fetcher 的实例\n\n``` java\n// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name->Fetcher\nprivate static final HashMap<String, ServiceFetcher<?>> SYSTEM_SERVICE_FETCHERS =\n            new HashMap<String, ServiceFetcher<?>>();\n// 存储 Class->Name\nprivate static final HashMap<Class<?>, String> SYSTEM_SERVICE_NAMES =\n            new HashMap<Class<?>, String>();\n\nprivate static <T> void registerService(String serviceName, Class<T> serviceClass,\n            ServiceFetcher<T> serviceFetcher) {\n    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);\n    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);\n}\n```\n\n`SYSTEM_SERVICE_FETCHERS` 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 `registerService()`，这里我们只关心 LayoutInflater 的注册：\n\n``` java\nregisterService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,\n        new CachedServiceFetcher<LayoutInflater>() {                  \n    @Override                                                         \n    public LayoutInflater createService(ContextImpl ctx) {            \n        return new PhoneLayoutInflater(ctx.getOuterContext());        \n    }});                                                              \n```\n\nLayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 实际并没有特殊的操作，基本逻辑都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 `CachedServiceFetcher.getService()`\n\n``` java\npublic final T getService(ContextImpl ctx) {\n    final Object[] cache = ctx.mServiceCache;\n    synchronized (cache) {\n        Object service = cache[mCacheIndex];\n        if (service == null) {\n            try {\n                service = createService(ctx);\n                cache[mCacheIndex] = service;\n            } catch (ServiceNotFoundException e) {\n                \n            }\n        }\n        return (T)service;\n    }\n}\n```\n\n注意到，Service 的缓存是存储在 `ContextImpl.mServiceCache` 并且该字段不是静态的，即**Service 的缓存是针对于相同的 Context 实例的**，如果不存在缓存，那么调用 `createService()`，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：\n\n```java\n// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application\nreturn new PhoneLayoutInflater(ctx.getOuterContext()); \n```\n\n而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：\n\n``` java\nprotected LayoutInflater(Context context) {\n    // 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到\n    mContext = context;\n}\n```\n\n接下来我们看下 `inflate()` 源码：\n\n``` java\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n```\n\n``` java\npublic View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n    synchronized (mConstructorArgs) {\n        // mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了\n        final Context inflaterContext = mContext;\n        final AttributeSet attrs = Xml.asAttributeSet(parser);\n    \tContext lastContext = (Context) mConstructorArgs[0];\n        mConstructorArgs[0] = inflaterContext;\n        View result = root;\n        \n        try {\n            // 解析 xml 中的节点\n            \n            final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n        } catch () {\n            \n        } finally {\n            mConstructorArgs[0] = lastContext;\n            mConstructorArgs[1] = null;\n        }\n        \n        return result;\n    }\n}\n    \n```\n\n`inflater()` 就是对 xml 布局进行解析，实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 `createViewFromTag()` 它是根据标签名称是实例化具体的 View 实例\n\n``` java\nView createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n            boolean ignoreThemeAttr) {\n    if (name.equals(\"view\")) {\n        // 如果我们使用 view 标签则从 class 属性中获取具体类名称\n        name = attrs.getAttributeValue(null, \"class\");\n    }\n    \n    if (!ignoreThemeAttr) {\n        // 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性\n        // 获取设置的 theme 属性值\n        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);\n    \tfinal int themeResId = ta.getResourceId(0, 0);\n        if (themeResId != 0) {\n            // 如果设置了，则将 context 包装成 ContextThemeWrapper\n            // 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性\n            context = new ContextThemeWrapper(context, themeResId);\n        }\n        ta.recycle();\n    }\n    \n    try {\n        View view;\n        \n        // Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView\n        if (mFactory2 != null) {\n        \tview = mFactory2.onCreateView(parent, name, context, attrs);\n        } else if (mFactory != null) {\n            view = mFactory.onCreateView(name, context, attrs);\n        } else {\n            view = null;\n        }\n        \n        if (view == null && mPrivateFactory != null) {\n        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);\n        }\n        \n        if (view == null) {\n            final Object lastContext = mConstructorArgs[0];\n            mConstructorArgs[0] = context;\n            try {\n                if (-1 == name.indexOf('.')) {\n                    // 系统控件\n                    view = onCreateView(parent, name, attrs);\n                } else {\n                    // 自定义控件\n                    view = createView(name, null, attrs);\n                }\n            } finally {\n                mConstructorArgs[0] = lastContext;\n            }\n        }\n        \n        return view;\n    } catch () {\n        \n    }\n}\n```\n\n不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 `createView()`\n\n``` java\npublic final View createView(String name, String prefix, AttributeSet attrs){\n\t// 缓存构造函数\n    Constructor<? extends View> constructor = sConstructorMap.get(name);\n    // 检查构造函数类加载器\n    if (constructor != null && !verifyClassLoader(constructor)){\n        constructor = null;\n        sConstructorMap.remove(name);\n    }\n    Class<? extends View> clazz = null;\n    try {\n        \n        // 获取 View 构造函数实例，并处理过滤情况\n        if (constructor == null) {\n        \tclazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n        \n            if (mFilter != null && clazz != null) {\n            // 检查是否过滤\n        \tboolean allowed = mFilter.onLoadClass(clazz);\n            if (!allowed) {\n                failNotAllowed(name, prefix, attrs);\n            }\n            }\n            constructor = clazz.getConstructor(mConstructorSignature);\n            constructor.setAccessible(true);\n            sConstructorMap.put(name, constructor);\n        } else {\n            if (mFilter != null) {\n                // 存在过滤器\n                Boolean allowedState = mFilterMap.get(name);\n                if (allowedState == null) {\n                    // 没有缓存过滤结果，新的类\n                    clazz = mContext.getClassLoader().loadClass(                            \n                    prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \tboolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                \tmFilterMap.put(name, allowed);\n                    if (!allowed) {\n                    \tfailNotAllowed(name, prefix, attrs);\n                    }\n                } else if (allowedState.equals(Boolean.FALSE)) {\n                    failNotAllowed(name, prefix, attrs);\n                } \n            }\n        }\n        \n        Object lastContext = mConstructorArgs[0];\n        if (mConstructorArgs[0] == null) {\n            // 如果还没设置 context 参数\n            mConstructorArgs[0] = mContext;\n        }\n        Object[] args = mConstructorArgs;\n        args[1] = attrs;\n        // 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知\n        final View view = constructor.newInstance(args); \n        if (view instanceof ViewStub) {\n            // 使用相同的 Context 处理 ViewStub\n            final ViewStub viewStub = (ViewStub) view;\n            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n        }\n        mConstructorArgs[0] = lastContext;\n        return view;\n    } catech () {\n        \n    }\n}\n```\n\n最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同地方，我们先通过一个例子来看下效果：\n\n``` java\nprotected void onCreate(Bundle savedInstanceState) {\n    // 使用两种 Context 创建两个 EditText\n    addEditText(this);                   \n\taddEditText(getApplicationContext());\n}\nprivate void addEditText(@Nullable Context context) { \n                                                      \n    if (mRootLayout == null) {                        \n        return;                                       \n    }                                                 \n                                                      \n    if (context == null) {                            \n        return;                                       \n    }                                                 \n                                                                                                       \n    EditText editText = new EditText(context);        \n    mRootLayout.addView(editText);                    \n    editText.setText(context.toString());                                                               \n}                                                     \n```\n\n代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题\n\n``` xml\n<Applicatin \n  android:theme=\"@style/AppTheme\">\n</Applicatin>\n\n<item name=\"colorAccent\">@color/colorAccent</item>\n<color name=\"colorAccent\">#FF4081</color>\n```\n\n![ActivityContextEditText](http://oy017242u.bkt.clouddn.com/ActivityContextEditText.png?time=123)\n\n![ApplicationContextEditText](http://oy017242u.bkt.clouddn.com/ApplicationContextEditText.png)\n\n我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：\n\n``` java\npublic Resources.Theme getTheme() {\n    if (mTheme != null) {\n        return mTheme;\n    }\n    if (mThemeResource == 0) {\n        mThemeResource = R.style.Theme_AppCompat_Light;\n    }\n    initializeTheme();\n    return mTheme;\n}\n\nprivate void initializeTheme() {\n    final boolean first = mTheme == null;\n    if (first) {\n        mTheme = getResources().newTheme();\n        Resources.Theme theme = getBaseContext().getTheme();\n        if (theme != null) {\n            mTheme.setTo(theme);\n        }\n    }\n    onApplyThemeResource(mTheme, mThemeResource, first);\n}\n\nprotected void onApplyThemeResource(Resources.Theme theme, int resid, boolean first) {\n    theme.applyStyle(resid, true);\n}\n```\n\n`mTheme` 和 `mThemeResource` 都可以通过构造方法和 set 方法进行赋值，假设没有给 `mTheme` 赋值，只给 `mThemeResource` 赋值，那么上面的代码将 `mThemeSource` 应用到 `ContextWrapper.getTheme()` 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 `ActivityThread.performLaunchActivity()` 中，其中涉及 Theme 的赋值是：\n\n``` java\nint theme = r.activityInfo.getThemeResource();\nif (theme != 0) {\n    activity.setTheme(theme);\n}\n```\n\n现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。\n\n#### 小结\n\n通过上面的源码分析，我们可以知道：\n\n1. 当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 `View(Context,AttributeSet)` 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。\n2. Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。\n\n### getApplication()和getApplicatinContext()\n\n**接下来的分析参考于 [android-context](http://gityuan.com/2017/04/09/android_context/)**\n\n绝大数情况下，这两个方法的返回值是一样。\n\n`getApplicationContext()` 的存在是 Android 历史原因，`getApplication()` 这两个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 `getApplicationContext()`。\n\n两者对比：\n\n1. 对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过\n2. BroadcastReceiver 只能通过 `getApplicationContext()` 获取 Application 实例\n3. ContentProvider 也只能通过 `getApplicationContext()` 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 `getApplicationContext()` 则会返回空。\n\n#### 小结\n\n绝大数情况下，`getApplication()` 和 `getApplicationContext()` 返回是一样的，但如果不是特别熟悉，最好对 `getApplicationContext()` 进行空值判断。\n\n### Dialog Context\n\n我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：\n\n```\nCaused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?\n```\n\n### start Activity\n\n通过调用 `startActivity()` 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 `startActivity()` 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：\n\n在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记的话，则会抛出以下异常：\n\n```\nCaused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?\n```\n\nAndroid 26 上 ContextImpl 的相关代码如下：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n\n    }\n}\n```\n\n只要没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记就会抛异常。\n\n而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0\n        && options != null && ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n    }\n}\n```\n\n只有在指定了 `options` 同时其中没有指定 LaunchTaskId 才会抛异常。\n\n## 总结\n\n上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。\n\n不管如何谨慎小心，怀着诚惶诚恐的心态，毕竟作者的水平有限，如果有说的不对的地方，敬请指出，先行感谢。","slug":"熟悉又陌生的Context","published":1,"updated":"2018-04-15T09:10:15.952Z","_id":"cjg0kyrxt0000rro6qufp4k6i","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><blockquote>\n<p>本文中涉及的源码分析都是基于 Android 27</p>\n</blockquote>\n<p>Context 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 <code>getResources()</code> 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对于 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/Context.png\" alt=\"Context\" title=\"\">\n                </div>\n                <div class=\"image-caption\">Context</div>\n            </figure>\n<p>其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ContextWrapper</span><span class=\"params\">(Context base)</span> </span>&#123;</span><br><span class=\"line\">\tmBase = base;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    mBase.startActivity(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过在构造函数中将 ContextImpl 实例赋值给 <code>mBase</code>，然后在比如 <code>startActivity</code> 等方法实现中，将调用转发给 <code>mBase</code>，至于 <code>mBase</code> 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。</p>\n<p>通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。</p>\n<h2 id=\"Context初始化\"><a href=\"#Context初始化\" class=\"headerlink\" title=\"Context初始化\"></a>Context初始化</h2><h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>在前面的 <a href=\"https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/\">Activity 启动分析</a>中，我们知道最终 Activity 启动方法是 <code>ActivityThread.performLaunchActivity()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.packageInfo == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tr.packageInfo = getPackageInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        appContext.setOuterContext(activity);</span><br><span class=\"line\">        activity.attach();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先获取 LoadedApk 实例，接着调用 <code>createBaseContextForActivity()</code> 创建 ContextImpl 实例，之前我们提到 ContextWraper 是将 Context 核心功能转发给 ContextImpl 实现的，在 Activity 启动流程中，是通过调用 <code>Activity.attach()</code> 实现，这个我们在后面的分析中可以知道。</p>\n<h4 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ComtextImpl <span class=\"title\">createBaseContextForActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> displayId;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        displayId = ActivityManager.getService().getActivityDisplayId(r.token);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ContextImpl appContext = ContextImpl.createActivityContext();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createActivityContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ResourcesManager resourcesManager = ResourcesManager.getInstance();</span><br><span class=\"line\">    context.setResources(resourcesManager.createBaseActivityResources(activityToken,</span><br><span class=\"line\">                packageInfo.getResDir(),</span><br><span class=\"line\">                splitDirs,</span><br><span class=\"line\">                packageInfo.getOverlayDirs(),</span><br><span class=\"line\">                packageInfo.getApplicationInfo().sharedLibraryFiles,</span><br><span class=\"line\">                displayId,</span><br><span class=\"line\">                overrideConfiguration,</span><br><span class=\"line\">                compatInfo,</span><br><span class=\"line\">                classLoader));</span><br><span class=\"line\">    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,</span><br><span class=\"line\">                context.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach\"><a href=\"#attach\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">attachBaseContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.attachBaseContext(newBase);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个步骤比较简单，最终也是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h3><p>Service 的创建是在 <code>ActivityThread.handleCreateService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">LoadedApk packageInfo = getPackageInfoNoCheck();</span><br><span class=\"line\"></span><br><span class=\"line\">Service service = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class=\"line\">    <span class=\"comment\">// 通过反射实例化 Service</span></span><br><span class=\"line\">    service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ContextImpl context = ContextImpl.createAppContext(<span class=\"keyword\">this</span>, packageInfo);</span><br><span class=\"line\">    context.setOuterContext(service);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Application app = packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">    service.attach();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 Context 初始化流程和 Activity 是差不多，相同的是 LoadedApk -&gt; ContextImpl -&gt; attach</p>\n<h4 id=\"create-1\"><a href=\"#create-1\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    <span class=\"comment\">// Service 的 Resources 相对于 Activity 是比较简单的</span></span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-1\"><a href=\"#attach-1\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 attach 和 Activity 相同，都是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h3><p>Application 的创建是在 <code>LoadedApk.makeApplication()</code> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Application <span class=\"title\">makeApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保持单例</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> mApplication;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Application app = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    String appClass = mApplicationInfo.className;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forceDefaultAppClass || (appClass == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果强制使用默认 Application，或者没有实现自定义 Application</span></span><br><span class=\"line\">    \tappClass = <span class=\"string\">\"android.app.Application\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mPackageName.equals(<span class=\"string\">\"android\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 包名不是 \"android\"，即非系统进程</span></span><br><span class=\"line\">        \tinitializeJavaContextClassLoader();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建 Application 实例</span></span><br><span class=\"line\">    \tapp = mActivityThread.mInstrumentation.newApplication(</span><br><span class=\"line\">                    cl, appClass, appContext);</span><br><span class=\"line\">    \tappContext.setOuterContext(app);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>咋一看好像 Application 的流程和其他两个不太相同，其实不是这样的，Application 的 attach 在 <code>Instrumentation.newApplication()</code></p>\n<h4 id=\"create-2\"><a href=\"#create-2\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-2\"><a href=\"#attach-2\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Application <span class=\"title\">newApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 反射获取实例</span></span><br><span class=\"line\">    Application app = (Application)clazz.newInstance();</span><br><span class=\"line\">    app.attach(context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>通过我们对 Activity、Service、Application 的 Context 初始化流程的分析，首先创建 ContextImpl 实例，接着调用 <code>ContextWrapper.attachBaseContext()</code> 赋值给 <code>mBase</code>，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。</p>\n<h3 id=\"View-Context\"><a href=\"#View-Context\" class=\"headerlink\" title=\"View Context\"></a>View Context</h3><h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>我们知道可以通过调用 <code>View.getContext()</code> 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>首先我们对 View 的 <code>mContext</code> 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。</p>\n<p>如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater mLayoutInflater = LayoutInflater.from(context);</span><br><span class=\"line\">View view = mLayoutInflater.inflate(R.layout.xxx,<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>首先我们看下 <code>LayoutInflater.from()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LayoutInflater <span class=\"title\">from</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">\tLayoutInflater LayoutInflater =(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LayoutInflater == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"LayoutInflater not found.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> LayoutInflater;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上文我们提到 Context 的核心方法都转发给 <code>mBase</code> 即 ContextImpl 实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SystemServiceRegistry.getSystemService(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class=\"line\">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetcher != <span class=\"keyword\">null</span> ? fetcher.getService(ctx) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终的调用都转发给了 ServiceFetcher，而 <code>SYSTEM_SERVICE_FETCHERS</code> 存储着各个类型的 Fetcher 的实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name-&gt;Fetcher</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 存储 Class-&gt;Name</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">registerService</span><span class=\"params\">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class=\"line\">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class=\"line\">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SYSTEM_SERVICE_FETCHERS</code> 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 <code>registerService()</code>，这里我们只关心 LayoutInflater 的注册：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;                  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutInflater <span class=\"title\">createService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());        </span><br><span class=\"line\">    &#125;&#125;);</span><br></pre></td></tr></table></figure>\n<p>LayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 实际并没有特殊的操作，基本逻辑都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 <code>CachedServiceFetcher.getService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> T <span class=\"title\">getService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] cache = ctx.mServiceCache;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (cache) &#123;</span><br><span class=\"line\">        Object service = cache[mCacheIndex];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                service = createService(ctx);</span><br><span class=\"line\">                cache[mCacheIndex] = service;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ServiceNotFoundException e) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意到，Service 的缓存是存储在 <code>ContextImpl.mServiceCache</code> 并且该字段不是静态的，即<strong>Service 的缓存是针对于相同的 Context 实例的</strong>，如果不存在缓存，那么调用 <code>createService()</code>，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br></pre></td></tr></table></figure>\n<p>而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">LayoutInflater</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到</span></span><br><span class=\"line\">    mContext = context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们看下 <code>inflate()</code> 源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> resource, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Resources res = getContext().getResources();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inflate(parser, root, attachToRoot);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        parser.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(XmlPullParser parser, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mConstructorArgs) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Context inflaterContext = mContext;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class=\"line\">    \tContext lastContext = (Context) mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = inflaterContext;</span><br><span class=\"line\">        View result = root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 解析 xml 中的节点</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>inflater()</code> 就是对 xml 布局进行解析，实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 <code>createViewFromTag()</code> 它是根据标签名称是实例化具体的 View 实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">View <span class=\"title\">createViewFromTag</span><span class=\"params\">(View parent, String name, Context context, AttributeSet attrs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name.equals(<span class=\"string\">\"view\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果我们使用 view 标签则从 class 属性中获取具体类名称</span></span><br><span class=\"line\">        name = attrs.getAttributeValue(<span class=\"keyword\">null</span>, <span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ignoreThemeAttr) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取设置的 theme 属性值</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> themeResId = ta.getResourceId(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (themeResId != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了，则将 context 包装成 ContextThemeWrapper</span></span><br><span class=\"line\">            <span class=\"comment\">// 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性</span></span><br><span class=\"line\">            context = <span class=\"keyword\">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ta.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        View view;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFactory2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            view = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span> &amp;&amp; mPrivateFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = context;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == name.indexOf(<span class=\"string\">'.'</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 系统控件</span></span><br><span class=\"line\">                    view = onCreateView(parent, name, attrs);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 自定义控件</span></span><br><span class=\"line\">                    view = createView(name, <span class=\"keyword\">null</span>, attrs);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 <code>createView()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> View <span class=\"title\">createView</span><span class=\"params\">(String name, String prefix, AttributeSet attrs)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存构造函数</span></span><br><span class=\"line\">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class=\"line\">    <span class=\"comment\">// 检查构造函数类加载器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (constructor != <span class=\"keyword\">null</span> &amp;&amp; !verifyClassLoader(constructor))&#123;</span><br><span class=\"line\">        constructor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        sConstructorMap.remove(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Class&lt;? extends View&gt; clazz = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取 View 构造函数实例，并处理过滤情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (constructor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tclazz = mContext.getClassLoader().loadClass(</span><br><span class=\"line\">                        prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span> &amp;&amp; clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 检查是否过滤</span></span><br><span class=\"line\">        \t<span class=\"keyword\">boolean</span> allowed = mFilter.onLoadClass(clazz);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class=\"line\">            constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            sConstructorMap.put(name, constructor);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 存在过滤器</span></span><br><span class=\"line\">                Boolean allowedState = mFilterMap.get(name);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (allowedState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 没有缓存过滤结果，新的类</span></span><br><span class=\"line\">                    clazz = mContext.getClassLoader().loadClass(                            </span><br><span class=\"line\">                    prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">                \t<span class=\"keyword\">boolean</span> allowed = clazz != <span class=\"keyword\">null</span> &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class=\"line\">                \tmFilterMap.put(name, allowed);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                    \tfailNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (allowedState.equals(Boolean.FALSE)) &#123;</span><br><span class=\"line\">                    failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mConstructorArgs[<span class=\"number\">0</span>] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果还没设置 context 参数</span></span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = mContext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object[] args = mConstructorArgs;</span><br><span class=\"line\">        args[<span class=\"number\">1</span>] = attrs;</span><br><span class=\"line\">        <span class=\"comment\">// 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View view = constructor.newInstance(args); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view <span class=\"keyword\">instanceof</span> ViewStub) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用相同的 Context 处理 ViewStub</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> ViewStub viewStub = (ViewStub) view;</span><br><span class=\"line\">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; catech () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同地方，我们先通过一个例子来看下效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用两种 Context 创建两个 EditText</span></span><br><span class=\"line\">    addEditText(<span class=\"keyword\">this</span>);                   </span><br><span class=\"line\">\taddEditText(getApplicationContext());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addEditText</span><span class=\"params\">(@Nullable Context context)</span> </span>&#123; </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mRootLayout == <span class=\"keyword\">null</span>) &#123;                        </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;                            </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                                                                       </span><br><span class=\"line\">    EditText editText = <span class=\"keyword\">new</span> EditText(context);        </span><br><span class=\"line\">    mRootLayout.addView(editText);                    </span><br><span class=\"line\">    editText.setText(context.toString());                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Applicatin</span> </span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/AppTheme\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Applicatin</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>@color/colorAccent<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">color</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>#FF4081<span class=\"tag\">&lt;/<span class=\"name\">color</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/ActivityContextEditText.png?time=123\" alt=\"ActivityContextEditText\" title=\"\">\n                </div>\n                <div class=\"image-caption\">ActivityContextEditText</div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/ApplicationContextEditText.png\" alt=\"ApplicationContextEditText\" title=\"\">\n                </div>\n                <div class=\"image-caption\">ApplicationContextEditText</div>\n            </figure>\n<p>我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Resources.<span class=\"function\">Theme <span class=\"title\">getTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTheme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThemeResource == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mThemeResource = R.style.Theme_AppCompat_Light;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    initializeTheme();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initializeTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> first = mTheme == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first) &#123;</span><br><span class=\"line\">        mTheme = getResources().newTheme();</span><br><span class=\"line\">        Resources.Theme theme = getBaseContext().getTheme();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (theme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mTheme.setTo(theme);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    onApplyThemeResource(mTheme, mThemeResource, first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplyThemeResource</span><span class=\"params\">(Resources.Theme theme, <span class=\"keyword\">int</span> resid, <span class=\"keyword\">boolean</span> first)</span> </span>&#123;</span><br><span class=\"line\">    theme.applyStyle(resid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mTheme</code> 和 <code>mThemeResource</code> 都可以通过构造方法和 set 方法进行赋值，假设没有给 <code>mTheme</code> 赋值，只给 <code>mThemeResource</code> 赋值，那么上面的代码将 <code>mThemeSource</code> 应用到 <code>ContextWrapper.getTheme()</code> 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 <code>ActivityThread.performLaunchActivity()</code> 中，其中涉及 Theme 的赋值是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (theme != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    activity.setTheme(theme);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过上面的源码分析，我们可以知道：</p>\n<ol>\n<li>当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 <code>View(Context,AttributeSet)</code> 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。</li>\n<li>Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。</li>\n</ol>\n<h3 id=\"getApplication-和getApplicatinContext\"><a href=\"#getApplication-和getApplicatinContext\" class=\"headerlink\" title=\"getApplication()和getApplicatinContext()\"></a>getApplication()和getApplicatinContext()</h3><p><strong>接下来的分析参考于 <a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></strong></p>\n<p>绝大数情况下，这两个方法的返回值是一样。</p>\n<p><code>getApplicationContext()</code> 的存在是 Android 历史原因，<code>getApplication()</code> 这两个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 <code>getApplicationContext()</code>。</p>\n<p>两者对比：</p>\n<ol>\n<li>对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过</li>\n<li>BroadcastReceiver 只能通过 <code>getApplicationContext()</code> 获取 Application 实例</li>\n<li>ContentProvider 也只能通过 <code>getApplicationContext()</code> 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 <code>getApplicationContext()</code> 则会返回空。</li>\n</ol>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>绝大数情况下，<code>getApplication()</code> 和 <code>getApplicationContext()</code> 返回是一样的，但如果不是特别熟悉，最好对 <code>getApplicationContext()</code> 进行空值判断。</p>\n<h3 id=\"Dialog-Context\"><a href=\"#Dialog-Context\" class=\"headerlink\" title=\"Dialog Context\"></a>Dialog Context</h3><p>我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?</span><br></pre></td></tr></table></figure>\n<h3 id=\"start-Activity\"><a href=\"#start-Activity\" class=\"headerlink\" title=\"start Activity\"></a>start Activity</h3><p>通过调用 <code>startActivity()</code> 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 <code>startActivity()</code> 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：</p>\n<p>在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记的话，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br></pre></td></tr></table></figure>\n<p>Android 26 上 ContextImpl 的相关代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记就会抛异常。</p>\n<p>而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span></span><br><span class=\"line\">        &amp;&amp; options != <span class=\"keyword\">null</span> &amp;&amp; ActivityOptions.fromBundle(options).getLaunchTaskId() == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有在指定了 <code>options</code> 同时其中没有指定 LaunchTaskId 才会抛异常。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。</p>\n<p>不管如何谨慎小心，怀着诚惶诚恐的心态，毕竟作者的水平有限，如果有说的不对的地方，敬请指出，先行感谢。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><blockquote>\n<p>本文中涉及的源码分析都是基于 Android 27</p>\n</blockquote>\n<p>Context 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 <code>getResources()</code> 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对于 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/Context.png\" alt=\"Context\" title=\"\">\n                </div>\n                <div class=\"image-caption\">Context</div>\n            </figure>\n<p>其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ContextWrapper</span><span class=\"params\">(Context base)</span> </span>&#123;</span><br><span class=\"line\">\tmBase = base;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    mBase.startActivity(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过在构造函数中将 ContextImpl 实例赋值给 <code>mBase</code>，然后在比如 <code>startActivity</code> 等方法实现中，将调用转发给 <code>mBase</code>，至于 <code>mBase</code> 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。</p>\n<p>通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。</p>\n<h2 id=\"Context初始化\"><a href=\"#Context初始化\" class=\"headerlink\" title=\"Context初始化\"></a>Context初始化</h2><h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>在前面的 <a href=\"https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/\">Activity 启动分析</a>中，我们知道最终 Activity 启动方法是 <code>ActivityThread.performLaunchActivity()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.packageInfo == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tr.packageInfo = getPackageInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        appContext.setOuterContext(activity);</span><br><span class=\"line\">        activity.attach();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先获取 LoadedApk 实例，接着调用 <code>createBaseContextForActivity()</code> 创建 ContextImpl 实例，之前我们提到 ContextWraper 是将 Context 核心功能转发给 ContextImpl 实现的，在 Activity 启动流程中，是通过调用 <code>Activity.attach()</code> 实现，这个我们在后面的分析中可以知道。</p>\n<h4 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ComtextImpl <span class=\"title\">createBaseContextForActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> displayId;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        displayId = ActivityManager.getService().getActivityDisplayId(r.token);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ContextImpl appContext = ContextImpl.createActivityContext();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createActivityContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ResourcesManager resourcesManager = ResourcesManager.getInstance();</span><br><span class=\"line\">    context.setResources(resourcesManager.createBaseActivityResources(activityToken,</span><br><span class=\"line\">                packageInfo.getResDir(),</span><br><span class=\"line\">                splitDirs,</span><br><span class=\"line\">                packageInfo.getOverlayDirs(),</span><br><span class=\"line\">                packageInfo.getApplicationInfo().sharedLibraryFiles,</span><br><span class=\"line\">                displayId,</span><br><span class=\"line\">                overrideConfiguration,</span><br><span class=\"line\">                compatInfo,</span><br><span class=\"line\">                classLoader));</span><br><span class=\"line\">    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,</span><br><span class=\"line\">                context.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach\"><a href=\"#attach\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">attachBaseContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.attachBaseContext(newBase);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个步骤比较简单，最终也是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h3><p>Service 的创建是在 <code>ActivityThread.handleCreateService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">LoadedApk packageInfo = getPackageInfoNoCheck();</span><br><span class=\"line\"></span><br><span class=\"line\">Service service = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class=\"line\">    <span class=\"comment\">// 通过反射实例化 Service</span></span><br><span class=\"line\">    service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ContextImpl context = ContextImpl.createAppContext(<span class=\"keyword\">this</span>, packageInfo);</span><br><span class=\"line\">    context.setOuterContext(service);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Application app = packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">    service.attach();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 Context 初始化流程和 Activity 是差不多，相同的是 LoadedApk -&gt; ContextImpl -&gt; attach</p>\n<h4 id=\"create-1\"><a href=\"#create-1\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    <span class=\"comment\">// Service 的 Resources 相对于 Activity 是比较简单的</span></span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-1\"><a href=\"#attach-1\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 attach 和 Activity 相同，都是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h3><p>Application 的创建是在 <code>LoadedApk.makeApplication()</code> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Application <span class=\"title\">makeApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保持单例</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> mApplication;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Application app = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    String appClass = mApplicationInfo.className;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forceDefaultAppClass || (appClass == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果强制使用默认 Application，或者没有实现自定义 Application</span></span><br><span class=\"line\">    \tappClass = <span class=\"string\">\"android.app.Application\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mPackageName.equals(<span class=\"string\">\"android\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 包名不是 \"android\"，即非系统进程</span></span><br><span class=\"line\">        \tinitializeJavaContextClassLoader();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建 Application 实例</span></span><br><span class=\"line\">    \tapp = mActivityThread.mInstrumentation.newApplication(</span><br><span class=\"line\">                    cl, appClass, appContext);</span><br><span class=\"line\">    \tappContext.setOuterContext(app);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>咋一看好像 Application 的流程和其他两个不太相同，其实不是这样的，Application 的 attach 在 <code>Instrumentation.newApplication()</code></p>\n<h4 id=\"create-2\"><a href=\"#create-2\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-2\"><a href=\"#attach-2\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Application <span class=\"title\">newApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 反射获取实例</span></span><br><span class=\"line\">    Application app = (Application)clazz.newInstance();</span><br><span class=\"line\">    app.attach(context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>通过我们对 Activity、Service、Application 的 Context 初始化流程的分析，首先创建 ContextImpl 实例，接着调用 <code>ContextWrapper.attachBaseContext()</code> 赋值给 <code>mBase</code>，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。</p>\n<h3 id=\"View-Context\"><a href=\"#View-Context\" class=\"headerlink\" title=\"View Context\"></a>View Context</h3><h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>我们知道可以通过调用 <code>View.getContext()</code> 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>首先我们对 View 的 <code>mContext</code> 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。</p>\n<p>如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater mLayoutInflater = LayoutInflater.from(context);</span><br><span class=\"line\">View view = mLayoutInflater.inflate(R.layout.xxx,<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>首先我们看下 <code>LayoutInflater.from()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LayoutInflater <span class=\"title\">from</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">\tLayoutInflater LayoutInflater =(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LayoutInflater == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"LayoutInflater not found.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> LayoutInflater;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上文我们提到 Context 的核心方法都转发给 <code>mBase</code> 即 ContextImpl 实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SystemServiceRegistry.getSystemService(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class=\"line\">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetcher != <span class=\"keyword\">null</span> ? fetcher.getService(ctx) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终的调用都转发给了 ServiceFetcher，而 <code>SYSTEM_SERVICE_FETCHERS</code> 存储着各个类型的 Fetcher 的实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name-&gt;Fetcher</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 存储 Class-&gt;Name</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">registerService</span><span class=\"params\">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class=\"line\">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class=\"line\">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SYSTEM_SERVICE_FETCHERS</code> 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 <code>registerService()</code>，这里我们只关心 LayoutInflater 的注册：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;                  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutInflater <span class=\"title\">createService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());        </span><br><span class=\"line\">    &#125;&#125;);</span><br></pre></td></tr></table></figure>\n<p>LayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 实际并没有特殊的操作，基本逻辑都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 <code>CachedServiceFetcher.getService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> T <span class=\"title\">getService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] cache = ctx.mServiceCache;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (cache) &#123;</span><br><span class=\"line\">        Object service = cache[mCacheIndex];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                service = createService(ctx);</span><br><span class=\"line\">                cache[mCacheIndex] = service;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ServiceNotFoundException e) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意到，Service 的缓存是存储在 <code>ContextImpl.mServiceCache</code> 并且该字段不是静态的，即<strong>Service 的缓存是针对于相同的 Context 实例的</strong>，如果不存在缓存，那么调用 <code>createService()</code>，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br></pre></td></tr></table></figure>\n<p>而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">LayoutInflater</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到</span></span><br><span class=\"line\">    mContext = context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们看下 <code>inflate()</code> 源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> resource, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Resources res = getContext().getResources();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inflate(parser, root, attachToRoot);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        parser.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(XmlPullParser parser, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mConstructorArgs) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Context inflaterContext = mContext;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class=\"line\">    \tContext lastContext = (Context) mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = inflaterContext;</span><br><span class=\"line\">        View result = root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 解析 xml 中的节点</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>inflater()</code> 就是对 xml 布局进行解析，实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 <code>createViewFromTag()</code> 它是根据标签名称是实例化具体的 View 实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">View <span class=\"title\">createViewFromTag</span><span class=\"params\">(View parent, String name, Context context, AttributeSet attrs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name.equals(<span class=\"string\">\"view\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果我们使用 view 标签则从 class 属性中获取具体类名称</span></span><br><span class=\"line\">        name = attrs.getAttributeValue(<span class=\"keyword\">null</span>, <span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ignoreThemeAttr) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取设置的 theme 属性值</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> themeResId = ta.getResourceId(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (themeResId != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了，则将 context 包装成 ContextThemeWrapper</span></span><br><span class=\"line\">            <span class=\"comment\">// 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性</span></span><br><span class=\"line\">            context = <span class=\"keyword\">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ta.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        View view;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFactory2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            view = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span> &amp;&amp; mPrivateFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = context;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == name.indexOf(<span class=\"string\">'.'</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 系统控件</span></span><br><span class=\"line\">                    view = onCreateView(parent, name, attrs);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 自定义控件</span></span><br><span class=\"line\">                    view = createView(name, <span class=\"keyword\">null</span>, attrs);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 <code>createView()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> View <span class=\"title\">createView</span><span class=\"params\">(String name, String prefix, AttributeSet attrs)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存构造函数</span></span><br><span class=\"line\">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class=\"line\">    <span class=\"comment\">// 检查构造函数类加载器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (constructor != <span class=\"keyword\">null</span> &amp;&amp; !verifyClassLoader(constructor))&#123;</span><br><span class=\"line\">        constructor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        sConstructorMap.remove(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Class&lt;? extends View&gt; clazz = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取 View 构造函数实例，并处理过滤情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (constructor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tclazz = mContext.getClassLoader().loadClass(</span><br><span class=\"line\">                        prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span> &amp;&amp; clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 检查是否过滤</span></span><br><span class=\"line\">        \t<span class=\"keyword\">boolean</span> allowed = mFilter.onLoadClass(clazz);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class=\"line\">            constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            sConstructorMap.put(name, constructor);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 存在过滤器</span></span><br><span class=\"line\">                Boolean allowedState = mFilterMap.get(name);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (allowedState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 没有缓存过滤结果，新的类</span></span><br><span class=\"line\">                    clazz = mContext.getClassLoader().loadClass(                            </span><br><span class=\"line\">                    prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">                \t<span class=\"keyword\">boolean</span> allowed = clazz != <span class=\"keyword\">null</span> &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class=\"line\">                \tmFilterMap.put(name, allowed);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                    \tfailNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (allowedState.equals(Boolean.FALSE)) &#123;</span><br><span class=\"line\">                    failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mConstructorArgs[<span class=\"number\">0</span>] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果还没设置 context 参数</span></span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = mContext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object[] args = mConstructorArgs;</span><br><span class=\"line\">        args[<span class=\"number\">1</span>] = attrs;</span><br><span class=\"line\">        <span class=\"comment\">// 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View view = constructor.newInstance(args); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view <span class=\"keyword\">instanceof</span> ViewStub) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用相同的 Context 处理 ViewStub</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> ViewStub viewStub = (ViewStub) view;</span><br><span class=\"line\">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; catech () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同地方，我们先通过一个例子来看下效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用两种 Context 创建两个 EditText</span></span><br><span class=\"line\">    addEditText(<span class=\"keyword\">this</span>);                   </span><br><span class=\"line\">\taddEditText(getApplicationContext());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addEditText</span><span class=\"params\">(@Nullable Context context)</span> </span>&#123; </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mRootLayout == <span class=\"keyword\">null</span>) &#123;                        </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;                            </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                                                                       </span><br><span class=\"line\">    EditText editText = <span class=\"keyword\">new</span> EditText(context);        </span><br><span class=\"line\">    mRootLayout.addView(editText);                    </span><br><span class=\"line\">    editText.setText(context.toString());                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Applicatin</span> </span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/AppTheme\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Applicatin</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>@color/colorAccent<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">color</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>#FF4081<span class=\"tag\">&lt;/<span class=\"name\">color</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/ActivityContextEditText.png?time=123\" alt=\"ActivityContextEditText\" title=\"\">\n                </div>\n                <div class=\"image-caption\">ActivityContextEditText</div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://oy017242u.bkt.clouddn.com/ApplicationContextEditText.png\" alt=\"ApplicationContextEditText\" title=\"\">\n                </div>\n                <div class=\"image-caption\">ApplicationContextEditText</div>\n            </figure>\n<p>我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Resources.<span class=\"function\">Theme <span class=\"title\">getTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTheme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThemeResource == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mThemeResource = R.style.Theme_AppCompat_Light;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    initializeTheme();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initializeTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> first = mTheme == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first) &#123;</span><br><span class=\"line\">        mTheme = getResources().newTheme();</span><br><span class=\"line\">        Resources.Theme theme = getBaseContext().getTheme();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (theme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mTheme.setTo(theme);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    onApplyThemeResource(mTheme, mThemeResource, first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplyThemeResource</span><span class=\"params\">(Resources.Theme theme, <span class=\"keyword\">int</span> resid, <span class=\"keyword\">boolean</span> first)</span> </span>&#123;</span><br><span class=\"line\">    theme.applyStyle(resid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mTheme</code> 和 <code>mThemeResource</code> 都可以通过构造方法和 set 方法进行赋值，假设没有给 <code>mTheme</code> 赋值，只给 <code>mThemeResource</code> 赋值，那么上面的代码将 <code>mThemeSource</code> 应用到 <code>ContextWrapper.getTheme()</code> 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 <code>ActivityThread.performLaunchActivity()</code> 中，其中涉及 Theme 的赋值是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (theme != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    activity.setTheme(theme);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过上面的源码分析，我们可以知道：</p>\n<ol>\n<li>当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 <code>View(Context,AttributeSet)</code> 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。</li>\n<li>Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。</li>\n</ol>\n<h3 id=\"getApplication-和getApplicatinContext\"><a href=\"#getApplication-和getApplicatinContext\" class=\"headerlink\" title=\"getApplication()和getApplicatinContext()\"></a>getApplication()和getApplicatinContext()</h3><p><strong>接下来的分析参考于 <a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></strong></p>\n<p>绝大数情况下，这两个方法的返回值是一样。</p>\n<p><code>getApplicationContext()</code> 的存在是 Android 历史原因，<code>getApplication()</code> 这两个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 <code>getApplicationContext()</code>。</p>\n<p>两者对比：</p>\n<ol>\n<li>对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过</li>\n<li>BroadcastReceiver 只能通过 <code>getApplicationContext()</code> 获取 Application 实例</li>\n<li>ContentProvider 也只能通过 <code>getApplicationContext()</code> 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 <code>getApplicationContext()</code> 则会返回空。</li>\n</ol>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>绝大数情况下，<code>getApplication()</code> 和 <code>getApplicationContext()</code> 返回是一样的，但如果不是特别熟悉，最好对 <code>getApplicationContext()</code> 进行空值判断。</p>\n<h3 id=\"Dialog-Context\"><a href=\"#Dialog-Context\" class=\"headerlink\" title=\"Dialog Context\"></a>Dialog Context</h3><p>我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?</span><br></pre></td></tr></table></figure>\n<h3 id=\"start-Activity\"><a href=\"#start-Activity\" class=\"headerlink\" title=\"start Activity\"></a>start Activity</h3><p>通过调用 <code>startActivity()</code> 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 <code>startActivity()</code> 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：</p>\n<p>在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记的话，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br></pre></td></tr></table></figure>\n<p>Android 26 上 ContextImpl 的相关代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记就会抛异常。</p>\n<p>而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span></span><br><span class=\"line\">        &amp;&amp; options != <span class=\"keyword\">null</span> &amp;&amp; ActivityOptions.fromBundle(options).getLaunchTaskId() == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有在指定了 <code>options</code> 同时其中没有指定 LaunchTaskId 才会抛异常。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。</p>\n<p>不管如何谨慎小心，怀着诚惶诚恐的心态，毕竟作者的水平有限，如果有说的不对的地方，敬请指出，先行感谢。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjg0ku89y0000hio644mhx1tq","category_id":"cjg0ku8a60004hio6yqsdklrd","_id":"cjg0ku8ad0008hio65j0ayiea"},{"post_id":"cjg0ku8a30002hio6snmfub19","category_id":"cjg0ku8ac0007hio6bgamiqcl","_id":"cjg0ku8af000ahio6xdq3rwpm"},{"post_id":"cjg0ku8a80005hio67cgcwf35","category_id":"cjg0ku8ad0009hio6dr3eovci","_id":"cjg0ku8ag000chio6a4cjxu90"},{"post_id":"cjg0ku8aa0006hio6nbgjsod4","category_id":"cjg0ku8ac0007hio6bgamiqcl","_id":"cjg0ku8ah000dhio656c38cc9"},{"post_id":"cjg0kyrxt0000rro6qufp4k6i","category_id":"cjg0ku8ac0007hio6bgamiqcl","_id":"cjg0lb2ze0000x7o64j4vq809"}],"PostTag":[],"Tag":[{"name":"Android Framework","_id":"cjg0kyry10001rro6syblp9ui"}]}}