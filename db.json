{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":1,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":1,"renderable":1},{"_id":"themes/archer/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":1,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":1,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":1,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":1,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"dfe3c19144aee33a3fcab8091b0eab325ba41612","modified":1525681161000},{"_id":"themes/archer/.eslintrc.json","hash":"35eeca97fa5a2d0c6d78ef1257c58f03c42d43df","modified":1575187883288},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1575187883288},{"_id":"themes/archer/.gitignore","hash":"e2d7fa953bade3b94ed1cab25ffcf442c7540433","modified":1575187883289},{"_id":"themes/archer/.prettierignore","hash":"58caf761f07e5df9cdc21f7f19f0670fde41089b","modified":1575187883290},{"_id":"themes/archer/.prettierrc.js","hash":"875b0b95f6eb24a23e4ea83a75709b97897135e0","modified":1575187883290},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1575187883290},{"_id":"themes/archer/README.md","hash":"97edb54cb7aecff714f132110ed4ba8215da7136","modified":1575187883290},{"_id":"themes/archer/_config.yml","hash":"2e2d7eb03fe2da4227c0ecab3891fb4bd03c630c","modified":1575187883290},{"_id":"themes/archer/gulpfile.js","hash":"46dfe693b00ac4dea4d1b1af56f5ced4ee095c10","modified":1575187883292},{"_id":"themes/archer/package.json","hash":"531fe40833ca63493f62adfa249b6434310a2d0a","modified":1575187883298},{"_id":"themes/archer/webpack.config.js","hash":"d20b6350c50e2981484cb9356a3e21a2124bcd72","modified":1575187883317},{"_id":"themes/archer/webpack.prod.js","hash":"48de76cfa6274895801d3afc89ecbf04ee182a1c","modified":1575187883317},{"_id":"source/_posts/2018年复盘.md","hash":"338e77db3bcd96bdcb1461ff07a2217448745bbd","modified":1546269985000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1546270061000},{"_id":"source/_posts/Activity启动流程-基于Android26.md","hash":"999ee6726f9abf294514294e1686fa95f2740a3b","modified":1542363057000},{"_id":"source/_posts/Android消息机制-Handler.md","hash":"9d208a44a9bedbeca071851197d362ed52e1d594","modified":1523455530000},{"_id":"source/_posts/ArrayList源码分析.md","hash":"683f1abe2fe32c76242074784849394d4fb9a072","modified":1547015950000},{"_id":"source/_posts/AppPlugin中的Task-第一篇.md","hash":"1b07e2a3c05639214049d356a761a021d9d7f620","modified":1542766575000},{"_id":"source/_posts/Gradle多项目实践.md","hash":"0cca966a802c440fa49d60f4af5f850fdf2c1dbd","modified":1525868877000},{"_id":"source/_posts/Gradle多项目构建.md","hash":"635bb4c68fd958ca3836824c4165a2d875250599","modified":1525617798000},{"_id":"source/_posts/Gradle插件-基础篇.md","hash":"d7e11790592eba05427c0c6c4289b156a87f10cb","modified":1541941582000},{"_id":"source/_posts/Gradle插件-提高篇.md","hash":"0ac087efbca9e9d94a1754041e1beddb7dafa021","modified":1527396116000},{"_id":"source/_posts/HashMap源码分析.md","hash":"d1acf7770fbb152391a6c309d07c1ac487bab69a","modified":1541657239000},{"_id":"source/_posts/JavaScript正则表达式.md","hash":"7bb74b186c9df5efbf45840cdd6e79c869b556d3","modified":1536420042000},{"_id":"source/_posts/Jetpack中的ViewModel.md","hash":"bffdf5b77c3dc08bad721b5e17b5642732e30587","modified":1556148972000},{"_id":"source/_posts/Jetpack中的LiveData.md","hash":"bc0a49db3bba2e91d1262ba29aa70f482f7b7add","modified":1552316622000},{"_id":"source/_posts/Looper中的死循环.md","hash":"fe6bec321381f29033dbadb75bd203032f2e27b5","modified":1556148951000},{"_id":"source/_posts/Jetpack中的Lifecycle.md","hash":"d60b7e68c4ec31c562d00b3b22c5416ea71c27bc","modified":1548575076000},{"_id":"source/_posts/hello-world.md","hash":"7d143ea20eb8fe54463dd464d7fe7f6856e9d616","modified":1523455530000},{"_id":"source/_posts/SparseArray源码解析.md","hash":"4999af871ae7dc069bcc5af20d8cc1486c80f041","modified":1546959783000},{"_id":"source/_posts/灵活使用位运算符.md","hash":"0a7c2e118393f6f396a0b45a49a2f15600b48a6a","modified":1536391670000},{"_id":"source/_posts/可拖拽的网格布局.md","hash":"c8414690f2bace346bd1e039a6854e41fa8ebb1a","modified":1542363240000},{"_id":"source/_posts/性能优化第一步.md","hash":"1d7c2a16f7e8428ee03914a4ad196f673efa694c","modified":1542363649000},{"_id":"source/_posts/熟悉又陌生的Context.md","hash":"c97e6da98d9ea1716df6b4bab5bed6fa7a17db46","modified":1542363104000},{"_id":"source/_posts/触摸事件实践之路.md","hash":"3f197fd5d489306808f85d8239ccf9bf53bab5c8","modified":1542363196000},{"_id":"source/categories/index.md","hash":"01aaad46196103db69d1d2545e486453d0c4cafb","modified":1523782008000},{"_id":"source/categories/.DS_Store","hash":"45673a8ec47535550c1655fb6f129816c4bf94f9","modified":1523782076000},{"_id":"source/tags/index.md","hash":"758576e3a3061215a1c02f147bd5e8572df4f3a5","modified":1523781921000},{"_id":"themes/archer/.git/config","hash":"6998f51f0cc705be211a46fe87abdcd373a68c70","modified":1575187883284},{"_id":"themes/archer/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1575187883283},{"_id":"themes/archer/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1575187872506},{"_id":"themes/archer/.git/index","hash":"66a0157c7e1adb8ff75ad90b64def32c09a42de2","modified":1575187883318},{"_id":"source/_posts/scoped-model源码解析.md","hash":"8614e327992e563e26243b06488051e2f358e635","modified":1557152097650},{"_id":"themes/archer/.git/packed-refs","hash":"e6bb720318e32c3c1b55e1dd99bf981a6b74be00","modified":1575187883281},{"_id":"themes/archer/.git/shallow","hash":"277214e2809b9c62a00a663f98cf5a4a8204a215","modified":1575187876086},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1575187883290},{"_id":"themes/archer/docs/README-en.md","hash":"f325565c0bb94501fd046268659c7752709895d1","modified":1575187883291},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"0bb09c3c9d5f56820cb84e3316f60352b731d70c","modified":1575187883291},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"effc2bc9e0cecfd228b19283337ff29649ea5985","modified":1575187883291},{"_id":"themes/archer/languages/default.yml","hash":"d56b6923c70efdef09cd1f0270d7adc9cc338f6b","modified":1575187883292},{"_id":"themes/archer/languages/en.yml","hash":"ad75d3e5f7f5f0463d3077e1b5a26f40938a1faa","modified":1575187883293},{"_id":"themes/archer/layout/404.ejs","hash":"879641b1b5e49c43f2e096cad281f7d74df05127","modified":1575187883293},{"_id":"themes/archer/layout/index.ejs","hash":"716ba4a30860e36077dfdfffa02c1cd60301d8a3","modified":1575187883296},{"_id":"themes/archer/layout/about.ejs","hash":"06019d835c0a51fed8aa086d1dfcf368f9921b42","modified":1575187883296},{"_id":"themes/archer/layout/layout.ejs","hash":"08ebd10c1b2bfc11be8f5115a836a98e6c6ba13c","modified":1575187883296},{"_id":"themes/archer/layout/post.ejs","hash":"b61156aff41641a14d5e4e45d9fd776309f2801a","modified":1575187883296},{"_id":"themes/archer/layout/site-meta.ejs","hash":"d866aa1a892d4bfe3368f6dbd0f1baa8c5831947","modified":1575187883296},{"_id":"themes/archer/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1575187872508},{"_id":"themes/archer/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1575187872506},{"_id":"themes/archer/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1575187872507},{"_id":"themes/archer/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1575187872507},{"_id":"themes/archer/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1575187872507},{"_id":"themes/archer/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1575187872509},{"_id":"themes/archer/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1575187872507},{"_id":"themes/archer/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1575187872509},{"_id":"themes/archer/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1575187872508},{"_id":"themes/archer/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1575187872508},{"_id":"themes/archer/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1575187872506},{"_id":"themes/archer/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1575187872509},{"_id":"themes/archer/.git/logs/HEAD","hash":"c04db227dd219ebb180583e821307d7a0f553615","modified":1575187883283},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"012bd3afea5565204f75d8c89048ad33b9c2f948","modified":1575187883289},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"886fb1252702d46c89536b579d35ce49e53ec54d","modified":1575187883289},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"4bf3c8ebef14a81bb55e8e0468d816e83c4133ac","modified":1575187883289},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"82203d9a1c6e16ef2d37b8b587f56bf6d16edaf2","modified":1575187883293},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"2f5f9073378f628a9124792b5301c1540bc5a264","modified":1575187883293},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"7bfb8af21f7d30780d1a3af5484760b07b4fbb1d","modified":1575187883293},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"2aea84cb43f4479131620b3c3dfd7cebe9be36ba","modified":1575187883294},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"f2e8d4dfd11d879491a4b10f74f8c886cd392240","modified":1575187883293},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"12e28693dc53cab5f6fd389f15ea0f811c9c37e9","modified":1575187883293},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"743d97452d4ac358e631c43c9c2120aafdfd3e24","modified":1575187883294},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"2d068432031b3bebf9438c775370a2d1b4492d6b","modified":1575187883294},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"418559ab11726f69621c3a58cd21903adff1e48e","modified":1575187883294},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"cd0d34a811dc4666980d57c00d70dd82bd5450eb","modified":1575187883295},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1575187883299},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1575187883299},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1575187883298},{"_id":"themes/archer/source/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1575187883299},{"_id":"themes/archer/source/css/mobile.css","hash":"51d7b5cf26c8f82a3daad4bc55518673fdf281f5","modified":1575187883300},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1575187883299},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1575187883301},{"_id":"themes/archer/source/css/style.css","hash":"5d5e869db0c62957d59c6865baaecd1428c51804","modified":1575187883300},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1575187883302},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1575187883310},{"_id":"themes/archer/source/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1575187883311},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1575187883311},{"_id":"themes/archer/src/js/browser.js","hash":"ce061db99db5b880db0ddb768246352ca885b13c","modified":1575187883312},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1575187883311},{"_id":"themes/archer/src/js/fancybox.js","hash":"0daf0e83deca055102268e3bd95cb1962acc2264","modified":1575187883312},{"_id":"themes/archer/src/js/init.js","hash":"346c6ef75ae85e4350c1b0811985172fdaa0d3a5","modified":1575187883312},{"_id":"themes/archer/src/js/initSidebar.js","hash":"b25615ff254913db83e2a20263d445f35083843b","modified":1575187883312},{"_id":"themes/archer/src/js/main.js","hash":"e1a48d5822326792e38d44efee86e01473549eba","modified":1575187883312},{"_id":"themes/archer/src/js/scroll.js","hash":"aa2315a80daaa183a7e462c7e879ff9d2f050933","modified":1575187883313},{"_id":"themes/archer/src/js/share.js","hash":"1314b19a852e291e35d6809f7f58652d3e7c524c","modified":1575187883313},{"_id":"themes/archer/src/js/mobile.js","hash":"228a68d851517b5e47d2132f1d499cb812a64171","modified":1575187883312},{"_id":"themes/archer/src/js/search.js","hash":"2e59ac745da7c22801d9029cf9904a4fc3c384f1","modified":1575187883313},{"_id":"themes/archer/src/js/sidebar.js","hash":"68d5fe0ee5e86df810d304e5efe11e5e1fddc46d","modified":1575187883313},{"_id":"themes/archer/src/js/toc.js","hash":"b3482031e4c8728535d480bfaec76229469e3aba","modified":1575187883313},{"_id":"themes/archer/src/js/util.js","hash":"27de6446892bcf399430dd5776df0b8759ca0eea","modified":1575187883314},{"_id":"themes/archer/src/js/tag.js","hash":"e0f0a914c02922e42977d78dc4993b3855167cd8","modified":1575187883313},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1575187883314},{"_id":"themes/archer/src/scss/_variables.scss","hash":"136e5d990c4f8eadf6cabdfa5a053941e90bcd20","modified":1575187883317},{"_id":"themes/archer/src/scss/_common.scss","hash":"dedc313b082e0a16daf87213badd21b13be11af8","modified":1575187883314},{"_id":"themes/archer/src/scss/mobile.scss","hash":"aadc2fbf37fefc2ad391d8172d5b61817f9db0c5","modified":1575187883317},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"e7deb20a16868ae9d3e35ba3c5693de71fdf6999","modified":1575187883314},{"_id":"themes/archer/src/scss/style.scss","hash":"78e31370d45089b97fa91929345f1a29f2e6a0a2","modified":1575187883317},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1575187883294},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1575187883301},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1575187883302},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1575187883302},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1575187883303},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1575187883310},{"_id":"themes/archer/package-lock.json","hash":"89a3b67d32f6916cdc21d590d87e43d8a44be8c3","modified":1575187883298},{"_id":"themes/archer/.git/refs/heads/master","hash":"277214e2809b9c62a00a663f98cf5a4a8204a215","modified":1575187883283},{"_id":"themes/archer/.git/objects/pack/pack-f8fed2b1bba0dfab15feba1aa870dcde1da07f8d.idx","hash":"a3e667f45a19c1286054989a30db17c2d7e980ff","modified":1575187883273},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cadd97820a23d01d8b7e2f19a86e5290cef5a8a6","modified":1575187883294},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"7691642fb9375607e0ac988a7420999e242cb2c9","modified":1575187883294},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"794647a8a4ac9e1d01d74c07717175a141b1e01c","modified":1575187883294},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"b27469f19f35ec2037c7bce736a12e9dfb5e360b","modified":1575187883294},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"2154360e330dab94540e168e9d301c7b7091968e","modified":1575187883295},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"790d76f2667377db78a7d04bad8d629e47e7aab0","modified":1575187883295},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"c03e16a7741908c207bf58363dcd1349cb639ef8","modified":1575187883295},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"291cc0a4a444a93b93c32e2c39383c70e36e46de","modified":1575187883295},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"2d38af7cb5aabc0af99de239bd180c516ec4c56c","modified":1575187883295},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"daa78b17a773bca569f1c8ca2c916495ca138da6","modified":1575187883295},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"147214469c4909eb94943599883f9fa0f3cc090d","modified":1575187883296},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"d6e1a192cac5dcf365ce1a52df4f23feafeeb849","modified":1575187883296},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"a2b56f441a9a44d7f5b9b41eaa8136321328d7e9","modified":1575187883314},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"c679578d2feb0bd7d3f80c2f693ba58cbca4428b","modified":1575187883314},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"fa993cf0bbe0086cd8ec3d9a639b2d5b28ccfa8e","modified":1575187883314},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7c557844850d53cc4fc36aaf6d59847d8f238947","modified":1575187883316},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1575187883292},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1575187883306},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1575187883309},{"_id":"themes/archer/.git/logs/refs/heads/master","hash":"c04db227dd219ebb180583e821307d7a0f553615","modified":1575187883284},{"_id":"themes/archer/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1575187883283},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"a1569f39eccd64a12425d81b794c53df126a4d87","modified":1575187883315},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"726c543ee066e0b3222b236d9b4ef0109c0bdddf","modified":1575187883315},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"77003ff22b1a10fae2d2768938277959b3f93a72","modified":1575187883315},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1575187883315},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"f2514031f9d7e4ed4a126694e78618ce6ff3a574","modified":1575187883315},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"0c986b52ce9083f08c37c5c9b5de045ac5e1d2fa","modified":1575187883315},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"9c9a4e470da8732c9a3be3d5ce0d2f80f53714fe","modified":1575187883316},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"14bc42292873880c61b5fa9f47ee9d2e08d46871","modified":1575187883316},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"981a94978535769cb51c29e12b627f83c6fcedc5","modified":1575187883316},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"9ab6f96d0df0c4ad4c72e2515fa2599d487d8f1a","modified":1575187883316},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1575187883308},{"_id":"themes/archer/.git/logs/refs/remotes/origin/HEAD","hash":"c04db227dd219ebb180583e821307d7a0f553615","modified":1575187883282},{"_id":"themes/archer/.git/objects/pack/pack-f8fed2b1bba0dfab15feba1aa870dcde1da07f8d.pack","hash":"eaa1f47afcb757f87db409ea10cfd12cb8d9f59f","modified":1575187883272},{"_id":"public/content.json","hash":"4bcba1218f03a476cb4365b9139cda97b26dfbd3","modified":1575188105288},{"_id":"public/atom.xml","hash":"01241422c66fe3fe6bdb368ded065b7ce82f1338","modified":1575188105669},{"_id":"public/categories/index.html","hash":"0bde7920e7fbedfabc72a89eb800e1b0dcc4f815","modified":1575188105717},{"_id":"public/tags/index.html","hash":"0c8f1c76e81a55fcac5e8f5a942469188f47f03b","modified":1575188105718},{"_id":"public/2019/05/06/scoped-model源码解析/index.html","hash":"ddf99098d1ba2630144f33e6e4699cf0f7e5d977","modified":1575188105718},{"_id":"public/2019/04/25/Looper中的死循环/index.html","hash":"181b0c6d18684197f8952c4e7d2a32a1f0d77bf5","modified":1575188105718},{"_id":"public/2019/02/05/Jetpack中的LiveData/index.html","hash":"a46526fd236964fba0c874d7274d726d794eaa33","modified":1575188105718},{"_id":"public/2019/01/14/Jetpack中的Lifecycle/index.html","hash":"cd0e3ee578c8b1a31c308c1e422d52650b0aa99f","modified":1575188105718},{"_id":"public/2019/01/08/SparseArray源码解析/index.html","hash":"cdda49e003cfe29fd68c1f951ac67b4f9843d813","modified":1575188105718},{"_id":"public/2019/01/05/Jetpack中的ViewModel/index.html","hash":"aa19f534cd0d516adbe7a058497587e5938e538c","modified":1575188105718},{"_id":"public/2018/12/31/2018年复盘/index.html","hash":"7844cb7b2dc144ec9c9aa439703669ab9f7326e1","modified":1575188105718},{"_id":"public/2018/11/12/AppPlugin中的Task-第一篇/index.html","hash":"21fe3c19cbe1fea6950c7120a23d0dcdb849cfb8","modified":1575188105719},{"_id":"public/2018/11/09/ArrayList源码分析/index.html","hash":"49da4fe10c3c7198616512f2446a09b7d25c7ab4","modified":1575188105719},{"_id":"public/2018/11/07/HashMap源码分析/index.html","hash":"46eecea8a6f1c22d1268e86150e28105ce62fd6d","modified":1575188105719},{"_id":"public/2018/09/08/JavaScript正则表达式/index.html","hash":"4f425eaeac9efc6505e036f78ee5944d2fd53635","modified":1575188105719},{"_id":"public/2018/09/08/灵活使用位运算符/index.html","hash":"a6b06b4ac77ff2af44db5f02615ddb8a46351501","modified":1575188105719},{"_id":"public/2018/07/19/可拖拽的网格布局/index.html","hash":"f82695fcd68ebd51bbc8a6458a043d3cf6250264","modified":1575188105719},{"_id":"public/2018/05/21/Gradle插件-提高篇/index.html","hash":"468ac898a9f1ffaa4a9191e6ab457e49ace6faf1","modified":1575188105719},{"_id":"public/2018/05/16/Gradle插件-基础篇/index.html","hash":"50a062c3f157d39f2afd8c45b42e7c308e245ef2","modified":1575188105719},{"_id":"public/2018/05/08/Gradle多项目实践/index.html","hash":"5ea63ba27f7410bf16ab397ea97cffbcc72ee77a","modified":1575188105719},{"_id":"public/2018/04/29/Gradle多项目构建/index.html","hash":"e1676b010560f4fa60aa73d8b92121b12e1bf4c8","modified":1575188105719},{"_id":"public/2018/04/19/性能优化第一步/index.html","hash":"773e05184f2ea1c05ff671c13f3a8e46a235db45","modified":1575188105720},{"_id":"public/2018/04/12/熟悉又陌生的Context/index.html","hash":"a4ad6ddf80b90fa23be7a49dc0418ebf796a0500","modified":1575188105720},{"_id":"public/2018/04/11/hello-world/index.html","hash":"0b3cb7b4705328bad7dbaa56a777e4973a156ed4","modified":1575188105720},{"_id":"public/2018/04/03/触摸事件实践之路/index.html","hash":"7dd64a516a258ccc5cd2abe79a7f422ab265bd88","modified":1575188105720},{"_id":"public/2018/03/27/Activity启动流程-基于Android26/index.html","hash":"5722856581c1e01f16e031371072e5ace347ad6e","modified":1575188105720},{"_id":"public/2018/03/23/Android消息机制-Handler/index.html","hash":"13d1cb6b699cca3fbc916604b0088ec683127b54","modified":1575188105720},{"_id":"public/archives/index.html","hash":"aa797f21fe0cff4a471f8abde1735cd884aa649a","modified":1575188105720},{"_id":"public/archives/page/2/index.html","hash":"d115a2d2dd3ec32995de8e2a6f152d8c7ad38116","modified":1575188105721},{"_id":"public/archives/page/3/index.html","hash":"df857ad1fd307f17a301eadae50b4c4e9b4fbc1c","modified":1575188105721},{"_id":"public/archives/2018/index.html","hash":"8ec0f79623a3f22d29ff7401141c6e2f63800b5e","modified":1575188105721},{"_id":"public/archives/2018/page/2/index.html","hash":"b2b8fb8efb0366ebc3bef570d1c81a9383347fca","modified":1575188105721},{"_id":"public/archives/2018/03/index.html","hash":"02f0a7b015ec2e44a96aa63670898bcaf8f2c8fe","modified":1575188105721},{"_id":"public/archives/2018/04/index.html","hash":"270f8f6a825144b5acecc13011a46f72d61d7ba8","modified":1575188105721},{"_id":"public/archives/2018/05/index.html","hash":"b98bdb3e49679452b7ad5c5a4d70e36d2361a709","modified":1575188105721},{"_id":"public/archives/2018/07/index.html","hash":"057c71d7bdc0b18e187abc04abcb810e455e3355","modified":1575188105721},{"_id":"public/archives/2018/09/index.html","hash":"4a72bd6f7258e3ed80f90cab1496b9c43f646b85","modified":1575188105721},{"_id":"public/archives/2018/11/index.html","hash":"339e4750ea1a1fd5a89ea5df42226c578326b327","modified":1575188105721},{"_id":"public/archives/2018/12/index.html","hash":"4f3c0d4a6139bd1460ec9ef5526a92d64e20ee6b","modified":1575188105721},{"_id":"public/archives/2019/index.html","hash":"78381198fddef32c1629e63ecd361dd0e71e3f77","modified":1575188105722},{"_id":"public/archives/2019/01/index.html","hash":"e923c9029d6d129741ac5bd1f17db9d349880113","modified":1575188105722},{"_id":"public/archives/2019/02/index.html","hash":"a852dd8d03ccd2268fea210d4b2bdb7a07e5012d","modified":1575188105722},{"_id":"public/archives/2019/04/index.html","hash":"6c6b64dd1bd0ab648f0c5e730e939a184280c5bd","modified":1575188105722},{"_id":"public/archives/2019/05/index.html","hash":"3b9cbc89160e34a223a8281fb8eba0354abc1eb3","modified":1575188105722},{"_id":"public/categories/随笔/index.html","hash":"5f85c80f40f415a420b60d151c42d6df521b222f","modified":1575188105722},{"_id":"public/categories/Java/index.html","hash":"b78aaf6fcae57dafae721b5374a5d20a7e88d526","modified":1575188105722},{"_id":"public/categories/Android-Framework/index.html","hash":"d88efc197ea0202343d72191a6b02e94e6c4e4ff","modified":1575188105722},{"_id":"public/categories/Gradle/index.html","hash":"fd1235b27b7a1cbed9dbca973c33c10603eae622","modified":1575188105722},{"_id":"public/categories/Android-Application/index.html","hash":"19dc0d851bb47dd7c46d8f0e2cbebc9bf0a294d4","modified":1575188105722},{"_id":"public/categories/Flutter/index.html","hash":"3b9cbc89160e34a223a8281fb8eba0354abc1eb3","modified":1575188105722},{"_id":"public/tags/JavaScript/index.html","hash":"c5d45dd8acf2d0e7ea5d07fe8022a0346e13ecf9","modified":1575188105723},{"_id":"public/index.html","hash":"ca90229c1a3b12df15731c97d48e330bf17011b2","modified":1575188105723},{"_id":"public/page/2/index.html","hash":"6fb90084b7ee7cc7a301cc9337553f7fcf84b511","modified":1575188105723},{"_id":"public/page/3/index.html","hash":"f107ff58cf963a3a9845e71b5cc5a5e2409637c8","modified":1575188105723},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1575188105728},{"_id":"public/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1575188105728},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1575188105728},{"_id":"public/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1575188105728},{"_id":"public/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1575188105728},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1575188105729},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1575188105729},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1575188105731},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1575188105732},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1575188105733},{"_id":"public/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1575188105733},{"_id":"public/css/mobile.css","hash":"51d7b5cf26c8f82a3daad4bc55518673fdf281f5","modified":1575188105736},{"_id":"public/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1575188105737},{"_id":"public/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1575188105737},{"_id":"public/css/style.css","hash":"5d5e869db0c62957d59c6865baaecd1428c51804","modified":1575188105737},{"_id":"public/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1575188105737},{"_id":"public/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1575188105737},{"_id":"public/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1575188105737},{"_id":"public/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1575188105743},{"_id":"public/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1575188105743},{"_id":"public/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1575188105745}],"Category":[{"name":"随笔","_id":"ck3mqbs0o0003e39kaoyythr0"},{"name":"Java","_id":"ck3mqbs0t0007e39kna9aiszu"},{"name":"Android Framework","_id":"ck3mqbs0v000be39kh3ex4flk"},{"name":"Gradle","_id":"ck3mqbs12000ie39ki44a01gp"},{"name":"Android Application","_id":"ck3mqbs1d0017e39kghs1klcj"},{"name":"Flutter","_id":"ck3mqbs1o001te39kbkc4pw0p"}],"Data":[],"Page":[{"title":"categories","date":"2018-04-15T08:45:33.000Z","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-04-15 16:45:33\nlayout: categories\ncomments: false\n---\n","updated":"2018-04-15T08:46:48.000Z","path":"categories/index.html","_id":"ck3mqbs0l0001e39k2m1ypqtr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","layout":"tags","comments":0,"date":"2018-04-15T08:44:13.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\nlayout: tags\ncomments: false\ndate: 2018-04-15 16:44:13\n---\n","updated":"2018-04-15T08:45:21.000Z","path":"tags/index.html","_id":"ck3mqbs1n001re39knda0ummo","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2018年复盘","date":"2018-12-31T15:25:06.000Z","_content":"\n2018也到了尾声，这一年感觉经历了较之往年更多的事情，比如有了想守护一辈子的另一半，一年之间换了两次工作，面了很多试。。。\n算算从毕业工作到现在也有三年多了，一直做着 Android 开发，说起来入门 Android 真的是非常巧合，大学的专业不是软件工程，虽然说跟计算机有点联系，但课程跟软件有点联系的，也就 C 语言，数据库和网络课程等，编程基础的数据结构算法，这些都没有。那时候对编程的认识，也仅限于很模糊的 \"很酷的黑客\"，大一大二的时候也开始自学数据结构和算法知识，很可惜都没有坚持下去，那时候感觉很枯燥，每次都是信心满满然后又半途而废，学过 c++，c#，还用过 qt，可惜要么是学了基础语法后就没实用过，要么是跟着教程写了个粗糙的页面就放弃了。现在想起来也是挺可笑的，那时候甚至没明白 GUI 编程，想着为什么写来写去都是这黑黑的控制台。那时候跟着网上教程写了贪吃蛇游戏，都能自豪好久。直到今天我都觉得真的是非常可惜那时候没有找准学习的方向。\n如果说对大学期间的编程学习做下复盘的话，我觉得那时候最大的失误是，没有去接触外面的编程世界，甚至都没有用好搜索，只是沉浸在个人世界中。\n但是人生永远没有后悔药吃，这段经历永远告诉我，看事情要站在一定的高度上，这样思考才能最大程度的避免局限性。\n大学就这样浑浑噩噩的度过，直到开始找工作，那时候真的不知道自己能干什么，那时候有个老师和同学都跟我说过，现在移动端发展不错可以试试。反正自己也没啥一技之长，就去了解了下，跟很多入门 Android 的同学一样，因为没有苹果设备而放弃了 iOS 开发。知道 Android 需要学习 Java ，就花了一个星期学了基础语法。那时候学习 Android 是从一个视频学校网站上学的，跟着视频一点点手打了一个程序，所以不知道什么意思但也成功运行起来了。就这样，学了两个星期就开始找工作，第一面就失败了，影响深刻，当时人家问了什么是四大组件，没答上来就说了个 Activity，23333，接着问了我那个程序的实现原理，支支吾吾说不上了。接着去面了家 web 开发的岗位，那时候还天真的以为 web 开发是写 html，css 后来才发现人家招的是后端人员，开始让我写了一套题目，还有手写排序，写完了，有个小伙子进来面试，问我用过什么框架，我说没有用过。然后就问了一些其他的，没记清，因为那时候不懂前端开发和后端开发，所以估计也是答的乱七八糟。最后人家让回去等消息，自己还以为是还有机会。。。\n最后还是找到了实习工作，在一家十几个人的小公司，开发人员加上我就两个，面试的时候，估计另外一个开发不懂移动开发，所以老板就让我回去做个从网络获取数据的页面，我花了几天时间，不断百度，拼了个页面发给老板，老板说可以了去实习了。。公司就我一个几乎零基础的 Android 开发，从零开始搭建项目，甚至连对接后端的人员都没有，说是在招了，但到我离职都没有。老板就让我自己去摸索，那时候每天的工作内容就是不断的学习 Android 知识，看博客，看视频去积累，这里特别感谢下郭大神，郭霖，真正意义上的启蒙老师。从他的博客学习了太多的知识了。在那里实习了两个月，说来惭愧最后没写出什么来，就做了几个列表页面。。。接口是自己从工作的外包出去的 web 项目源码中找到了\n虽然两个月的实习很短，但让我接触到了 Android 开发入门的门槛。感谢郭大神，感谢实习公司的老板。\n讲完了入门的经历，再来讲讲今年在开发技能上的得与失。\n掌握了 gradle shell 等脚本编程，能通过搜索辅助，实现一些持续构建，优化打包的需求。在新语言上面，kotlin 和 js 也更加熟练了，特别是 kotlin 以后 Android 开发的主力语言。开始去刷 Leetcode，掌握了更为全面的知识后，开发信心上也得到了提升。\n本来年初想着今年的能在 Android Framework 和 逆向安全上面有所提升，可惜也是三天打鱼两天晒网。这也是今年心态上的一个写照，心急。总想着快速去学习不同的新东西，尝试过小程序，前端开发，flutter 等等，总是怕落后别人，但都没有去深入。哎\n以前一直以为自己是个独行侠，暂时不会在感情上有所投入，但至少她进入我的生活后，才发现原来每天下班回到出租屋中，有个人在等你回来的感觉是这么的好。才意识到认认真真生活真的是非常美好。当你真正想去照顾一个人的时候，你就像是一瞬间长大的大人。\n工作上，今年竟然换了两家工作，这种太过频繁的跳动，其实是我不愿意看到的。因为每到一家新公司都需要一段时间去融入新环境。哎，只能说计划赶不上变化。\n新的一年里，我希望在学习上，能够沉下心去，完完整整，有计划地去学习某个知识点。工作上能够稳定，在现在这家公司不断锤炼自己的技能。生活上能够给予我所爱的人一片天空。\n最后希望我所爱的人，和爱我的人身体健康。\n2018.12.31 23.06","source":"_posts/2018年复盘.md","raw":"---\ntitle: 2018年复盘\ndate: 2018-12-31 23:25:06\ncategories: 随笔\ntags:\n---\n\n2018也到了尾声，这一年感觉经历了较之往年更多的事情，比如有了想守护一辈子的另一半，一年之间换了两次工作，面了很多试。。。\n算算从毕业工作到现在也有三年多了，一直做着 Android 开发，说起来入门 Android 真的是非常巧合，大学的专业不是软件工程，虽然说跟计算机有点联系，但课程跟软件有点联系的，也就 C 语言，数据库和网络课程等，编程基础的数据结构算法，这些都没有。那时候对编程的认识，也仅限于很模糊的 \"很酷的黑客\"，大一大二的时候也开始自学数据结构和算法知识，很可惜都没有坚持下去，那时候感觉很枯燥，每次都是信心满满然后又半途而废，学过 c++，c#，还用过 qt，可惜要么是学了基础语法后就没实用过，要么是跟着教程写了个粗糙的页面就放弃了。现在想起来也是挺可笑的，那时候甚至没明白 GUI 编程，想着为什么写来写去都是这黑黑的控制台。那时候跟着网上教程写了贪吃蛇游戏，都能自豪好久。直到今天我都觉得真的是非常可惜那时候没有找准学习的方向。\n如果说对大学期间的编程学习做下复盘的话，我觉得那时候最大的失误是，没有去接触外面的编程世界，甚至都没有用好搜索，只是沉浸在个人世界中。\n但是人生永远没有后悔药吃，这段经历永远告诉我，看事情要站在一定的高度上，这样思考才能最大程度的避免局限性。\n大学就这样浑浑噩噩的度过，直到开始找工作，那时候真的不知道自己能干什么，那时候有个老师和同学都跟我说过，现在移动端发展不错可以试试。反正自己也没啥一技之长，就去了解了下，跟很多入门 Android 的同学一样，因为没有苹果设备而放弃了 iOS 开发。知道 Android 需要学习 Java ，就花了一个星期学了基础语法。那时候学习 Android 是从一个视频学校网站上学的，跟着视频一点点手打了一个程序，所以不知道什么意思但也成功运行起来了。就这样，学了两个星期就开始找工作，第一面就失败了，影响深刻，当时人家问了什么是四大组件，没答上来就说了个 Activity，23333，接着问了我那个程序的实现原理，支支吾吾说不上了。接着去面了家 web 开发的岗位，那时候还天真的以为 web 开发是写 html，css 后来才发现人家招的是后端人员，开始让我写了一套题目，还有手写排序，写完了，有个小伙子进来面试，问我用过什么框架，我说没有用过。然后就问了一些其他的，没记清，因为那时候不懂前端开发和后端开发，所以估计也是答的乱七八糟。最后人家让回去等消息，自己还以为是还有机会。。。\n最后还是找到了实习工作，在一家十几个人的小公司，开发人员加上我就两个，面试的时候，估计另外一个开发不懂移动开发，所以老板就让我回去做个从网络获取数据的页面，我花了几天时间，不断百度，拼了个页面发给老板，老板说可以了去实习了。。公司就我一个几乎零基础的 Android 开发，从零开始搭建项目，甚至连对接后端的人员都没有，说是在招了，但到我离职都没有。老板就让我自己去摸索，那时候每天的工作内容就是不断的学习 Android 知识，看博客，看视频去积累，这里特别感谢下郭大神，郭霖，真正意义上的启蒙老师。从他的博客学习了太多的知识了。在那里实习了两个月，说来惭愧最后没写出什么来，就做了几个列表页面。。。接口是自己从工作的外包出去的 web 项目源码中找到了\n虽然两个月的实习很短，但让我接触到了 Android 开发入门的门槛。感谢郭大神，感谢实习公司的老板。\n讲完了入门的经历，再来讲讲今年在开发技能上的得与失。\n掌握了 gradle shell 等脚本编程，能通过搜索辅助，实现一些持续构建，优化打包的需求。在新语言上面，kotlin 和 js 也更加熟练了，特别是 kotlin 以后 Android 开发的主力语言。开始去刷 Leetcode，掌握了更为全面的知识后，开发信心上也得到了提升。\n本来年初想着今年的能在 Android Framework 和 逆向安全上面有所提升，可惜也是三天打鱼两天晒网。这也是今年心态上的一个写照，心急。总想着快速去学习不同的新东西，尝试过小程序，前端开发，flutter 等等，总是怕落后别人，但都没有去深入。哎\n以前一直以为自己是个独行侠，暂时不会在感情上有所投入，但至少她进入我的生活后，才发现原来每天下班回到出租屋中，有个人在等你回来的感觉是这么的好。才意识到认认真真生活真的是非常美好。当你真正想去照顾一个人的时候，你就像是一瞬间长大的大人。\n工作上，今年竟然换了两家工作，这种太过频繁的跳动，其实是我不愿意看到的。因为每到一家新公司都需要一段时间去融入新环境。哎，只能说计划赶不上变化。\n新的一年里，我希望在学习上，能够沉下心去，完完整整，有计划地去学习某个知识点。工作上能够稳定，在现在这家公司不断锤炼自己的技能。生活上能够给予我所爱的人一片天空。\n最后希望我所爱的人，和爱我的人身体健康。\n2018.12.31 23.06","slug":"2018年复盘","published":1,"updated":"2018-12-31T15:26:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs0i0000e39kvtkx8tmd","content":"<p>2018也到了尾声，这一年感觉经历了较之往年更多的事情，比如有了想守护一辈子的另一半，一年之间换了两次工作，面了很多试。。。<br>算算从毕业工作到现在也有三年多了，一直做着 Android 开发，说起来入门 Android 真的是非常巧合，大学的专业不是软件工程，虽然说跟计算机有点联系，但课程跟软件有点联系的，也就 C 语言，数据库和网络课程等，编程基础的数据结构算法，这些都没有。那时候对编程的认识，也仅限于很模糊的 “很酷的黑客”，大一大二的时候也开始自学数据结构和算法知识，很可惜都没有坚持下去，那时候感觉很枯燥，每次都是信心满满然后又半途而废，学过 c++，c#，还用过 qt，可惜要么是学了基础语法后就没实用过，要么是跟着教程写了个粗糙的页面就放弃了。现在想起来也是挺可笑的，那时候甚至没明白 GUI 编程，想着为什么写来写去都是这黑黑的控制台。那时候跟着网上教程写了贪吃蛇游戏，都能自豪好久。直到今天我都觉得真的是非常可惜那时候没有找准学习的方向。<br>如果说对大学期间的编程学习做下复盘的话，我觉得那时候最大的失误是，没有去接触外面的编程世界，甚至都没有用好搜索，只是沉浸在个人世界中。<br>但是人生永远没有后悔药吃，这段经历永远告诉我，看事情要站在一定的高度上，这样思考才能最大程度的避免局限性。<br>大学就这样浑浑噩噩的度过，直到开始找工作，那时候真的不知道自己能干什么，那时候有个老师和同学都跟我说过，现在移动端发展不错可以试试。反正自己也没啥一技之长，就去了解了下，跟很多入门 Android 的同学一样，因为没有苹果设备而放弃了 iOS 开发。知道 Android 需要学习 Java ，就花了一个星期学了基础语法。那时候学习 Android 是从一个视频学校网站上学的，跟着视频一点点手打了一个程序，所以不知道什么意思但也成功运行起来了。就这样，学了两个星期就开始找工作，第一面就失败了，影响深刻，当时人家问了什么是四大组件，没答上来就说了个 Activity，23333，接着问了我那个程序的实现原理，支支吾吾说不上了。接着去面了家 web 开发的岗位，那时候还天真的以为 web 开发是写 html，css 后来才发现人家招的是后端人员，开始让我写了一套题目，还有手写排序，写完了，有个小伙子进来面试，问我用过什么框架，我说没有用过。然后就问了一些其他的，没记清，因为那时候不懂前端开发和后端开发，所以估计也是答的乱七八糟。最后人家让回去等消息，自己还以为是还有机会。。。<br>最后还是找到了实习工作，在一家十几个人的小公司，开发人员加上我就两个，面试的时候，估计另外一个开发不懂移动开发，所以老板就让我回去做个从网络获取数据的页面，我花了几天时间，不断百度，拼了个页面发给老板，老板说可以了去实习了。。公司就我一个几乎零基础的 Android 开发，从零开始搭建项目，甚至连对接后端的人员都没有，说是在招了，但到我离职都没有。老板就让我自己去摸索，那时候每天的工作内容就是不断的学习 Android 知识，看博客，看视频去积累，这里特别感谢下郭大神，郭霖，真正意义上的启蒙老师。从他的博客学习了太多的知识了。在那里实习了两个月，说来惭愧最后没写出什么来，就做了几个列表页面。。。接口是自己从工作的外包出去的 web 项目源码中找到了<br>虽然两个月的实习很短，但让我接触到了 Android 开发入门的门槛。感谢郭大神，感谢实习公司的老板。<br>讲完了入门的经历，再来讲讲今年在开发技能上的得与失。<br>掌握了 gradle shell 等脚本编程，能通过搜索辅助，实现一些持续构建，优化打包的需求。在新语言上面，kotlin 和 js 也更加熟练了，特别是 kotlin 以后 Android 开发的主力语言。开始去刷 Leetcode，掌握了更为全面的知识后，开发信心上也得到了提升。<br>本来年初想着今年的能在 Android Framework 和 逆向安全上面有所提升，可惜也是三天打鱼两天晒网。这也是今年心态上的一个写照，心急。总想着快速去学习不同的新东西，尝试过小程序，前端开发，flutter 等等，总是怕落后别人，但都没有去深入。哎<br>以前一直以为自己是个独行侠，暂时不会在感情上有所投入，但至少她进入我的生活后，才发现原来每天下班回到出租屋中，有个人在等你回来的感觉是这么的好。才意识到认认真真生活真的是非常美好。当你真正想去照顾一个人的时候，你就像是一瞬间长大的大人。<br>工作上，今年竟然换了两家工作，这种太过频繁的跳动，其实是我不愿意看到的。因为每到一家新公司都需要一段时间去融入新环境。哎，只能说计划赶不上变化。<br>新的一年里，我希望在学习上，能够沉下心去，完完整整，有计划地去学习某个知识点。工作上能够稳定，在现在这家公司不断锤炼自己的技能。生活上能够给予我所爱的人一片天空。<br>最后希望我所爱的人，和爱我的人身体健康。<br>2018.12.31 23.06</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2018也到了尾声，这一年感觉经历了较之往年更多的事情，比如有了想守护一辈子的另一半，一年之间换了两次工作，面了很多试。。。<br>算算从毕业工作到现在也有三年多了，一直做着 Android 开发，说起来入门 Android 真的是非常巧合，大学的专业不是软件工程，虽然说跟计算机有点联系，但课程跟软件有点联系的，也就 C 语言，数据库和网络课程等，编程基础的数据结构算法，这些都没有。那时候对编程的认识，也仅限于很模糊的 “很酷的黑客”，大一大二的时候也开始自学数据结构和算法知识，很可惜都没有坚持下去，那时候感觉很枯燥，每次都是信心满满然后又半途而废，学过 c++，c#，还用过 qt，可惜要么是学了基础语法后就没实用过，要么是跟着教程写了个粗糙的页面就放弃了。现在想起来也是挺可笑的，那时候甚至没明白 GUI 编程，想着为什么写来写去都是这黑黑的控制台。那时候跟着网上教程写了贪吃蛇游戏，都能自豪好久。直到今天我都觉得真的是非常可惜那时候没有找准学习的方向。<br>如果说对大学期间的编程学习做下复盘的话，我觉得那时候最大的失误是，没有去接触外面的编程世界，甚至都没有用好搜索，只是沉浸在个人世界中。<br>但是人生永远没有后悔药吃，这段经历永远告诉我，看事情要站在一定的高度上，这样思考才能最大程度的避免局限性。<br>大学就这样浑浑噩噩的度过，直到开始找工作，那时候真的不知道自己能干什么，那时候有个老师和同学都跟我说过，现在移动端发展不错可以试试。反正自己也没啥一技之长，就去了解了下，跟很多入门 Android 的同学一样，因为没有苹果设备而放弃了 iOS 开发。知道 Android 需要学习 Java ，就花了一个星期学了基础语法。那时候学习 Android 是从一个视频学校网站上学的，跟着视频一点点手打了一个程序，所以不知道什么意思但也成功运行起来了。就这样，学了两个星期就开始找工作，第一面就失败了，影响深刻，当时人家问了什么是四大组件，没答上来就说了个 Activity，23333，接着问了我那个程序的实现原理，支支吾吾说不上了。接着去面了家 web 开发的岗位，那时候还天真的以为 web 开发是写 html，css 后来才发现人家招的是后端人员，开始让我写了一套题目，还有手写排序，写完了，有个小伙子进来面试，问我用过什么框架，我说没有用过。然后就问了一些其他的，没记清，因为那时候不懂前端开发和后端开发，所以估计也是答的乱七八糟。最后人家让回去等消息，自己还以为是还有机会。。。<br>最后还是找到了实习工作，在一家十几个人的小公司，开发人员加上我就两个，面试的时候，估计另外一个开发不懂移动开发，所以老板就让我回去做个从网络获取数据的页面，我花了几天时间，不断百度，拼了个页面发给老板，老板说可以了去实习了。。公司就我一个几乎零基础的 Android 开发，从零开始搭建项目，甚至连对接后端的人员都没有，说是在招了，但到我离职都没有。老板就让我自己去摸索，那时候每天的工作内容就是不断的学习 Android 知识，看博客，看视频去积累，这里特别感谢下郭大神，郭霖，真正意义上的启蒙老师。从他的博客学习了太多的知识了。在那里实习了两个月，说来惭愧最后没写出什么来，就做了几个列表页面。。。接口是自己从工作的外包出去的 web 项目源码中找到了<br>虽然两个月的实习很短，但让我接触到了 Android 开发入门的门槛。感谢郭大神，感谢实习公司的老板。<br>讲完了入门的经历，再来讲讲今年在开发技能上的得与失。<br>掌握了 gradle shell 等脚本编程，能通过搜索辅助，实现一些持续构建，优化打包的需求。在新语言上面，kotlin 和 js 也更加熟练了，特别是 kotlin 以后 Android 开发的主力语言。开始去刷 Leetcode，掌握了更为全面的知识后，开发信心上也得到了提升。<br>本来年初想着今年的能在 Android Framework 和 逆向安全上面有所提升，可惜也是三天打鱼两天晒网。这也是今年心态上的一个写照，心急。总想着快速去学习不同的新东西，尝试过小程序，前端开发，flutter 等等，总是怕落后别人，但都没有去深入。哎<br>以前一直以为自己是个独行侠，暂时不会在感情上有所投入，但至少她进入我的生活后，才发现原来每天下班回到出租屋中，有个人在等你回来的感觉是这么的好。才意识到认认真真生活真的是非常美好。当你真正想去照顾一个人的时候，你就像是一瞬间长大的大人。<br>工作上，今年竟然换了两家工作，这种太过频繁的跳动，其实是我不愿意看到的。因为每到一家新公司都需要一段时间去融入新环境。哎，只能说计划赶不上变化。<br>新的一年里，我希望在学习上，能够沉下心去，完完整整，有计划地去学习某个知识点。工作上能够稳定，在现在这家公司不断锤炼自己的技能。生活上能够给予我所爱的人一片天空。<br>最后希望我所爱的人，和爱我的人身体健康。<br>2018.12.31 23.06</p>\n"},{"title":"ArrayList源码分析","date":"2018-11-09T02:16:12.000Z","_content":"\n### 构造函数\n\nArrayList 的构造函数有三个：\n\n* `ArrayList()`\n* `ArrayList(int)`\n* `ArrayList(Collection<? extends E>)`\n\n其中用的最多的是无参默认构造函数，ArrayList 底层是使用数组实现的，这里初始化一个空数组\n\n``` java\npublic ArrayList() {                                     \n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n} \n\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n```\n\n如果传入指定的容量（initialCapacity），则会初始化指定大小的数组\n\n### add 操作\n\n调用 `add(value)` 会在列表的尾部添加一个元素\n\n``` java\npublic boolean add(E e) {                                                  \n    ensureCapacityInternal(size + 1);  // Increments modCount!!            \n    elementData[size++] = e;                                               \n    return true;                                                           \n}\n\nprivate void ensureCapacityInternal(int minCapacity) {                  \n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        // 如果是初始化，则使用 DEFAULT_CAPACITY = 10\n        return Math.max(DEFAULT_CAPACITY, minCapacity);                       \n    }                                                                         \n    return minCapacity;                                                       \n}\n\nprivate void ensureExplicitCapacity(int minCapacity) { \n    modCount++;                                        \n                                                       \n    // overflow-conscious code                         \n    if (minCapacity - elementData.length > 0) // 需要扩容          \n        grow(minCapacity);                             \n}\n\n// 可使用的数组最大容量，一些虚拟机会在数组中保留一个头部字段\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\nprivate void grow(int minCapacity) {                           \n    // overflow-conscious code 考虑溢出情况                                 \n    int oldCapacity = elementData.length;\n    // 增加旧容量 * 0.5 = 旧容量 * 1.5\n    int newCapacity = oldCapacity + (oldCapacity >> 1);        \n    if (newCapacity - minCapacity < 0)                         \n        newCapacity = minCapacity;     // 还不够大，直接用 minCapacity                       \n    if (newCapacity - MAX_ARRAY_SIZE > 0)  // 大于允许的最大容量                    \n        newCapacity = hugeCapacity(minCapacity);               \n    // minCapacity is usually close to size, so this is a win: \n    elementData = Arrays.copyOf(elementData, newCapacity);     \n}\n\nprivate static int hugeCapacity(int minCapacity) { \n    if (minCapacity < 0) // overflow // 超过 Integer.MAX_VALUE，变成负值             \n        throw new OutOfMemoryError();              \n    return (minCapacity > MAX_ARRAY_SIZE) ?        \n        Integer.MAX_VALUE :                        \n        MAX_ARRAY_SIZE;                            \n}                                                  \n```\n\n> 允许添加 null\n\n### remove 操作\n\n调用 `remove(int)` 删除指定下标的元素\n\n``` java\npublic E remove(int index) {\n    // 下标范围检查\n    rangeCheck(index);                                                   \n                                                                         \n    modCount++;                                                          \n    E oldValue = elementData(index);                                     \n    \n    // 需要移动的个数\n    int numMoved = size - index - 1;                                     \n    if (numMoved > 0)\n        // 元素拷贝移动\n        System.arraycopy(elementData, index+1, elementData, index,       \n                         numMoved);                                      \n    elementData[--size] = null; // clear to let GC do its work           \n                                                                         \n    return oldValue;                                                     \n}                                                                        \n```\n\n调用 `remove(object)` 删除指定元素\n\n``` java\npublic boolean remove(Object o) {                      \n    if (o == null) {\n        // 如果删除 null 元素\n        for (int index = 0; index < size; index++)     \n            if (elementData[index] == null) {          \n                fastRemove(index);                     \n                return true;                           \n            }                                          \n    } else {                                           \n        for (int index = 0; index < size; index++)\n            // 调用 equals 判断\n            if (o.equals(elementData[index])) {        \n                fastRemove(index);                     \n                return true;                           \n            }                                          \n    }                                                  \n    return false;                                      \n} \nprivate void fastRemove(int index) {                                       \n    modCount++;                                                            \n    int numMoved = size - index - 1;                                       \n    if (numMoved > 0)                                                      \n        System.arraycopy(elementData, index+1, elementData, index,         \n                         numMoved);                                        \n    elementData[--size] = null; // clear to let GC do its work             \n}                                                                                                                               \n```\n\n","source":"_posts/ArrayList源码分析.md","raw":"---\ntitle: ArrayList源码分析\ndate: 2018-11-09 10:16:12\ncategories: Java\ntags:\n---\n\n### 构造函数\n\nArrayList 的构造函数有三个：\n\n* `ArrayList()`\n* `ArrayList(int)`\n* `ArrayList(Collection<? extends E>)`\n\n其中用的最多的是无参默认构造函数，ArrayList 底层是使用数组实现的，这里初始化一个空数组\n\n``` java\npublic ArrayList() {                                     \n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n} \n\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n```\n\n如果传入指定的容量（initialCapacity），则会初始化指定大小的数组\n\n### add 操作\n\n调用 `add(value)` 会在列表的尾部添加一个元素\n\n``` java\npublic boolean add(E e) {                                                  \n    ensureCapacityInternal(size + 1);  // Increments modCount!!            \n    elementData[size++] = e;                                               \n    return true;                                                           \n}\n\nprivate void ensureCapacityInternal(int minCapacity) {                  \n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        // 如果是初始化，则使用 DEFAULT_CAPACITY = 10\n        return Math.max(DEFAULT_CAPACITY, minCapacity);                       \n    }                                                                         \n    return minCapacity;                                                       \n}\n\nprivate void ensureExplicitCapacity(int minCapacity) { \n    modCount++;                                        \n                                                       \n    // overflow-conscious code                         \n    if (minCapacity - elementData.length > 0) // 需要扩容          \n        grow(minCapacity);                             \n}\n\n// 可使用的数组最大容量，一些虚拟机会在数组中保留一个头部字段\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\nprivate void grow(int minCapacity) {                           \n    // overflow-conscious code 考虑溢出情况                                 \n    int oldCapacity = elementData.length;\n    // 增加旧容量 * 0.5 = 旧容量 * 1.5\n    int newCapacity = oldCapacity + (oldCapacity >> 1);        \n    if (newCapacity - minCapacity < 0)                         \n        newCapacity = minCapacity;     // 还不够大，直接用 minCapacity                       \n    if (newCapacity - MAX_ARRAY_SIZE > 0)  // 大于允许的最大容量                    \n        newCapacity = hugeCapacity(minCapacity);               \n    // minCapacity is usually close to size, so this is a win: \n    elementData = Arrays.copyOf(elementData, newCapacity);     \n}\n\nprivate static int hugeCapacity(int minCapacity) { \n    if (minCapacity < 0) // overflow // 超过 Integer.MAX_VALUE，变成负值             \n        throw new OutOfMemoryError();              \n    return (minCapacity > MAX_ARRAY_SIZE) ?        \n        Integer.MAX_VALUE :                        \n        MAX_ARRAY_SIZE;                            \n}                                                  \n```\n\n> 允许添加 null\n\n### remove 操作\n\n调用 `remove(int)` 删除指定下标的元素\n\n``` java\npublic E remove(int index) {\n    // 下标范围检查\n    rangeCheck(index);                                                   \n                                                                         \n    modCount++;                                                          \n    E oldValue = elementData(index);                                     \n    \n    // 需要移动的个数\n    int numMoved = size - index - 1;                                     \n    if (numMoved > 0)\n        // 元素拷贝移动\n        System.arraycopy(elementData, index+1, elementData, index,       \n                         numMoved);                                      \n    elementData[--size] = null; // clear to let GC do its work           \n                                                                         \n    return oldValue;                                                     \n}                                                                        \n```\n\n调用 `remove(object)` 删除指定元素\n\n``` java\npublic boolean remove(Object o) {                      \n    if (o == null) {\n        // 如果删除 null 元素\n        for (int index = 0; index < size; index++)     \n            if (elementData[index] == null) {          \n                fastRemove(index);                     \n                return true;                           \n            }                                          \n    } else {                                           \n        for (int index = 0; index < size; index++)\n            // 调用 equals 判断\n            if (o.equals(elementData[index])) {        \n                fastRemove(index);                     \n                return true;                           \n            }                                          \n    }                                                  \n    return false;                                      \n} \nprivate void fastRemove(int index) {                                       \n    modCount++;                                                            \n    int numMoved = size - index - 1;                                       \n    if (numMoved > 0)                                                      \n        System.arraycopy(elementData, index+1, elementData, index,         \n                         numMoved);                                        \n    elementData[--size] = null; // clear to let GC do its work             \n}                                                                                                                               \n```\n\n","slug":"ArrayList源码分析","published":1,"updated":"2019-01-09T06:39:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs0m0002e39kltlfodye","content":"<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>ArrayList 的构造函数有三个：</p>\n<ul>\n<li><code>ArrayList()</code></li>\n<li><code>ArrayList(int)</code></li>\n<li><code>ArrayList(Collection&lt;? extends E&gt;)</code></li>\n</ul>\n<p>其中用的最多的是无参默认构造函数，ArrayList 底层是使用数组实现的，这里初始化一个空数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果传入指定的容量（initialCapacity），则会初始化指定大小的数组</p>\n<h3 id=\"add-操作\"><a href=\"#add-操作\" class=\"headerlink\" title=\"add 操作\"></a>add 操作</h3><p>调用 <code>add(value)</code> 会在列表的尾部添加一个元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;                                                  </span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!            </span></span><br><span class=\"line\">    elementData[size++] = e;                                               </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                           </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;                  </span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是初始化，则使用 DEFAULT_CAPACITY = 10</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);                       </span><br><span class=\"line\">    &#125;                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;                                                       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123; </span><br><span class=\"line\">    modCount++;                                        </span><br><span class=\"line\">                                                       </span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code                         </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>) <span class=\"comment\">// 需要扩容          </span></span><br><span class=\"line\">        grow(minCapacity);                             </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可使用的数组最大容量，一些虚拟机会在数组中保留一个头部字段</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;                           </span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code 考虑溢出情况                                 </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// 增加旧容量 * 0.5 = 旧容量 * 1.5</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);        </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)                         </span><br><span class=\"line\">        newCapacity = minCapacity;     <span class=\"comment\">// 还不够大，直接用 minCapacity                       </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)  <span class=\"comment\">// 大于允许的最大容量                    </span></span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);               </span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win: </span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow // 超过 Integer.MAX_VALUE，变成负值             </span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();              </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?        </span><br><span class=\"line\">        Integer.MAX_VALUE :                        </span><br><span class=\"line\">        MAX_ARRAY_SIZE;                            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>允许添加 null</p>\n</blockquote>\n<h3 id=\"remove-操作\"><a href=\"#remove-操作\" class=\"headerlink\" title=\"remove 操作\"></a>remove 操作</h3><p>调用 <code>remove(int)</code> 删除指定下标的元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标范围检查</span></span><br><span class=\"line\">    rangeCheck(index);                                                   </span><br><span class=\"line\">                                                                         </span><br><span class=\"line\">    modCount++;                                                          </span><br><span class=\"line\">    E oldValue = elementData(index);                                     </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 需要移动的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 元素拷贝移动</span></span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,       </span><br><span class=\"line\">                         numMoved);                                      </span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work           </span></span><br><span class=\"line\">                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用 <code>remove(object)</code> 删除指定元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果删除 null 元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)     </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;          </span><br><span class=\"line\">                fastRemove(index);                     </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                           </span><br><span class=\"line\">            &#125;                                          </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                           </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"comment\">// 调用 equals 判断</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;        </span><br><span class=\"line\">                fastRemove(index);                     </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                           </span><br><span class=\"line\">            &#125;                                          </span><br><span class=\"line\">    &#125;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                      </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;                                       </span><br><span class=\"line\">    modCount++;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)                                                      </span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,         </span><br><span class=\"line\">                         numMoved);                                        </span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work             </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>ArrayList 的构造函数有三个：</p>\n<ul>\n<li><code>ArrayList()</code></li>\n<li><code>ArrayList(int)</code></li>\n<li><code>ArrayList(Collection&lt;? extends E&gt;)</code></li>\n</ul>\n<p>其中用的最多的是无参默认构造函数，ArrayList 底层是使用数组实现的，这里初始化一个空数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果传入指定的容量（initialCapacity），则会初始化指定大小的数组</p>\n<h3 id=\"add-操作\"><a href=\"#add-操作\" class=\"headerlink\" title=\"add 操作\"></a>add 操作</h3><p>调用 <code>add(value)</code> 会在列表的尾部添加一个元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;                                                  </span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!            </span></span><br><span class=\"line\">    elementData[size++] = e;                                               </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                           </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;                  </span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是初始化，则使用 DEFAULT_CAPACITY = 10</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);                       </span><br><span class=\"line\">    &#125;                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;                                                       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123; </span><br><span class=\"line\">    modCount++;                                        </span><br><span class=\"line\">                                                       </span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code                         </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>) <span class=\"comment\">// 需要扩容          </span></span><br><span class=\"line\">        grow(minCapacity);                             </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可使用的数组最大容量，一些虚拟机会在数组中保留一个头部字段</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;                           </span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code 考虑溢出情况                                 </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// 增加旧容量 * 0.5 = 旧容量 * 1.5</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);        </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)                         </span><br><span class=\"line\">        newCapacity = minCapacity;     <span class=\"comment\">// 还不够大，直接用 minCapacity                       </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)  <span class=\"comment\">// 大于允许的最大容量                    </span></span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);               </span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win: </span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow // 超过 Integer.MAX_VALUE，变成负值             </span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();              </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?        </span><br><span class=\"line\">        Integer.MAX_VALUE :                        </span><br><span class=\"line\">        MAX_ARRAY_SIZE;                            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>允许添加 null</p>\n</blockquote>\n<h3 id=\"remove-操作\"><a href=\"#remove-操作\" class=\"headerlink\" title=\"remove 操作\"></a>remove 操作</h3><p>调用 <code>remove(int)</code> 删除指定下标的元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标范围检查</span></span><br><span class=\"line\">    rangeCheck(index);                                                   </span><br><span class=\"line\">                                                                         </span><br><span class=\"line\">    modCount++;                                                          </span><br><span class=\"line\">    E oldValue = elementData(index);                                     </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 需要移动的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 元素拷贝移动</span></span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,       </span><br><span class=\"line\">                         numMoved);                                      </span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work           </span></span><br><span class=\"line\">                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用 <code>remove(object)</code> 删除指定元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果删除 null 元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)     </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;          </span><br><span class=\"line\">                fastRemove(index);                     </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                           </span><br><span class=\"line\">            &#125;                                          </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                           </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"comment\">// 调用 equals 判断</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;        </span><br><span class=\"line\">                fastRemove(index);                     </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                           </span><br><span class=\"line\">            &#125;                                          </span><br><span class=\"line\">    &#125;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                      </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;                                       </span><br><span class=\"line\">    modCount++;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)                                                      </span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,         </span><br><span class=\"line\">                         numMoved);                                        </span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work             </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Activity启动流程(基于Android26)","date":"2018-03-27T01:54:17.000Z","_content":"\n> 基于 Android 26，分析 Android Activity 启动流程\n\n## 参考\n\n[startActivity启动过程分析](http://gityuan.com/2016/03/12/start-activity/)\n\n## 源码\n\n**源码篇幅可能过长，所以会省略一下不必要的代码和注释**\n\n### Activity\n\n``` java\n@Override                                    \npublic void startActivity() {   \n    this.startActivity(intent, null);        \n}\n\n@Override                                                           \npublic void startActivity() {\n    if (options != null) {                                          \n        startActivityForResult(intent, -1, options);                \n    } else {                                                        \n        startActivityForResult(intent, -1);                         \n    }                                                               \n}                                                                   \n```\n\n最终都会调用到 `startActivityForResult`：\n\n``` java\npublic void startActivityForResult() {                                                             \n    if (mParent == null) {\n        // 转场动画的处理\n        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      \n        if (ar != null) {                                                                       \n            mMainThread.sendActivityResult();                                                                                                             \n        }                                                                                       \n        if (requestCode >= 0) {                                                                                        \n            mStartedActivity = true;                                                            \n        }                                                                                                                                                                             \n    } else {                                                                                    \n        // 如果存在 Parent Activity 则交由它处理                                                                                    \n    }                                                                                           \n}                                                                                               \n```\n\n可以知道 Activity 启动委托给了 Instrumentation 进行实现\n\n### Instrumentation\n\n``` java\npublic ActivityResult execStartActivity() {\n    // 由 ActivityThread.getApplicationThread 提供的 ApplicationThread\n    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                \n    if (mActivityMonitors != null) {                                       \n        synchronized (mSync) {                                             \n            final int N = mActivityMonitors.size();                        \n            for (int i=0; i<N; i++) {                                      \n                final ActivityMonitor am = mActivityMonitors.get(i);       \n                ActivityResult result = null;                              \n                if (am.ignoreMatchingSpecificIntents()) {\n                    // true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 \n                    result = am.onStartActivity(intent);                   \n                }                                                          \n                if (result != null) {                                      \n                    am.mHits++;                                            \n                    return result;                                         \n                } else if (am.match(who, null, intent)) {\n                    // match 使用 IntentFilter 和 类名 进行匹配\n                    am.mHits++;                                            \n                    if (am.isBlocking()) {\n                        // 当前监视器阻止 Activity 启动\n                        return requestCode >= 0 ? am.getResult() : null;   \n                    }                                                      \n                    break;                                                 \n                }                                                          \n            }                                                              \n        }                                                                  \n    }                                                                      \n    try {\n        // 委托为 ActivityManagerService(AMS) 去处理\n        int result = ActivityManager.getService().startActivity();                          \n        // 检查 AMS 的处理结果\n        checkStartActivityResult(result, intent);                          \n    } catch (RemoteException e) {                                          \n        throw new RuntimeException(\"Failure from system\", e);              \n    }                                                                      \n    return null;                                                           \n}                                                                          \n```\n\n可以通过最后的调用委托给了`ActivityManager.getService`，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现\n\n> 相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC\n\n``` java\npublic static IActivityManager getService() {\n    return IActivityManagerSingleton.get();  \n}\n\nprivate static final Singleton<IActivityManager> IActivityManagerSingleton =          \n        new Singleton<IActivityManager>() {                                           \n            @Override                                                                 \n            protected IActivityManager create() {                                     \n                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);\n                final IActivityManager am = IActivityManager.Stub.asInterface(b);     \n                return am;                                                            \n            }                                                                         \n        };                                                                            \n```\n\n### ActivityManagerService\n\n``` java\n@Override                                                                                       \npublic final int startActivity() {                           \n    return startActivityAsUser();                                                     \n}\n\n@Override                                                                                                                          \npublic final int startActivityAsUser() {                                                                                                                                   \n    return mActivityStarter.startActivityMayWait();                                                                                                \n}                                                                                                                                  \n```\n\n这里将启动请求又委托给了 ActivityStarter\n\n### ActivityStarter\n\n``` java\nfinal int startActivityMayWait() {                                                \n    // Intent 的响应\n    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           \n    // Intent 的 Activity 信息                                                               \n    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        \n        final ActivityRecord[] outRecord = new ActivityRecord[1];\n    \t// 调用 startActivityLocked\n        int res = startActivityLocked(outRecord);                                                                                                                          \n        return res;                                                                                                       \n    }                                                                                                                     \n}                                                                                                                         \n```\n\n``` java\nprivate int startActivity() {\n    // 源 Activity 记录，即在哪个 Activity 进行 startActivity\n    ActivityRecord sourceRecord = null;\n    // 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity\n    ActivityRecord resultRecord = null;                                                                       \n    if (resultTo != null) {\n        // 获取 Activity Stack 中已经存在的源 Activity 记录\n        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 \n        if (sourceRecord != null) {                                                                           \n            if (requestCode >= 0 && !sourceRecord.finishing) {\n                // requestCode >= 0，源 Activity 同时为 结果 Activity\n                resultRecord = sourceRecord;                                                                  \n            }                                                                                                 \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    final int launchFlags = intent.getFlags();                                                                \n                                                                                                              \n    if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {                   \n        // 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity\n        // 比如：A -> B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A\n        if (requestCode >= 0) {\n            // 不允许有 requestCode\n            ActivityOptions.abort(options);                                                                   \n            return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        \n        }\n        // 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity\n        resultRecord = sourceRecord.resultTo;                                                                 \n        if (resultRecord != null && !resultRecord.isInStackLocked()) {                                        \n            resultRecord = null;                                                                              \n        }\n        // requestCode 处理\n        resultWho = sourceRecord.resultWho;                                                                   \n        requestCode = sourceRecord.requestCode;                                                               \n        sourceRecord.resultTo = null;                                                                         \n        if (resultRecord != null) {\n            // 删除源 Activity 记录\n            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           \n        }                                                                                                                                                                                         \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {                              \n        // component 找不到                                                                         \n        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && aInfo == null) {                                              \n        // ActivityInfo 找不到                                                                         \n        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && sourceRecord != null                                          \n            && sourceRecord.getTask().voiceSession != null) {                                                 \n        // 语音启动 Activity，检查是否符合                                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && voiceSession != null) {                                       \n        // 启动语音会话                                                       \n    }                                                                                                         \n                                                                                                              \n    final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack();                  \n                                                                                                              \n    if (err != START_SUCCESS) {\n        // 启动 Activity 失败\n        if (resultRecord != null) {\n            // 发送取消通知\n            resultStack.sendActivityResultLocked(                                                             \n                    -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);                         \n        }                                                                                                     \n        ActivityOptions.abort(options);                                                                       \n        return err;                                                                                           \n    }                                                                                                         \n                                                                                                              \n    // 进行一些权限检查，判断是否终止                                                              \n    if (abort) {\n        // 如果需要终止 Activity\n        if (resultRecord != null) {                                                                           \n            resultStack.sendActivityResultLocked();                                                                   \n        }                                                                                                     \n        // 返回启动成功，实际终止                                                                \n        ActivityOptions.abort(options);                                                                       \n        return START_SUCCESS;                                                                                 \n    }                                                                                                         \n                                                                                                              \n    // 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             \n                                                                                                              \n    // 处理 ephemeral app                                                                    \n    \n    // 构造一个 ActivityRecord\n    ActivityRecord r = new ActivityRecord();                                                   \n                                                                                                     \n    final ActivityStack stack = mSupervisor.mFocusedStack;                                                    \n    if (voiceSession == null && (stack.mResumedActivity == null                                               \n            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) {\n        // 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换\n        if (!mService.checkAppSwitchAllowedLocked() {                                          \n            PendingActivityLaunch pal =  new PendingActivityLaunch();                                              \n            mPendingActivityLaunches.add(pal);                                                                \n            ActivityOptions.abort(options);\n            // 切换 app 失败\n            return ActivityManager.START_SWITCHES_CANCELED;                                                   \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    if (mService.mDidAppSwitch) {                                                                             \n        // 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            \n        mService.mAppSwitchesAllowedTime = 0;                                                                 \n    } else {                                                                                                  \n        mService.mDidAppSwitch = true;                                                                        \n    }                                                                                                         \n    \n    // 执行因为不允许 app 切换，而加到等待启动的 Activity\n    doPendingActivityLaunchesLocked(false);                                                                   \n                                                                                                              \n    return startActivity();                                                                    \n}                                                                                                             \n```\n\n``` java\nprivate int startActivity() {                                                        \n    int result = START_CANCELED;                                                               \n    try {                                                                                      \n        mService.mWindowManager.deferSurfaceLayout();\n        // 下一步流程\n        result = startActivityUnchecked();                           \n    } finally {                                                                                \n        // 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      \n        if (!ActivityManager.isStartResultSuccessful(result)                                   \n                && mStartActivity.getTask() != null) {                                         \n            mStartActivity.getTask().removeActivity(mStartActivity);                           \n        }                                                                                      \n        mService.mWindowManager.continueSurfaceLayout();                                       \n    }                                                                                          \n                                                                                               \n    postStartActivityProcessing();                                                                     \n                                                                                               \n    return result;                                                                             \n}                                                                                              \n```\n\n``` java\nprivate int startActivityUnchecked() {\n\t\n    // 设置一些初始化状态\n    setInitialState();\n    // 计算 launch flags\n    computeLaunchingTaskFlags();\n    // 计算源 Task，源 Task 是否存在等\n    computeSourceStack();\n    // 获取是否存在可以复用的 Activity，根据 flags 和 launchMode\n    ActivityRecord reusedActivity = getReusableIntentActivity();\n    if (reusedActivity != null) {\n    \t// 存在可复用的 Activity，复用它\n        // 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置\n    }\n    if (mStartActivity.packageName == null) {\n    \treturn START_CLASS_NOT_FOUND;\n    }\n    // 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity\n    final boolean dontStart = top != null && mStartActivity.resultTo == null\n                && top.realActivity.equals(mStartActivity.realActivity)\n                && top.userId == mStartActivity.userId\n                && top.app != null && top.app.thread != null\n                && ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0\n                || mLaunchSingleTop || mLaunchSingleTask);\n    if(dontStart){\n        // 传递一个新的 Intent 到 onNewIntent \n        top.deliverNewIntentLocked();\n        return START_DELIVERED_TO_TOP;\n    }\n    \n    // 获取 mTargetStack\n    if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask\n                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n    \tnewTask = true;\n        // 需要创建新的 Task\n        result = setTaskFromReuseOrCreateNewTask();\n    } else if (mSourceRecord != null) {\n        // 从源 Activity 中获取 Task\n    \tresult = setTaskFromSourceRecord();\n    } else if (mInTask != null) {\n        // 从 InTask 中获取 Task\n    \tresult = setTaskFromInTask();\n    } else {\n        // 可能创建新的 Task 或使用当前 Task，一般不会发生\n    \tsetTaskToCurrentTopOrCreateNewTask();\n    }\n    \n    // 使用 mTargetStack 启动 Activity \n    mTargetStack.startActivityLocked();\n    \n    if (mDoResume) {\n        if (!mTargetStack.isFocusable()\n                    || (topTaskActivity != null && topTaskActivity.mTaskOverlay\n                    && mStartActivity != topTaskActivity)) {\n        \t// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity\n            // 那么我们不恢复目标 Task，只需要确保它可见即可\n            mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        }\n    } else {\n        if (mTargetStack.isFocusable() && !mSupervisor.isFocusedStack(mTargetStack)) {\n        \t// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台\n            mTargetStack.moveToFront(\"startActivityUnchecked\");\n        }\n        // 恢复目标 Task\n        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,\n                        mOptions);\n    } else {\n        // 如果不需要恢复，那么加到\"最近活动\"中\n        mTargetStack.addRecentActivityLocked(mStartActivity);\n    }\n    \n    return START_SUCCESS;\n}\n\nprivate void setInitialState(){\n    // 获取 DisplayId\n    mSourceDisplayId = getSourceDisplayId();\n    // 获取用于启动 Activity 的范围，Rect\n    mLaunchBounds = getOerrideBounds();\n    // launchMode\n    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;\n    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;\n    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;\n    // Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主\n    // 如果 requestCode >= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity\n    sendNewTaskResultRequestIfNeeded();\n}\n\nprivate void computeLaunchingTaskFlags(){\n    if (mSourceRecord == null && mInTask != null && mInTask.getStack() != null){\n        // 如果不存在源 Activity\n        final Intent baseIntent = mInTask.getBaseIntent();\n        final ActivityRecord root = mInTask.getRootActivity();\n        if (baseIntent == null){\n            throw new IllegalArgumentException();\n        }\n        if (mLaunchSingleInstance || mLaunchSingleTask) {\n            // 如果设置了 SingleInstacne 或 SingleTask\n        \tif (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent())){\n                // Task 不符合\n                throw new IllegalArgumentException();\n            }\n            \n            if(root != null){\n                // 已经存在 Task 根 Activity\n                throw new IllegalArgumentException();\n            }\n        }\n        \n        if (root == null) {\n        \t// 如果不存在根 Activity，重新设置 launch flags\n            mAddingToTask = true;\n        }else if ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n             mAddingToTask = false;\n        }else {\n            mAddingToTask = true;\n        }\n    }else {\n                     if ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) && mSourceRecord != null\n                    && mSourceRecord.isFreeform())  {\n                         // 如果使用 ResolverActivity 启动或者 noDisplay\n                mAddingToTask = true;\n            }\n    }\n    \n    if(mInTask == null){\n        if (mSourceRecord == null) {\n        \tif ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) == 0 && mInTask == null) {\n                // 不存在 Task，并且不存在源 Activity\n            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n            }\n        }else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) {\n        \t// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }else if (mLaunchSingleInstance || mLaunchSingleTask) {\n        \t// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }\n    }\n    \n}\n```\n\nActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity\n\n### ActivityStack\n\n``` java\nfinal void startActivityLocked(){\n    if(!newTask) {\n      // 如果从已存在的 Task 中启动 Activity\n      boolean startIt = true;\n      for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {\n      \ttask = mTaskHistory.get(taskNdx);\n          if (task.getTopActivity() == null){\n              // 如果 task 不存在 Activity\n              continue;\n          }\n          if (task == rTask) {\n          \t// 找到对应的 task\n            if (!startIt) {\n            \t// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动\n                r.createWindowContainer();\n                ActivityOptions.abort(options);\n                return;\n            }\n          } else if (task.numFullscreen > 0) {\n              startIt = false;\n          }\n      }\n    }\n    \n    // 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调\n    if (task == activityTask && mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) {\n        mStackSupervisor.mUserLeaving = false;\n    }\n    \n    if (!isHomeOrRecentsStack() || numActivities() > 0) {\n    \t// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0\n        \n        // 处理 动画\n        \n        if (newTask) {\n            if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {\n            // 如果设置了重置的标记\n            resetTaskIfNeededLocked(r, r);\n            doShow = topRunningNonDelayedActivityLocked(null) == r;\n            } else if (options != null && options.getAnimationType()\n                    == ActivityOptions.ANIM_SCENE_TRANSITION) {\n                // 需要进行转场动画\n                doShow = false;\n        }\n    }\n        \n        \n        if (r.mLaunchTaskBehind) {\n        \t// 如果为 true，那么不开启 window，但要确保 Activity 是可见的\n            r.setVisibility(true);\n            ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        } else if (SHOW_APP_STARTING_PREVIEW && doShow) {\n            TaskRecord prevTask = r.getTask();\n            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();\n            if (prev != null) {\n                // 以下两种情况不展示之前的 Activity 预览\n            \tif (prev.getTask() != prevTask) {\n                    // 之前的 Activity 在不同的 Task\n                \tprev = null;\n                } else if (prev.nowVisible) {\n                    // 现在可见\n                \t prev = null;\n                }\n            }\n            // 显示启动 Activity 的 Window\n        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));\n        } else {\n            // 当前为栈顶 Activity\n            ActivityOptions.abort(options);\n        }\n    \n}\n```\n\n`ActivityStack.startActivityLocked` 主要是创建 WindowContainer，同时显示 Window\n\n### ActivityStackSupervisor\n\n``` java\nboolean resumeFocusedStackTopActivityLocked(){\n    if (targetStack != null && isFocusedStack(targetStack)) {\n        // 存在 targetStack\n    \treturn targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);\n    }\n    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();\n    if (r == null || r.state != RESUMED) {\n        // 恢复聚焦 task\n    \tmFocusedStack.resumeTopActivityUncheckedLocked(null, null);\n    } else if (r.state == RESUMED) {\n        // 执行应用转场动画\n    \tmFocusedStack.executeAppTransition(targetOptions);\n    }\n}\n```\n\n### ActivityStack\n\n``` java\nboolean resumeTopActivityUncheckedLocked() {\n    if (mStackSupervisor.inResumeTopActivity) {\n        // 防止递归\n    \treturn false;\n    }\n    try {\n        // 设置恢复标记\n        mStackSupervisor.inResumeTopActivity = true;\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        mStackSupervisor.inResumeTopActivity = false;\n    }\n    // 在恢复过程中，确保必要的暂停逻辑\n    mStackSupervisor.checkReadyForSleepLocked();\n}\n```\n\n``` java\nprivate boolean resumeTopActivityInnerLocked() {\n    \n    // 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦\n    final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);\n    final boolean hasRunningActivity = next != null;\n    final ActivityRecord parent = mActivityContainer.mParentActivity;\n    final boolean isParentNotResumed = parent != null && parent.state != ActivityState.RESUMED;\n    if (hasRunningActivity\n                && (isParentNotResumed || !mActivityContainer.isAttachedLocked())) {\n           // 如果父 Activity 不是恢复状态，则不恢复当前 Activity\n            return false;\n        }\n    \n    if (!hasRunningActivity) {\n        // 当前 Task 没有需要恢复的 Activity\n    \treturn resumeTopActivityInNextFocusableStack(prev, options, \"noMoreActivities\");\n    }\n    \n    if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                    mStackSupervisor.allResumedActivitiesComplete()) {\n        // 如果 Activity 已经是恢复状态\n        // 确保已经执行了所有等待的转场\n        executeAppTransition(options);\n    \treturn false;\n    }\n    \n    if (mService.isSleepingOrShuttingDownLocked()\n                && mLastPausedActivity == next\n                && mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果系统处于休眠状态，当前 Activity 处于暂停状态\n        // 确保转场执行\n        executeAppTransition(options);\n        return false;\n    }\n    \n    if (!mService.mUserController.hasStartedUserState(next.userId)) {\n        // 如果拥有该 Activity 的用户没有启动\n    \treturn false;\n    }\n    \n    if (!mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果存在暂停 Activity 的操作未完成\n        return false;\n    }\n    \n    boolean lastResumedCanPip = false;\n    final ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();\n    if (lastFocusedStack != null && lastFocusedStack != this) {\n    \tfinal ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;\n        // 最后一个恢复的 Activity 是否可以 画中画\n        lastResumedCanPip = lastResumed != null && lastResumed.checkEnterPictureInPictureState(\n                    \"resumeTopActivity\", true /* noThrow */, userLeaving /* beforeStopping */);\n    }\n    \n    // 是否需要可以在上一个 Activity 暂停时进行恢复\n    final boolean resumeWhilePausing = (next.info.flags & FLAG_RESUME_WHILE_PAUSING) != 0\n                && !lastResumedCanPip;\n    // 是否暂停了回退的 task\n    boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);\n    \n    if (mResumedActivity != null) {\n        // 暂停上一个恢复状态的 Activity\n    \tpausing |= startPausingLocked(userLeaving, false, next, false);\n    }\n    \n    if (pausing && !resumeWhilePausing) {\n    \t// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity\n        if (next.app != null && next.app.thread != null) {\n            // hosting application，一般不执行\n            // 让当前 Activity 放在 Lru 的顶部，避免早早杀死\n        \tmService.updateLruProcessLocked(next.app, true, null);\n        }\n        return true;\n    } else if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                mStackSupervisor.allResumedActivitiesComplete()) {\n    \t// 当前需要恢复的 Activity 已经是恢复状态\n        // 确保执行转场\n        executeAppTransition(options);\n        return true;\n    }\n    \n    if (mService.isSleepingLocked() && mLastNoHistoryActivity != null &&\n                !mLastNoHistoryActivity.finishing) {\n        // 结束因为系统休眠而还没结束的 Activity\n    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,\n                    null, \"resume-no-history\", false);\n        mLastNoHistoryActivity = null;\n    }\n    \n    if (prev != null && prev != next) {\n    \tif (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)\n                    && next != null && !next.nowVisible) {\n        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);\n        } else {\n            // 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity\n            if (prev.finishing) {\n            \tprev.setVisibility(false);\n            } else {\n                \n            }\n        }\n    }\n    \n    // Activity 转场处理\n    \n    ActivityStack lastStack = mStackSupervisor.getLastStack();\n    if (next.app != null && next.app.thread != null) {\n        // 上一个 Activity 是否为透明\n    \tfinal boolean lastActivityTranslucent = lastStack != null\n                    && (!lastStack.mFullscreen\n                    || (lastStack.mLastPausedActivity != null\n                    && !lastStack.mLastPausedActivity.fullscreen));\n        \n        if (!next.visible || next.stopped || lastActivityTranslucent) {\n            // 前一个 Activity 为透明，并且当前 Activity 还没显示\n            // 设置为显示状态\n            next.setVisibility(true);\n        }\n        \n        // 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向\n    boolean notUpdated = true;\n    if (mStackSupervisor.isFocusedStack(this)) {\n    \tfinal Configuration config = mWindowManager.updateOrientationFromAppTokens(\n                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),\n                        next.mayFreezeScreenLocked(next.app) ? next.appToken : null, mDisplayId);\n        \n        if (config != null) {\n    \tnext.frozenBeforeDestroy = true;\n        }\n        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,\n                        false /* deferResume */, mDisplayId);\n    }\n    \n     if (notUpdated) {\n         // 配置发生更新无法保持已经存在的 Activity 实例\n         // 重新获取需要恢复的 Activity\n         ActivityRecord nextNext = topRunningActivityLocked();\n         // 确保 Activity 仍然保持在栈顶，同时安排另外一次执行\n         if (nextNext != next) {\n         \tmStackSupervisor.scheduleResumeTopActivities();\n         }\n         if (!next.visible || next.stopped) {\n         \tnext.setVisibility(true);\n         }\n         next.completeResumeLocked();\n         return true;\n     }\n    \n    try {\n        // 传递所有等待的结果\n        \n        if (next.newIntents != null){\n            next.app.thread.scheduleNewIntent(\n                            next.newIntents, next.appToken, false /* andPause */);\n        }\n        \n        next.notifyAppResumed(next.stopped);\n        \n        // 准备恢复 Activity\n        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,\n                        mService.isNextTransitionForward(), resumeAnimOptions);\n    } catch (Exception e){\n        // 发生异常，重新启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, false);\n        return true;\n    }\n        \n        try {\n            next.completeResumeLocked();\n        } catch(Exception e){\n            // 发生异常，结束 Activity\n            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null,\n                        \"resume-exception\", true);\n            return true;\n        }\n        \n    } else {\n        // 需要启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\n    }\n    \n    return true;\n\n}\n```\n\n如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：\n\n### ActivityStackSupervisor\n\n``` java\nvoid startSpecificActivityLocked() {\n    // 获取应用进程信息\n    ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n                r.info.applicationInfo.uid, true);\n    \n    if (app != null && app.thread != null) {\n    \t// 如果进程已经启动\n        try {\n            realStartActivityLocked(r, app, andResume, checkConfig);\n            return;\n        }catch (RemoteException e){\n            \n        }\n    }\n    \n    // 启动应用进程\n    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n}\n```\n\n``` java\nfinal boolean realStartActivityLocked() {\n    // 冻结屏幕\n    r.startFreezingScreenLocked(app, 0);\n    if (checkConfig) {\n    \t// 根据新的 Activity 顺序重新评估屏幕的方向\n    }\n    \n    int idx = app.activities.indexOf(r);\n    if (idx < 0) {\n        // 将 Activity 添加到应用进程中\n        app.activities.add(r);\n    }\n    \n    try {\n        app.thread.scheduleLaunchActivity();\n    }catch(RemoteException e){\n        // 发生异常，结束 Activity\n        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,\n                        \"2nd-crash\", false);\n        return false;\n    }\n    \n    return true;\n}\n```\n\n启动流程最后还是回到了 ApplicationThread\n\n### ApplicationThread\n\n``` java\npublic final void scheduleLaunchActivity() {\n    // 通过 Handler 发送 LAUNCH_ACTIVITY\n    sendMessage(H.LAUNCH_ACTIVITY, r);\n}\n```\n\n我们单独把 LAUNCH_ACTIVITY 的处理拿出来：\n\n``` java\nfinal ActivityClientRecord r = (ActivityClientRecord) msg.obj;\nr.packageInfo = getPackageInfoNoCheck(\n                            r.activityInfo.applicationInfo, r.compatInfo);\nhandleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n```\n\n### ActivityThread\n\n``` java\nprivate void handleLaunchActivity() {\n    // 执行启动 Activity\n    Activity a = performLaunchActivity(r, customIntent);\n    if (a != null) {\n        // resume activity\n        handleResumeActivity(r.token, false, r.isForward,\n                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);\n    } else {\n        \n    }\n}\n```\n\n``` java\nprivate performLaunchActivity() {\n    // Activity 信息初始化\n    \n    // 创建 context\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        // 构建 Activity\n        activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n    }catch(Exception e){\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        if(activity != null){\n        \tactivity.attach();\n            \n            // 通过 Instrumentation 执行 Activity onCreate\n            if (r.isPersistable()) {\n                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            }else {\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            \n            if (!r.activity.mFinished) {\n                // Activity onStart\n            \tactivity.performStart();\n            }\n            \n            // 通过 Instrumentation 执行 Activity onRestoreInstanceState\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                \tif (r.state != null || r.persistentState != null) {\n                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,\n                                    r.persistentState);\n                    }\n                } else if (r.state != null) {\n                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);\n                }\n            }\n            \n             // 通过 Instrumentation 执行 Activity onPostCreeate\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state,\n                                r.persistentState);\n                }else {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state);\n                }\n            }       \n    }\n        \n    return activity;\n    \n}\n```\n\n``` java\nfinal void handleResumeActivity() {\n    r = performResumeActivity();\n    if(r != null) {\n        final Activity a = r.activity;\n        if (r.window == null && !a.mFinished && willBeVisible) {\n            r.window = r.activity.getWindow();\n            View decor = r.window.getDecorView();\n            decor.setVisibility(View.INVISIBLE);\n            ViewManager wm = a.getWindowManager();\n            if (a.mVisibleFromClient) {\n            \tif (!a.mWindowAdded) {\n                \ta.mWindowAdded = true;\n                    // window\n                    wm.addView(decor, l);\n                }\n            }\n        }\n    }\n}\n```\n\n``` java\npublic final ActivityClientRecord performResumeActivity() {\n \tif (r != null && !r.activity.mFinished) {\n    \ttry {\n            // 处理等待的 Intent\n            if (r.pendingIntents != null) {\n            \tdeliverNewIntents(r, r.pendingIntents);\n                r.pendingIntents = null;\n            }\n            // 处理等待的 result\n            if (r.pendingResults != null) {\n            \tdeliverResults(r, r.pendingResults);\n                r.pendingResults = null;\n            }\n            // 执行 resume\n            r.activity.performResume();\n        }\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic Activity newActivity(){\n    return (Activity)cl.loadClass(className).newInstance();\n}\n```\n\n``` java\nprivate void callActivityOnCreate(){\n    prePerformCreate(activity);\n    activity.performCreate(icicle);\n    postPerformCreate(activity);\n}\n```\n\n### Activity\n\n``` java\nfinal void performCreate() {\n    restoreHasCurrentPermissionRequest(icicle);\n    // 调用 onCreate\n    onCreate(icicle);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n```\n\n``` java\nfinal void performStart() {\n    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());\n    mInstrumentation.callActivityOnStart(this);\n    mActivityTransitionState.enterReady(this);\n}\n```\n\n``` java\nfinal void performResume() {\n    // 执行 restart\n    performRestart();\n    mInstrumentation.callActivityOnResume(this);\n}\n```\n\n``` java\nfinal void performRestart() {\n    if (mStopped) {\n        mStopped = false;\n        mInstrumentation.callActivityOnRestart(this);\n        // 执行 start\n        performStart();\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic void callActivityOnStart() {\n    activity.onStart();\n}\n```\n\n``` java\npublic void callActivityOnResume() {\n     activity.mResumed = true;\n    activity.onResume();\n}\n```\n\n``` java\npublic void callActivityOnRestart() {\n    activity.onRestart();\n}\n```\n\n## 总结\n\n简单总结下 Activity 的启动流程：\n\n1. 从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信\n2. ActivityManagerService 用于管理所有的 Activity 活动\n   * 当接受到启动 Activity 的调用时，使用 `resolveActivity` ，查询系统中符合要求的 Activity\n   * 创建使用合适的  ActivityStack 和 launch flags 来启动 Activity\n   * 如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity\n   * 如果不存在应用进程，先创建应用进程\n3. 最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行\n   * 使用 Instrumentation 去通过反射构建 Activity 实例\n   * 使用 Handler 机制调用 Activity 的生命周期\n\n下面的图例来自[博客](http://gityuan.com/2016/03/12/start-activity/)：\n\n![启动流程](http://gityuan.com/images/activity/start_activity_process.jpg)\n\n### 时序图\n\n![Android启动流程](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png?x-oss-process=style/doc-img)\n\n","source":"_posts/Activity启动流程-基于Android26.md","raw":"---\ntitle: Activity启动流程(基于Android26)\ndate: 2018-03-27 09:54:17\ncategories: Android Framework\ntags:\n---\n\n> 基于 Android 26，分析 Android Activity 启动流程\n\n## 参考\n\n[startActivity启动过程分析](http://gityuan.com/2016/03/12/start-activity/)\n\n## 源码\n\n**源码篇幅可能过长，所以会省略一下不必要的代码和注释**\n\n### Activity\n\n``` java\n@Override                                    \npublic void startActivity() {   \n    this.startActivity(intent, null);        \n}\n\n@Override                                                           \npublic void startActivity() {\n    if (options != null) {                                          \n        startActivityForResult(intent, -1, options);                \n    } else {                                                        \n        startActivityForResult(intent, -1);                         \n    }                                                               \n}                                                                   \n```\n\n最终都会调用到 `startActivityForResult`：\n\n``` java\npublic void startActivityForResult() {                                                             \n    if (mParent == null) {\n        // 转场动画的处理\n        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      \n        if (ar != null) {                                                                       \n            mMainThread.sendActivityResult();                                                                                                             \n        }                                                                                       \n        if (requestCode >= 0) {                                                                                        \n            mStartedActivity = true;                                                            \n        }                                                                                                                                                                             \n    } else {                                                                                    \n        // 如果存在 Parent Activity 则交由它处理                                                                                    \n    }                                                                                           \n}                                                                                               \n```\n\n可以知道 Activity 启动委托给了 Instrumentation 进行实现\n\n### Instrumentation\n\n``` java\npublic ActivityResult execStartActivity() {\n    // 由 ActivityThread.getApplicationThread 提供的 ApplicationThread\n    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                \n    if (mActivityMonitors != null) {                                       \n        synchronized (mSync) {                                             \n            final int N = mActivityMonitors.size();                        \n            for (int i=0; i<N; i++) {                                      \n                final ActivityMonitor am = mActivityMonitors.get(i);       \n                ActivityResult result = null;                              \n                if (am.ignoreMatchingSpecificIntents()) {\n                    // true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 \n                    result = am.onStartActivity(intent);                   \n                }                                                          \n                if (result != null) {                                      \n                    am.mHits++;                                            \n                    return result;                                         \n                } else if (am.match(who, null, intent)) {\n                    // match 使用 IntentFilter 和 类名 进行匹配\n                    am.mHits++;                                            \n                    if (am.isBlocking()) {\n                        // 当前监视器阻止 Activity 启动\n                        return requestCode >= 0 ? am.getResult() : null;   \n                    }                                                      \n                    break;                                                 \n                }                                                          \n            }                                                              \n        }                                                                  \n    }                                                                      \n    try {\n        // 委托为 ActivityManagerService(AMS) 去处理\n        int result = ActivityManager.getService().startActivity();                          \n        // 检查 AMS 的处理结果\n        checkStartActivityResult(result, intent);                          \n    } catch (RemoteException e) {                                          \n        throw new RuntimeException(\"Failure from system\", e);              \n    }                                                                      \n    return null;                                                           \n}                                                                          \n```\n\n可以通过最后的调用委托给了`ActivityManager.getService`，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现\n\n> 相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC\n\n``` java\npublic static IActivityManager getService() {\n    return IActivityManagerSingleton.get();  \n}\n\nprivate static final Singleton<IActivityManager> IActivityManagerSingleton =          \n        new Singleton<IActivityManager>() {                                           \n            @Override                                                                 \n            protected IActivityManager create() {                                     \n                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);\n                final IActivityManager am = IActivityManager.Stub.asInterface(b);     \n                return am;                                                            \n            }                                                                         \n        };                                                                            \n```\n\n### ActivityManagerService\n\n``` java\n@Override                                                                                       \npublic final int startActivity() {                           \n    return startActivityAsUser();                                                     \n}\n\n@Override                                                                                                                          \npublic final int startActivityAsUser() {                                                                                                                                   \n    return mActivityStarter.startActivityMayWait();                                                                                                \n}                                                                                                                                  \n```\n\n这里将启动请求又委托给了 ActivityStarter\n\n### ActivityStarter\n\n``` java\nfinal int startActivityMayWait() {                                                \n    // Intent 的响应\n    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           \n    // Intent 的 Activity 信息                                                               \n    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        \n        final ActivityRecord[] outRecord = new ActivityRecord[1];\n    \t// 调用 startActivityLocked\n        int res = startActivityLocked(outRecord);                                                                                                                          \n        return res;                                                                                                       \n    }                                                                                                                     \n}                                                                                                                         \n```\n\n``` java\nprivate int startActivity() {\n    // 源 Activity 记录，即在哪个 Activity 进行 startActivity\n    ActivityRecord sourceRecord = null;\n    // 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity\n    ActivityRecord resultRecord = null;                                                                       \n    if (resultTo != null) {\n        // 获取 Activity Stack 中已经存在的源 Activity 记录\n        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 \n        if (sourceRecord != null) {                                                                           \n            if (requestCode >= 0 && !sourceRecord.finishing) {\n                // requestCode >= 0，源 Activity 同时为 结果 Activity\n                resultRecord = sourceRecord;                                                                  \n            }                                                                                                 \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    final int launchFlags = intent.getFlags();                                                                \n                                                                                                              \n    if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {                   \n        // 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity\n        // 比如：A -> B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A\n        if (requestCode >= 0) {\n            // 不允许有 requestCode\n            ActivityOptions.abort(options);                                                                   \n            return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        \n        }\n        // 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity\n        resultRecord = sourceRecord.resultTo;                                                                 \n        if (resultRecord != null && !resultRecord.isInStackLocked()) {                                        \n            resultRecord = null;                                                                              \n        }\n        // requestCode 处理\n        resultWho = sourceRecord.resultWho;                                                                   \n        requestCode = sourceRecord.requestCode;                                                               \n        sourceRecord.resultTo = null;                                                                         \n        if (resultRecord != null) {\n            // 删除源 Activity 记录\n            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           \n        }                                                                                                                                                                                         \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {                              \n        // component 找不到                                                                         \n        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && aInfo == null) {                                              \n        // ActivityInfo 找不到                                                                         \n        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && sourceRecord != null                                          \n            && sourceRecord.getTask().voiceSession != null) {                                                 \n        // 语音启动 Activity，检查是否符合                                                                      \n    }                                                                                                         \n                                                                                                              \n    if (err == ActivityManager.START_SUCCESS && voiceSession != null) {                                       \n        // 启动语音会话                                                       \n    }                                                                                                         \n                                                                                                              \n    final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack();                  \n                                                                                                              \n    if (err != START_SUCCESS) {\n        // 启动 Activity 失败\n        if (resultRecord != null) {\n            // 发送取消通知\n            resultStack.sendActivityResultLocked(                                                             \n                    -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);                         \n        }                                                                                                     \n        ActivityOptions.abort(options);                                                                       \n        return err;                                                                                           \n    }                                                                                                         \n                                                                                                              \n    // 进行一些权限检查，判断是否终止                                                              \n    if (abort) {\n        // 如果需要终止 Activity\n        if (resultRecord != null) {                                                                           \n            resultStack.sendActivityResultLocked();                                                                   \n        }                                                                                                     \n        // 返回启动成功，实际终止                                                                \n        ActivityOptions.abort(options);                                                                       \n        return START_SUCCESS;                                                                                 \n    }                                                                                                         \n                                                                                                              \n    // 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             \n                                                                                                              \n    // 处理 ephemeral app                                                                    \n    \n    // 构造一个 ActivityRecord\n    ActivityRecord r = new ActivityRecord();                                                   \n                                                                                                     \n    final ActivityStack stack = mSupervisor.mFocusedStack;                                                    \n    if (voiceSession == null && (stack.mResumedActivity == null                                               \n            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) {\n        // 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换\n        if (!mService.checkAppSwitchAllowedLocked() {                                          \n            PendingActivityLaunch pal =  new PendingActivityLaunch();                                              \n            mPendingActivityLaunches.add(pal);                                                                \n            ActivityOptions.abort(options);\n            // 切换 app 失败\n            return ActivityManager.START_SWITCHES_CANCELED;                                                   \n        }                                                                                                     \n    }                                                                                                         \n                                                                                                              \n    if (mService.mDidAppSwitch) {                                                                             \n        // 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            \n        mService.mAppSwitchesAllowedTime = 0;                                                                 \n    } else {                                                                                                  \n        mService.mDidAppSwitch = true;                                                                        \n    }                                                                                                         \n    \n    // 执行因为不允许 app 切换，而加到等待启动的 Activity\n    doPendingActivityLaunchesLocked(false);                                                                   \n                                                                                                              \n    return startActivity();                                                                    \n}                                                                                                             \n```\n\n``` java\nprivate int startActivity() {                                                        \n    int result = START_CANCELED;                                                               \n    try {                                                                                      \n        mService.mWindowManager.deferSurfaceLayout();\n        // 下一步流程\n        result = startActivityUnchecked();                           \n    } finally {                                                                                \n        // 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      \n        if (!ActivityManager.isStartResultSuccessful(result)                                   \n                && mStartActivity.getTask() != null) {                                         \n            mStartActivity.getTask().removeActivity(mStartActivity);                           \n        }                                                                                      \n        mService.mWindowManager.continueSurfaceLayout();                                       \n    }                                                                                          \n                                                                                               \n    postStartActivityProcessing();                                                                     \n                                                                                               \n    return result;                                                                             \n}                                                                                              \n```\n\n``` java\nprivate int startActivityUnchecked() {\n\t\n    // 设置一些初始化状态\n    setInitialState();\n    // 计算 launch flags\n    computeLaunchingTaskFlags();\n    // 计算源 Task，源 Task 是否存在等\n    computeSourceStack();\n    // 获取是否存在可以复用的 Activity，根据 flags 和 launchMode\n    ActivityRecord reusedActivity = getReusableIntentActivity();\n    if (reusedActivity != null) {\n    \t// 存在可复用的 Activity，复用它\n        // 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置\n    }\n    if (mStartActivity.packageName == null) {\n    \treturn START_CLASS_NOT_FOUND;\n    }\n    // 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity\n    final boolean dontStart = top != null && mStartActivity.resultTo == null\n                && top.realActivity.equals(mStartActivity.realActivity)\n                && top.userId == mStartActivity.userId\n                && top.app != null && top.app.thread != null\n                && ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0\n                || mLaunchSingleTop || mLaunchSingleTask);\n    if(dontStart){\n        // 传递一个新的 Intent 到 onNewIntent \n        top.deliverNewIntentLocked();\n        return START_DELIVERED_TO_TOP;\n    }\n    \n    // 获取 mTargetStack\n    if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask\n                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n    \tnewTask = true;\n        // 需要创建新的 Task\n        result = setTaskFromReuseOrCreateNewTask();\n    } else if (mSourceRecord != null) {\n        // 从源 Activity 中获取 Task\n    \tresult = setTaskFromSourceRecord();\n    } else if (mInTask != null) {\n        // 从 InTask 中获取 Task\n    \tresult = setTaskFromInTask();\n    } else {\n        // 可能创建新的 Task 或使用当前 Task，一般不会发生\n    \tsetTaskToCurrentTopOrCreateNewTask();\n    }\n    \n    // 使用 mTargetStack 启动 Activity \n    mTargetStack.startActivityLocked();\n    \n    if (mDoResume) {\n        if (!mTargetStack.isFocusable()\n                    || (topTaskActivity != null && topTaskActivity.mTaskOverlay\n                    && mStartActivity != topTaskActivity)) {\n        \t// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity\n            // 那么我们不恢复目标 Task，只需要确保它可见即可\n            mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        }\n    } else {\n        if (mTargetStack.isFocusable() && !mSupervisor.isFocusedStack(mTargetStack)) {\n        \t// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台\n            mTargetStack.moveToFront(\"startActivityUnchecked\");\n        }\n        // 恢复目标 Task\n        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,\n                        mOptions);\n    } else {\n        // 如果不需要恢复，那么加到\"最近活动\"中\n        mTargetStack.addRecentActivityLocked(mStartActivity);\n    }\n    \n    return START_SUCCESS;\n}\n\nprivate void setInitialState(){\n    // 获取 DisplayId\n    mSourceDisplayId = getSourceDisplayId();\n    // 获取用于启动 Activity 的范围，Rect\n    mLaunchBounds = getOerrideBounds();\n    // launchMode\n    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;\n    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;\n    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;\n    // Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主\n    // 如果 requestCode >= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity\n    sendNewTaskResultRequestIfNeeded();\n}\n\nprivate void computeLaunchingTaskFlags(){\n    if (mSourceRecord == null && mInTask != null && mInTask.getStack() != null){\n        // 如果不存在源 Activity\n        final Intent baseIntent = mInTask.getBaseIntent();\n        final ActivityRecord root = mInTask.getRootActivity();\n        if (baseIntent == null){\n            throw new IllegalArgumentException();\n        }\n        if (mLaunchSingleInstance || mLaunchSingleTask) {\n            // 如果设置了 SingleInstacne 或 SingleTask\n        \tif (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent())){\n                // Task 不符合\n                throw new IllegalArgumentException();\n            }\n            \n            if(root != null){\n                // 已经存在 Task 根 Activity\n                throw new IllegalArgumentException();\n            }\n        }\n        \n        if (root == null) {\n        \t// 如果不存在根 Activity，重新设置 launch flags\n            mAddingToTask = true;\n        }else if ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {\n             mAddingToTask = false;\n        }else {\n            mAddingToTask = true;\n        }\n    }else {\n                     if ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) && mSourceRecord != null\n                    && mSourceRecord.isFreeform())  {\n                         // 如果使用 ResolverActivity 启动或者 noDisplay\n                mAddingToTask = true;\n            }\n    }\n    \n    if(mInTask == null){\n        if (mSourceRecord == null) {\n        \tif ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) == 0 && mInTask == null) {\n                // 不存在 Task，并且不存在源 Activity\n            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n            }\n        }else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) {\n        \t// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }else if (mLaunchSingleInstance || mLaunchSingleTask) {\n        \t// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag\n            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;\n        }\n    }\n    \n}\n```\n\nActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity\n\n### ActivityStack\n\n``` java\nfinal void startActivityLocked(){\n    if(!newTask) {\n      // 如果从已存在的 Task 中启动 Activity\n      boolean startIt = true;\n      for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {\n      \ttask = mTaskHistory.get(taskNdx);\n          if (task.getTopActivity() == null){\n              // 如果 task 不存在 Activity\n              continue;\n          }\n          if (task == rTask) {\n          \t// 找到对应的 task\n            if (!startIt) {\n            \t// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动\n                r.createWindowContainer();\n                ActivityOptions.abort(options);\n                return;\n            }\n          } else if (task.numFullscreen > 0) {\n              startIt = false;\n          }\n      }\n    }\n    \n    // 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调\n    if (task == activityTask && mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) {\n        mStackSupervisor.mUserLeaving = false;\n    }\n    \n    if (!isHomeOrRecentsStack() || numActivities() > 0) {\n    \t// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0\n        \n        // 处理 动画\n        \n        if (newTask) {\n            if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {\n            // 如果设置了重置的标记\n            resetTaskIfNeededLocked(r, r);\n            doShow = topRunningNonDelayedActivityLocked(null) == r;\n            } else if (options != null && options.getAnimationType()\n                    == ActivityOptions.ANIM_SCENE_TRANSITION) {\n                // 需要进行转场动画\n                doShow = false;\n        }\n    }\n        \n        \n        if (r.mLaunchTaskBehind) {\n        \t// 如果为 true，那么不开启 window，但要确保 Activity 是可见的\n            r.setVisibility(true);\n            ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);\n        } else if (SHOW_APP_STARTING_PREVIEW && doShow) {\n            TaskRecord prevTask = r.getTask();\n            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();\n            if (prev != null) {\n                // 以下两种情况不展示之前的 Activity 预览\n            \tif (prev.getTask() != prevTask) {\n                    // 之前的 Activity 在不同的 Task\n                \tprev = null;\n                } else if (prev.nowVisible) {\n                    // 现在可见\n                \t prev = null;\n                }\n            }\n            // 显示启动 Activity 的 Window\n        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));\n        } else {\n            // 当前为栈顶 Activity\n            ActivityOptions.abort(options);\n        }\n    \n}\n```\n\n`ActivityStack.startActivityLocked` 主要是创建 WindowContainer，同时显示 Window\n\n### ActivityStackSupervisor\n\n``` java\nboolean resumeFocusedStackTopActivityLocked(){\n    if (targetStack != null && isFocusedStack(targetStack)) {\n        // 存在 targetStack\n    \treturn targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);\n    }\n    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();\n    if (r == null || r.state != RESUMED) {\n        // 恢复聚焦 task\n    \tmFocusedStack.resumeTopActivityUncheckedLocked(null, null);\n    } else if (r.state == RESUMED) {\n        // 执行应用转场动画\n    \tmFocusedStack.executeAppTransition(targetOptions);\n    }\n}\n```\n\n### ActivityStack\n\n``` java\nboolean resumeTopActivityUncheckedLocked() {\n    if (mStackSupervisor.inResumeTopActivity) {\n        // 防止递归\n    \treturn false;\n    }\n    try {\n        // 设置恢复标记\n        mStackSupervisor.inResumeTopActivity = true;\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        mStackSupervisor.inResumeTopActivity = false;\n    }\n    // 在恢复过程中，确保必要的暂停逻辑\n    mStackSupervisor.checkReadyForSleepLocked();\n}\n```\n\n``` java\nprivate boolean resumeTopActivityInnerLocked() {\n    \n    // 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦\n    final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);\n    final boolean hasRunningActivity = next != null;\n    final ActivityRecord parent = mActivityContainer.mParentActivity;\n    final boolean isParentNotResumed = parent != null && parent.state != ActivityState.RESUMED;\n    if (hasRunningActivity\n                && (isParentNotResumed || !mActivityContainer.isAttachedLocked())) {\n           // 如果父 Activity 不是恢复状态，则不恢复当前 Activity\n            return false;\n        }\n    \n    if (!hasRunningActivity) {\n        // 当前 Task 没有需要恢复的 Activity\n    \treturn resumeTopActivityInNextFocusableStack(prev, options, \"noMoreActivities\");\n    }\n    \n    if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                    mStackSupervisor.allResumedActivitiesComplete()) {\n        // 如果 Activity 已经是恢复状态\n        // 确保已经执行了所有等待的转场\n        executeAppTransition(options);\n    \treturn false;\n    }\n    \n    if (mService.isSleepingOrShuttingDownLocked()\n                && mLastPausedActivity == next\n                && mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果系统处于休眠状态，当前 Activity 处于暂停状态\n        // 确保转场执行\n        executeAppTransition(options);\n        return false;\n    }\n    \n    if (!mService.mUserController.hasStartedUserState(next.userId)) {\n        // 如果拥有该 Activity 的用户没有启动\n    \treturn false;\n    }\n    \n    if (!mStackSupervisor.allPausedActivitiesComplete()) {\n    \t// 如果存在暂停 Activity 的操作未完成\n        return false;\n    }\n    \n    boolean lastResumedCanPip = false;\n    final ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();\n    if (lastFocusedStack != null && lastFocusedStack != this) {\n    \tfinal ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;\n        // 最后一个恢复的 Activity 是否可以 画中画\n        lastResumedCanPip = lastResumed != null && lastResumed.checkEnterPictureInPictureState(\n                    \"resumeTopActivity\", true /* noThrow */, userLeaving /* beforeStopping */);\n    }\n    \n    // 是否需要可以在上一个 Activity 暂停时进行恢复\n    final boolean resumeWhilePausing = (next.info.flags & FLAG_RESUME_WHILE_PAUSING) != 0\n                && !lastResumedCanPip;\n    // 是否暂停了回退的 task\n    boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);\n    \n    if (mResumedActivity != null) {\n        // 暂停上一个恢复状态的 Activity\n    \tpausing |= startPausingLocked(userLeaving, false, next, false);\n    }\n    \n    if (pausing && !resumeWhilePausing) {\n    \t// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity\n        if (next.app != null && next.app.thread != null) {\n            // hosting application，一般不执行\n            // 让当前 Activity 放在 Lru 的顶部，避免早早杀死\n        \tmService.updateLruProcessLocked(next.app, true, null);\n        }\n        return true;\n    } else if (mResumedActivity == next && next.state == ActivityState.RESUMED &&\n                mStackSupervisor.allResumedActivitiesComplete()) {\n    \t// 当前需要恢复的 Activity 已经是恢复状态\n        // 确保执行转场\n        executeAppTransition(options);\n        return true;\n    }\n    \n    if (mService.isSleepingLocked() && mLastNoHistoryActivity != null &&\n                !mLastNoHistoryActivity.finishing) {\n        // 结束因为系统休眠而还没结束的 Activity\n    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,\n                    null, \"resume-no-history\", false);\n        mLastNoHistoryActivity = null;\n    }\n    \n    if (prev != null && prev != next) {\n    \tif (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)\n                    && next != null && !next.nowVisible) {\n        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);\n        } else {\n            // 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity\n            if (prev.finishing) {\n            \tprev.setVisibility(false);\n            } else {\n                \n            }\n        }\n    }\n    \n    // Activity 转场处理\n    \n    ActivityStack lastStack = mStackSupervisor.getLastStack();\n    if (next.app != null && next.app.thread != null) {\n        // 上一个 Activity 是否为透明\n    \tfinal boolean lastActivityTranslucent = lastStack != null\n                    && (!lastStack.mFullscreen\n                    || (lastStack.mLastPausedActivity != null\n                    && !lastStack.mLastPausedActivity.fullscreen));\n        \n        if (!next.visible || next.stopped || lastActivityTranslucent) {\n            // 前一个 Activity 为透明，并且当前 Activity 还没显示\n            // 设置为显示状态\n            next.setVisibility(true);\n        }\n        \n        // 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向\n    boolean notUpdated = true;\n    if (mStackSupervisor.isFocusedStack(this)) {\n    \tfinal Configuration config = mWindowManager.updateOrientationFromAppTokens(\n                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),\n                        next.mayFreezeScreenLocked(next.app) ? next.appToken : null, mDisplayId);\n        \n        if (config != null) {\n    \tnext.frozenBeforeDestroy = true;\n        }\n        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,\n                        false /* deferResume */, mDisplayId);\n    }\n    \n     if (notUpdated) {\n         // 配置发生更新无法保持已经存在的 Activity 实例\n         // 重新获取需要恢复的 Activity\n         ActivityRecord nextNext = topRunningActivityLocked();\n         // 确保 Activity 仍然保持在栈顶，同时安排另外一次执行\n         if (nextNext != next) {\n         \tmStackSupervisor.scheduleResumeTopActivities();\n         }\n         if (!next.visible || next.stopped) {\n         \tnext.setVisibility(true);\n         }\n         next.completeResumeLocked();\n         return true;\n     }\n    \n    try {\n        // 传递所有等待的结果\n        \n        if (next.newIntents != null){\n            next.app.thread.scheduleNewIntent(\n                            next.newIntents, next.appToken, false /* andPause */);\n        }\n        \n        next.notifyAppResumed(next.stopped);\n        \n        // 准备恢复 Activity\n        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,\n                        mService.isNextTransitionForward(), resumeAnimOptions);\n    } catch (Exception e){\n        // 发生异常，重新启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, false);\n        return true;\n    }\n        \n        try {\n            next.completeResumeLocked();\n        } catch(Exception e){\n            // 发生异常，结束 Activity\n            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null,\n                        \"resume-exception\", true);\n            return true;\n        }\n        \n    } else {\n        // 需要启动 Activity\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\n    }\n    \n    return true;\n\n}\n```\n\n如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：\n\n### ActivityStackSupervisor\n\n``` java\nvoid startSpecificActivityLocked() {\n    // 获取应用进程信息\n    ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n                r.info.applicationInfo.uid, true);\n    \n    if (app != null && app.thread != null) {\n    \t// 如果进程已经启动\n        try {\n            realStartActivityLocked(r, app, andResume, checkConfig);\n            return;\n        }catch (RemoteException e){\n            \n        }\n    }\n    \n    // 启动应用进程\n    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n}\n```\n\n``` java\nfinal boolean realStartActivityLocked() {\n    // 冻结屏幕\n    r.startFreezingScreenLocked(app, 0);\n    if (checkConfig) {\n    \t// 根据新的 Activity 顺序重新评估屏幕的方向\n    }\n    \n    int idx = app.activities.indexOf(r);\n    if (idx < 0) {\n        // 将 Activity 添加到应用进程中\n        app.activities.add(r);\n    }\n    \n    try {\n        app.thread.scheduleLaunchActivity();\n    }catch(RemoteException e){\n        // 发生异常，结束 Activity\n        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,\n                        \"2nd-crash\", false);\n        return false;\n    }\n    \n    return true;\n}\n```\n\n启动流程最后还是回到了 ApplicationThread\n\n### ApplicationThread\n\n``` java\npublic final void scheduleLaunchActivity() {\n    // 通过 Handler 发送 LAUNCH_ACTIVITY\n    sendMessage(H.LAUNCH_ACTIVITY, r);\n}\n```\n\n我们单独把 LAUNCH_ACTIVITY 的处理拿出来：\n\n``` java\nfinal ActivityClientRecord r = (ActivityClientRecord) msg.obj;\nr.packageInfo = getPackageInfoNoCheck(\n                            r.activityInfo.applicationInfo, r.compatInfo);\nhandleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n```\n\n### ActivityThread\n\n``` java\nprivate void handleLaunchActivity() {\n    // 执行启动 Activity\n    Activity a = performLaunchActivity(r, customIntent);\n    if (a != null) {\n        // resume activity\n        handleResumeActivity(r.token, false, r.isForward,\n                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);\n    } else {\n        \n    }\n}\n```\n\n``` java\nprivate performLaunchActivity() {\n    // Activity 信息初始化\n    \n    // 创建 context\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        // 构建 Activity\n        activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n    }catch(Exception e){\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        if(activity != null){\n        \tactivity.attach();\n            \n            // 通过 Instrumentation 执行 Activity onCreate\n            if (r.isPersistable()) {\n                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            }else {\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            \n            if (!r.activity.mFinished) {\n                // Activity onStart\n            \tactivity.performStart();\n            }\n            \n            // 通过 Instrumentation 执行 Activity onRestoreInstanceState\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                \tif (r.state != null || r.persistentState != null) {\n                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,\n                                    r.persistentState);\n                    }\n                } else if (r.state != null) {\n                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);\n                }\n            }\n            \n             // 通过 Instrumentation 执行 Activity onPostCreeate\n            if (!r.activity.mFinished) {\n            \tif (r.isPersistable()) {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state,\n                                r.persistentState);\n                }else {\n                    mInstrumentation.callActivityOnPostCreate(activity, r.state);\n                }\n            }       \n    }\n        \n    return activity;\n    \n}\n```\n\n``` java\nfinal void handleResumeActivity() {\n    r = performResumeActivity();\n    if(r != null) {\n        final Activity a = r.activity;\n        if (r.window == null && !a.mFinished && willBeVisible) {\n            r.window = r.activity.getWindow();\n            View decor = r.window.getDecorView();\n            decor.setVisibility(View.INVISIBLE);\n            ViewManager wm = a.getWindowManager();\n            if (a.mVisibleFromClient) {\n            \tif (!a.mWindowAdded) {\n                \ta.mWindowAdded = true;\n                    // window\n                    wm.addView(decor, l);\n                }\n            }\n        }\n    }\n}\n```\n\n``` java\npublic final ActivityClientRecord performResumeActivity() {\n \tif (r != null && !r.activity.mFinished) {\n    \ttry {\n            // 处理等待的 Intent\n            if (r.pendingIntents != null) {\n            \tdeliverNewIntents(r, r.pendingIntents);\n                r.pendingIntents = null;\n            }\n            // 处理等待的 result\n            if (r.pendingResults != null) {\n            \tdeliverResults(r, r.pendingResults);\n                r.pendingResults = null;\n            }\n            // 执行 resume\n            r.activity.performResume();\n        }\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic Activity newActivity(){\n    return (Activity)cl.loadClass(className).newInstance();\n}\n```\n\n``` java\nprivate void callActivityOnCreate(){\n    prePerformCreate(activity);\n    activity.performCreate(icicle);\n    postPerformCreate(activity);\n}\n```\n\n### Activity\n\n``` java\nfinal void performCreate() {\n    restoreHasCurrentPermissionRequest(icicle);\n    // 调用 onCreate\n    onCreate(icicle);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n```\n\n``` java\nfinal void performStart() {\n    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());\n    mInstrumentation.callActivityOnStart(this);\n    mActivityTransitionState.enterReady(this);\n}\n```\n\n``` java\nfinal void performResume() {\n    // 执行 restart\n    performRestart();\n    mInstrumentation.callActivityOnResume(this);\n}\n```\n\n``` java\nfinal void performRestart() {\n    if (mStopped) {\n        mStopped = false;\n        mInstrumentation.callActivityOnRestart(this);\n        // 执行 start\n        performStart();\n    }\n}\n```\n\n### Instrumentation\n\n``` java\npublic void callActivityOnStart() {\n    activity.onStart();\n}\n```\n\n``` java\npublic void callActivityOnResume() {\n     activity.mResumed = true;\n    activity.onResume();\n}\n```\n\n``` java\npublic void callActivityOnRestart() {\n    activity.onRestart();\n}\n```\n\n## 总结\n\n简单总结下 Activity 的启动流程：\n\n1. 从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信\n2. ActivityManagerService 用于管理所有的 Activity 活动\n   * 当接受到启动 Activity 的调用时，使用 `resolveActivity` ，查询系统中符合要求的 Activity\n   * 创建使用合适的  ActivityStack 和 launch flags 来启动 Activity\n   * 如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity\n   * 如果不存在应用进程，先创建应用进程\n3. 最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行\n   * 使用 Instrumentation 去通过反射构建 Activity 实例\n   * 使用 Handler 机制调用 Activity 的生命周期\n\n下面的图例来自[博客](http://gityuan.com/2016/03/12/start-activity/)：\n\n![启动流程](http://gityuan.com/images/activity/start_activity_process.jpg)\n\n### 时序图\n\n![Android启动流程](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png?x-oss-process=style/doc-img)\n\n","slug":"Activity启动流程-基于Android26","published":1,"updated":"2018-11-16T10:10:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs0q0004e39kbm3e0d4x","content":"<blockquote>\n<p>基于 Android 26，分析 Android Activity 启动流程</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">startActivity启动过程分析</a></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><strong>源码篇幅可能过长，所以会省略一下不必要的代码和注释</strong></p>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.startActivity(intent, <span class=\"keyword\">null</span>);        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>, options);                </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                        </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>);                         </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终都会调用到 <code>startActivityForResult</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">()</span> </span>&#123;                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 转场动画的处理</span></span><br><span class=\"line\">        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;                                                                       </span><br><span class=\"line\">            mMainThread.sendActivityResult();                                                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;                                                                                        </span><br><span class=\"line\">            mStartedActivity = <span class=\"keyword\">true</span>;                                                            </span><br><span class=\"line\">        &#125;                                                                                                                                                                             </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                    </span><br><span class=\"line\">        <span class=\"comment\">// 如果存在 Parent Activity 则交由它处理                                                                                    </span></span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道 Activity 启动委托给了 Instrumentation 进行实现</p>\n<h3 id=\"Instrumentation\"><a href=\"#Instrumentation\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由 ActivityThread.getApplicationThread 提供的 ApplicationThread</span></span><br><span class=\"line\">    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActivityMonitors != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mSync) &#123;                                             </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = mActivityMonitors.size();                        </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;                                      </span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityMonitor am = mActivityMonitors.get(i);       </span><br><span class=\"line\">                ActivityResult result = <span class=\"keyword\">null</span>;                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 </span></span><br><span class=\"line\">                    result = am.onStartActivity(intent);                   </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;                                      </span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;                                         </span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (am.match(who, <span class=\"keyword\">null</span>, intent)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// match 使用 IntentFilter 和 类名 进行匹配</span></span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (am.isBlocking()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 当前监视器阻止 Activity 启动</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> requestCode &gt;= <span class=\"number\">0</span> ? am.getResult() : <span class=\"keyword\">null</span>;   </span><br><span class=\"line\">                    &#125;                                                      </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                 </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">            &#125;                                                              </span><br><span class=\"line\">        &#125;                                                                  </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 委托为 ActivityManagerService(AMS) 去处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ActivityManager.getService().startActivity();                          </span><br><span class=\"line\">        <span class=\"comment\">// 检查 AMS 的处理结果</span></span><br><span class=\"line\">        checkStartActivityResult(result, intent);                          </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Failure from system\"</span>, e);              </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以通过最后的调用委托给了<code>ActivityManager.getService</code>，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现</p>\n<blockquote>\n<p>相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IActivityManager <span class=\"title\">getService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> IActivityManagerSingleton.get();  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =          </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Singleton&lt;IActivityManager&gt;() &#123;                                           </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                                                 </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> IActivityManager <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">                <span class=\"keyword\">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);     </span><br><span class=\"line\">                <span class=\"keyword\">return</span> am;                                                            </span><br><span class=\"line\">            &#125;                                                                         </span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityManagerService\"><a href=\"#ActivityManagerService\" class=\"headerlink\" title=\"ActivityManagerService\"></a>ActivityManagerService</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                       </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                           </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivityAsUser();                                                     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">()</span> </span>&#123;                                                                                                                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mActivityStarter.startActivityMayWait();                                                                                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将启动请求又委托给了 ActivityStarter</p>\n<h3 id=\"ActivityStarter\"><a href=\"#ActivityStarter\" class=\"headerlink\" title=\"ActivityStarter\"></a>ActivityStarter</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityMayWait</span><span class=\"params\">()</span> </span>&#123;                                                </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的响应</span></span><br><span class=\"line\">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的 Activity 信息                                                               </span></span><br><span class=\"line\">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord[] outRecord = <span class=\"keyword\">new</span> ActivityRecord[<span class=\"number\">1</span>];</span><br><span class=\"line\">    \t<span class=\"comment\">// 调用 startActivityLocked</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = startActivityLocked(outRecord);                                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;                                                                                                       </span><br><span class=\"line\">    &#125;                                                                                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 源 Activity 记录，即在哪个 Activity 进行 startActivity</span></span><br><span class=\"line\">    ActivityRecord sourceRecord = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity</span></span><br><span class=\"line\">    ActivityRecord resultRecord = <span class=\"keyword\">null</span>;                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultTo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取 Activity Stack 中已经存在的源 Activity 记录</span></span><br><span class=\"line\">        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// requestCode &gt;= 0，源 Activity 同时为 结果 Activity</span></span><br><span class=\"line\">                resultRecord = sourceRecord;                                                                  </span><br><span class=\"line\">            &#125;                                                                                                 </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> launchFlags = intent.getFlags();                                                                </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class=\"number\">0</span> &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>) &#123;                   </span><br><span class=\"line\">        <span class=\"comment\">// 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity</span></span><br><span class=\"line\">        <span class=\"comment\">// 比如：A -&gt; B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不允许有 requestCode</span></span><br><span class=\"line\">            ActivityOptions.abort(options);                                                                   </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity</span></span><br><span class=\"line\">        resultRecord = sourceRecord.resultTo;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span> &amp;&amp; !resultRecord.isInStackLocked()) &#123;                                        </span><br><span class=\"line\">            resultRecord = <span class=\"keyword\">null</span>;                                                                              </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// requestCode 处理</span></span><br><span class=\"line\">        resultWho = sourceRecord.resultWho;                                                                   </span><br><span class=\"line\">        requestCode = sourceRecord.requestCode;                                                               </span><br><span class=\"line\">        sourceRecord.resultTo = <span class=\"keyword\">null</span>;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 删除源 Activity 记录</span></span><br><span class=\"line\">            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           </span><br><span class=\"line\">        &#125;                                                                                                                                                                                         </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class=\"keyword\">null</span>) &#123;                              </span><br><span class=\"line\">        <span class=\"comment\">// component 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class=\"keyword\">null</span>) &#123;                                              </span><br><span class=\"line\">        <span class=\"comment\">// ActivityInfo 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>                                          </span><br><span class=\"line\">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class=\"keyword\">null</span>) &#123;                                                 </span><br><span class=\"line\">        <span class=\"comment\">// 语音启动 Activity，检查是否符合                                                                      </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"comment\">// 启动语音会话                                                       </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack resultStack = resultRecord == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : resultRecord.getStack();                  </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err != START_SUCCESS) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 启动 Activity 失败</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发送取消通知</span></span><br><span class=\"line\">            resultStack.sendActivityResultLocked(                                                             </span><br><span class=\"line\">                    -<span class=\"number\">1</span>, resultRecord, resultWho, requestCode, RESULT_CANCELED, <span class=\"keyword\">null</span>);                         </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 进行一些权限检查，判断是否终止                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (abort) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果需要终止 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            resultStack.sendActivityResultLocked();                                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 返回启动成功，实际终止                                                                </span></span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_SUCCESS;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             </span></span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 处理 ephemeral app                                                                    </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造一个 ActivityRecord</span></span><br><span class=\"line\">    ActivityRecord r = <span class=\"keyword\">new</span> ActivityRecord();                                                   </span><br><span class=\"line\">                                                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack stack = mSupervisor.mFocusedStack;                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (voiceSession == <span class=\"keyword\">null</span> &amp;&amp; (stack.mResumedActivity == <span class=\"keyword\">null</span>                                               </span><br><span class=\"line\">            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mService.checkAppSwitchAllowedLocked() &#123;                                          </span><br><span class=\"line\">            PendingActivityLaunch pal =  <span class=\"keyword\">new</span> PendingActivityLaunch();                                              </span><br><span class=\"line\">            mPendingActivityLaunches.add(pal);                                                                </span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">            <span class=\"comment\">// 切换 app 失败</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_SWITCHES_CANCELED;                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.mDidAppSwitch) &#123;                                                                             </span><br><span class=\"line\">        <span class=\"comment\">// 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            </span></span><br><span class=\"line\">        mService.mAppSwitchesAllowedTime = <span class=\"number\">0</span>;                                                                 </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                                  </span><br><span class=\"line\">        mService.mDidAppSwitch = <span class=\"keyword\">true</span>;                                                                        </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 执行因为不允许 app 切换，而加到等待启动的 Activity</span></span><br><span class=\"line\">    doPendingActivityLaunchesLocked(<span class=\"keyword\">false</span>);                                                                   </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivity();                                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                                                        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = START_CANCELED;                                                               </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class=\"line\">        <span class=\"comment\">// 下一步流程</span></span><br><span class=\"line\">        result = startActivityUnchecked();                           </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ActivityManager.isStartResultSuccessful(result)                                   </span><br><span class=\"line\">                &amp;&amp; mStartActivity.getTask() != <span class=\"keyword\">null</span>) &#123;                                         </span><br><span class=\"line\">            mStartActivity.getTask().removeActivity(mStartActivity);                           </span><br><span class=\"line\">        &#125;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.continueSurfaceLayout();                                       </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    postStartActivityProcessing();                                                                     </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;                                                                             </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityUnchecked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 设置一些初始化状态</span></span><br><span class=\"line\">    setInitialState();</span><br><span class=\"line\">    <span class=\"comment\">// 计算 launch flags</span></span><br><span class=\"line\">    computeLaunchingTaskFlags();</span><br><span class=\"line\">    <span class=\"comment\">// 计算源 Task，源 Task 是否存在等</span></span><br><span class=\"line\">    computeSourceStack();</span><br><span class=\"line\">    <span class=\"comment\">// 获取是否存在可以复用的 Activity，根据 flags 和 launchMode</span></span><br><span class=\"line\">    ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reusedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 存在可复用的 Activity，复用它</span></span><br><span class=\"line\">        <span class=\"comment\">// 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.packageName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> START_CLASS_NOT_FOUND;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> dontStart = top != <span class=\"keyword\">null</span> &amp;&amp; mStartActivity.resultTo == <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class=\"line\">                &amp;&amp; top.userId == mStartActivity.userId</span><br><span class=\"line\">                &amp;&amp; top.app != <span class=\"keyword\">null</span> &amp;&amp; top.app.thread != <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != <span class=\"number\">0</span></span><br><span class=\"line\">                || mLaunchSingleTop || mLaunchSingleTask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dontStart)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递一个新的 Intent 到 onNewIntent </span></span><br><span class=\"line\">        top.deliverNewIntentLocked();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_DELIVERED_TO_TOP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取 mTargetStack</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.resultTo == <span class=\"keyword\">null</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span> &amp;&amp; !mAddingToTask</span><br><span class=\"line\">                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \tnewTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 需要创建新的 Task</span></span><br><span class=\"line\">        result = setTaskFromReuseOrCreateNewTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从源 Activity 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromSourceRecord();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mInTask != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 InTask 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromInTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可能创建新的 Task 或使用当前 Task，一般不会发生</span></span><br><span class=\"line\">    \tsetTaskToCurrentTopOrCreateNewTask();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用 mTargetStack 启动 Activity </span></span><br><span class=\"line\">    mTargetStack.startActivityLocked();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDoResume) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mTargetStack.isFocusable()</span><br><span class=\"line\">                    || (topTaskActivity != <span class=\"keyword\">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class=\"line\">                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity</span></span><br><span class=\"line\">            <span class=\"comment\">// 那么我们不恢复目标 Task，只需要确保它可见即可</span></span><br><span class=\"line\">            mTargetStack.ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台</span></span><br><span class=\"line\">            mTargetStack.moveToFront(<span class=\"string\">\"startActivityUnchecked\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复目标 Task</span></span><br><span class=\"line\">        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class=\"line\">                        mOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不需要恢复，那么加到\"最近活动\"中</span></span><br><span class=\"line\">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> START_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setInitialState</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 DisplayId</span></span><br><span class=\"line\">    mSourceDisplayId = getSourceDisplayId();</span><br><span class=\"line\">    <span class=\"comment\">// 获取用于启动 Activity 的范围，Rect</span></span><br><span class=\"line\">    mLaunchBounds = getOerrideBounds();</span><br><span class=\"line\">    <span class=\"comment\">// launchMode</span></span><br><span class=\"line\">    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;</span><br><span class=\"line\">    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;</span><br><span class=\"line\">    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;</span><br><span class=\"line\">    <span class=\"comment\">// Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 requestCode &gt;= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity</span></span><br><span class=\"line\">    sendNewTaskResultRequestIfNeeded();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">computeLaunchingTaskFlags</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span> &amp;&amp; mInTask != <span class=\"keyword\">null</span> &amp;&amp; mInTask.getStack() != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不存在源 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Intent baseIntent = mInTask.getBaseIntent();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord root = mInTask.getRootActivity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseIntent == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了 SingleInstacne 或 SingleTask</span></span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent()))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// Task 不符合</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 已经存在 Task 根 Activity</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果不存在根 Activity，重新设置 launch flags</span></span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">             mAddingToTask = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">if</span> ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) &amp;&amp; mSourceRecord != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; mSourceRecord.isFreeform())  &#123;</span><br><span class=\"line\">                         <span class=\"comment\">// 如果使用 ResolverActivity 启动或者 noDisplay</span></span><br><span class=\"line\">                mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mInTask == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 不存在 Task，并且不存在源 Activity</span></span><br><span class=\"line\">            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity</p>\n<h3 id=\"ActivityStack\"><a href=\"#ActivityStack\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!newTask) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果从已存在的 Task 中启动 Activity</span></span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> startIt = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> taskNdx = mTaskHistory.size() - <span class=\"number\">1</span>; taskNdx &gt;= <span class=\"number\">0</span>; --taskNdx) &#123;</span><br><span class=\"line\">      \ttask = mTaskHistory.get(taskNdx);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task.getTopActivity() == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果 task 不存在 Activity</span></span><br><span class=\"line\">              <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task == rTask) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// 找到对应的 task</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!startIt) &#123;</span><br><span class=\"line\">            \t<span class=\"comment\">// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动</span></span><br><span class=\"line\">                r.createWindowContainer();</span><br><span class=\"line\">                ActivityOptions.abort(options);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (task.numFullscreen &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              startIt = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == activityTask &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        mStackSupervisor.mUserLeaving = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHomeOrRecentsStack() || numActivities() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 处理 动画</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTask) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了重置的标记</span></span><br><span class=\"line\">            resetTaskIfNeededLocked(r, r);</span><br><span class=\"line\">            doShow = topRunningNonDelayedActivityLocked(<span class=\"keyword\">null</span>) == r;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span> &amp;&amp; options.getAnimationType()</span><br><span class=\"line\">                    == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 需要进行转场动画</span></span><br><span class=\"line\">                doShow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果为 true，那么不开启 window，但要确保 Activity 是可见的</span></span><br><span class=\"line\">            r.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class=\"line\">            TaskRecord prevTask = r.getTask();</span><br><span class=\"line\">            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 以下两种情况不展示之前的 Activity 预览</span></span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (prev.getTask() != prevTask) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 之前的 Activity 在不同的 Task</span></span><br><span class=\"line\">                \tprev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prev.nowVisible) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 现在可见</span></span><br><span class=\"line\">                \t prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 显示启动 Activity 的 Window</span></span><br><span class=\"line\">        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前为栈顶 Activity</span></span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ActivityStack.startActivityLocked</code> 主要是创建 WindowContainer，同时显示 Window</p>\n<h3 id=\"ActivityStackSupervisor\"><a href=\"#ActivityStackSupervisor\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeFocusedStackTopActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetStack != <span class=\"keyword\">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存在 targetStack</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"keyword\">null</span> || r.state != RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复聚焦 task</span></span><br><span class=\"line\">    \tmFocusedStack.resumeTopActivityUncheckedLocked(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state == RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行应用转场动画</span></span><br><span class=\"line\">    \tmFocusedStack.executeAppTransition(targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityStack-1\"><a href=\"#ActivityStack-1\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityUncheckedLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 防止递归</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置恢复标记</span></span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在恢复过程中，确保必要的暂停逻辑</span></span><br><span class=\"line\">    mStackSupervisor.checkReadyForSleepLocked();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityInnerLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord next = topRunningActivityLocked(<span class=\"keyword\">true</span> <span class=\"comment\">/* focusableOnly */</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasRunningActivity = next != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord parent = mActivityContainer.mParentActivity;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isParentNotResumed = parent != <span class=\"keyword\">null</span> &amp;&amp; parent.state != ActivityState.RESUMED;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasRunningActivity</span><br><span class=\"line\">                &amp;&amp; (isParentNotResumed || !mActivityContainer.isAttachedLocked())) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 如果父 Activity 不是恢复状态，则不恢复当前 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasRunningActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 Task 没有需要恢复的 Activity</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> resumeTopActivityInNextFocusableStack(prev, options, <span class=\"string\">\"noMoreActivities\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                    mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保已经执行了所有等待的转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingOrShuttingDownLocked()</span><br><span class=\"line\">                &amp;&amp; mLastPausedActivity == next</span><br><span class=\"line\">                &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果系统处于休眠状态，当前 Activity 处于暂停状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保转场执行</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mService.mUserController.hasStartedUserState(next.userId)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果拥有该 Activity 的用户没有启动</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果存在暂停 Activity 的操作未完成</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> lastResumedCanPip = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastFocusedStack != <span class=\"keyword\">null</span> &amp;&amp; lastFocusedStack != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class=\"line\">        <span class=\"comment\">// 最后一个恢复的 Activity 是否可以 画中画</span></span><br><span class=\"line\">        lastResumedCanPip = lastResumed != <span class=\"keyword\">null</span> &amp;&amp; lastResumed.checkEnterPictureInPictureState(</span><br><span class=\"line\">                    <span class=\"string\">\"resumeTopActivity\"</span>, <span class=\"keyword\">true</span> <span class=\"comment\">/* noThrow */</span>, userLeaving <span class=\"comment\">/* beforeStopping */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 是否需要可以在上一个 Activity 暂停时进行恢复</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; !lastResumedCanPip;</span><br><span class=\"line\">    <span class=\"comment\">// 是否暂停了回退的 task</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 暂停上一个恢复状态的 Activity</span></span><br><span class=\"line\">    \tpausing |= startPausingLocked(userLeaving, <span class=\"keyword\">false</span>, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hosting application，一般不执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 让当前 Activity 放在 Lru 的顶部，避免早早杀死</span></span><br><span class=\"line\">        \tmService.updateLruProcessLocked(next.app, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 当前需要恢复的 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保执行转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingLocked() &amp;&amp; mLastNoHistoryActivity != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                !mLastNoHistoryActivity.finishing) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 结束因为系统休眠而还没结束的 Activity</span></span><br><span class=\"line\">    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,</span><br><span class=\"line\">                    <span class=\"keyword\">null</span>, <span class=\"string\">\"resume-no-history\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        mLastNoHistoryActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span> &amp;&amp; prev != next) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class=\"line\">                    &amp;&amp; next != <span class=\"keyword\">null</span> &amp;&amp; !next.nowVisible) &#123;</span><br><span class=\"line\">        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev.finishing) &#123;</span><br><span class=\"line\">            \tprev.setVisibility(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity 转场处理</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 上一个 Activity 是否为透明</span></span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> lastActivityTranslucent = lastStack != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; (!lastStack.mFullscreen</span><br><span class=\"line\">                    || (lastStack.mLastPausedActivity != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; !lastStack.mLastPausedActivity.fullscreen));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!next.visible || next.stopped || lastActivityTranslucent) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 前一个 Activity 为透明，并且当前 Activity 还没显示</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置为显示状态</span></span><br><span class=\"line\">            next.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> notUpdated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.isFocusedStack(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> Configuration config = mWindowManager.updateOrientationFromAppTokens(</span><br><span class=\"line\">                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),</span><br><span class=\"line\">                        next.mayFreezeScreenLocked(next.app) ? next.appToken : <span class=\"keyword\">null</span>, mDisplayId);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tnext.frozenBeforeDestroy = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,</span><br><span class=\"line\">                        <span class=\"keyword\">false</span> <span class=\"comment\">/* deferResume */</span>, mDisplayId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (notUpdated) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 配置发生更新无法保持已经存在的 Activity 实例</span></span><br><span class=\"line\">         <span class=\"comment\">// 重新获取需要恢复的 Activity</span></span><br><span class=\"line\">         ActivityRecord nextNext = topRunningActivityLocked();</span><br><span class=\"line\">         <span class=\"comment\">// 确保 Activity 仍然保持在栈顶，同时安排另外一次执行</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (nextNext != next) &#123;</span><br><span class=\"line\">         \tmStackSupervisor.scheduleResumeTopActivities();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!next.visible || next.stopped) &#123;</span><br><span class=\"line\">         \tnext.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         next.completeResumeLocked();</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递所有等待的结果</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.newIntents != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            next.app.thread.scheduleNewIntent(</span><br><span class=\"line\">                            next.newIntents, next.appToken, <span class=\"keyword\">false</span> <span class=\"comment\">/* andPause */</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        next.notifyAppResumed(next.stopped);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 准备恢复 Activity</span></span><br><span class=\"line\">        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,</span><br><span class=\"line\">                        mService.isNextTransitionForward(), resumeAnimOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，重新启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            next.completeResumeLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"resume-exception\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 需要启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：</p>\n<h3 id=\"ActivityStackSupervisor-1\"><a href=\"#ActivityStackSupervisor-1\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取应用进程信息</span></span><br><span class=\"line\">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">                r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果进程已经启动</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (RemoteException e)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 启动应用进程</span></span><br><span class=\"line\">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 冻结屏幕</span></span><br><span class=\"line\">    r.startFreezingScreenLocked(app, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkConfig) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 根据新的 Activity 顺序重新评估屏幕的方向</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = app.activities.indexOf(r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将 Activity 添加到应用进程中</span></span><br><span class=\"line\">        app.activities.add(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        app.thread.scheduleLaunchActivity();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(RemoteException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"2nd-crash\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动流程最后还是回到了 ApplicationThread</p>\n<h3 id=\"ApplicationThread\"><a href=\"#ApplicationThread\" class=\"headerlink\" title=\"ApplicationThread\"></a>ApplicationThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 Handler 发送 LAUNCH_ACTIVITY</span></span><br><span class=\"line\">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们单独把 LAUNCH_ACTIVITY 的处理拿出来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\">r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">\"LAUNCH_ACTIVITY\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityThread\"><a href=\"#ActivityThread\" class=\"headerlink\" title=\"ActivityThread\"></a>ActivityThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行启动 Activity</span></span><br><span class=\"line\">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// resume activity</span></span><br><span class=\"line\">        handleResumeActivity(r.token, <span class=\"keyword\">false</span>, r.isForward,</span><br><span class=\"line\">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Activity 信息初始化</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 context</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        <span class=\"comment\">// 构建 Activity</span></span><br><span class=\"line\">        activity = mInstrumentation.newActivity(</span><br><span class=\"line\">                    cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(activity != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        \tactivity.attach();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onCreate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Activity onStart</span></span><br><span class=\"line\">            \tactivity.performStart();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onRestoreInstanceState</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                \t<span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span> || r.persistentState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class=\"line\">                                    r.persistentState);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">             <span class=\"comment\">// 通过 Instrumentation 执行 Activity onPostCreeate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class=\"line\">                                r.persistentState);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> activity;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    r = performResumeActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            r.window = r.activity.getWindow();</span><br><span class=\"line\">            View decor = r.window.getDecorView();</span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                \ta.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// window</span></span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span> &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 Intent</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingIntents != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverNewIntents(r, r.pendingIntents);</span><br><span class=\"line\">                r.pendingIntents = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 result</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingResults != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverResults(r, r.pendingResults);</span><br><span class=\"line\">                r.pendingResults = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 执行 resume</span></span><br><span class=\"line\">            r.activity.performResume();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-1\"><a href=\"#Instrumentation-1\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">newActivity</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    prePerformCreate(activity);</span><br><span class=\"line\">    activity.performCreate(icicle);</span><br><span class=\"line\">    postPerformCreate(activity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Activity-1\"><a href=\"#Activity-1\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class=\"line\">    <span class=\"comment\">// 调用 onCreate</span></span><br><span class=\"line\">    onCreate(icicle);</span><br><span class=\"line\">    mActivityTransitionState.readState(icicle);</span><br><span class=\"line\">    performCreateCommon();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mActivityTransitionState.setEnterActivityOptions(<span class=\"keyword\">this</span>, getActivityOptions());</span><br><span class=\"line\">    mInstrumentation.callActivityOnStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    mActivityTransitionState.enterReady(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行 restart</span></span><br><span class=\"line\">    performRestart();</span><br><span class=\"line\">    mInstrumentation.callActivityOnResume(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStopped) &#123;</span><br><span class=\"line\">        mStopped = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mInstrumentation.callActivityOnRestart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 执行 start</span></span><br><span class=\"line\">        performStart();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-2\"><a href=\"#Instrumentation-2\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onStart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     activity.mResumed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    activity.onResume();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onRestart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>简单总结下 Activity 的启动流程：</p>\n<ol>\n<li>从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信</li>\n<li>ActivityManagerService 用于管理所有的 Activity 活动<ul>\n<li>当接受到启动 Activity 的调用时，使用 <code>resolveActivity</code> ，查询系统中符合要求的 Activity</li>\n<li>创建使用合适的  ActivityStack 和 launch flags 来启动 Activity</li>\n<li>如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity</li>\n<li>如果不存在应用进程，先创建应用进程</li>\n</ul>\n</li>\n<li>最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行<ul>\n<li>使用 Instrumentation 去通过反射构建 Activity 实例</li>\n<li>使用 Handler 机制调用 Activity 的生命周期</li>\n</ul>\n</li>\n</ol>\n<p>下面的图例来自<a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">博客</a>：</p>\n<p><img src=\"http://gityuan.com/images/activity/start_activity_process.jpg\" alt=\"启动流程\"></p>\n<h3 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h3><p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png?x-oss-process=style/doc-img\" alt=\"Android启动流程\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>基于 Android 26，分析 Android Activity 启动流程</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">startActivity启动过程分析</a></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><strong>源码篇幅可能过长，所以会省略一下不必要的代码和注释</strong></p>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.startActivity(intent, <span class=\"keyword\">null</span>);        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>, options);                </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                        </span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>);                         </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终都会调用到 <code>startActivityForResult</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">()</span> </span>&#123;                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 转场动画的处理</span></span><br><span class=\"line\">        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity();                                                                                                                                                      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;                                                                       </span><br><span class=\"line\">            mMainThread.sendActivityResult();                                                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;                                                                                        </span><br><span class=\"line\">            mStartedActivity = <span class=\"keyword\">true</span>;                                                            </span><br><span class=\"line\">        &#125;                                                                                                                                                                             </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                    </span><br><span class=\"line\">        <span class=\"comment\">// 如果存在 Parent Activity 则交由它处理                                                                                    </span></span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道 Activity 启动委托给了 Instrumentation 进行实现</p>\n<h3 id=\"Instrumentation\"><a href=\"#Instrumentation\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由 ActivityThread.getApplicationThread 提供的 ApplicationThread</span></span><br><span class=\"line\">    IApplicationThread whoThread = (IApplicationThread) contextThread;                                                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActivityMonitors != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mSync) &#123;                                             </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = mActivityMonitors.size();                        </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;                                      </span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityMonitor am = mActivityMonitors.get(i);       </span><br><span class=\"line\">                ActivityResult result = <span class=\"keyword\">null</span>;                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 </span></span><br><span class=\"line\">                    result = am.onStartActivity(intent);                   </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;                                      </span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;                                         </span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (am.match(who, <span class=\"keyword\">null</span>, intent)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// match 使用 IntentFilter 和 类名 进行匹配</span></span><br><span class=\"line\">                    am.mHits++;                                            </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (am.isBlocking()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 当前监视器阻止 Activity 启动</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> requestCode &gt;= <span class=\"number\">0</span> ? am.getResult() : <span class=\"keyword\">null</span>;   </span><br><span class=\"line\">                    &#125;                                                      </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                 </span><br><span class=\"line\">                &#125;                                                          </span><br><span class=\"line\">            &#125;                                                              </span><br><span class=\"line\">        &#125;                                                                  </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 委托为 ActivityManagerService(AMS) 去处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ActivityManager.getService().startActivity();                          </span><br><span class=\"line\">        <span class=\"comment\">// 检查 AMS 的处理结果</span></span><br><span class=\"line\">        checkStartActivityResult(result, intent);                          </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Failure from system\"</span>, e);              </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以通过最后的调用委托给了<code>ActivityManager.getService</code>，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现</p>\n<blockquote>\n<p>相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IActivityManager <span class=\"title\">getService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> IActivityManagerSingleton.get();  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =          </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Singleton&lt;IActivityManager&gt;() &#123;                                           </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                                                 </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> IActivityManager <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">                <span class=\"keyword\">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);     </span><br><span class=\"line\">                <span class=\"keyword\">return</span> am;                                                            </span><br><span class=\"line\">            &#125;                                                                         </span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityManagerService\"><a href=\"#ActivityManagerService\" class=\"headerlink\" title=\"ActivityManagerService\"></a>ActivityManagerService</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                       </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                           </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivityAsUser();                                                     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">()</span> </span>&#123;                                                                                                                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mActivityStarter.startActivityMayWait();                                                                                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将启动请求又委托给了 ActivityStarter</p>\n<h3 id=\"ActivityStarter\"><a href=\"#ActivityStarter\" class=\"headerlink\" title=\"ActivityStarter\"></a>ActivityStarter</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityMayWait</span><span class=\"params\">()</span> </span>&#123;                                                </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的响应</span></span><br><span class=\"line\">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);                                                                                                                                           </span><br><span class=\"line\">    <span class=\"comment\">// Intent 的 Activity 信息                                                               </span></span><br><span class=\"line\">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);                                                                                                                                                                                                                                                                                                                                        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord[] outRecord = <span class=\"keyword\">new</span> ActivityRecord[<span class=\"number\">1</span>];</span><br><span class=\"line\">    \t<span class=\"comment\">// 调用 startActivityLocked</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = startActivityLocked(outRecord);                                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;                                                                                                       </span><br><span class=\"line\">    &#125;                                                                                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 源 Activity 记录，即在哪个 Activity 进行 startActivity</span></span><br><span class=\"line\">    ActivityRecord sourceRecord = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity</span></span><br><span class=\"line\">    ActivityRecord resultRecord = <span class=\"keyword\">null</span>;                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultTo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取 Activity Stack 中已经存在的源 Activity 记录</span></span><br><span class=\"line\">        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);                                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// requestCode &gt;= 0，源 Activity 同时为 结果 Activity</span></span><br><span class=\"line\">                resultRecord = sourceRecord;                                                                  </span><br><span class=\"line\">            &#125;                                                                                                 </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> launchFlags = intent.getFlags();                                                                </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class=\"number\">0</span> &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>) &#123;                   </span><br><span class=\"line\">        <span class=\"comment\">// 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity</span></span><br><span class=\"line\">        <span class=\"comment\">// 比如：A -&gt; B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不允许有 requestCode</span></span><br><span class=\"line\">            ActivityOptions.abort(options);                                                                   </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;                                        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity</span></span><br><span class=\"line\">        resultRecord = sourceRecord.resultTo;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span> &amp;&amp; !resultRecord.isInStackLocked()) &#123;                                        </span><br><span class=\"line\">            resultRecord = <span class=\"keyword\">null</span>;                                                                              </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// requestCode 处理</span></span><br><span class=\"line\">        resultWho = sourceRecord.resultWho;                                                                   </span><br><span class=\"line\">        requestCode = sourceRecord.requestCode;                                                               </span><br><span class=\"line\">        sourceRecord.resultTo = <span class=\"keyword\">null</span>;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 删除源 Activity 记录</span></span><br><span class=\"line\">            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);                           </span><br><span class=\"line\">        &#125;                                                                                                                                                                                         </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class=\"keyword\">null</span>) &#123;                              </span><br><span class=\"line\">        <span class=\"comment\">// component 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_INTENT_NOT_RESOLVED;                                                      </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class=\"keyword\">null</span>) &#123;                                              </span><br><span class=\"line\">        <span class=\"comment\">// ActivityInfo 找不到                                                                         </span></span><br><span class=\"line\">        err = ActivityManager.START_CLASS_NOT_FOUND;                                                          </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class=\"keyword\">null</span>                                          </span><br><span class=\"line\">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class=\"keyword\">null</span>) &#123;                                                 </span><br><span class=\"line\">        <span class=\"comment\">// 语音启动 Activity，检查是否符合                                                                      </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">        <span class=\"comment\">// 启动语音会话                                                       </span></span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack resultStack = resultRecord == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : resultRecord.getStack();                  </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err != START_SUCCESS) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 启动 Activity 失败</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发送取消通知</span></span><br><span class=\"line\">            resultStack.sendActivityResultLocked(                                                             </span><br><span class=\"line\">                    -<span class=\"number\">1</span>, resultRecord, resultWho, requestCode, RESULT_CANCELED, <span class=\"keyword\">null</span>);                         </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 进行一些权限检查，判断是否终止                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (abort) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果需要终止 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultRecord != <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">            resultStack.sendActivityResultLocked();                                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 返回启动成功，实际终止                                                                </span></span><br><span class=\"line\">        ActivityOptions.abort(options);                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_SUCCESS;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent                                                             </span></span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// 处理 ephemeral app                                                                    </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造一个 ActivityRecord</span></span><br><span class=\"line\">    ActivityRecord r = <span class=\"keyword\">new</span> ActivityRecord();                                                   </span><br><span class=\"line\">                                                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack stack = mSupervisor.mFocusedStack;                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (voiceSession == <span class=\"keyword\">null</span> &amp;&amp; (stack.mResumedActivity == <span class=\"keyword\">null</span>                                               </span><br><span class=\"line\">            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mService.checkAppSwitchAllowedLocked() &#123;                                          </span><br><span class=\"line\">            PendingActivityLaunch pal =  <span class=\"keyword\">new</span> PendingActivityLaunch();                                              </span><br><span class=\"line\">            mPendingActivityLaunches.add(pal);                                                                </span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">            <span class=\"comment\">// 切换 app 失败</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ActivityManager.START_SWITCHES_CANCELED;                                                   </span><br><span class=\"line\">        &#125;                                                                                                     </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.mDidAppSwitch) &#123;                                                                             </span><br><span class=\"line\">        <span class=\"comment\">// 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0                                                            </span></span><br><span class=\"line\">        mService.mAppSwitchesAllowedTime = <span class=\"number\">0</span>;                                                                 </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                                  </span><br><span class=\"line\">        mService.mDidAppSwitch = <span class=\"keyword\">true</span>;                                                                        </span><br><span class=\"line\">    &#125;                                                                                                         </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 执行因为不允许 app 切换，而加到等待启动的 Activity</span></span><br><span class=\"line\">    doPendingActivityLaunchesLocked(<span class=\"keyword\">false</span>);                                                                   </span><br><span class=\"line\">                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivity();                                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">()</span> </span>&#123;                                                        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = START_CANCELED;                                                               </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class=\"line\">        <span class=\"comment\">// 下一步流程</span></span><br><span class=\"line\">        result = startActivityUnchecked();                           </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// 如果启动 Activity 没有成功， 从 task 中移除 Activity                                                      </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ActivityManager.isStartResultSuccessful(result)                                   </span><br><span class=\"line\">                &amp;&amp; mStartActivity.getTask() != <span class=\"keyword\">null</span>) &#123;                                         </span><br><span class=\"line\">            mStartActivity.getTask().removeActivity(mStartActivity);                           </span><br><span class=\"line\">        &#125;                                                                                      </span><br><span class=\"line\">        mService.mWindowManager.continueSurfaceLayout();                                       </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    postStartActivityProcessing();                                                                     </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;                                                                             </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityUnchecked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 设置一些初始化状态</span></span><br><span class=\"line\">    setInitialState();</span><br><span class=\"line\">    <span class=\"comment\">// 计算 launch flags</span></span><br><span class=\"line\">    computeLaunchingTaskFlags();</span><br><span class=\"line\">    <span class=\"comment\">// 计算源 Task，源 Task 是否存在等</span></span><br><span class=\"line\">    computeSourceStack();</span><br><span class=\"line\">    <span class=\"comment\">// 获取是否存在可以复用的 Activity，根据 flags 和 launchMode</span></span><br><span class=\"line\">    ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reusedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 存在可复用的 Activity，复用它</span></span><br><span class=\"line\">        <span class=\"comment\">// 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.packageName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> START_CLASS_NOT_FOUND;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> dontStart = top != <span class=\"keyword\">null</span> &amp;&amp; mStartActivity.resultTo == <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class=\"line\">                &amp;&amp; top.userId == mStartActivity.userId</span><br><span class=\"line\">                &amp;&amp; top.app != <span class=\"keyword\">null</span> &amp;&amp; top.app.thread != <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != <span class=\"number\">0</span></span><br><span class=\"line\">                || mLaunchSingleTop || mLaunchSingleTask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dontStart)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递一个新的 Intent 到 onNewIntent </span></span><br><span class=\"line\">        top.deliverNewIntentLocked();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> START_DELIVERED_TO_TOP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取 mTargetStack</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartActivity.resultTo == <span class=\"keyword\">null</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span> &amp;&amp; !mAddingToTask</span><br><span class=\"line\">                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \tnewTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 需要创建新的 Task</span></span><br><span class=\"line\">        result = setTaskFromReuseOrCreateNewTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从源 Activity 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromSourceRecord();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mInTask != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 InTask 中获取 Task</span></span><br><span class=\"line\">    \tresult = setTaskFromInTask();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可能创建新的 Task 或使用当前 Task，一般不会发生</span></span><br><span class=\"line\">    \tsetTaskToCurrentTopOrCreateNewTask();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用 mTargetStack 启动 Activity </span></span><br><span class=\"line\">    mTargetStack.startActivityLocked();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDoResume) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mTargetStack.isFocusable()</span><br><span class=\"line\">                    || (topTaskActivity != <span class=\"keyword\">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class=\"line\">                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity</span></span><br><span class=\"line\">            <span class=\"comment\">// 那么我们不恢复目标 Task，只需要确保它可见即可</span></span><br><span class=\"line\">            mTargetStack.ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台</span></span><br><span class=\"line\">            mTargetStack.moveToFront(<span class=\"string\">\"startActivityUnchecked\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复目标 Task</span></span><br><span class=\"line\">        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class=\"line\">                        mOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不需要恢复，那么加到\"最近活动\"中</span></span><br><span class=\"line\">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> START_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setInitialState</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 DisplayId</span></span><br><span class=\"line\">    mSourceDisplayId = getSourceDisplayId();</span><br><span class=\"line\">    <span class=\"comment\">// 获取用于启动 Activity 的范围，Rect</span></span><br><span class=\"line\">    mLaunchBounds = getOerrideBounds();</span><br><span class=\"line\">    <span class=\"comment\">// launchMode</span></span><br><span class=\"line\">    mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP;</span><br><span class=\"line\">    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;</span><br><span class=\"line\">    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;</span><br><span class=\"line\">    <span class=\"comment\">// Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 requestCode &gt;= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity</span></span><br><span class=\"line\">    sendNewTaskResultRequestIfNeeded();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">computeLaunchingTaskFlags</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span> &amp;&amp; mInTask != <span class=\"keyword\">null</span> &amp;&amp; mInTask.getStack() != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不存在源 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Intent baseIntent = mInTask.getBaseIntent();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityRecord root = mInTask.getRootActivity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseIntent == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了 SingleInstacne 或 SingleTask</span></span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent()))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// Task 不符合</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 已经存在 Task 根 Activity</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果不存在根 Activity，重新设置 launch flags</span></span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">             mAddingToTask = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">if</span> ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) &amp;&amp; mSourceRecord != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; mSourceRecord.isFreeform())  &#123;</span><br><span class=\"line\">                         <span class=\"comment\">// 如果使用 ResolverActivity 启动或者 noDisplay</span></span><br><span class=\"line\">                mAddingToTask = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mInTask == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mSourceRecord == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span> &amp;&amp; mInTask == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 不存在 Task，并且不存在源 Activity</span></span><br><span class=\"line\">            \tmLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag</span></span><br><span class=\"line\">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity</p>\n<h3 id=\"ActivityStack\"><a href=\"#ActivityStack\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!newTask) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果从已存在的 Task 中启动 Activity</span></span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> startIt = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> taskNdx = mTaskHistory.size() - <span class=\"number\">1</span>; taskNdx &gt;= <span class=\"number\">0</span>; --taskNdx) &#123;</span><br><span class=\"line\">      \ttask = mTaskHistory.get(taskNdx);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task.getTopActivity() == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果 task 不存在 Activity</span></span><br><span class=\"line\">              <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task == rTask) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// 找到对应的 task</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!startIt) &#123;</span><br><span class=\"line\">            \t<span class=\"comment\">// 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动</span></span><br><span class=\"line\">                r.createWindowContainer();</span><br><span class=\"line\">                ActivityOptions.abort(options);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (task.numFullscreen &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              startIt = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == activityTask &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        mStackSupervisor.mUserLeaving = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHomeOrRecentsStack() || numActivities() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 处理 动画</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTask) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了重置的标记</span></span><br><span class=\"line\">            resetTaskIfNeededLocked(r, r);</span><br><span class=\"line\">            doShow = topRunningNonDelayedActivityLocked(<span class=\"keyword\">null</span>) == r;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span> &amp;&amp; options.getAnimationType()</span><br><span class=\"line\">                    == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 需要进行转场动画</span></span><br><span class=\"line\">                doShow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 如果为 true，那么不开启 window，但要确保 Activity 是可见的</span></span><br><span class=\"line\">            r.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            ensureActivitiesVisibleLocked(<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, !PRESERVE_WINDOWS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class=\"line\">            TaskRecord prevTask = r.getTask();</span><br><span class=\"line\">            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 以下两种情况不展示之前的 Activity 预览</span></span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (prev.getTask() != prevTask) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 之前的 Activity 在不同的 Task</span></span><br><span class=\"line\">                \tprev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prev.nowVisible) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 现在可见</span></span><br><span class=\"line\">                \t prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 显示启动 Activity 的 Window</span></span><br><span class=\"line\">        \tr.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前为栈顶 Activity</span></span><br><span class=\"line\">            ActivityOptions.abort(options);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ActivityStack.startActivityLocked</code> 主要是创建 WindowContainer，同时显示 Window</p>\n<h3 id=\"ActivityStackSupervisor\"><a href=\"#ActivityStackSupervisor\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeFocusedStackTopActivityLocked</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetStack != <span class=\"keyword\">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存在 targetStack</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"keyword\">null</span> || r.state != RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复聚焦 task</span></span><br><span class=\"line\">    \tmFocusedStack.resumeTopActivityUncheckedLocked(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state == RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行应用转场动画</span></span><br><span class=\"line\">    \tmFocusedStack.executeAppTransition(targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityStack-1\"><a href=\"#ActivityStack-1\" class=\"headerlink\" title=\"ActivityStack\"></a>ActivityStack</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityUncheckedLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 防止递归</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置恢复标记</span></span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在恢复过程中，确保必要的暂停逻辑</span></span><br><span class=\"line\">    mStackSupervisor.checkReadyForSleepLocked();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityInnerLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord next = topRunningActivityLocked(<span class=\"keyword\">true</span> <span class=\"comment\">/* focusableOnly */</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasRunningActivity = next != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord parent = mActivityContainer.mParentActivity;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isParentNotResumed = parent != <span class=\"keyword\">null</span> &amp;&amp; parent.state != ActivityState.RESUMED;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasRunningActivity</span><br><span class=\"line\">                &amp;&amp; (isParentNotResumed || !mActivityContainer.isAttachedLocked())) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 如果父 Activity 不是恢复状态，则不恢复当前 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasRunningActivity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 Task 没有需要恢复的 Activity</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> resumeTopActivityInNextFocusableStack(prev, options, <span class=\"string\">\"noMoreActivities\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                    mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保已经执行了所有等待的转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingOrShuttingDownLocked()</span><br><span class=\"line\">                &amp;&amp; mLastPausedActivity == next</span><br><span class=\"line\">                &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果系统处于休眠状态，当前 Activity 处于暂停状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保转场执行</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mService.mUserController.hasStartedUserState(next.userId)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果拥有该 Activity 的用户没有启动</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果存在暂停 Activity 的操作未完成</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> lastResumedCanPip = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastFocusedStack != <span class=\"keyword\">null</span> &amp;&amp; lastFocusedStack != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class=\"line\">        <span class=\"comment\">// 最后一个恢复的 Activity 是否可以 画中画</span></span><br><span class=\"line\">        lastResumedCanPip = lastResumed != <span class=\"keyword\">null</span> &amp;&amp; lastResumed.checkEnterPictureInPictureState(</span><br><span class=\"line\">                    <span class=\"string\">\"resumeTopActivity\"</span>, <span class=\"keyword\">true</span> <span class=\"comment\">/* noThrow */</span>, userLeaving <span class=\"comment\">/* beforeStopping */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 是否需要可以在上一个 Activity 暂停时进行恢复</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; !lastResumedCanPip;</span><br><span class=\"line\">    <span class=\"comment\">// 是否暂停了回退的 task</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 暂停上一个恢复状态的 Activity</span></span><br><span class=\"line\">    \tpausing |= startPausingLocked(userLeaving, <span class=\"keyword\">false</span>, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 之前的 Activity 已经暂停，但不能进行恢复当前 Activity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hosting application，一般不执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 让当前 Activity 放在 Lru 的顶部，避免早早杀死</span></span><br><span class=\"line\">        \tmService.updateLruProcessLocked(next.app, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class=\"line\">                mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 当前需要恢复的 Activity 已经是恢复状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 确保执行转场</span></span><br><span class=\"line\">        executeAppTransition(options);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mService.isSleepingLocked() &amp;&amp; mLastNoHistoryActivity != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                !mLastNoHistoryActivity.finishing) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 结束因为系统休眠而还没结束的 Activity</span></span><br><span class=\"line\">    \trequestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,</span><br><span class=\"line\">                    <span class=\"keyword\">null</span>, <span class=\"string\">\"resume-no-history\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        mLastNoHistoryActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span> &amp;&amp; prev != next) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class=\"line\">                    &amp;&amp; next != <span class=\"keyword\">null</span> &amp;&amp; !next.nowVisible) &#123;</span><br><span class=\"line\">        \tmStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev.finishing) &#123;</span><br><span class=\"line\">            \tprev.setVisibility(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity 转场处理</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 上一个 Activity 是否为透明</span></span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> lastActivityTranslucent = lastStack != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; (!lastStack.mFullscreen</span><br><span class=\"line\">                    || (lastStack.mLastPausedActivity != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; !lastStack.mLastPausedActivity.fullscreen));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!next.visible || next.stopped || lastActivityTranslucent) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 前一个 Activity 为透明，并且当前 Activity 还没显示</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置为显示状态</span></span><br><span class=\"line\">            next.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> notUpdated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStackSupervisor.isFocusedStack(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> Configuration config = mWindowManager.updateOrientationFromAppTokens(</span><br><span class=\"line\">                        mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),</span><br><span class=\"line\">                        next.mayFreezeScreenLocked(next.app) ? next.appToken : <span class=\"keyword\">null</span>, mDisplayId);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tnext.frozenBeforeDestroy = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,</span><br><span class=\"line\">                        <span class=\"keyword\">false</span> <span class=\"comment\">/* deferResume */</span>, mDisplayId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (notUpdated) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 配置发生更新无法保持已经存在的 Activity 实例</span></span><br><span class=\"line\">         <span class=\"comment\">// 重新获取需要恢复的 Activity</span></span><br><span class=\"line\">         ActivityRecord nextNext = topRunningActivityLocked();</span><br><span class=\"line\">         <span class=\"comment\">// 确保 Activity 仍然保持在栈顶，同时安排另外一次执行</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (nextNext != next) &#123;</span><br><span class=\"line\">         \tmStackSupervisor.scheduleResumeTopActivities();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!next.visible || next.stopped) &#123;</span><br><span class=\"line\">         \tnext.setVisibility(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         next.completeResumeLocked();</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递所有等待的结果</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.newIntents != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            next.app.thread.scheduleNewIntent(</span><br><span class=\"line\">                            next.newIntents, next.appToken, <span class=\"keyword\">false</span> <span class=\"comment\">/* andPause */</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        next.notifyAppResumed(next.stopped);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 准备恢复 Activity</span></span><br><span class=\"line\">        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,</span><br><span class=\"line\">                        mService.isNextTransitionForward(), resumeAnimOptions);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，重新启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            next.completeResumeLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"resume-exception\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 需要启动 Activity</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程：</p>\n<h3 id=\"ActivityStackSupervisor-1\"><a href=\"#ActivityStackSupervisor-1\" class=\"headerlink\" title=\"ActivityStackSupervisor\"></a>ActivityStackSupervisor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取应用进程信息</span></span><br><span class=\"line\">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">                r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果进程已经启动</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (RemoteException e)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 启动应用进程</span></span><br><span class=\"line\">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 冻结屏幕</span></span><br><span class=\"line\">    r.startFreezingScreenLocked(app, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkConfig) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 根据新的 Activity 顺序重新评估屏幕的方向</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = app.activities.indexOf(r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将 Activity 添加到应用进程中</span></span><br><span class=\"line\">        app.activities.add(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        app.thread.scheduleLaunchActivity();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(RemoteException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发生异常，结束 Activity</span></span><br><span class=\"line\">        stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"2nd-crash\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动流程最后还是回到了 ApplicationThread</p>\n<h3 id=\"ApplicationThread\"><a href=\"#ApplicationThread\" class=\"headerlink\" title=\"ApplicationThread\"></a>ApplicationThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 Handler 发送 LAUNCH_ACTIVITY</span></span><br><span class=\"line\">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们单独把 LAUNCH_ACTIVITY 的处理拿出来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\">r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">\"LAUNCH_ACTIVITY\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"ActivityThread\"><a href=\"#ActivityThread\" class=\"headerlink\" title=\"ActivityThread\"></a>ActivityThread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行启动 Activity</span></span><br><span class=\"line\">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// resume activity</span></span><br><span class=\"line\">        handleResumeActivity(r.token, <span class=\"keyword\">false</span>, r.isForward,</span><br><span class=\"line\">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Activity 信息初始化</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 context</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        <span class=\"comment\">// 构建 Activity</span></span><br><span class=\"line\">        activity = mInstrumentation.newActivity(</span><br><span class=\"line\">                    cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(activity != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        \tactivity.attach();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onCreate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Activity onStart</span></span><br><span class=\"line\">            \tactivity.performStart();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 通过 Instrumentation 执行 Activity onRestoreInstanceState</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                \t<span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span> || r.persistentState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    \tmInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class=\"line\">                                    r.persistentState);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">             <span class=\"comment\">// 通过 Instrumentation 执行 Activity onPostCreeate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!r.activity.mFinished) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class=\"line\">                                r.persistentState);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> activity;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    r = performResumeActivity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            r.window = r.activity.getWindow();</span><br><span class=\"line\">            View decor = r.window.getDecorView();</span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                \ta.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// window</span></span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span> &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 Intent</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingIntents != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverNewIntents(r, r.pendingIntents);</span><br><span class=\"line\">                r.pendingIntents = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理等待的 result</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingResults != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \tdeliverResults(r, r.pendingResults);</span><br><span class=\"line\">                r.pendingResults = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 执行 resume</span></span><br><span class=\"line\">            r.activity.performResume();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-1\"><a href=\"#Instrumentation-1\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">newActivity</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    prePerformCreate(activity);</span><br><span class=\"line\">    activity.performCreate(icicle);</span><br><span class=\"line\">    postPerformCreate(activity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Activity-1\"><a href=\"#Activity-1\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class=\"line\">    <span class=\"comment\">// 调用 onCreate</span></span><br><span class=\"line\">    onCreate(icicle);</span><br><span class=\"line\">    mActivityTransitionState.readState(icicle);</span><br><span class=\"line\">    performCreateCommon();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mActivityTransitionState.setEnterActivityOptions(<span class=\"keyword\">this</span>, getActivityOptions());</span><br><span class=\"line\">    mInstrumentation.callActivityOnStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    mActivityTransitionState.enterReady(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行 restart</span></span><br><span class=\"line\">    performRestart();</span><br><span class=\"line\">    mInstrumentation.callActivityOnResume(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStopped) &#123;</span><br><span class=\"line\">        mStopped = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mInstrumentation.callActivityOnRestart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 执行 start</span></span><br><span class=\"line\">        performStart();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Instrumentation-2\"><a href=\"#Instrumentation-2\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onStart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     activity.mResumed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    activity.onResume();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnRestart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    activity.onRestart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>简单总结下 Activity 的启动流程：</p>\n<ol>\n<li>从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信</li>\n<li>ActivityManagerService 用于管理所有的 Activity 活动<ul>\n<li>当接受到启动 Activity 的调用时，使用 <code>resolveActivity</code> ，查询系统中符合要求的 Activity</li>\n<li>创建使用合适的  ActivityStack 和 launch flags 来启动 Activity</li>\n<li>如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity</li>\n<li>如果不存在应用进程，先创建应用进程</li>\n</ul>\n</li>\n<li>最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行<ul>\n<li>使用 Instrumentation 去通过反射构建 Activity 实例</li>\n<li>使用 Handler 机制调用 Activity 的生命周期</li>\n</ul>\n</li>\n</ol>\n<p>下面的图例来自<a href=\"http://gityuan.com/2016/03/12/start-activity/\" target=\"_blank\" rel=\"noopener\">博客</a>：</p>\n<p><img src=\"http://gityuan.com/images/activity/start_activity_process.jpg\" alt=\"启动流程\"></p>\n<h3 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h3><p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png?x-oss-process=style/doc-img\" alt=\"Android启动流程\"></p>\n"},{"title":"Android消息机制-Handler","date":"2018-03-23T12:29:21.000Z","_content":"\n### 参考\n\n[Android消息机制1-Handler(Java层)](http://gityuan.com/2015/12/26/handler-message-framework/)\n\n[Android消息机制2-Handler(Native层)](http://gityuan.com/2015/12/27/handler-message-native/)\n\n[Android应用程序消息处理机制（Looper、Handler）分析](http://blog.csdn.net/luoshengyang/article/details/6817933)\n\n[管道(Unix)](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix))\n\n[Epoll](https://zh.wikipedia.org/zh-hans/Epoll)\n\n[文件描述符](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)\n\nHandler 机制主要由四个部分组成：\n\n* Looper\n* MessageQueue\n* Message\n* Handler\n\n### 典型用法\n\n``` java\nclass LooperThread extends Thread {\n    public Handler mHandler;\n    \n    public void run() {\n        Looper.prepare();\n        \n        mHandler = new Handler() {\n            public void handleMessage(Message msg) {\n                // process incoming messages here\n            }\n        };\n        \n        Looper.loop();\n    }\n}\n```\n\n### Looper\n\n不断循环执行 `Looper.loop`，按分发机制将消息分发给目标处理者\n\n``` java\nprivate static void prepare(boolean quitAllowed) {\n    if(sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    // 构建 Looper 存储到 ThreadLocal\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n`sThreadLocal` 是一个 ThreadLocal 类型的静态变量\n\n> ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域\n\n``` java\nprivate Looper(boolean quitAllowed) {\n    // Looper 中创建 MessageQueue\n    mQueue = new MessageQueue(quitAllowed);\n    mThread = Thread.currentThread();\n}\n```\n\n``` java\npublic static void loop() {                                                                     \n    final Looper me = myLooper();                                                               \n    if (me == null) {                                                                           \n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }                                                                                           \n    final MessageQueue queue = me.mQueue;                                                       \n                                                                                                \n    // Make sure the identity of this thread is that of the local process,                      \n    // and keep track of what that identity token actually is.                                  \n    Binder.clearCallingIdentity();                                                              \n    final long ident = Binder.clearCallingIdentity();                                           \n                                                                                                \n    for (;;) {                                                                                  \n        Message msg = queue.next(); // 获取下一条 Message，可能会阻塞                                              \n        if (msg == null) {                                                                      \n            // No message indicates that the message queue is quitting.                         \n            return;                                                                             \n        }                                                                                       \n                                                                                                \n        // This must be in a local variable, in case a UI event sets the logger                 \n        final Printer logging = me.mLogging;                                                    \n        if (logging != null) {                                                                  \n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +                        \n                    msg.callback + \": \" + msg.what);                                            \n        }                                                                                       \n                                                                                                \n        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       \n                                                                                                \n        //省略\n        \n        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();     \n        final long end;                                                                         \n        try {\n            // 分发 Message\n            msg.target.dispatchMessage(msg);                                                    \n            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();              \n        } finally {                                                                             \n            if (traceTag != 0) {                                                                \n                Trace.traceEnd(traceTag);                                                       \n            }                                                                                   \n        }                                                                                       \n        if (slowDispatchThresholdMs > 0) {                                                      \n            final long time = end - start;                                                      \n            if (time > slowDispatchThresholdMs) {                                               \n                Slog.w(TAG, \"Dispatch took \" + time + \"ms on \"                                  \n                        + Thread.currentThread().getName() + \", h=\" +                           \n                        msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what);               \n            }                                                                                   \n        }                                                                                       \n                                                                                                \n        if (logging != null) {                                                                  \n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);            \n        }                                                                                       \n                                                                                                \n        // Make sure that during the course of dispatching the                                  \n        // identity of the thread wasn't corrupted.                                             \n        final long newIdent = Binder.clearCallingIdentity();                                    \n        if (ident != newIdent) {                                                                \n            Log.wtf(TAG, \"Thread identity changed from 0x\"                                      \n                    + Long.toHexString(ident) + \" to 0x\"                                        \n                    + Long.toHexString(newIdent) + \" while dispatching to \"                     \n                    + msg.target.getClass().getName() + \" \"                                     \n                    + msg.callback + \" what=\" + msg.what);                                      \n        }                                                                                       \n         \n        // 释放 Message\n        msg.recycleUnchecked();                                                                 \n    }                                                                                           \n}                                                                                               \n```\n\n``` java\n// Looper.quit 最终调用的都是 MessageQueue.quit\npublic void quit() {\n    mQueue.quit(false); // 移除消息\n}\n\npublic void quitSafely() {\n    mQueue.quit(true); // 安全移除消息\n}\n```\n\nMessageQueue 在构造方法中，会调用 native 方法 `nativeInit` 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper\n\n``` cpp\n// frameworks/base/libs\nLooper::Looper(bool allowNonCallbacks) :  \n    mAllowNonCallbacks(allowNonCallbacks),  \n    mResponseIndex(0) {\n    // 管道机制\n    int wakeFds[2];  \n    int result = pipe(wakeFds);  \n    ......  \n  \n    mWakeReadPipeFd = wakeFds[0];  \n    mWakeWritePipeFd = wakeFds[1];  \n  \t\n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    // 分配新的 epoll 实例同时注册唤醒管道\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  \n    ......  \n  \n    struct epoll_event eventItem;  \n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    // 观察 EPOLLIN 事件\n    eventItem.events = EPOLLIN;  \n    eventItem.data.fd = mWakeReadPipeFd;  \n    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem);  \n    ......  \n#else  \n    ......  \n#endif  \n  \n    ......  \n}  \n```\n\n> 管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。\n>\n> epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。\n\npipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。\n\n以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。\n\n### Handler\n\n``` java\npublic Handler(Callback callback, boolean async) {                                                  \n    if (FIND_POTENTIAL_LEAKS) {                                                                     \n        final Class<? extends Handler> klass = getClass();                                          \n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&          \n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            // 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +      \n                klass.getCanonicalName());                                                          \n        }                                                                                           \n    }                                                                                               \n    // 默认使用当前线程的 Looper                                                                                                \n    mLooper = Looper.myLooper();                                                                    \n    if (mLooper == null) {                                                                          \n        throw new RuntimeException(                                                                 \n            \"Can't create handler inside thread that has not called Looper.prepare()\");             \n    }                                                                                               \n    mQueue = mLooper.mQueue;                                                                        \n    mCallback = callback;\n    // 是否为异步处理\n    mAsynchronous = async;                                                                          \n}                                                                                                   \n```\n\n在 `Looper.loop` 中，当存在 Message 需要处理时，会调用 `dispatchMessage` 来进行分发：\n\n``` java\npublic void dispatchMessage(Message msg) {      \n    if (msg.callback != null) {\n        // 先调用 callback\n        handleCallback(msg);                    \n    } else {                                    \n        if (mCallback != null) {\n            // 接着检查通过构造方法传进来的 Callback\n            if (mCallback.handleMessage(msg)) { \n                return;                         \n            }                                   \n        }\n        // 最后调用 handleMessage\n        handleMessage(msg);                     \n    }                                           \n}                                               \n```\n\n通过 Handler 发送消息：\n\n![发送消息调用链](http://gityuan.com/images/handler/java_sendmessage.png)\n\n最终所有的方法都会调用到 `MessageQueue.enqueueMessage`\n\n### MessageQueue\n\n> 消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理\n\n``` java\nMessageQueue(boolean quitAllowed) { \n    mQuitAllowed = quitAllowed;\n    // used by native code\n    mPtr = nativeInit();            \n}                                   \n```\n\nMessageQueue 的初始化工作主要由 native 方法来执行\n\n``` cpp\n//frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {\n    // 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();  \n    if (! nativeMessageQueue) {  \n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");  \n        return;  \n    }  \n  \t\n    // 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量\n    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  \n}  \n```\n\n`nativeInit` 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 `mPtr`，关联了 NativeMessageQueue 和 MessageQueue\n\n``` java\nMessage next() {                                                                              \n    // messsage loop has already quit                                                              \n    final long ptr = mPtr;                                                                    \n    if (ptr == 0) {                                                                           \n        return null;                                                                          \n    }                                                                                         \n                                                                                              \n    int pendingIdleHandlerCount = -1; // -1 only during first iteration                       \n    int nextPollTimeoutMillis = 0;                                                            \n    for (;;) {                                                                                \n        if (nextPollTimeoutMillis != 0) {                                                     \n            Binder.flushPendingCommands();                                                    \n        }                                                                                     \n        // 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回\n        // ptr 是在 JNI 层创建的 NativeMessageQueue\n        nativePollOnce(ptr, nextPollTimeoutMillis);                                           \n        \n        // 当前 nativePollOnce 返回后，查看消息队列中是否存在消息\n        synchronized (this) {                                                                 \n            // 尝试检索下一条消息，如果找到则返回                            \n            final long now = SystemClock.uptimeMillis();                                      \n            Message prevMsg = null;                                                           \n            Message msg = mMessages;                                                          \n            if (msg != null && msg.target == null) {                                          \n                // 找到下一条异步消息或者没有消息了，则退出循环\n                do {                                                                          \n                    prevMsg = msg;                                                            \n                    msg = msg.next;                                                           \n                } while (msg != null && !msg.isAsynchronous());                               \n            }                                                                                 \n            if (msg != null) {                                                                \n                if (now < msg.when) {                                                         \n                    // 下一个消息还没准备好，重新设置唤醒超时时间\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {                                                                      \n                    // 获取一条消息                                                         \n                    mBlocked = false;\n                    if (prevMsg != null) {                                                    \n                        prevMsg.next = msg.next;                                              \n                    } else {                                                                  \n                        mMessages = msg.next;                                                 \n                    }                                                                         \n                    msg.next = null;                                                          \n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    // 标记当前消息已使用\n                    msg.markInUse();                                                          \n                    return msg;                                                               \n                }                                                                             \n            } else {                                                                          \n                // 当前还没有消息，设置为 -1，无限等待中                                                     \n                nextPollTimeoutMillis = -1;                                                   \n            }                                                                                 \n                                                                                              \n            // Process the quit message now that all pending messages have been handled.      \n            if (mQuitting) {                                                                  \n                dispose();                                                                    \n                return null;                                                                  \n            }                                                                                 \n                                                                                              \n            // queue is empty or if the first message\n            // get pending idle handler count\n            if (pendingIdleHandlerCount < 0                                                   \n                    && (mMessages == null || now < mMessages.when)) {                         \n                pendingIdleHandlerCount = mIdleHandlers.size();                               \n            }                                                                                 \n            if (pendingIdleHandlerCount <= 0) {                                               \n                // 没有 idle handlers 需要运行，循环继续等待                        \n                mBlocked = true;                                                              \n                continue;                                                                     \n            }                                                                                 \n                                                                                              \n            if (mPendingIdleHandlers == null) {                                               \n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; \n            }                                                                                 \n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               \n        }                                                                                     \n                                                                                              \n        // Run the idle handlers.                                                        \n        // We only ever reach this code block during the first iteration                    \n        for (int i = 0; i < pendingIdleHandlerCount; i++) {                                   \n            final IdleHandler idler = mPendingIdleHandlers[i];                                \n            mPendingIdleHandlers[i] = null;           \n                                                                                              \n            boolean keep = false;                                                             \n            try {                                                                             \n                keep = idler.queueIdle();                                                     \n            } catch (Throwable t) {                                                           \n                Log.wtf(TAG, \"IdleHandler threw exception\", t);                               \n            }                                                                                 \n                                                                                              \n            if (!keep) {                                                                      \n                synchronized (this) {\n                    mIdleHandlers.remove(idler);                                              \n                }                                                                             \n            }                                                                                 \n        }                                                                                     \n                                                                                              \n        // Reset the idle handler count to 0 so we do not run them again.                     \n        pendingIdleHandlerCount = 0;                                                          \n                                                                                              \n        //不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                \n        nextPollTimeoutMillis = 0;                                                            \n    }                                                                                         \n}                                                                                             \n```\n\n在 `next` 方法中，`nativePollOnce` 是阻塞操作，其中 `nextPollTimeoutMillis` 代表下一个消息到来之前，还需要等待的时长；`nextPollTimeoutMillis == -1` 表示当前没有更多消息。`nativePollOnce` 调用结束后，从 `mMessages` 中提取一个消息\n\n当处于空闲时，执行 `IdleHandler` 中的回调方法。\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,  \n        jint ptr, jint timeoutMillis) {\n    // 通过前面设置的 mPrt 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr); \n    // 调用 NativeMessageQueue.pollOnce 进行轮询\n    nativeMessageQueue->pollOnce(timeoutMillis);  \n}  \n```\n\n``` cpp\nvoid NativeMessageQueue::pollOnce(int timeoutMillis) {\n    // 将调用转发给了 JNI 层的 Looper\n    mLooper->pollOnce(timeoutMillis);  \n} \n```\n\n`pollOnce` 会调用 `pollnner` 来进一步操作，如果 `pollnner` 返回值不等于 0，则返回\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nint Looper::pollInner(int timeoutMillis) {  \n    ......  \n  \n    int result = ALOOPER_POLL_WAKE;  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis\n    // 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件\n    // 如果检查成功或者超时，则结束等待\n    // 处于 Idle 状态\n    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    bool acquiredLock = false;  \n#else  \n    ......  \n#endif  \n    \n    // eventCount < 0 可能出错了\n    if (eventCount < 0) {  \n        if (errno == EINTR) {  \n            goto Done;  \n        }  \n  \n        LOGW(\"Poll failed with an unexpected error, errno=%d\", errno);  \n        result = ALOOPER_POLL_ERROR;  \n        goto Done;  \n    }  \n  \t\n    // eventCount == 0 超时\n    if (eventCount == 0) {  \n        ......  \n        result = ALOOPER_POLL_TIMEOUT;  \n        goto Done;  \n    }  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL\n    // eventCount > 0 存在事件\n    for (int i = 0; i < eventCount; i++) {  \n        int fd = eventItems[i].data.fd;  \n        uint32_t epollEvents = eventItems[i].events;  \n        if (fd == mWakeReadPipeFd) {  \n            if (epollEvents & EPOLLIN) {\n                // Looper 中使用 epoll 监听的 EPOLLIN 事件\n                awoken();  \n            } else {  \n                LOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents);  \n            }  \n        } else {  \n            ......  \n        }  \n    }  \n    if (acquiredLock) {  \n        mLock.unlock();  \n    }  \nDone: ;  \n#else  \n    ......  \n#endif  \n  \n    ......  \n  \n    return result;  \n} \n```\n\n``` cpp\nvoid Looper::awoken() {  \n    ......  \n  \n    char buffer[16];  \n    ssize_t nRead;  \n    do {  \n        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));  \n    } while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));  \n}  \n```\n\n总结上面的代码，Looper 通过 `loop` 调用 MessageQueue 的 `next`，`next` 中又会调用到 native 方法 `nativePollOnce`，在这个方法中，会调用到 NativeMessageQueue 的 `pollInner`，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 `awoken`，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。\n\n``` java\nboolean enqueueMessage(Message msg, long when) {                                         \n    if (msg.target == null) {                                                            \n        throw new IllegalArgumentException(\"Message must have a target.\");               \n    }                                                                                    \n    if (msg.isInUse()) {                                                                 \n        throw new IllegalStateException(msg + \" This message is already in use.\");       \n    }                                                                                    \n                                                                                         \n    synchronized (this) {                                                                \n        if (mQuitting) {                                                                 \n            IllegalStateException e = new IllegalStateException(                         \n                    msg.target + \" sending message to a Handler on a dead thread\");      \n            Log.w(TAG, e.getMessage(), e);                                               \n            msg.recycle();                                                               \n            return false;                                                                \n        }                                                                                \n                                                                                         \n        msg.markInUse();                                                                 \n        msg.when = when;                                                                 \n        Message p = mMessages;                                                           \n        boolean needWake;                                                                \n        if (p == null || when == 0 || when < p.when) {                                   \n            // 不存在头部消息或立即执行或执行时机快于头部消息\n            // 将处理的消息作为新的头部消息\n            msg.next = p;                                                                \n            mMessages = msg;                                                             \n            needWake = mBlocked;                                                         \n        } else {                                                                         \n            // 将处理的消息插入到队列的尾部\n            // 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();             \n            Message prev;                                                                \n            for (;;) {                                                                   \n                prev = p;                                                                \n                p = p.next;                                                              \n                if (p == null || when < p.when) {                                        \n                    break;                                                               \n                }                                                                        \n                if (needWake && p.isAsynchronous()) {                                    \n                    needWake = false;                                                    \n                }                                                                        \n            }                                                                            \n            msg.next = p; // invariant: p == prev.next                                   \n            prev.next = msg;                                                             \n        }                                                                                \n                                                                                         \n        // We can assume mPtr != 0 because mQuitting is false.                           \n        if (needWake) {                                                                  \n            nativeWake(mPtr);                                                            \n        }                                                                                \n    }                                                                                    \n    return true;                                                                         \n}                                                                                        \n```\n\n`MessageQueue` 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。\n\n如果当前线程处于空闲等待状态，那么还需要调用 `nativeWake` 来唤醒：\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj, jint ptr) {\n    // ptr 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);  \n    return nativeMessageQueue->wake();  \n}  \n```\n\n这里将唤醒请求转发到 Looper `wake`：\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nvoid Looper::wake() {  \n    ......  \n  \n    ssize_t nWrite;  \n    do {\n        // 先管道中写入 \"W\n        nWrite = write(mWakeWritePipeFd, \"W\", 1);  \n    } while (nWrite == -1 && errno == EINTR);  \n  \n    .......  \n}  \n```\n\n往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 `polllnner` 中调用 `epoll_wait` 进入\n\n``` java\nvoid removeMessages(Handler h, int what, Object object) {     \n    if (h == null) {                                          \n        return;                                               \n    }                                                         \n                                                              \n    synchronized (this) {                                     \n        Message p = mMessages;                                \n                                                              \n        // 从队列头部开始，移除连续的所有符合条件的消息                     \n        while (p != null && p.target == h && p.what == what   \n               && (object == null || p.obj == object)) {      \n            Message n = p.next;                               \n            mMessages = n;\n            // 找到对应的消息，释放它\n            p.recycleUnchecked();                             \n            p = n;                                            \n        }                                                     \n                                                              \n        //  从新的队列头部开始，移除全部符合条件的消息                  \n        while (p != null) {                                   \n            Message n = p.next;                               \n            if (n != null) {                                  \n                if (n.target == h && n.what == what           \n                    && (object == null || n.obj == object)) { \n                    Message nn = n.next;                      \n                    n.recycleUnchecked();                     \n                    p.next = nn;                              \n                    continue;                                 \n                }                                             \n            }                                                 \n            p = n;                                            \n        }                                                     \n    }                                                         \n}                                                             \n```\n\n`postSyncBarrier` 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 `removeSyncBarrier`\n\n当 MessageQueue 退出时，需要 `dispose`：\n\n``` java\n// Disposes of the underlying message queue.                 \n// Must only be called on the looper thread or the finalizer.\nprivate void dispose() {                                     \n    if (mPtr != 0) {\n        // native 方法\n        nativeDestroy(mPtr);\n        // mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量\n        mPtr = 0;                                            \n    }                                                        \n}                                                            \n```\n\n`nativeDestroy` 最终会调用 RefBase 的 `decStrong`：\n\n``` cpp\nvoid RefBase::decStrong(const void* id) const\n{\n    weakref_impl* const refs = mRefs;\n    refs->removeStrongRef(id); //移除强引用\n    const int32_t c = android_atomic_dec(&refs->mStrong);\n    if (c == 1) {\n        refs->mBase->onLastStrongRef(id);\n        if ((refs->mFlags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {\n            delete this;\n        }\n    }\n    refs->decWeak(id); // 移除弱引用\n}\n```\n\n### Message\n\n``` java\nvoid recycleUnchecked() {                 \n    // 标记为使用状态，清除其他状态     \n    flags = FLAG_IN_USE;                  \n    what = 0;                             \n    arg1 = 0;                             \n    arg2 = 0;                             \n    obj = null;                           \n    replyTo = null;                       \n    sendingUid = -1;                      \n    when = 0;                             \n    target = null;                        \n    callback = null;                      \n    data = null;                          \n                                          \n    synchronized (sPoolSync) {\n        // 消息缓存\n        if (sPoolSize < MAX_POOL_SIZE) {  \n            next = sPool;                 \n            sPool = this;                 \n            sPoolSize++;                  \n        }                                 \n    }                                     \n}                                         \n```\n\n``` java\npublic static Message obtain() {             \n    synchronized (sPoolSync) {               \n        if (sPool != null) {\n            // 从缓存中获取\n            Message m = sPool;               \n            sPool = m.next;                  \n            m.next = null;                   \n            m.flags = 0; // clear in-use flag\n            sPoolSize--;                     \n            return m;                        \n        }                                    \n    }                                        \n    return new Message();                    \n}                                            \n```\n\n### 总结\n\n![消息机制](http://gityuan.com/images/handler/handler_java.jpg)\n\nJava 层：\n\n* Handler 通过 `sendMessage`，将 Message 通过 `MessageQueue.enqueueMessage` 添加到队列中\n* Looper 通过 `loop` 提取需要执行的 Message，并交与 `Message.target` 的 Handler 进行 `dispatchMessage` 分发\n*  将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler \n\nJNI 层：\n\n* 线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态\n* 通过 epoll 机制监听 `EPOLLIN` 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程\n\n消息分发的优先级：\n\n1. `Message.callback.run()`\n2. `Handler.mCallback.handleMessage()`\n3. `Handler.handleMessage()`\n\n> EPOLL：Linux 内核的可扩展 I/O 事件通知机制\n>\n> PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入\n>\n> 文件描述符(File descriptor)：用于表述指向[文件](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6)的引用的抽象化概念","source":"_posts/Android消息机制-Handler.md","raw":"---\ntitle: Android消息机制-Handler\ndate: 2018-03-23 20:29:21\ncategories: Android Framework\n---\n\n### 参考\n\n[Android消息机制1-Handler(Java层)](http://gityuan.com/2015/12/26/handler-message-framework/)\n\n[Android消息机制2-Handler(Native层)](http://gityuan.com/2015/12/27/handler-message-native/)\n\n[Android应用程序消息处理机制（Looper、Handler）分析](http://blog.csdn.net/luoshengyang/article/details/6817933)\n\n[管道(Unix)](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix))\n\n[Epoll](https://zh.wikipedia.org/zh-hans/Epoll)\n\n[文件描述符](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)\n\nHandler 机制主要由四个部分组成：\n\n* Looper\n* MessageQueue\n* Message\n* Handler\n\n### 典型用法\n\n``` java\nclass LooperThread extends Thread {\n    public Handler mHandler;\n    \n    public void run() {\n        Looper.prepare();\n        \n        mHandler = new Handler() {\n            public void handleMessage(Message msg) {\n                // process incoming messages here\n            }\n        };\n        \n        Looper.loop();\n    }\n}\n```\n\n### Looper\n\n不断循环执行 `Looper.loop`，按分发机制将消息分发给目标处理者\n\n``` java\nprivate static void prepare(boolean quitAllowed) {\n    if(sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    // 构建 Looper 存储到 ThreadLocal\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n`sThreadLocal` 是一个 ThreadLocal 类型的静态变量\n\n> ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域\n\n``` java\nprivate Looper(boolean quitAllowed) {\n    // Looper 中创建 MessageQueue\n    mQueue = new MessageQueue(quitAllowed);\n    mThread = Thread.currentThread();\n}\n```\n\n``` java\npublic static void loop() {                                                                     \n    final Looper me = myLooper();                                                               \n    if (me == null) {                                                                           \n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }                                                                                           \n    final MessageQueue queue = me.mQueue;                                                       \n                                                                                                \n    // Make sure the identity of this thread is that of the local process,                      \n    // and keep track of what that identity token actually is.                                  \n    Binder.clearCallingIdentity();                                                              \n    final long ident = Binder.clearCallingIdentity();                                           \n                                                                                                \n    for (;;) {                                                                                  \n        Message msg = queue.next(); // 获取下一条 Message，可能会阻塞                                              \n        if (msg == null) {                                                                      \n            // No message indicates that the message queue is quitting.                         \n            return;                                                                             \n        }                                                                                       \n                                                                                                \n        // This must be in a local variable, in case a UI event sets the logger                 \n        final Printer logging = me.mLogging;                                                    \n        if (logging != null) {                                                                  \n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +                        \n                    msg.callback + \": \" + msg.what);                                            \n        }                                                                                       \n                                                                                                \n        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       \n                                                                                                \n        //省略\n        \n        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();     \n        final long end;                                                                         \n        try {\n            // 分发 Message\n            msg.target.dispatchMessage(msg);                                                    \n            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();              \n        } finally {                                                                             \n            if (traceTag != 0) {                                                                \n                Trace.traceEnd(traceTag);                                                       \n            }                                                                                   \n        }                                                                                       \n        if (slowDispatchThresholdMs > 0) {                                                      \n            final long time = end - start;                                                      \n            if (time > slowDispatchThresholdMs) {                                               \n                Slog.w(TAG, \"Dispatch took \" + time + \"ms on \"                                  \n                        + Thread.currentThread().getName() + \", h=\" +                           \n                        msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what);               \n            }                                                                                   \n        }                                                                                       \n                                                                                                \n        if (logging != null) {                                                                  \n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);            \n        }                                                                                       \n                                                                                                \n        // Make sure that during the course of dispatching the                                  \n        // identity of the thread wasn't corrupted.                                             \n        final long newIdent = Binder.clearCallingIdentity();                                    \n        if (ident != newIdent) {                                                                \n            Log.wtf(TAG, \"Thread identity changed from 0x\"                                      \n                    + Long.toHexString(ident) + \" to 0x\"                                        \n                    + Long.toHexString(newIdent) + \" while dispatching to \"                     \n                    + msg.target.getClass().getName() + \" \"                                     \n                    + msg.callback + \" what=\" + msg.what);                                      \n        }                                                                                       \n         \n        // 释放 Message\n        msg.recycleUnchecked();                                                                 \n    }                                                                                           \n}                                                                                               \n```\n\n``` java\n// Looper.quit 最终调用的都是 MessageQueue.quit\npublic void quit() {\n    mQueue.quit(false); // 移除消息\n}\n\npublic void quitSafely() {\n    mQueue.quit(true); // 安全移除消息\n}\n```\n\nMessageQueue 在构造方法中，会调用 native 方法 `nativeInit` 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper\n\n``` cpp\n// frameworks/base/libs\nLooper::Looper(bool allowNonCallbacks) :  \n    mAllowNonCallbacks(allowNonCallbacks),  \n    mResponseIndex(0) {\n    // 管道机制\n    int wakeFds[2];  \n    int result = pipe(wakeFds);  \n    ......  \n  \n    mWakeReadPipeFd = wakeFds[0];  \n    mWakeWritePipeFd = wakeFds[1];  \n  \t\n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    // 分配新的 epoll 实例同时注册唤醒管道\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  \n    ......  \n  \n    struct epoll_event eventItem;  \n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    // 观察 EPOLLIN 事件\n    eventItem.events = EPOLLIN;  \n    eventItem.data.fd = mWakeReadPipeFd;  \n    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem);  \n    ......  \n#else  \n    ......  \n#endif  \n  \n    ......  \n}  \n```\n\n> 管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。\n>\n> epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。\n\npipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。\n\n以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。\n\n### Handler\n\n``` java\npublic Handler(Callback callback, boolean async) {                                                  \n    if (FIND_POTENTIAL_LEAKS) {                                                                     \n        final Class<? extends Handler> klass = getClass();                                          \n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&          \n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            // 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +      \n                klass.getCanonicalName());                                                          \n        }                                                                                           \n    }                                                                                               \n    // 默认使用当前线程的 Looper                                                                                                \n    mLooper = Looper.myLooper();                                                                    \n    if (mLooper == null) {                                                                          \n        throw new RuntimeException(                                                                 \n            \"Can't create handler inside thread that has not called Looper.prepare()\");             \n    }                                                                                               \n    mQueue = mLooper.mQueue;                                                                        \n    mCallback = callback;\n    // 是否为异步处理\n    mAsynchronous = async;                                                                          \n}                                                                                                   \n```\n\n在 `Looper.loop` 中，当存在 Message 需要处理时，会调用 `dispatchMessage` 来进行分发：\n\n``` java\npublic void dispatchMessage(Message msg) {      \n    if (msg.callback != null) {\n        // 先调用 callback\n        handleCallback(msg);                    \n    } else {                                    \n        if (mCallback != null) {\n            // 接着检查通过构造方法传进来的 Callback\n            if (mCallback.handleMessage(msg)) { \n                return;                         \n            }                                   \n        }\n        // 最后调用 handleMessage\n        handleMessage(msg);                     \n    }                                           \n}                                               \n```\n\n通过 Handler 发送消息：\n\n![发送消息调用链](http://gityuan.com/images/handler/java_sendmessage.png)\n\n最终所有的方法都会调用到 `MessageQueue.enqueueMessage`\n\n### MessageQueue\n\n> 消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理\n\n``` java\nMessageQueue(boolean quitAllowed) { \n    mQuitAllowed = quitAllowed;\n    // used by native code\n    mPtr = nativeInit();            \n}                                   \n```\n\nMessageQueue 的初始化工作主要由 native 方法来执行\n\n``` cpp\n//frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {\n    // 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();  \n    if (! nativeMessageQueue) {  \n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");  \n        return;  \n    }  \n  \t\n    // 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量\n    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  \n}  \n```\n\n`nativeInit` 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 `mPtr`，关联了 NativeMessageQueue 和 MessageQueue\n\n``` java\nMessage next() {                                                                              \n    // messsage loop has already quit                                                              \n    final long ptr = mPtr;                                                                    \n    if (ptr == 0) {                                                                           \n        return null;                                                                          \n    }                                                                                         \n                                                                                              \n    int pendingIdleHandlerCount = -1; // -1 only during first iteration                       \n    int nextPollTimeoutMillis = 0;                                                            \n    for (;;) {                                                                                \n        if (nextPollTimeoutMillis != 0) {                                                     \n            Binder.flushPendingCommands();                                                    \n        }                                                                                     \n        // 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回\n        // ptr 是在 JNI 层创建的 NativeMessageQueue\n        nativePollOnce(ptr, nextPollTimeoutMillis);                                           \n        \n        // 当前 nativePollOnce 返回后，查看消息队列中是否存在消息\n        synchronized (this) {                                                                 \n            // 尝试检索下一条消息，如果找到则返回                            \n            final long now = SystemClock.uptimeMillis();                                      \n            Message prevMsg = null;                                                           \n            Message msg = mMessages;                                                          \n            if (msg != null && msg.target == null) {                                          \n                // 找到下一条异步消息或者没有消息了，则退出循环\n                do {                                                                          \n                    prevMsg = msg;                                                            \n                    msg = msg.next;                                                           \n                } while (msg != null && !msg.isAsynchronous());                               \n            }                                                                                 \n            if (msg != null) {                                                                \n                if (now < msg.when) {                                                         \n                    // 下一个消息还没准备好，重新设置唤醒超时时间\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {                                                                      \n                    // 获取一条消息                                                         \n                    mBlocked = false;\n                    if (prevMsg != null) {                                                    \n                        prevMsg.next = msg.next;                                              \n                    } else {                                                                  \n                        mMessages = msg.next;                                                 \n                    }                                                                         \n                    msg.next = null;                                                          \n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    // 标记当前消息已使用\n                    msg.markInUse();                                                          \n                    return msg;                                                               \n                }                                                                             \n            } else {                                                                          \n                // 当前还没有消息，设置为 -1，无限等待中                                                     \n                nextPollTimeoutMillis = -1;                                                   \n            }                                                                                 \n                                                                                              \n            // Process the quit message now that all pending messages have been handled.      \n            if (mQuitting) {                                                                  \n                dispose();                                                                    \n                return null;                                                                  \n            }                                                                                 \n                                                                                              \n            // queue is empty or if the first message\n            // get pending idle handler count\n            if (pendingIdleHandlerCount < 0                                                   \n                    && (mMessages == null || now < mMessages.when)) {                         \n                pendingIdleHandlerCount = mIdleHandlers.size();                               \n            }                                                                                 \n            if (pendingIdleHandlerCount <= 0) {                                               \n                // 没有 idle handlers 需要运行，循环继续等待                        \n                mBlocked = true;                                                              \n                continue;                                                                     \n            }                                                                                 \n                                                                                              \n            if (mPendingIdleHandlers == null) {                                               \n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; \n            }                                                                                 \n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               \n        }                                                                                     \n                                                                                              \n        // Run the idle handlers.                                                        \n        // We only ever reach this code block during the first iteration                    \n        for (int i = 0; i < pendingIdleHandlerCount; i++) {                                   \n            final IdleHandler idler = mPendingIdleHandlers[i];                                \n            mPendingIdleHandlers[i] = null;           \n                                                                                              \n            boolean keep = false;                                                             \n            try {                                                                             \n                keep = idler.queueIdle();                                                     \n            } catch (Throwable t) {                                                           \n                Log.wtf(TAG, \"IdleHandler threw exception\", t);                               \n            }                                                                                 \n                                                                                              \n            if (!keep) {                                                                      \n                synchronized (this) {\n                    mIdleHandlers.remove(idler);                                              \n                }                                                                             \n            }                                                                                 \n        }                                                                                     \n                                                                                              \n        // Reset the idle handler count to 0 so we do not run them again.                     \n        pendingIdleHandlerCount = 0;                                                          \n                                                                                              \n        //不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                \n        nextPollTimeoutMillis = 0;                                                            \n    }                                                                                         \n}                                                                                             \n```\n\n在 `next` 方法中，`nativePollOnce` 是阻塞操作，其中 `nextPollTimeoutMillis` 代表下一个消息到来之前，还需要等待的时长；`nextPollTimeoutMillis == -1` 表示当前没有更多消息。`nativePollOnce` 调用结束后，从 `mMessages` 中提取一个消息\n\n当处于空闲时，执行 `IdleHandler` 中的回调方法。\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,  \n        jint ptr, jint timeoutMillis) {\n    // 通过前面设置的 mPrt 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr); \n    // 调用 NativeMessageQueue.pollOnce 进行轮询\n    nativeMessageQueue->pollOnce(timeoutMillis);  \n}  \n```\n\n``` cpp\nvoid NativeMessageQueue::pollOnce(int timeoutMillis) {\n    // 将调用转发给了 JNI 层的 Looper\n    mLooper->pollOnce(timeoutMillis);  \n} \n```\n\n`pollOnce` 会调用 `pollnner` 来进一步操作，如果 `pollnner` 返回值不等于 0，则返回\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nint Looper::pollInner(int timeoutMillis) {  \n    ......  \n  \n    int result = ALOOPER_POLL_WAKE;  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL  \n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis\n    // 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件\n    // 如果检查成功或者超时，则结束等待\n    // 处于 Idle 状态\n    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    bool acquiredLock = false;  \n#else  \n    ......  \n#endif  \n    \n    // eventCount < 0 可能出错了\n    if (eventCount < 0) {  \n        if (errno == EINTR) {  \n            goto Done;  \n        }  \n  \n        LOGW(\"Poll failed with an unexpected error, errno=%d\", errno);  \n        result = ALOOPER_POLL_ERROR;  \n        goto Done;  \n    }  \n  \t\n    // eventCount == 0 超时\n    if (eventCount == 0) {  \n        ......  \n        result = ALOOPER_POLL_TIMEOUT;  \n        goto Done;  \n    }  \n  \n    ......  \n  \n#ifdef LOOPER_USES_EPOLL\n    // eventCount > 0 存在事件\n    for (int i = 0; i < eventCount; i++) {  \n        int fd = eventItems[i].data.fd;  \n        uint32_t epollEvents = eventItems[i].events;  \n        if (fd == mWakeReadPipeFd) {  \n            if (epollEvents & EPOLLIN) {\n                // Looper 中使用 epoll 监听的 EPOLLIN 事件\n                awoken();  \n            } else {  \n                LOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents);  \n            }  \n        } else {  \n            ......  \n        }  \n    }  \n    if (acquiredLock) {  \n        mLock.unlock();  \n    }  \nDone: ;  \n#else  \n    ......  \n#endif  \n  \n    ......  \n  \n    return result;  \n} \n```\n\n``` cpp\nvoid Looper::awoken() {  \n    ......  \n  \n    char buffer[16];  \n    ssize_t nRead;  \n    do {  \n        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));  \n    } while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));  \n}  \n```\n\n总结上面的代码，Looper 通过 `loop` 调用 MessageQueue 的 `next`，`next` 中又会调用到 native 方法 `nativePollOnce`，在这个方法中，会调用到 NativeMessageQueue 的 `pollInner`，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 `awoken`，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。\n\n``` java\nboolean enqueueMessage(Message msg, long when) {                                         \n    if (msg.target == null) {                                                            \n        throw new IllegalArgumentException(\"Message must have a target.\");               \n    }                                                                                    \n    if (msg.isInUse()) {                                                                 \n        throw new IllegalStateException(msg + \" This message is already in use.\");       \n    }                                                                                    \n                                                                                         \n    synchronized (this) {                                                                \n        if (mQuitting) {                                                                 \n            IllegalStateException e = new IllegalStateException(                         \n                    msg.target + \" sending message to a Handler on a dead thread\");      \n            Log.w(TAG, e.getMessage(), e);                                               \n            msg.recycle();                                                               \n            return false;                                                                \n        }                                                                                \n                                                                                         \n        msg.markInUse();                                                                 \n        msg.when = when;                                                                 \n        Message p = mMessages;                                                           \n        boolean needWake;                                                                \n        if (p == null || when == 0 || when < p.when) {                                   \n            // 不存在头部消息或立即执行或执行时机快于头部消息\n            // 将处理的消息作为新的头部消息\n            msg.next = p;                                                                \n            mMessages = msg;                                                             \n            needWake = mBlocked;                                                         \n        } else {                                                                         \n            // 将处理的消息插入到队列的尾部\n            // 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();             \n            Message prev;                                                                \n            for (;;) {                                                                   \n                prev = p;                                                                \n                p = p.next;                                                              \n                if (p == null || when < p.when) {                                        \n                    break;                                                               \n                }                                                                        \n                if (needWake && p.isAsynchronous()) {                                    \n                    needWake = false;                                                    \n                }                                                                        \n            }                                                                            \n            msg.next = p; // invariant: p == prev.next                                   \n            prev.next = msg;                                                             \n        }                                                                                \n                                                                                         \n        // We can assume mPtr != 0 because mQuitting is false.                           \n        if (needWake) {                                                                  \n            nativeWake(mPtr);                                                            \n        }                                                                                \n    }                                                                                    \n    return true;                                                                         \n}                                                                                        \n```\n\n`MessageQueue` 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。\n\n如果当前线程处于空闲等待状态，那么还需要调用 `nativeWake` 来唤醒：\n\n``` cpp\n// frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj, jint ptr) {\n    // ptr 获取 NativeMessageQueue\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);  \n    return nativeMessageQueue->wake();  \n}  \n```\n\n这里将唤醒请求转发到 Looper `wake`：\n\n``` cpp\n// frameworks/base/libs/utils/Looper.cpp\nvoid Looper::wake() {  \n    ......  \n  \n    ssize_t nWrite;  \n    do {\n        // 先管道中写入 \"W\n        nWrite = write(mWakeWritePipeFd, \"W\", 1);  \n    } while (nWrite == -1 && errno == EINTR);  \n  \n    .......  \n}  \n```\n\n往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 `polllnner` 中调用 `epoll_wait` 进入\n\n``` java\nvoid removeMessages(Handler h, int what, Object object) {     \n    if (h == null) {                                          \n        return;                                               \n    }                                                         \n                                                              \n    synchronized (this) {                                     \n        Message p = mMessages;                                \n                                                              \n        // 从队列头部开始，移除连续的所有符合条件的消息                     \n        while (p != null && p.target == h && p.what == what   \n               && (object == null || p.obj == object)) {      \n            Message n = p.next;                               \n            mMessages = n;\n            // 找到对应的消息，释放它\n            p.recycleUnchecked();                             \n            p = n;                                            \n        }                                                     \n                                                              \n        //  从新的队列头部开始，移除全部符合条件的消息                  \n        while (p != null) {                                   \n            Message n = p.next;                               \n            if (n != null) {                                  \n                if (n.target == h && n.what == what           \n                    && (object == null || n.obj == object)) { \n                    Message nn = n.next;                      \n                    n.recycleUnchecked();                     \n                    p.next = nn;                              \n                    continue;                                 \n                }                                             \n            }                                                 \n            p = n;                                            \n        }                                                     \n    }                                                         \n}                                                             \n```\n\n`postSyncBarrier` 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 `removeSyncBarrier`\n\n当 MessageQueue 退出时，需要 `dispose`：\n\n``` java\n// Disposes of the underlying message queue.                 \n// Must only be called on the looper thread or the finalizer.\nprivate void dispose() {                                     \n    if (mPtr != 0) {\n        // native 方法\n        nativeDestroy(mPtr);\n        // mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量\n        mPtr = 0;                                            \n    }                                                        \n}                                                            \n```\n\n`nativeDestroy` 最终会调用 RefBase 的 `decStrong`：\n\n``` cpp\nvoid RefBase::decStrong(const void* id) const\n{\n    weakref_impl* const refs = mRefs;\n    refs->removeStrongRef(id); //移除强引用\n    const int32_t c = android_atomic_dec(&refs->mStrong);\n    if (c == 1) {\n        refs->mBase->onLastStrongRef(id);\n        if ((refs->mFlags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {\n            delete this;\n        }\n    }\n    refs->decWeak(id); // 移除弱引用\n}\n```\n\n### Message\n\n``` java\nvoid recycleUnchecked() {                 \n    // 标记为使用状态，清除其他状态     \n    flags = FLAG_IN_USE;                  \n    what = 0;                             \n    arg1 = 0;                             \n    arg2 = 0;                             \n    obj = null;                           \n    replyTo = null;                       \n    sendingUid = -1;                      \n    when = 0;                             \n    target = null;                        \n    callback = null;                      \n    data = null;                          \n                                          \n    synchronized (sPoolSync) {\n        // 消息缓存\n        if (sPoolSize < MAX_POOL_SIZE) {  \n            next = sPool;                 \n            sPool = this;                 \n            sPoolSize++;                  \n        }                                 \n    }                                     \n}                                         \n```\n\n``` java\npublic static Message obtain() {             \n    synchronized (sPoolSync) {               \n        if (sPool != null) {\n            // 从缓存中获取\n            Message m = sPool;               \n            sPool = m.next;                  \n            m.next = null;                   \n            m.flags = 0; // clear in-use flag\n            sPoolSize--;                     \n            return m;                        \n        }                                    \n    }                                        \n    return new Message();                    \n}                                            \n```\n\n### 总结\n\n![消息机制](http://gityuan.com/images/handler/handler_java.jpg)\n\nJava 层：\n\n* Handler 通过 `sendMessage`，将 Message 通过 `MessageQueue.enqueueMessage` 添加到队列中\n* Looper 通过 `loop` 提取需要执行的 Message，并交与 `Message.target` 的 Handler 进行 `dispatchMessage` 分发\n*  将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler \n\nJNI 层：\n\n* 线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态\n* 通过 epoll 机制监听 `EPOLLIN` 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程\n\n消息分发的优先级：\n\n1. `Message.callback.run()`\n2. `Handler.mCallback.handleMessage()`\n3. `Handler.handleMessage()`\n\n> EPOLL：Linux 内核的可扩展 I/O 事件通知机制\n>\n> PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入\n>\n> 文件描述符(File descriptor)：用于表述指向[文件](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6)的引用的抽象化概念","slug":"Android消息机制-Handler","published":1,"updated":"2018-04-11T14:05:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs0r0005e39kanl0p2kj","content":"<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://gityuan.com/2015/12/26/handler-message-framework/\" target=\"_blank\" rel=\"noopener\">Android消息机制1-Handler(Java层)</a></p>\n<p><a href=\"http://gityuan.com/2015/12/27/handler-message-native/\" target=\"_blank\" rel=\"noopener\">Android消息机制2-Handler(Native层)</a></p>\n<p><a href=\"http://blog.csdn.net/luoshengyang/article/details/6817933\" target=\"_blank\" rel=\"noopener\">Android应用程序消息处理机制（Looper、Handler）分析</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix\" target=\"_blank\" rel=\"noopener\">管道(Unix)</a>)</p>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/Epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">文件描述符</a></p>\n<p>Handler 机制主要由四个部分组成：</p>\n<ul>\n<li>Looper</li>\n<li>MessageQueue</li>\n<li>Message</li>\n<li>Handler</li>\n</ul>\n<h3 id=\"典型用法\"><a href=\"#典型用法\" class=\"headerlink\" title=\"典型用法\"></a>典型用法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        </span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>不断循环执行 <code>Looper.loop</code>，按分发机制将消息分发给目标处理者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构建 Looper 存储到 ThreadLocal</span></span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>sThreadLocal</code> 是一个 ThreadLocal 类型的静态变量</p>\n<blockquote>\n<p>ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Looper 中创建 MessageQueue</span></span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,                      </span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.                                  </span></span><br><span class=\"line\">    Binder.clearCallingIdentity();                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();                                           </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                  </span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// 获取下一条 Message，可能会阻塞                                              </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;                                                                      </span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.                         </span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger                 </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Printer logging = me.mLogging;                                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +                        </span><br><span class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);                                            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">//省略</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> end;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 分发 Message</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);                                                    </span><br><span class=\"line\">            end = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();              </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;                                                                             </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;                                                                </span><br><span class=\"line\">                Trace.traceEnd(traceTag);                                                       </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>) &#123;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> time = end - start;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; slowDispatchThresholdMs) &#123;                                               </span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Dispatch took \"</span> + time + <span class=\"string\">\"ms on \"</span>                                  </span><br><span class=\"line\">                        + Thread.currentThread().getName() + <span class=\"string\">\", h=\"</span> +                           </span><br><span class=\"line\">                        msg.target + <span class=\"string\">\" cb=\"</span> + msg.callback + <span class=\"string\">\" msg=\"</span> + msg.what);               </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the                                  </span></span><br><span class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.                                             </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;                                                                </span><br><span class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span>                                      </span><br><span class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span>                                        </span><br><span class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span>                     </span><br><span class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span>                                     </span><br><span class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);                                      </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"comment\">// 释放 Message</span></span><br><span class=\"line\">        msg.recycleUnchecked();                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Looper.quit 最终调用的都是 MessageQueue.quit</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">false</span>); <span class=\"comment\">// 移除消息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quitSafely</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">true</span>); <span class=\"comment\">// 安全移除消息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 在构造方法中，会调用 native 方法 <code>nativeInit</code> 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs</span></span><br><span class=\"line\">Looper::Looper(<span class=\"keyword\">bool</span> allowNonCallbacks) :  </span><br><span class=\"line\">    mAllowNonCallbacks(allowNonCallbacks),  </span><br><span class=\"line\">    mResponseIndex(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 管道机制</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> wakeFds[<span class=\"number\">2</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = pipe(wakeFds);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    mWakeReadPipeFd = wakeFds[<span class=\"number\">0</span>];  </span><br><span class=\"line\">    mWakeWritePipeFd = wakeFds[<span class=\"number\">1</span>];  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"comment\">// 分配新的 epoll 实例同时注册唤醒管道</span></span><br><span class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItem</span>;</span>  </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp; eventItem, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(epoll_event)); <span class=\"comment\">// zero out unused members of data field union</span></span><br><span class=\"line\">    <span class=\"comment\">// 观察 EPOLLIN 事件</span></span><br><span class=\"line\">    eventItem.events = EPOLLIN;  </span><br><span class=\"line\">    eventItem.data.fd = mWakeReadPipeFd;  </span><br><span class=\"line\">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。</p>\n<p>epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p>\n</blockquote>\n<p>pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。</p>\n<p>以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;                                                                     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();                                          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;          </span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏</span></span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +      </span><br><span class=\"line\">                klass.getCanonicalName());                                                          </span><br><span class=\"line\">        &#125;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    <span class=\"comment\">// 默认使用当前线程的 Looper                                                                                                </span></span><br><span class=\"line\">    mLooper = Looper.myLooper();                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(                                                                 </span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread that has not called Looper.prepare()\"</span>);             </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    mQueue = mLooper.mQueue;                                                                        </span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    <span class=\"comment\">// 是否为异步处理</span></span><br><span class=\"line\">    mAsynchronous = async;                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>Looper.loop</code> 中，当存在 Message 需要处理时，会调用 <code>dispatchMessage</code> 来进行分发：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用 callback</span></span><br><span class=\"line\">        handleCallback(msg);                    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接着检查通过构造方法传进来的 Callback</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123; </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;                         </span><br><span class=\"line\">            &#125;                                   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 最后调用 handleMessage</span></span><br><span class=\"line\">        handleMessage(msg);                     </span><br><span class=\"line\">    &#125;                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 Handler 发送消息：</p>\n<p><img src=\"http://gityuan.com/images/handler/java_sendmessage.png\" alt=\"发送消息调用链\"></p>\n<p>最终所有的方法都会调用到 <code>MessageQueue.enqueueMessage</code></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><blockquote>\n<p>消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123; </span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    <span class=\"comment\">// used by native code</span></span><br><span class=\"line\">    mPtr = nativeInit();            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 的初始化工作主要由 native 方法来执行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> NativeMessageQueue();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! nativeMessageQueue) &#123;  </span><br><span class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Unable to allocate native queue\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量</span></span><br><span class=\"line\">    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeInit</code> 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 <code>mPtr</code>，关联了 NativeMessageQueue 和 MessageQueue</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// messsage loop has already quit                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                          </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration                       </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;                                                     </span><br><span class=\"line\">            Binder.flushPendingCommands();                                                    </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class=\"line\">        <span class=\"comment\">// ptr 是在 JNI 层创建的 NativeMessageQueue</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);                                           </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 当前 nativePollOnce 返回后，查看消息队列中是否存在消息</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                 </span><br><span class=\"line\">            <span class=\"comment\">// 尝试检索下一条消息，如果找到则返回                            </span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();                                      </span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">            Message msg = mMessages;                                                          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">                <span class=\"comment\">// 找到下一条异步消息或者没有消息了，则退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;                                                                          </span><br><span class=\"line\">                    prevMsg = msg;                                                            </span><br><span class=\"line\">                    msg = msg.next;                                                           </span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;                                                                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;                                                         </span><br><span class=\"line\">                    <span class=\"comment\">// 下一个消息还没准备好，重新设置唤醒超时时间</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;                                                                      </span><br><span class=\"line\">                    <span class=\"comment\">// 获取一条消息                                                         </span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;                                                    </span><br><span class=\"line\">                        prevMsg.next = msg.next;                                              </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;                                                                  </span><br><span class=\"line\">                        mMessages = msg.next;                                                 </span><br><span class=\"line\">                    &#125;                                                                         </span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"Returning message: \"</span> + msg);</span><br><span class=\"line\">                    <span class=\"comment\">// 标记当前消息已使用</span></span><br><span class=\"line\">                    msg.markInUse();                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;                                                               </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;                                                                          </span><br><span class=\"line\">                <span class=\"comment\">// 当前还没有消息，设置为 -1，无限等待中                                                     </span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;                                                   </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.      </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                  </span><br><span class=\"line\">                dispose();                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                  </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// get pending idle handler count</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span>                                                   </span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;                         </span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">                <span class=\"comment\">// 没有 idle handlers 需要运行，循环继续等待                        </span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                                                                     </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;                                               </span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)]; </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.                                                        </span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration                    </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;                                   </span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];                                </span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>;           </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;                                                             </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;                                                                             </span><br><span class=\"line\">                keep = idler.queueIdle();                                                     </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;                                                           </span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;                                                                      </span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);                                              </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.                     </span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;                                                          </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">//不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                </span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>next</code> 方法中，<code>nativePollOnce</code> 是阻塞操作，其中 <code>nextPollTimeoutMillis</code> 代表下一个消息到来之前，还需要等待的时长；<code>nextPollTimeoutMillis == -1</code> 表示当前没有更多消息。<code>nativePollOnce</code> 调用结束后，从 <code>mMessages</code> 中提取一个消息</p>\n<p>当处于空闲时，执行 <code>IdleHandler</code> 中的回调方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jint ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过前面设置的 mPrt 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr); </span><br><span class=\"line\">    <span class=\"comment\">// 调用 NativeMessageQueue.pollOnce 进行轮询</span></span><br><span class=\"line\">    nativeMessageQueue-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> NativeMessageQueue::pollOnce(<span class=\"keyword\">int</span> timeoutMillis) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将调用转发给了 JNI 层的 Looper</span></span><br><span class=\"line\">    mLooper-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>pollOnce</code> 会调用 <code>pollnner</code> 来进一步操作，如果 <code>pollnner</code> 返回值不等于 0，则返回</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Looper::pollInner(<span class=\"keyword\">int</span> timeoutMillis) &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = ALOOPER_POLL_WAKE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItems</span>[<span class=\"title\">EPOLL_MAX_EVENTS</span>];</span></span><br><span class=\"line\">    <span class=\"comment\">// 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis</span></span><br><span class=\"line\">    <span class=\"comment\">// 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果检查成功或者超时，则结束等待</span></span><br><span class=\"line\">    <span class=\"comment\">// 处于 Idle 状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> acquiredLock = <span class=\"literal\">false</span>;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// eventCount &lt; 0 可能出错了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        LOGW(<span class=\"string\">\"Poll failed with an unexpected error, errno=%d\"</span>, errno);  </span><br><span class=\"line\">        result = ALOOPER_POLL_ERROR;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// eventCount == 0 超时</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        ......  </span><br><span class=\"line\">        result = ALOOPER_POLL_TIMEOUT;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL</span></span><br><span class=\"line\">    <span class=\"comment\">// eventCount &gt; 0 存在事件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd = eventItems[i].data.fd;  </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Looper 中使用 epoll 监听的 EPOLLIN 事件</span></span><br><span class=\"line\">                awoken();  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                LOGW(<span class=\"string\">\"Ignoring unexpected epoll events 0x%x on wake read pipe.\"</span>, epollEvents);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            ......  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquiredLock) &#123;  </span><br><span class=\"line\">        mLock.unlock();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">Done: ;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::awoken() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">16</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nRead;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">        nRead = read(mWakeReadPipeFd, buffer, <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((nRead == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结上面的代码，Looper 通过 <code>loop</code> 调用 MessageQueue 的 <code>next</code>，<code>next</code> 中又会调用到 native 方法 <code>nativePollOnce</code>，在这个方法中，会调用到 NativeMessageQueue 的 <code>pollInner</code>，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 <code>awoken</code>，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;                                                            </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Message must have a target.\"</span>);               </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">\" This message is already in use.\"</span>);       </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                 </span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(                         </span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);      </span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);                                               </span><br><span class=\"line\">            msg.recycle();                                                               </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        msg.markInUse();                                                                 </span><br><span class=\"line\">        msg.when = when;                                                                 </span><br><span class=\"line\">        Message p = mMessages;                                                           </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;                                   </span><br><span class=\"line\">            <span class=\"comment\">// 不存在头部消息或立即执行或执行时机快于头部消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息作为新的头部消息</span></span><br><span class=\"line\">            msg.next = p;                                                                </span><br><span class=\"line\">            mMessages = msg;                                                             </span><br><span class=\"line\">            needWake = mBlocked;                                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                                         </span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息插入到队列的尾部</span></span><br><span class=\"line\">            <span class=\"comment\">// 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();             </span><br><span class=\"line\">            Message prev;                                                                </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;                                                                   </span><br><span class=\"line\">                prev = p;                                                                </span><br><span class=\"line\">                p = p.next;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;                                        </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                               </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;                                    </span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;                                                    </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">            &#125;                                                                            </span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next                                   </span></span><br><span class=\"line\">            prev.next = msg;                                                             </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.                           </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;                                                                  </span><br><span class=\"line\">            nativeWake(mPtr);                                                            </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MessageQueue</code> 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。</p>\n<p>如果当前线程处于空闲等待状态，那么还需要调用 <code>nativeWake</code> 来唤醒：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jobject obj, jint ptr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ptr 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nativeMessageQueue-&gt;wake();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将唤醒请求转发到 Looper <code>wake</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Looper::wake() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nWrite;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先管道中写入 \"W</span></span><br><span class=\"line\">        nWrite = write(mWakeWritePipeFd, <span class=\"string\">\"W\"</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (nWrite == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    .......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 <code>polllnner</code> 中调用 <code>epoll_wait</code> 进入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, <span class=\"keyword\">int</span> what, Object object)</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                               </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                     </span><br><span class=\"line\">        Message p = mMessages;                                </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">// 从队列头部开始，移除连续的所有符合条件的消息                     </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what   </span><br><span class=\"line\">               &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;      </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            <span class=\"comment\">// 找到对应的消息，释放它</span></span><br><span class=\"line\">            p.recycleUnchecked();                             </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">//  从新的队列头部开始，移除全部符合条件的消息                  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;                                   </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;                                  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.what == what           </span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123; </span><br><span class=\"line\">                    Message nn = n.next;                      </span><br><span class=\"line\">                    n.recycleUnchecked();                     </span><br><span class=\"line\">                    p.next = nn;                              </span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;                                 </span><br><span class=\"line\">                &#125;                                             </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSyncBarrier</code> 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 <code>removeSyncBarrier</code></p>\n<p>当 MessageQueue 退出时，需要 <code>dispose</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposes of the underlying message queue.                 </span></span><br><span class=\"line\"><span class=\"comment\">// Must only be called on the looper thread or the finalizer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPtr != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// native 方法</span></span><br><span class=\"line\">        nativeDestroy(mPtr);</span><br><span class=\"line\">        <span class=\"comment\">// mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量</span></span><br><span class=\"line\">        mPtr = <span class=\"number\">0</span>;                                            </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeDestroy</code> 最终会调用 RefBase 的 <code>decStrong</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> RefBase::decStrong(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* id) <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weakref_impl* <span class=\"keyword\">const</span> refs = mRefs;</span><br><span class=\"line\">    refs-&gt;removeStrongRef(id); <span class=\"comment\">//移除强引用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs-&gt;decWeak(id); <span class=\"comment\">// 移除弱引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycleUnchecked</span><span class=\"params\">()</span> </span>&#123;                 </span><br><span class=\"line\">    <span class=\"comment\">// 标记为使用状态，清除其他状态     </span></span><br><span class=\"line\">    flags = FLAG_IN_USE;                  </span><br><span class=\"line\">    what = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg1 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg2 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    obj = <span class=\"keyword\">null</span>;                           </span><br><span class=\"line\">    replyTo = <span class=\"keyword\">null</span>;                       </span><br><span class=\"line\">    sendingUid = -<span class=\"number\">1</span>;                      </span><br><span class=\"line\">    when = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    target = <span class=\"keyword\">null</span>;                        </span><br><span class=\"line\">    callback = <span class=\"keyword\">null</span>;                      </span><br><span class=\"line\">    data = <span class=\"keyword\">null</span>;                          </span><br><span class=\"line\">                                          </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;  </span><br><span class=\"line\">            next = sPool;                 </span><br><span class=\"line\">            sPool = <span class=\"keyword\">this</span>;                 </span><br><span class=\"line\">            sPoolSize++;                  </span><br><span class=\"line\">        &#125;                                 </span><br><span class=\"line\">    &#125;                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;             </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从缓存中获取</span></span><br><span class=\"line\">            Message m = sPool;               </span><br><span class=\"line\">            sPool = m.next;                  </span><br><span class=\"line\">            m.next = <span class=\"keyword\">null</span>;                   </span><br><span class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></span><br><span class=\"line\">            sPoolSize--;                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;                        </span><br><span class=\"line\">        &#125;                                    </span><br><span class=\"line\">    &#125;                                        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"http://gityuan.com/images/handler/handler_java.jpg\" alt=\"消息机制\"></p>\n<p>Java 层：</p>\n<ul>\n<li>Handler 通过 <code>sendMessage</code>，将 Message 通过 <code>MessageQueue.enqueueMessage</code> 添加到队列中</li>\n<li>Looper 通过 <code>loop</code> 提取需要执行的 Message，并交与 <code>Message.target</code> 的 Handler 进行 <code>dispatchMessage</code> 分发</li>\n<li>将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler </li>\n</ul>\n<p>JNI 层：</p>\n<ul>\n<li>线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态</li>\n<li>通过 epoll 机制监听 <code>EPOLLIN</code> 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程</li>\n</ul>\n<p>消息分发的优先级：</p>\n<ol>\n<li><code>Message.callback.run()</code></li>\n<li><code>Handler.mCallback.handleMessage()</code></li>\n<li><code>Handler.handleMessage()</code></li>\n</ol>\n<blockquote>\n<p>EPOLL：Linux 内核的可扩展 I/O 事件通知机制</p>\n<p>PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入</p>\n<p>文件描述符(File descriptor)：用于表述指向<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">文件</a>的引用的抽象化概念</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://gityuan.com/2015/12/26/handler-message-framework/\" target=\"_blank\" rel=\"noopener\">Android消息机制1-Handler(Java层)</a></p>\n<p><a href=\"http://gityuan.com/2015/12/27/handler-message-native/\" target=\"_blank\" rel=\"noopener\">Android消息机制2-Handler(Native层)</a></p>\n<p><a href=\"http://blog.csdn.net/luoshengyang/article/details/6817933\" target=\"_blank\" rel=\"noopener\">Android应用程序消息处理机制（Looper、Handler）分析</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix\" target=\"_blank\" rel=\"noopener\">管道(Unix)</a>)</p>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/Epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">文件描述符</a></p>\n<p>Handler 机制主要由四个部分组成：</p>\n<ul>\n<li>Looper</li>\n<li>MessageQueue</li>\n<li>Message</li>\n<li>Handler</li>\n</ul>\n<h3 id=\"典型用法\"><a href=\"#典型用法\" class=\"headerlink\" title=\"典型用法\"></a>典型用法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        </span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>不断循环执行 <code>Looper.loop</code>，按分发机制将消息分发给目标处理者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构建 Looper 存储到 ThreadLocal</span></span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>sThreadLocal</code> 是一个 ThreadLocal 类型的静态变量</p>\n<blockquote>\n<p>ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Looper 中创建 MessageQueue</span></span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,                      </span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.                                  </span></span><br><span class=\"line\">    Binder.clearCallingIdentity();                                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();                                           </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                  </span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// 获取下一条 Message，可能会阻塞                                              </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;                                                                      </span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.                         </span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger                 </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Printer logging = me.mLogging;                                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +                        </span><br><span class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);                                            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">//省略</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> end;                                                                         </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 分发 Message</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);                                                    </span><br><span class=\"line\">            end = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();              </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;                                                                             </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;                                                                </span><br><span class=\"line\">                Trace.traceEnd(traceTag);                                                       </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>) &#123;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> time = end - start;                                                      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; slowDispatchThresholdMs) &#123;                                               </span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Dispatch took \"</span> + time + <span class=\"string\">\"ms on \"</span>                                  </span><br><span class=\"line\">                        + Thread.currentThread().getName() + <span class=\"string\">\", h=\"</span> +                           </span><br><span class=\"line\">                        msg.target + <span class=\"string\">\" cb=\"</span> + msg.callback + <span class=\"string\">\" msg=\"</span> + msg.what);               </span><br><span class=\"line\">            &#125;                                                                                   </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;                                                                  </span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);            </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the                                  </span></span><br><span class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.                                             </span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;                                                                </span><br><span class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span>                                      </span><br><span class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span>                                        </span><br><span class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span>                     </span><br><span class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span>                                     </span><br><span class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);                                      </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"comment\">// 释放 Message</span></span><br><span class=\"line\">        msg.recycleUnchecked();                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Looper.quit 最终调用的都是 MessageQueue.quit</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">false</span>); <span class=\"comment\">// 移除消息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quitSafely</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">true</span>); <span class=\"comment\">// 安全移除消息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 在构造方法中，会调用 native 方法 <code>nativeInit</code> 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs</span></span><br><span class=\"line\">Looper::Looper(<span class=\"keyword\">bool</span> allowNonCallbacks) :  </span><br><span class=\"line\">    mAllowNonCallbacks(allowNonCallbacks),  </span><br><span class=\"line\">    mResponseIndex(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 管道机制</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> wakeFds[<span class=\"number\">2</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = pipe(wakeFds);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    mWakeReadPipeFd = wakeFds[<span class=\"number\">0</span>];  </span><br><span class=\"line\">    mWakeWritePipeFd = wakeFds[<span class=\"number\">1</span>];  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"comment\">// 分配新的 epoll 实例同时注册唤醒管道</span></span><br><span class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItem</span>;</span>  </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp; eventItem, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(epoll_event)); <span class=\"comment\">// zero out unused members of data field union</span></span><br><span class=\"line\">    <span class=\"comment\">// 观察 EPOLLIN 事件</span></span><br><span class=\"line\">    eventItem.events = EPOLLIN;  </span><br><span class=\"line\">    eventItem.data.fd = mWakeReadPipeFd;  </span><br><span class=\"line\">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。</p>\n<p>epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p>\n</blockquote>\n<p>pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。</p>\n<p>以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;                                                                     </span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();                                          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;          </span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏</span></span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +      </span><br><span class=\"line\">                klass.getCanonicalName());                                                          </span><br><span class=\"line\">        &#125;                                                                                           </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    <span class=\"comment\">// 默认使用当前线程的 Looper                                                                                                </span></span><br><span class=\"line\">    mLooper = Looper.myLooper();                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(                                                                 </span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread that has not called Looper.prepare()\"</span>);             </span><br><span class=\"line\">    &#125;                                                                                               </span><br><span class=\"line\">    mQueue = mLooper.mQueue;                                                                        </span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    <span class=\"comment\">// 是否为异步处理</span></span><br><span class=\"line\">    mAsynchronous = async;                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>Looper.loop</code> 中，当存在 Message 需要处理时，会调用 <code>dispatchMessage</code> 来进行分发：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用 callback</span></span><br><span class=\"line\">        handleCallback(msg);                    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接着检查通过构造方法传进来的 Callback</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123; </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;                         </span><br><span class=\"line\">            &#125;                                   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 最后调用 handleMessage</span></span><br><span class=\"line\">        handleMessage(msg);                     </span><br><span class=\"line\">    &#125;                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 Handler 发送消息：</p>\n<p><img src=\"http://gityuan.com/images/handler/java_sendmessage.png\" alt=\"发送消息调用链\"></p>\n<p>最终所有的方法都会调用到 <code>MessageQueue.enqueueMessage</code></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><blockquote>\n<p>消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123; </span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    <span class=\"comment\">// used by native code</span></span><br><span class=\"line\">    mPtr = nativeInit();            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue 的初始化工作主要由 native 方法来执行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> NativeMessageQueue();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! nativeMessageQueue) &#123;  </span><br><span class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Unable to allocate native queue\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量</span></span><br><span class=\"line\">    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeInit</code> 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 <code>mPtr</code>，关联了 NativeMessageQueue 和 MessageQueue</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;                                                                              </span><br><span class=\"line\">    <span class=\"comment\">// messsage loop has already quit                                                              </span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;                                                                           </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                          </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration                       </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;                                                     </span><br><span class=\"line\">            Binder.flushPendingCommands();                                                    </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">        <span class=\"comment\">// 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class=\"line\">        <span class=\"comment\">// ptr 是在 JNI 层创建的 NativeMessageQueue</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);                                           </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 当前 nativePollOnce 返回后，查看消息队列中是否存在消息</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                 </span><br><span class=\"line\">            <span class=\"comment\">// 尝试检索下一条消息，如果找到则返回                            </span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();                                      </span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;                                                           </span><br><span class=\"line\">            Message msg = mMessages;                                                          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">                <span class=\"comment\">// 找到下一条异步消息或者没有消息了，则退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;                                                                          </span><br><span class=\"line\">                    prevMsg = msg;                                                            </span><br><span class=\"line\">                    msg = msg.next;                                                           </span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;                                                                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;                                                         </span><br><span class=\"line\">                    <span class=\"comment\">// 下一个消息还没准备好，重新设置唤醒超时时间</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;                                                                      </span><br><span class=\"line\">                    <span class=\"comment\">// 获取一条消息                                                         </span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;                                                    </span><br><span class=\"line\">                        prevMsg.next = msg.next;                                              </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;                                                                  </span><br><span class=\"line\">                        mMessages = msg.next;                                                 </span><br><span class=\"line\">                    &#125;                                                                         </span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"Returning message: \"</span> + msg);</span><br><span class=\"line\">                    <span class=\"comment\">// 标记当前消息已使用</span></span><br><span class=\"line\">                    msg.markInUse();                                                          </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;                                                               </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;                                                                          </span><br><span class=\"line\">                <span class=\"comment\">// 当前还没有消息，设置为 -1，无限等待中                                                     </span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;                                                   </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.      </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                  </span><br><span class=\"line\">                dispose();                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                  </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// get pending idle handler count</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span>                                                   </span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;                         </span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">                <span class=\"comment\">// 没有 idle handlers 需要运行，循环继续等待                        </span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                                                                     </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;                                               </span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)]; </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.                                                        </span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration                    </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;                                   </span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];                                </span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>;           </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;                                                             </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;                                                                             </span><br><span class=\"line\">                keep = idler.queueIdle();                                                     </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;                                                           </span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);                               </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;                                                                      </span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);                                              </span><br><span class=\"line\">                &#125;                                                                             </span><br><span class=\"line\">            &#125;                                                                                 </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.                     </span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;                                                          </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">        <span class=\"comment\">//不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                </span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;                                                            </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>next</code> 方法中，<code>nativePollOnce</code> 是阻塞操作，其中 <code>nextPollTimeoutMillis</code> 代表下一个消息到来之前，还需要等待的时长；<code>nextPollTimeoutMillis == -1</code> 表示当前没有更多消息。<code>nativePollOnce</code> 调用结束后，从 <code>mMessages</code> 中提取一个消息</p>\n<p>当处于空闲时，执行 <code>IdleHandler</code> 中的回调方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jint ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过前面设置的 mPrt 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr); </span><br><span class=\"line\">    <span class=\"comment\">// 调用 NativeMessageQueue.pollOnce 进行轮询</span></span><br><span class=\"line\">    nativeMessageQueue-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> NativeMessageQueue::pollOnce(<span class=\"keyword\">int</span> timeoutMillis) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将调用转发给了 JNI 层的 Looper</span></span><br><span class=\"line\">    mLooper-&gt;pollOnce(timeoutMillis);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>pollOnce</code> 会调用 <code>pollnner</code> 来进一步操作，如果 <code>pollnner</code> 返回值不等于 0，则返回</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Looper::pollInner(<span class=\"keyword\">int</span> timeoutMillis) &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = ALOOPER_POLL_WAKE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">eventItems</span>[<span class=\"title\">EPOLL_MAX_EVENTS</span>];</span></span><br><span class=\"line\">    <span class=\"comment\">// 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis</span></span><br><span class=\"line\">    <span class=\"comment\">// 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果检查成功或者超时，则结束等待</span></span><br><span class=\"line\">    <span class=\"comment\">// 处于 Idle 状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> acquiredLock = <span class=\"literal\">false</span>;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// eventCount &lt; 0 可能出错了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        LOGW(<span class=\"string\">\"Poll failed with an unexpected error, errno=%d\"</span>, errno);  </span><br><span class=\"line\">        result = ALOOPER_POLL_ERROR;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  \t</span><br><span class=\"line\">    <span class=\"comment\">// eventCount == 0 超时</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        ......  </span><br><span class=\"line\">        result = ALOOPER_POLL_TIMEOUT;  </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOOPER_USES_EPOLL</span></span><br><span class=\"line\">    <span class=\"comment\">// eventCount &gt; 0 存在事件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd = eventItems[i].data.fd;  </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Looper 中使用 epoll 监听的 EPOLLIN 事件</span></span><br><span class=\"line\">                awoken();  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                LOGW(<span class=\"string\">\"Ignoring unexpected epoll events 0x%x on wake read pipe.\"</span>, epollEvents);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            ......  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquiredLock) &#123;  </span><br><span class=\"line\">        mLock.unlock();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">Done: ;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  </span></span><br><span class=\"line\">    ......  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::awoken() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">16</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nRead;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">        nRead = read(mWakeReadPipeFd, buffer, <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((nRead == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class=\"keyword\">sizeof</span>(buffer));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结上面的代码，Looper 通过 <code>loop</code> 调用 MessageQueue 的 <code>next</code>，<code>next</code> 中又会调用到 native 方法 <code>nativePollOnce</code>，在这个方法中，会调用到 NativeMessageQueue 的 <code>pollInner</code>，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 <code>awoken</code>，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;                                                            </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Message must have a target.\"</span>);               </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">\" This message is already in use.\"</span>);       </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;                                                                 </span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(                         </span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);      </span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);                                               </span><br><span class=\"line\">            msg.recycle();                                                               </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        msg.markInUse();                                                                 </span><br><span class=\"line\">        msg.when = when;                                                                 </span><br><span class=\"line\">        Message p = mMessages;                                                           </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;                                   </span><br><span class=\"line\">            <span class=\"comment\">// 不存在头部消息或立即执行或执行时机快于头部消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息作为新的头部消息</span></span><br><span class=\"line\">            msg.next = p;                                                                </span><br><span class=\"line\">            mMessages = msg;                                                             </span><br><span class=\"line\">            needWake = mBlocked;                                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                                         </span><br><span class=\"line\">            <span class=\"comment\">// 将处理的消息插入到队列的尾部</span></span><br><span class=\"line\">            <span class=\"comment\">// 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();             </span><br><span class=\"line\">            Message prev;                                                                </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;                                                                   </span><br><span class=\"line\">                prev = p;                                                                </span><br><span class=\"line\">                p = p.next;                                                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;                                        </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                               </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;                                    </span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;                                                    </span><br><span class=\"line\">                &#125;                                                                        </span><br><span class=\"line\">            &#125;                                                                            </span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next                                   </span></span><br><span class=\"line\">            prev.next = msg;                                                             </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.                           </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;                                                                  </span><br><span class=\"line\">            nativeWake(mPtr);                                                            </span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MessageQueue</code> 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。</p>\n<p>如果当前线程处于空闲等待状态，那么还需要调用 <code>nativeWake</code> 来唤醒：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jobject obj, jint ptr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ptr 获取 NativeMessageQueue</span></span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nativeMessageQueue-&gt;wake();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里将唤醒请求转发到 Looper <code>wake</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Looper::wake() &#123;  </span><br><span class=\"line\">    ......  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> nWrite;  </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先管道中写入 \"W</span></span><br><span class=\"line\">        nWrite = write(mWakeWritePipeFd, <span class=\"string\">\"W\"</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (nWrite == <span class=\"number\">-1</span> &amp;&amp; errno == EINTR);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    .......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 <code>polllnner</code> 中调用 <code>epoll_wait</code> 进入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, <span class=\"keyword\">int</span> what, Object object)</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                               </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;                                     </span><br><span class=\"line\">        Message p = mMessages;                                </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">// 从队列头部开始，移除连续的所有符合条件的消息                     </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what   </span><br><span class=\"line\">               &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;      </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            <span class=\"comment\">// 找到对应的消息，释放它</span></span><br><span class=\"line\">            p.recycleUnchecked();                             </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">        <span class=\"comment\">//  从新的队列头部开始，移除全部符合条件的消息                  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;                                   </span><br><span class=\"line\">            Message n = p.next;                               </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;                                  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.what == what           </span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123; </span><br><span class=\"line\">                    Message nn = n.next;                      </span><br><span class=\"line\">                    n.recycleUnchecked();                     </span><br><span class=\"line\">                    p.next = nn;                              </span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;                                 </span><br><span class=\"line\">                &#125;                                             </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">            p = n;                                            </span><br><span class=\"line\">        &#125;                                                     </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSyncBarrier</code> 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 <code>removeSyncBarrier</code></p>\n<p>当 MessageQueue 退出时，需要 <code>dispose</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposes of the underlying message queue.                 </span></span><br><span class=\"line\"><span class=\"comment\">// Must only be called on the looper thread or the finalizer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPtr != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// native 方法</span></span><br><span class=\"line\">        nativeDestroy(mPtr);</span><br><span class=\"line\">        <span class=\"comment\">// mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量</span></span><br><span class=\"line\">        mPtr = <span class=\"number\">0</span>;                                            </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>nativeDestroy</code> 最终会调用 RefBase 的 <code>decStrong</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> RefBase::decStrong(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* id) <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weakref_impl* <span class=\"keyword\">const</span> refs = mRefs;</span><br><span class=\"line\">    refs-&gt;removeStrongRef(id); <span class=\"comment\">//移除强引用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs-&gt;decWeak(id); <span class=\"comment\">// 移除弱引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycleUnchecked</span><span class=\"params\">()</span> </span>&#123;                 </span><br><span class=\"line\">    <span class=\"comment\">// 标记为使用状态，清除其他状态     </span></span><br><span class=\"line\">    flags = FLAG_IN_USE;                  </span><br><span class=\"line\">    what = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg1 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    arg2 = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    obj = <span class=\"keyword\">null</span>;                           </span><br><span class=\"line\">    replyTo = <span class=\"keyword\">null</span>;                       </span><br><span class=\"line\">    sendingUid = -<span class=\"number\">1</span>;                      </span><br><span class=\"line\">    when = <span class=\"number\">0</span>;                             </span><br><span class=\"line\">    target = <span class=\"keyword\">null</span>;                        </span><br><span class=\"line\">    callback = <span class=\"keyword\">null</span>;                      </span><br><span class=\"line\">    data = <span class=\"keyword\">null</span>;                          </span><br><span class=\"line\">                                          </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;  </span><br><span class=\"line\">            next = sPool;                 </span><br><span class=\"line\">            sPool = <span class=\"keyword\">this</span>;                 </span><br><span class=\"line\">            sPoolSize++;                  </span><br><span class=\"line\">        &#125;                                 </span><br><span class=\"line\">    &#125;                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;             </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从缓存中获取</span></span><br><span class=\"line\">            Message m = sPool;               </span><br><span class=\"line\">            sPool = m.next;                  </span><br><span class=\"line\">            m.next = <span class=\"keyword\">null</span>;                   </span><br><span class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></span><br><span class=\"line\">            sPoolSize--;                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;                        </span><br><span class=\"line\">        &#125;                                    </span><br><span class=\"line\">    &#125;                                        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"http://gityuan.com/images/handler/handler_java.jpg\" alt=\"消息机制\"></p>\n<p>Java 层：</p>\n<ul>\n<li>Handler 通过 <code>sendMessage</code>，将 Message 通过 <code>MessageQueue.enqueueMessage</code> 添加到队列中</li>\n<li>Looper 通过 <code>loop</code> 提取需要执行的 Message，并交与 <code>Message.target</code> 的 Handler 进行 <code>dispatchMessage</code> 分发</li>\n<li>将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler </li>\n</ul>\n<p>JNI 层：</p>\n<ul>\n<li>线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态</li>\n<li>通过 epoll 机制监听 <code>EPOLLIN</code> 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程</li>\n</ul>\n<p>消息分发的优先级：</p>\n<ol>\n<li><code>Message.callback.run()</code></li>\n<li><code>Handler.mCallback.handleMessage()</code></li>\n<li><code>Handler.handleMessage()</code></li>\n</ol>\n<blockquote>\n<p>EPOLL：Linux 内核的可扩展 I/O 事件通知机制</p>\n<p>PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入</p>\n<p>文件描述符(File descriptor)：用于表述指向<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">文件</a>的引用的抽象化概念</p>\n</blockquote>\n"},{"title":"AppPlugin中的Task-第一篇","date":"2018-11-12T02:26:03.000Z","_content":"\n### 前言\n\n在使用 Android Studio 以后，基本新的 Android 项目都是用 Gradle 作为构建工具，关于 Gradle 的介绍不在本文范畴，当新建一个 Android 项目时，默认只会有个 module 使用`com.android.application` 插件，Gradle 的核心在于 task，即从 java 源文件和资源文件编译成 apk 文件（编译过程），就是由一系列的 task 组成，task 可以相互依赖，比如最基本的 `Task.dependsOn()`，所以理解 Android 编译过程就是理解各个 task 的作用。\n\n> 本文涉及的源码：\n>\n> * com.android.tools.build:gradle:3.1.4\n> * gradle-api-4.4\n\n### AppPlugin\n\n`com.android.application` 的源码位于 `com.android.build.gradle.AppPlugin`，AppPlugin 继承于 BasePlugin，BasePlugin 封装了大部分通用的逻辑：\n\n``` java\n@Override                                                                                \npublic void apply(@NonNull Project project) {                                            \n    \n    // 省略初始化步骤\n    \n    if (!projectOptions.get(BooleanOption.ENABLE_NEW_DSL_AND_API)) {\n        // 不使用新的 DSL API\n        TaskInputHelper.enableBypass();                                                  \n        \n        // threadRecorder 用于记录执行时间\n        \n        // configureProject 配置项目\n        threadRecorder.record(                                                           \n                ExecutionType.BASE_PLUGIN_PROJECT_CONFIGURE,                             \n                project.getPath(),                                                       \n                null,                                                                    \n                this::configureProject);                                                 \n        \n        // configureExtension 配置 Extension 后，我们才能使用 android {} 进行配置\n        threadRecorder.record(                                                           \n                ExecutionType.BASE_PLUGIN_PROJECT_BASE_EXTENSION_CREATION,               \n                project.getPath(),                                                       \n                null,                                                                    \n                this::configureExtension);                                               \n        \n        // createTasks 本文的重点，创建必须的 task\n        threadRecorder.record(                                                           \n                ExecutionType.BASE_PLUGIN_PROJECT_TASKS_CREATION,                        \n                project.getPath(),                                                       \n                null,                                                                    \n                this::createTasks);                                                      \n    } else {                                                                             \n         // 省略                   \n    }                                                                                    \n}                                                                                        \n```\n\n``` java\nprivate void createTasks() {\n    \n    // createTasksBeforeEvaluate\n    threadRecorder.record(                                                   \n            ExecutionType.TASK_MANAGER_CREATE_TASKS,                         \n            project.getPath(),                                               \n            null,                                                            \n            () -> taskManager.createTasksBeforeEvaluate());                  \n    \n    // afterEvaluate 执行\n    project.afterEvaluate(                                                   \n            project ->                                                       \n                    threadRecorder.record(                                   \n                            ExecutionType.BASE_PLUGIN_CREATE_ANDROID_TASKS,  \n                            project.getPath(),                               \n                            null,                                            \n                            () -> createAndroidTasks(false)));               \n}                                                                            \n```\n\n从 `createTasks()` 可以看到，`createAndroidTasks()` 是在 `afterEvaluate()` 中执行的，evaluate 是 Gradle  一个执行的过程\n\n> Gradle 编译的三个阶段：Initialization、Configuration、Execution。具体可以阅读 [build_lifecycle](https://docs.gradle.org/current/userguide/build_lifecycle.html)\n\n`createAndroidTasks()` 这个方法较长，但是我们关心的是 `VariantManager.createAndroidTasks()`\n\n``` java\npublic void createAndroidTasks() {                                                    \n    variantFactory.validateModel(this);                                               \n    variantFactory.preVariantWork(project);                                           \n                                                                                      \n    if (variantScopes.isEmpty()) {\n        // 创建 variantScopes\n        recorder.record(                                                              \n                ExecutionType.VARIANT_MANAGER_CREATE_VARIANTS,                        \n                project.getPath(),                                                    \n                null /*variantName*/,                                                 \n                this::populateVariantDataList);                                       \n    }                                                                                 \n                                                                                      \n    // Create top level test tasks.                                                   \n    recorder.record(                                                                  \n            ExecutionType.VARIANT_MANAGER_CREATE_TESTS_TASKS,                         \n            project.getPath(),                                                        \n            null /*variantName*/,                                                     \n            () -> taskManager.createTopLevelTestTasks(!productFlavors.isEmpty()));    \n                                                                                      \n                                                                                      \n                                                                                      \n    for (final VariantScope variantScope : variantScopes) {\n        // 为每个 variant 生成各自的 task\n        recorder.record(                                                              \n                ExecutionType.VARIANT_MANAGER_CREATE_TASKS_FOR_VARIANT,               \n                project.getPath(),                                                    \n                variantScope.getFullVariantName(),                                    \n                () -> createTasksForVariantData(variantScope));                       \n    }                                                                                 \n                                                                                      \n    taskManager.createReportTasks(variantScopes);                                     \n}                                                                                     \n```\n\n调用 `populateVariantDataList()` 来生成 VariantScopes，它是由 ProductFlavors、BuildType、VariantType 组合\n\n``` java\npublic void createTasksForVariantData(final VariantScope variantScope) {                                              \n    final BaseVariantData variantData = variantScope.getVariantData();                                                \n    final VariantType variantType = variantData.getType();                                                            \n                                                                                                                      \n    final GradleVariantConfiguration variantConfig = variantScope.getVariantConfiguration();                          \n                                                                                                                      \n    final BuildTypeData buildTypeData = buildTypes.get(variantConfig.getBuildType().getName());                       \n    if (buildTypeData.getAssembleTask() == null) {\n        // 创建 BuildType 的 assemble task\n        // 比如 assembleDebug 和 assembleRelease\n        buildTypeData.setAssembleTask(taskManager.createAssembleTask(buildTypeData));                                 \n    }                                                                                                                 \n                                                                                                                      \n    // Add dependency of assemble task on assemble build type task.\n    // assemble 依赖于 assembleDebug 和 assembleRelease\n    taskManager                                                                                                       \n            .getTaskFactory()                                                                                         \n            .configure(                                                                                               \n                    \"assemble\",                                                                                       \n                    task -> {                                                                                         \n                        assert buildTypeData.getAssembleTask() != null;                                               \n                        task.dependsOn(buildTypeData.getAssembleTask().getName());                                    \n                    });                                                                                               \n    \n    // 根据 variant 创建 assemble task\n    createAssembleTaskForVariantData(variantData);                                                                    \n    if (variantType.isForTesting()) {                                                                                 \n         // 省略代码                                                                       \n    } else {\n        // 根据 variant 创建 task\n        taskManager.createTasksForVariantScope(variantScope);                                                         \n    }                                                                                                                 \n}                                                                                                                     \n```\n\nassemble task 用于将源文件编译为最终产物，比如 jar、aar、apk 等，在 `createTasksForVariantData()` 中会生成对应 BuildType 的 assemble task，比如 `assembleDebug` 和 `assembleRelease` ，接着设置 `assemble` 依赖于这两个 task，最后根据 variant 生成对应的 assemble task，比如 `assembleTestDebug`\n\n``` java\nprivate void createAssembleTaskForVariantData(final BaseVariantData variantData) {                      \n    final VariantScope variantScope = variantData.getScope();                                           \n    if (variantData.getType().isForTesting()) {                                                         \n        variantScope.setAssembleTask(taskManager.createAssembleTask(variantData));                      \n    } else {                                                                                            \n        BuildTypeData buildTypeData =                                                                   \n                buildTypes.get(variantData.getVariantConfiguration().getBuildType().getName());         \n                                                                                                        \n        Preconditions.checkNotNull(buildTypeData.getAssembleTask());                                    \n                                                                                                        \n        if (productFlavors.isEmpty()) {                                                                 \n            // Reuse assemble task for build type if there is no product flavor.                        \n            variantScope.setAssembleTask(buildTypeData.getAssembleTask());                              \n                                                                                                        \n            variantData.addTask(                                                                        \n                    TaskContainer.TaskKind.ASSEMBLE, buildTypeData.getAssembleTask());                  \n        } else {\n            // 根据 variant 创建对应的 assemble task，比如 assembleTesDebug\n            variantScope.setAssembleTask(taskManager.createAssembleTask(variantData));                  \n                                                                                                        \n            // setup the task dependencies                                                              \n            // build type\n            // build type assemble task 依赖于 具体的 assemble task\n            buildTypeData.getAssembleTask().dependsOn(variantScope.getAssembleTask());                  \n                                                                                                        \n            // each flavor                                                                              \n            GradleVariantConfiguration variantConfig = variantData.getVariantConfiguration();           \n            for (CoreProductFlavor flavor : variantConfig.getProductFlavors()) {                        \n                ProductFlavorData productFlavorData = productFlavors.get(flavor.getName());             \n                                                                                                        \n                DefaultTask flavorAssembleTask = productFlavorData.getAssembleTask();                   \n                if (flavorAssembleTask == null) {\n                    // 创建 flavor 的 assemble task\n                    // 比如 assembleTes\n                    flavorAssembleTask = taskManager.createAssembleTask(productFlavorData);             \n                    productFlavorData.setAssembleTask(flavorAssembleTask);                              \n                }\n                // flavor assemble task 依赖于具体的 assemble task\n                flavorAssembleTask.dependsOn(variantScope.getAssembleTask());                           \n            }                                                                                           \n                                                                                                        \n            // assembleTask for this flavor(dimension), created on demand if needed.                    \n            if (variantConfig.getProductFlavors().size() > 1) {                                         \n                final String name = StringHelper.capitalize(variantConfig.getFlavorName());             \n                final String variantAssembleTaskName =                                                  \n                        StringHelper.appendCapitalized(\"assemble\", name);                               \n                if (!taskManager.getTaskFactory().containsKey(variantAssembleTaskName)) {               \n                    Task task = taskManager.getTaskFactory().create(variantAssembleTaskName);           \n                    task.setDescription(\"Assembles all builds for flavor combination: \" + name);        \n                    task.setGroup(\"Build\");                                                             \n                    task.dependsOn(variantScope.getAssembleTask().getName());                           \n                }                                                                                       \n                taskManager                                                                             \n                        .getTaskFactory()                                                               \n                        .configure(                                                                     \n                                \"assemble\", task1 -> task1.dependsOn(variantAssembleTaskName));         \n            }                                                                                           \n        }                                                                                               \n    }                                                                                                   \n}                                                                                                       \n```\n\n上面会生成包括 BuildType、Flavor、BuildType + Flavor + VariantType 的 assemble task，同时 task 之间存在依赖关系：`assemble > buildType/flavor > 具体 ` \n\n![assemble-task-demo](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/assemble-task-demo.png?x-oss-process=style/doc-img)\n\n除了上面所说的 assemble task，还将生成以下 task：\n\n| task                                            | impl                                | dependsOn                                                    |\n| ----------------------------------------------- | ----------------------------------- | ------------------------------------------------------------ |\n| assemble{variant}                               | DefaultTask                         | compile{variant}Sources，package{variant}                    |\n| pre{variant}Build                               | AppPreBuildTask                     | preBuild，extractProguardFiles(可能)                         |\n| extractProguardFiles                            | ExtractProguardFiles                |                                                              |\n| generate{variant}Sources                        | DefaultTask                         | compile{variant}Renderscript，generate{variant}BuildConfig，bundle{variant}Resources，compile{variant}Aidl |\n| generate{variant}Resources                      | DefaultTask                         | generate{variant}ResValues，compile{variant}Renderscript     |\n| generate{variant}Assets                         | DefaultTask                         | compile{variant}Shaders                                      |\n| compile{variant}Sources                         | DefaultTask                         | compile{variant}Ndk，compile{variant}JavaWithJavac           |\n| check{variant}Manifest                          | CheckManifest                       | pre{variant}Build                                            |\n| write{variant}ApplicationId                     | ApplicationIdIdWriteTask            |                                                              |\n| mainApkListPersistence{variant}                 | MainApkListPersistence              |                                                              |\n| reportBuildArtifacts{variant}                   | BuildArtifactReportTask             |                                                              |\n| create{variant}CompatibleScreenManifests        | CompatibleScreensManifest           |                                                              |\n| process{variant}Manifest                        | MergeManifests                      | check{variant}Manifest                                       |\n| generate{variant}ResValues                      | GenerateResValues                   |                                                              |\n| compile{variant}Renderscript                    | RenderscriptCompile                 | pre{variant}Build                                            |\n| merge{variant}Resources                         | MergeResources                      | generate{variant}Resources                                   |\n| merge{variant}Shaders                           | MergeSourceSetFolders               |                                                              |\n| compile{variant}Shaders                         | ShaderCompile                       | merge{variant}Shaders                                        |\n| merge{variant}Assets                            | MergeSourceSetFolders               | generate{variant}Assets                                      |\n| generate{variant}BuildConfig                    | GenerateBuildConfig                 | check{variant}Manifest                                       |\n| splitsDiscoveryTask{variant}                    | SplitsDiscovery                     |                                                              |\n| process{variant}JavaRes                         | Sync                                | pre{variant}Build                                            |\n| process{variant}Resources                       | LinkApplicationAndroidResourcesTask |                                                              |\n| bundle{variant}Resources                        | LinkAndroidResForBundleTask         |                                                              |\n| compile{variant}Aidl                            | AidlCompile                         | pre{variant}Build                                            |\n| compile{variant}Ndk                             | NdkCompile                          | pre{variant}Build                                            |\n| merge{variant}JniLibFolders                     | MergeSourceSetFolders               | generate{variant}Assets                                      |\n| javaPreCompile{variant}                         | JavaPreCompileTask                  | pre{variant}Build                                            |\n| compile{variant}JavaWithJavac                   | AndroidJavaCompile                  | generate{variant}Sources                                     |\n| bundleAppClasses{variant}                       | Jar                                 |                                                              |\n| transformResourcesWithMergeJavaResFor{variant}  | TransformTask                       |                                                              |\n| transformClassesWithMultidexlistFor{variant}    | TransformTask                       |                                                              |\n| transformClassesWithDexBuilderFor{variant}      | TransformTask                       |                                                              |\n| transformDexArchiveWithDexMergerFor{variant}    | TransformTask                       | transformClassesWithMultidexlistFor{variant}                 |\n| preparePUBLISHED_JAVA_RES{variant}ForPublishing | PipelineToPublicationTask           |                                                              |\n| package{variant}                                | PackageApplication                  | merge{variant}Assets，process{variant}Resources，validateSigning{variant}，compile{variant}JavaWithJavac |\n| validateSigning{variant}                        | ValidateSigningTask                 |                                                              |\n| install{variant}                                | InstallVariantTask                  | assemble{variant}                                            |\n| uninstall{variant}                              | UninstallTask                       |                                                              |\n| lint{variant}                                   | LintPerVariantTask                  |                                                              |\n\n以 `assembleProdRelease` 命令，依次执行的 task：\n\n> prod 是 product flavor\n\n```\npreBuild\nextractProguardFiles\npreProdReleaseBuild\ncompileProdReleaseRenderscript\ncheckProdReleaseManifest\ngenerateProdReleaseBuildConfig\nprepareLintJar\nmainApkListPersistenceProdRelease\ngenerateProdReleaseResValues\ngenerateProdReleaseResources\ncompileProdReleaseAidl\ncreateProdReleaseCompatibleScreenManifests\nprocessProdReleaseManifest\nmergeProdReleaseResources  // 合并资源\nsplitsDiscoveryTaskProdRelease\nprocessProdReleaseResources\ngenerateProdReleaseSources\njavaPreCompileProdRelease\ncompileProdReleaseJavaWithJavac // javac\ncompileProdReleaseNdk\ncompileProdReleaseSources\nmergeProdReleaseShaders\ncompileProdReleaseShaders\ngenerateProdReleaseAssets\nmergeProdReleaseAssets\ntransformClassesWithComponentCodeForProdRelease \nprocessProdReleaseJavaRes\ntransformResourcesWithMergeJavaResForProdRelease\ntransformClassesAndResourcesWithProguardForProdRelease // 混淆\ntransformClassesWithMultidexlistForProdRelease\ntransformClassesWithDexForProdRelease\t\t\t\t// dex\ntransformClassesWithShrinkResForProdRelease\nmergeProdReleaseJniLibFolders\ntransformNativeLibsWithMergeJniLibsForProdRelease\nvalidateSigningProdRelease\npackageProdRelease\n```\n\n接下来分析下比较重要的几个 task\n\n> 接下来的分析，因为对应的源码比较复杂，所以只会简短介绍结果，没有详细过程，推荐 debug 整个流程\n\n### CompileJavaWithJavac\n\n首先找到执行的 AndroidJavaCompile\n\n``` java\n// AndroidJavaCompile.java\n@Override                                                                                       \nprotected void compile(IncrementalTaskInputs inputs) {                                          \n    // compileSdkVersion >= 24，需要使用 jdk1.8                                                     \n    if (isPostN()) {                                                                            \n        if (!JavaVersion.current().isJava8Compatible()) {                                       \n            throw new RuntimeException(\"compileSdkVersion '\" + compileSdkVersion + \"' requires \"\n                    + \"JDK 1.8 or later to compile.\");                                          \n        }                                                                                       \n    }                                                                                           \n    \n    // 处理注解处理器，在之前 task 会将使用 annotationProcessor 标示的注解处理器写入到 annotationProcessors.json 中\n    processAnalytics();                                                                         \n                                                                                                \n    // Create directory for output of annotation processor.                                     \n    FileUtils.mkdirs(annotationProcessorOutputFolder);                                          \n                                                                                                \n    mInstantRunBuildContext.startRecording(InstantRunBuildContext.TaskType.JAVAC);\n    // 调用 JavaCompile.compile\n    super.compile(inputs);                                                                      \n    mInstantRunBuildContext.stopRecording(InstantRunBuildContext.TaskType.JAVAC);               \n}                                                                                               \n```\n\n``` java\n// JavaCompile.java\n@TaskAction                                                                                                                                                                                                                                                                                                           \nprotected void compile(IncrementalTaskInputs inputs) {\n    // 是否为增量编译\n    if (!this.compileOptions.isIncremental()) {\n        this.compile();                                                                                                                                                                                                                                                                                               \n    } else {                                                                                                                                                                                                                                                                                                          \n        DefaultJavaCompileSpec spec = this.createSpec();                                                                                                                                                                                                                                                              \n        CompileCaches compileCaches = this.createCompileCaches();                                                                                                                                                                                                                                                     \n        IncrementalCompilerFactory factory = new IncrementalCompilerFactory(this.getFileOperations(), this.getStreamHasher(), this.getCachingFileHasher(), this.getPath(), this.createCompiler(spec), this.source, compileCaches, (IncrementalTaskInputsInternal)inputs, this.getEffectiveAnnotationProcessorPath()); \n        Compiler<JavaCompileSpec> compiler = factory.createCompiler();                                                                                                                                                                                                                                                \n        this.performCompilation(spec, compiler);                                                                                                                                                                                                                                                                      \n    }                                                                                                                                                                                                                                                                                                                 \n}                                                                                                                                                                                                                                                                                                                     \n```\n\n不管是增量编译还是全量编译，最后都会调用 `performCompilation`\n\n``` java\nprivate void performCompilation(JavaCompileSpec spec, Compiler<JavaCompileSpec> compiler) {\n\t// 执行编译\n    WorkResult result = compiler.execute(spec);                                             \n    this.setDidWork(result.getDidWork());                                                   \n}                                                                                           \n```\n\nCompiler 采用**装饰者设计模式**，最外层是 `CleaningJavaCompilerSupport` 会先删除编译目录，再调用 `JdkJavaCompiler` 执行 `javac` 过程，具体为，创建一个 `JavacTaskImpl` 然后 JavacTask 会调用 `com.sun.tools.javac.main.Main` 进行处理，其中创建 JavacTask 的任务是由 `JavacTool` 完成\n\n","source":"_posts/AppPlugin中的Task-第一篇.md","raw":"---\ntitle: AppPlugin中的Task-第一篇\ndate: 2018-11-12 10:26:03\ncategories: Gradle\ntags:\n---\n\n### 前言\n\n在使用 Android Studio 以后，基本新的 Android 项目都是用 Gradle 作为构建工具，关于 Gradle 的介绍不在本文范畴，当新建一个 Android 项目时，默认只会有个 module 使用`com.android.application` 插件，Gradle 的核心在于 task，即从 java 源文件和资源文件编译成 apk 文件（编译过程），就是由一系列的 task 组成，task 可以相互依赖，比如最基本的 `Task.dependsOn()`，所以理解 Android 编译过程就是理解各个 task 的作用。\n\n> 本文涉及的源码：\n>\n> * com.android.tools.build:gradle:3.1.4\n> * gradle-api-4.4\n\n### AppPlugin\n\n`com.android.application` 的源码位于 `com.android.build.gradle.AppPlugin`，AppPlugin 继承于 BasePlugin，BasePlugin 封装了大部分通用的逻辑：\n\n``` java\n@Override                                                                                \npublic void apply(@NonNull Project project) {                                            \n    \n    // 省略初始化步骤\n    \n    if (!projectOptions.get(BooleanOption.ENABLE_NEW_DSL_AND_API)) {\n        // 不使用新的 DSL API\n        TaskInputHelper.enableBypass();                                                  \n        \n        // threadRecorder 用于记录执行时间\n        \n        // configureProject 配置项目\n        threadRecorder.record(                                                           \n                ExecutionType.BASE_PLUGIN_PROJECT_CONFIGURE,                             \n                project.getPath(),                                                       \n                null,                                                                    \n                this::configureProject);                                                 \n        \n        // configureExtension 配置 Extension 后，我们才能使用 android {} 进行配置\n        threadRecorder.record(                                                           \n                ExecutionType.BASE_PLUGIN_PROJECT_BASE_EXTENSION_CREATION,               \n                project.getPath(),                                                       \n                null,                                                                    \n                this::configureExtension);                                               \n        \n        // createTasks 本文的重点，创建必须的 task\n        threadRecorder.record(                                                           \n                ExecutionType.BASE_PLUGIN_PROJECT_TASKS_CREATION,                        \n                project.getPath(),                                                       \n                null,                                                                    \n                this::createTasks);                                                      \n    } else {                                                                             \n         // 省略                   \n    }                                                                                    \n}                                                                                        \n```\n\n``` java\nprivate void createTasks() {\n    \n    // createTasksBeforeEvaluate\n    threadRecorder.record(                                                   \n            ExecutionType.TASK_MANAGER_CREATE_TASKS,                         \n            project.getPath(),                                               \n            null,                                                            \n            () -> taskManager.createTasksBeforeEvaluate());                  \n    \n    // afterEvaluate 执行\n    project.afterEvaluate(                                                   \n            project ->                                                       \n                    threadRecorder.record(                                   \n                            ExecutionType.BASE_PLUGIN_CREATE_ANDROID_TASKS,  \n                            project.getPath(),                               \n                            null,                                            \n                            () -> createAndroidTasks(false)));               \n}                                                                            \n```\n\n从 `createTasks()` 可以看到，`createAndroidTasks()` 是在 `afterEvaluate()` 中执行的，evaluate 是 Gradle  一个执行的过程\n\n> Gradle 编译的三个阶段：Initialization、Configuration、Execution。具体可以阅读 [build_lifecycle](https://docs.gradle.org/current/userguide/build_lifecycle.html)\n\n`createAndroidTasks()` 这个方法较长，但是我们关心的是 `VariantManager.createAndroidTasks()`\n\n``` java\npublic void createAndroidTasks() {                                                    \n    variantFactory.validateModel(this);                                               \n    variantFactory.preVariantWork(project);                                           \n                                                                                      \n    if (variantScopes.isEmpty()) {\n        // 创建 variantScopes\n        recorder.record(                                                              \n                ExecutionType.VARIANT_MANAGER_CREATE_VARIANTS,                        \n                project.getPath(),                                                    \n                null /*variantName*/,                                                 \n                this::populateVariantDataList);                                       \n    }                                                                                 \n                                                                                      \n    // Create top level test tasks.                                                   \n    recorder.record(                                                                  \n            ExecutionType.VARIANT_MANAGER_CREATE_TESTS_TASKS,                         \n            project.getPath(),                                                        \n            null /*variantName*/,                                                     \n            () -> taskManager.createTopLevelTestTasks(!productFlavors.isEmpty()));    \n                                                                                      \n                                                                                      \n                                                                                      \n    for (final VariantScope variantScope : variantScopes) {\n        // 为每个 variant 生成各自的 task\n        recorder.record(                                                              \n                ExecutionType.VARIANT_MANAGER_CREATE_TASKS_FOR_VARIANT,               \n                project.getPath(),                                                    \n                variantScope.getFullVariantName(),                                    \n                () -> createTasksForVariantData(variantScope));                       \n    }                                                                                 \n                                                                                      \n    taskManager.createReportTasks(variantScopes);                                     \n}                                                                                     \n```\n\n调用 `populateVariantDataList()` 来生成 VariantScopes，它是由 ProductFlavors、BuildType、VariantType 组合\n\n``` java\npublic void createTasksForVariantData(final VariantScope variantScope) {                                              \n    final BaseVariantData variantData = variantScope.getVariantData();                                                \n    final VariantType variantType = variantData.getType();                                                            \n                                                                                                                      \n    final GradleVariantConfiguration variantConfig = variantScope.getVariantConfiguration();                          \n                                                                                                                      \n    final BuildTypeData buildTypeData = buildTypes.get(variantConfig.getBuildType().getName());                       \n    if (buildTypeData.getAssembleTask() == null) {\n        // 创建 BuildType 的 assemble task\n        // 比如 assembleDebug 和 assembleRelease\n        buildTypeData.setAssembleTask(taskManager.createAssembleTask(buildTypeData));                                 \n    }                                                                                                                 \n                                                                                                                      \n    // Add dependency of assemble task on assemble build type task.\n    // assemble 依赖于 assembleDebug 和 assembleRelease\n    taskManager                                                                                                       \n            .getTaskFactory()                                                                                         \n            .configure(                                                                                               \n                    \"assemble\",                                                                                       \n                    task -> {                                                                                         \n                        assert buildTypeData.getAssembleTask() != null;                                               \n                        task.dependsOn(buildTypeData.getAssembleTask().getName());                                    \n                    });                                                                                               \n    \n    // 根据 variant 创建 assemble task\n    createAssembleTaskForVariantData(variantData);                                                                    \n    if (variantType.isForTesting()) {                                                                                 \n         // 省略代码                                                                       \n    } else {\n        // 根据 variant 创建 task\n        taskManager.createTasksForVariantScope(variantScope);                                                         \n    }                                                                                                                 \n}                                                                                                                     \n```\n\nassemble task 用于将源文件编译为最终产物，比如 jar、aar、apk 等，在 `createTasksForVariantData()` 中会生成对应 BuildType 的 assemble task，比如 `assembleDebug` 和 `assembleRelease` ，接着设置 `assemble` 依赖于这两个 task，最后根据 variant 生成对应的 assemble task，比如 `assembleTestDebug`\n\n``` java\nprivate void createAssembleTaskForVariantData(final BaseVariantData variantData) {                      \n    final VariantScope variantScope = variantData.getScope();                                           \n    if (variantData.getType().isForTesting()) {                                                         \n        variantScope.setAssembleTask(taskManager.createAssembleTask(variantData));                      \n    } else {                                                                                            \n        BuildTypeData buildTypeData =                                                                   \n                buildTypes.get(variantData.getVariantConfiguration().getBuildType().getName());         \n                                                                                                        \n        Preconditions.checkNotNull(buildTypeData.getAssembleTask());                                    \n                                                                                                        \n        if (productFlavors.isEmpty()) {                                                                 \n            // Reuse assemble task for build type if there is no product flavor.                        \n            variantScope.setAssembleTask(buildTypeData.getAssembleTask());                              \n                                                                                                        \n            variantData.addTask(                                                                        \n                    TaskContainer.TaskKind.ASSEMBLE, buildTypeData.getAssembleTask());                  \n        } else {\n            // 根据 variant 创建对应的 assemble task，比如 assembleTesDebug\n            variantScope.setAssembleTask(taskManager.createAssembleTask(variantData));                  \n                                                                                                        \n            // setup the task dependencies                                                              \n            // build type\n            // build type assemble task 依赖于 具体的 assemble task\n            buildTypeData.getAssembleTask().dependsOn(variantScope.getAssembleTask());                  \n                                                                                                        \n            // each flavor                                                                              \n            GradleVariantConfiguration variantConfig = variantData.getVariantConfiguration();           \n            for (CoreProductFlavor flavor : variantConfig.getProductFlavors()) {                        \n                ProductFlavorData productFlavorData = productFlavors.get(flavor.getName());             \n                                                                                                        \n                DefaultTask flavorAssembleTask = productFlavorData.getAssembleTask();                   \n                if (flavorAssembleTask == null) {\n                    // 创建 flavor 的 assemble task\n                    // 比如 assembleTes\n                    flavorAssembleTask = taskManager.createAssembleTask(productFlavorData);             \n                    productFlavorData.setAssembleTask(flavorAssembleTask);                              \n                }\n                // flavor assemble task 依赖于具体的 assemble task\n                flavorAssembleTask.dependsOn(variantScope.getAssembleTask());                           \n            }                                                                                           \n                                                                                                        \n            // assembleTask for this flavor(dimension), created on demand if needed.                    \n            if (variantConfig.getProductFlavors().size() > 1) {                                         \n                final String name = StringHelper.capitalize(variantConfig.getFlavorName());             \n                final String variantAssembleTaskName =                                                  \n                        StringHelper.appendCapitalized(\"assemble\", name);                               \n                if (!taskManager.getTaskFactory().containsKey(variantAssembleTaskName)) {               \n                    Task task = taskManager.getTaskFactory().create(variantAssembleTaskName);           \n                    task.setDescription(\"Assembles all builds for flavor combination: \" + name);        \n                    task.setGroup(\"Build\");                                                             \n                    task.dependsOn(variantScope.getAssembleTask().getName());                           \n                }                                                                                       \n                taskManager                                                                             \n                        .getTaskFactory()                                                               \n                        .configure(                                                                     \n                                \"assemble\", task1 -> task1.dependsOn(variantAssembleTaskName));         \n            }                                                                                           \n        }                                                                                               \n    }                                                                                                   \n}                                                                                                       \n```\n\n上面会生成包括 BuildType、Flavor、BuildType + Flavor + VariantType 的 assemble task，同时 task 之间存在依赖关系：`assemble > buildType/flavor > 具体 ` \n\n![assemble-task-demo](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/assemble-task-demo.png?x-oss-process=style/doc-img)\n\n除了上面所说的 assemble task，还将生成以下 task：\n\n| task                                            | impl                                | dependsOn                                                    |\n| ----------------------------------------------- | ----------------------------------- | ------------------------------------------------------------ |\n| assemble{variant}                               | DefaultTask                         | compile{variant}Sources，package{variant}                    |\n| pre{variant}Build                               | AppPreBuildTask                     | preBuild，extractProguardFiles(可能)                         |\n| extractProguardFiles                            | ExtractProguardFiles                |                                                              |\n| generate{variant}Sources                        | DefaultTask                         | compile{variant}Renderscript，generate{variant}BuildConfig，bundle{variant}Resources，compile{variant}Aidl |\n| generate{variant}Resources                      | DefaultTask                         | generate{variant}ResValues，compile{variant}Renderscript     |\n| generate{variant}Assets                         | DefaultTask                         | compile{variant}Shaders                                      |\n| compile{variant}Sources                         | DefaultTask                         | compile{variant}Ndk，compile{variant}JavaWithJavac           |\n| check{variant}Manifest                          | CheckManifest                       | pre{variant}Build                                            |\n| write{variant}ApplicationId                     | ApplicationIdIdWriteTask            |                                                              |\n| mainApkListPersistence{variant}                 | MainApkListPersistence              |                                                              |\n| reportBuildArtifacts{variant}                   | BuildArtifactReportTask             |                                                              |\n| create{variant}CompatibleScreenManifests        | CompatibleScreensManifest           |                                                              |\n| process{variant}Manifest                        | MergeManifests                      | check{variant}Manifest                                       |\n| generate{variant}ResValues                      | GenerateResValues                   |                                                              |\n| compile{variant}Renderscript                    | RenderscriptCompile                 | pre{variant}Build                                            |\n| merge{variant}Resources                         | MergeResources                      | generate{variant}Resources                                   |\n| merge{variant}Shaders                           | MergeSourceSetFolders               |                                                              |\n| compile{variant}Shaders                         | ShaderCompile                       | merge{variant}Shaders                                        |\n| merge{variant}Assets                            | MergeSourceSetFolders               | generate{variant}Assets                                      |\n| generate{variant}BuildConfig                    | GenerateBuildConfig                 | check{variant}Manifest                                       |\n| splitsDiscoveryTask{variant}                    | SplitsDiscovery                     |                                                              |\n| process{variant}JavaRes                         | Sync                                | pre{variant}Build                                            |\n| process{variant}Resources                       | LinkApplicationAndroidResourcesTask |                                                              |\n| bundle{variant}Resources                        | LinkAndroidResForBundleTask         |                                                              |\n| compile{variant}Aidl                            | AidlCompile                         | pre{variant}Build                                            |\n| compile{variant}Ndk                             | NdkCompile                          | pre{variant}Build                                            |\n| merge{variant}JniLibFolders                     | MergeSourceSetFolders               | generate{variant}Assets                                      |\n| javaPreCompile{variant}                         | JavaPreCompileTask                  | pre{variant}Build                                            |\n| compile{variant}JavaWithJavac                   | AndroidJavaCompile                  | generate{variant}Sources                                     |\n| bundleAppClasses{variant}                       | Jar                                 |                                                              |\n| transformResourcesWithMergeJavaResFor{variant}  | TransformTask                       |                                                              |\n| transformClassesWithMultidexlistFor{variant}    | TransformTask                       |                                                              |\n| transformClassesWithDexBuilderFor{variant}      | TransformTask                       |                                                              |\n| transformDexArchiveWithDexMergerFor{variant}    | TransformTask                       | transformClassesWithMultidexlistFor{variant}                 |\n| preparePUBLISHED_JAVA_RES{variant}ForPublishing | PipelineToPublicationTask           |                                                              |\n| package{variant}                                | PackageApplication                  | merge{variant}Assets，process{variant}Resources，validateSigning{variant}，compile{variant}JavaWithJavac |\n| validateSigning{variant}                        | ValidateSigningTask                 |                                                              |\n| install{variant}                                | InstallVariantTask                  | assemble{variant}                                            |\n| uninstall{variant}                              | UninstallTask                       |                                                              |\n| lint{variant}                                   | LintPerVariantTask                  |                                                              |\n\n以 `assembleProdRelease` 命令，依次执行的 task：\n\n> prod 是 product flavor\n\n```\npreBuild\nextractProguardFiles\npreProdReleaseBuild\ncompileProdReleaseRenderscript\ncheckProdReleaseManifest\ngenerateProdReleaseBuildConfig\nprepareLintJar\nmainApkListPersistenceProdRelease\ngenerateProdReleaseResValues\ngenerateProdReleaseResources\ncompileProdReleaseAidl\ncreateProdReleaseCompatibleScreenManifests\nprocessProdReleaseManifest\nmergeProdReleaseResources  // 合并资源\nsplitsDiscoveryTaskProdRelease\nprocessProdReleaseResources\ngenerateProdReleaseSources\njavaPreCompileProdRelease\ncompileProdReleaseJavaWithJavac // javac\ncompileProdReleaseNdk\ncompileProdReleaseSources\nmergeProdReleaseShaders\ncompileProdReleaseShaders\ngenerateProdReleaseAssets\nmergeProdReleaseAssets\ntransformClassesWithComponentCodeForProdRelease \nprocessProdReleaseJavaRes\ntransformResourcesWithMergeJavaResForProdRelease\ntransformClassesAndResourcesWithProguardForProdRelease // 混淆\ntransformClassesWithMultidexlistForProdRelease\ntransformClassesWithDexForProdRelease\t\t\t\t// dex\ntransformClassesWithShrinkResForProdRelease\nmergeProdReleaseJniLibFolders\ntransformNativeLibsWithMergeJniLibsForProdRelease\nvalidateSigningProdRelease\npackageProdRelease\n```\n\n接下来分析下比较重要的几个 task\n\n> 接下来的分析，因为对应的源码比较复杂，所以只会简短介绍结果，没有详细过程，推荐 debug 整个流程\n\n### CompileJavaWithJavac\n\n首先找到执行的 AndroidJavaCompile\n\n``` java\n// AndroidJavaCompile.java\n@Override                                                                                       \nprotected void compile(IncrementalTaskInputs inputs) {                                          \n    // compileSdkVersion >= 24，需要使用 jdk1.8                                                     \n    if (isPostN()) {                                                                            \n        if (!JavaVersion.current().isJava8Compatible()) {                                       \n            throw new RuntimeException(\"compileSdkVersion '\" + compileSdkVersion + \"' requires \"\n                    + \"JDK 1.8 or later to compile.\");                                          \n        }                                                                                       \n    }                                                                                           \n    \n    // 处理注解处理器，在之前 task 会将使用 annotationProcessor 标示的注解处理器写入到 annotationProcessors.json 中\n    processAnalytics();                                                                         \n                                                                                                \n    // Create directory for output of annotation processor.                                     \n    FileUtils.mkdirs(annotationProcessorOutputFolder);                                          \n                                                                                                \n    mInstantRunBuildContext.startRecording(InstantRunBuildContext.TaskType.JAVAC);\n    // 调用 JavaCompile.compile\n    super.compile(inputs);                                                                      \n    mInstantRunBuildContext.stopRecording(InstantRunBuildContext.TaskType.JAVAC);               \n}                                                                                               \n```\n\n``` java\n// JavaCompile.java\n@TaskAction                                                                                                                                                                                                                                                                                                           \nprotected void compile(IncrementalTaskInputs inputs) {\n    // 是否为增量编译\n    if (!this.compileOptions.isIncremental()) {\n        this.compile();                                                                                                                                                                                                                                                                                               \n    } else {                                                                                                                                                                                                                                                                                                          \n        DefaultJavaCompileSpec spec = this.createSpec();                                                                                                                                                                                                                                                              \n        CompileCaches compileCaches = this.createCompileCaches();                                                                                                                                                                                                                                                     \n        IncrementalCompilerFactory factory = new IncrementalCompilerFactory(this.getFileOperations(), this.getStreamHasher(), this.getCachingFileHasher(), this.getPath(), this.createCompiler(spec), this.source, compileCaches, (IncrementalTaskInputsInternal)inputs, this.getEffectiveAnnotationProcessorPath()); \n        Compiler<JavaCompileSpec> compiler = factory.createCompiler();                                                                                                                                                                                                                                                \n        this.performCompilation(spec, compiler);                                                                                                                                                                                                                                                                      \n    }                                                                                                                                                                                                                                                                                                                 \n}                                                                                                                                                                                                                                                                                                                     \n```\n\n不管是增量编译还是全量编译，最后都会调用 `performCompilation`\n\n``` java\nprivate void performCompilation(JavaCompileSpec spec, Compiler<JavaCompileSpec> compiler) {\n\t// 执行编译\n    WorkResult result = compiler.execute(spec);                                             \n    this.setDidWork(result.getDidWork());                                                   \n}                                                                                           \n```\n\nCompiler 采用**装饰者设计模式**，最外层是 `CleaningJavaCompilerSupport` 会先删除编译目录，再调用 `JdkJavaCompiler` 执行 `javac` 过程，具体为，创建一个 `JavacTaskImpl` 然后 JavacTask 会调用 `com.sun.tools.javac.main.Main` 进行处理，其中创建 JavacTask 的任务是由 `JavacTool` 完成\n\n","slug":"AppPlugin中的Task-第一篇","published":1,"updated":"2018-11-21T02:16:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs0s0006e39k9p36fwp7","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在使用 Android Studio 以后，基本新的 Android 项目都是用 Gradle 作为构建工具，关于 Gradle 的介绍不在本文范畴，当新建一个 Android 项目时，默认只会有个 module 使用<code>com.android.application</code> 插件，Gradle 的核心在于 task，即从 java 源文件和资源文件编译成 apk 文件（编译过程），就是由一系列的 task 组成，task 可以相互依赖，比如最基本的 <code>Task.dependsOn()</code>，所以理解 Android 编译过程就是理解各个 task 的作用。</p>\n<blockquote>\n<p>本文涉及的源码：</p>\n<ul>\n<li>com.android.tools.build:gradle:3.1.4</li>\n<li>gradle-api-4.4</li>\n</ul>\n</blockquote>\n<h3 id=\"AppPlugin\"><a href=\"#AppPlugin\" class=\"headerlink\" title=\"AppPlugin\"></a>AppPlugin</h3><p><code>com.android.application</code> 的源码位于 <code>com.android.build.gradle.AppPlugin</code>，AppPlugin 继承于 BasePlugin，BasePlugin 封装了大部分通用的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">apply</span><span class=\"params\">(@NonNull Project project)</span> </span>&#123;                                            </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 省略初始化步骤</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!projectOptions.get(BooleanOption.ENABLE_NEW_DSL_AND_API)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不使用新的 DSL API</span></span><br><span class=\"line\">        TaskInputHelper.enableBypass();                                                  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// threadRecorder 用于记录执行时间</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// configureProject 配置项目</span></span><br><span class=\"line\">        threadRecorder.record(                                                           </span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_CONFIGURE,                             </span><br><span class=\"line\">                project.getPath(),                                                       </span><br><span class=\"line\">                <span class=\"keyword\">null</span>,                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">this</span>::configureProject);                                                 </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// configureExtension 配置 Extension 后，我们才能使用 android &#123;&#125; 进行配置</span></span><br><span class=\"line\">        threadRecorder.record(                                                           </span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_BASE_EXTENSION_CREATION,               </span><br><span class=\"line\">                project.getPath(),                                                       </span><br><span class=\"line\">                <span class=\"keyword\">null</span>,                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">this</span>::configureExtension);                                               </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// createTasks 本文的重点，创建必须的 task</span></span><br><span class=\"line\">        threadRecorder.record(                                                           </span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_TASKS_CREATION,                        </span><br><span class=\"line\">                project.getPath(),                                                       </span><br><span class=\"line\">                <span class=\"keyword\">null</span>,                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">this</span>::createTasks);                                                      </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                             </span><br><span class=\"line\">         <span class=\"comment\">// 省略                   </span></span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createTasks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// createTasksBeforeEvaluate</span></span><br><span class=\"line\">    threadRecorder.record(                                                   </span><br><span class=\"line\">            ExecutionType.TASK_MANAGER_CREATE_TASKS,                         </span><br><span class=\"line\">            project.getPath(),                                               </span><br><span class=\"line\">            <span class=\"keyword\">null</span>,                                                            </span><br><span class=\"line\">            () -&gt; taskManager.createTasksBeforeEvaluate());                  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// afterEvaluate 执行</span></span><br><span class=\"line\">    project.afterEvaluate(                                                   </span><br><span class=\"line\">            project -&gt;                                                       </span><br><span class=\"line\">                    threadRecorder.record(                                   </span><br><span class=\"line\">                            ExecutionType.BASE_PLUGIN_CREATE_ANDROID_TASKS,  </span><br><span class=\"line\">                            project.getPath(),                               </span><br><span class=\"line\">                            <span class=\"keyword\">null</span>,                                            </span><br><span class=\"line\">                            () -&gt; createAndroidTasks(<span class=\"keyword\">false</span>)));               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从 <code>createTasks()</code> 可以看到，<code>createAndroidTasks()</code> 是在 <code>afterEvaluate()</code> 中执行的，evaluate 是 Gradle  一个执行的过程</p>\n<blockquote>\n<p>Gradle 编译的三个阶段：Initialization、Configuration、Execution。具体可以阅读 <a href=\"https://docs.gradle.org/current/userguide/build_lifecycle.html\" target=\"_blank\" rel=\"noopener\">build_lifecycle</a></p>\n</blockquote>\n<p><code>createAndroidTasks()</code> 这个方法较长，但是我们关心的是 <code>VariantManager.createAndroidTasks()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createAndroidTasks</span><span class=\"params\">()</span> </span>&#123;                                                    </span><br><span class=\"line\">    variantFactory.validateModel(<span class=\"keyword\">this</span>);                                               </span><br><span class=\"line\">    variantFactory.preVariantWork(project);                                           </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (variantScopes.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 variantScopes</span></span><br><span class=\"line\">        recorder.record(                                                              </span><br><span class=\"line\">                ExecutionType.VARIANT_MANAGER_CREATE_VARIANTS,                        </span><br><span class=\"line\">                project.getPath(),                                                    </span><br><span class=\"line\">                <span class=\"keyword\">null</span> <span class=\"comment\">/*variantName*/</span>,                                                 </span><br><span class=\"line\">                <span class=\"keyword\">this</span>::populateVariantDataList);                                       </span><br><span class=\"line\">    &#125;                                                                                 </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">    <span class=\"comment\">// Create top level test tasks.                                                   </span></span><br><span class=\"line\">    recorder.record(                                                                  </span><br><span class=\"line\">            ExecutionType.VARIANT_MANAGER_CREATE_TESTS_TASKS,                         </span><br><span class=\"line\">            project.getPath(),                                                        </span><br><span class=\"line\">            <span class=\"keyword\">null</span> <span class=\"comment\">/*variantName*/</span>,                                                     </span><br><span class=\"line\">            () -&gt; taskManager.createTopLevelTestTasks(!productFlavors.isEmpty()));    </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> VariantScope variantScope : variantScopes) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为每个 variant 生成各自的 task</span></span><br><span class=\"line\">        recorder.record(                                                              </span><br><span class=\"line\">                ExecutionType.VARIANT_MANAGER_CREATE_TASKS_FOR_VARIANT,               </span><br><span class=\"line\">                project.getPath(),                                                    </span><br><span class=\"line\">                variantScope.getFullVariantName(),                                    </span><br><span class=\"line\">                () -&gt; createTasksForVariantData(variantScope));                       </span><br><span class=\"line\">    &#125;                                                                                 </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">    taskManager.createReportTasks(variantScopes);                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用 <code>populateVariantDataList()</code> 来生成 VariantScopes，它是由 ProductFlavors、BuildType、VariantType 组合</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createTasksForVariantData</span><span class=\"params\">(<span class=\"keyword\">final</span> VariantScope variantScope)</span> </span>&#123;                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> BaseVariantData variantData = variantScope.getVariantData();                                                </span><br><span class=\"line\">    <span class=\"keyword\">final</span> VariantType variantType = variantData.getType();                                                            </span><br><span class=\"line\">                                                                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> GradleVariantConfiguration variantConfig = variantScope.getVariantConfiguration();                          </span><br><span class=\"line\">                                                                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> BuildTypeData buildTypeData = buildTypes.get(variantConfig.getBuildType().getName());                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buildTypeData.getAssembleTask() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 BuildType 的 assemble task</span></span><br><span class=\"line\">        <span class=\"comment\">// 比如 assembleDebug 和 assembleRelease</span></span><br><span class=\"line\">        buildTypeData.setAssembleTask(taskManager.createAssembleTask(buildTypeData));                                 </span><br><span class=\"line\">    &#125;                                                                                                                 </span><br><span class=\"line\">                                                                                                                      </span><br><span class=\"line\">    <span class=\"comment\">// Add dependency of assemble task on assemble build type task.</span></span><br><span class=\"line\">    <span class=\"comment\">// assemble 依赖于 assembleDebug 和 assembleRelease</span></span><br><span class=\"line\">    taskManager                                                                                                       </span><br><span class=\"line\">            .getTaskFactory()                                                                                         </span><br><span class=\"line\">            .configure(                                                                                               </span><br><span class=\"line\">                    <span class=\"string\">\"assemble\"</span>,                                                                                       </span><br><span class=\"line\">                    task -&gt; &#123;                                                                                         </span><br><span class=\"line\">                        <span class=\"keyword\">assert</span> buildTypeData.getAssembleTask() != <span class=\"keyword\">null</span>;                                               </span><br><span class=\"line\">                        task.dependsOn(buildTypeData.getAssembleTask().getName());                                    </span><br><span class=\"line\">                    &#125;);                                                                                               </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 根据 variant 创建 assemble task</span></span><br><span class=\"line\">    createAssembleTaskForVariantData(variantData);                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (variantType.isForTesting()) &#123;                                                                                 </span><br><span class=\"line\">         <span class=\"comment\">// 省略代码                                                                       </span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据 variant 创建 task</span></span><br><span class=\"line\">        taskManager.createTasksForVariantScope(variantScope);                                                         </span><br><span class=\"line\">    &#125;                                                                                                                 </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>assemble task 用于将源文件编译为最终产物，比如 jar、aar、apk 等，在 <code>createTasksForVariantData()</code> 中会生成对应 BuildType 的 assemble task，比如 <code>assembleDebug</code> 和 <code>assembleRelease</code> ，接着设置 <code>assemble</code> 依赖于这两个 task，最后根据 variant 生成对应的 assemble task，比如 <code>assembleTestDebug</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createAssembleTaskForVariantData</span><span class=\"params\">(<span class=\"keyword\">final</span> BaseVariantData variantData)</span> </span>&#123;                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> VariantScope variantScope = variantData.getScope();                                           </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (variantData.getType().isForTesting()) &#123;                                                         </span><br><span class=\"line\">        variantScope.setAssembleTask(taskManager.createAssembleTask(variantData));                      </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                            </span><br><span class=\"line\">        BuildTypeData buildTypeData =                                                                   </span><br><span class=\"line\">                buildTypes.get(variantData.getVariantConfiguration().getBuildType().getName());         </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">        Preconditions.checkNotNull(buildTypeData.getAssembleTask());                                    </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (productFlavors.isEmpty()) &#123;                                                                 </span><br><span class=\"line\">            <span class=\"comment\">// Reuse assemble task for build type if there is no product flavor.                        </span></span><br><span class=\"line\">            variantScope.setAssembleTask(buildTypeData.getAssembleTask());                              </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">            variantData.addTask(                                                                        </span><br><span class=\"line\">                    TaskContainer.TaskKind.ASSEMBLE, buildTypeData.getAssembleTask());                  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据 variant 创建对应的 assemble task，比如 assembleTesDebug</span></span><br><span class=\"line\">            variantScope.setAssembleTask(taskManager.createAssembleTask(variantData));                  </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">            <span class=\"comment\">// setup the task dependencies                                                              </span></span><br><span class=\"line\">            <span class=\"comment\">// build type</span></span><br><span class=\"line\">            <span class=\"comment\">// build type assemble task 依赖于 具体的 assemble task</span></span><br><span class=\"line\">            buildTypeData.getAssembleTask().dependsOn(variantScope.getAssembleTask());                  </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">            <span class=\"comment\">// each flavor                                                                              </span></span><br><span class=\"line\">            GradleVariantConfiguration variantConfig = variantData.getVariantConfiguration();           </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (CoreProductFlavor flavor : variantConfig.getProductFlavors()) &#123;                        </span><br><span class=\"line\">                ProductFlavorData productFlavorData = productFlavors.get(flavor.getName());             </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">                DefaultTask flavorAssembleTask = productFlavorData.getAssembleTask();                   </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flavorAssembleTask == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 创建 flavor 的 assemble task</span></span><br><span class=\"line\">                    <span class=\"comment\">// 比如 assembleTes</span></span><br><span class=\"line\">                    flavorAssembleTask = taskManager.createAssembleTask(productFlavorData);             </span><br><span class=\"line\">                    productFlavorData.setAssembleTask(flavorAssembleTask);                              </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// flavor assemble task 依赖于具体的 assemble task</span></span><br><span class=\"line\">                flavorAssembleTask.dependsOn(variantScope.getAssembleTask());                           </span><br><span class=\"line\">            &#125;                                                                                           </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">            <span class=\"comment\">// assembleTask for this flavor(dimension), created on demand if needed.                    </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (variantConfig.getProductFlavors().size() &gt; <span class=\"number\">1</span>) &#123;                                         </span><br><span class=\"line\">                <span class=\"keyword\">final</span> String name = StringHelper.capitalize(variantConfig.getFlavorName());             </span><br><span class=\"line\">                <span class=\"keyword\">final</span> String variantAssembleTaskName =                                                  </span><br><span class=\"line\">                        StringHelper.appendCapitalized(<span class=\"string\">\"assemble\"</span>, name);                               </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!taskManager.getTaskFactory().containsKey(variantAssembleTaskName)) &#123;               </span><br><span class=\"line\">                    Task task = taskManager.getTaskFactory().create(variantAssembleTaskName);           </span><br><span class=\"line\">                    task.setDescription(<span class=\"string\">\"Assembles all builds for flavor combination: \"</span> + name);        </span><br><span class=\"line\">                    task.setGroup(<span class=\"string\">\"Build\"</span>);                                                             </span><br><span class=\"line\">                    task.dependsOn(variantScope.getAssembleTask().getName());                           </span><br><span class=\"line\">                &#125;                                                                                       </span><br><span class=\"line\">                taskManager                                                                             </span><br><span class=\"line\">                        .getTaskFactory()                                                               </span><br><span class=\"line\">                        .configure(                                                                     </span><br><span class=\"line\">                                <span class=\"string\">\"assemble\"</span>, task1 -&gt; task1.dependsOn(variantAssembleTaskName));         </span><br><span class=\"line\">            &#125;                                                                                           </span><br><span class=\"line\">        &#125;                                                                                               </span><br><span class=\"line\">    &#125;                                                                                                   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面会生成包括 BuildType、Flavor、BuildType + Flavor + VariantType 的 assemble task，同时 task 之间存在依赖关系：<code>assemble &gt; buildType/flavor &gt; 具体</code> </p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/assemble-task-demo.png?x-oss-process=style/doc-img\" alt=\"assemble-task-demo\"></p>\n<p>除了上面所说的 assemble task，还将生成以下 task：</p>\n<table>\n<thead>\n<tr>\n<th>task</th>\n<th>impl</th>\n<th>dependsOn</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>assemble{variant}</td>\n<td>DefaultTask</td>\n<td>compile{variant}Sources，package{variant}</td>\n</tr>\n<tr>\n<td>pre{variant}Build</td>\n<td>AppPreBuildTask</td>\n<td>preBuild，extractProguardFiles(可能)</td>\n</tr>\n<tr>\n<td>extractProguardFiles</td>\n<td>ExtractProguardFiles</td>\n<td></td>\n</tr>\n<tr>\n<td>generate{variant}Sources</td>\n<td>DefaultTask</td>\n<td>compile{variant}Renderscript，generate{variant}BuildConfig，bundle{variant}Resources，compile{variant}Aidl</td>\n</tr>\n<tr>\n<td>generate{variant}Resources</td>\n<td>DefaultTask</td>\n<td>generate{variant}ResValues，compile{variant}Renderscript</td>\n</tr>\n<tr>\n<td>generate{variant}Assets</td>\n<td>DefaultTask</td>\n<td>compile{variant}Shaders</td>\n</tr>\n<tr>\n<td>compile{variant}Sources</td>\n<td>DefaultTask</td>\n<td>compile{variant}Ndk，compile{variant}JavaWithJavac</td>\n</tr>\n<tr>\n<td>check{variant}Manifest</td>\n<td>CheckManifest</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>write{variant}ApplicationId</td>\n<td>ApplicationIdIdWriteTask</td>\n<td></td>\n</tr>\n<tr>\n<td>mainApkListPersistence{variant}</td>\n<td>MainApkListPersistence</td>\n<td></td>\n</tr>\n<tr>\n<td>reportBuildArtifacts{variant}</td>\n<td>BuildArtifactReportTask</td>\n<td></td>\n</tr>\n<tr>\n<td>create{variant}CompatibleScreenManifests</td>\n<td>CompatibleScreensManifest</td>\n<td></td>\n</tr>\n<tr>\n<td>process{variant}Manifest</td>\n<td>MergeManifests</td>\n<td>check{variant}Manifest</td>\n</tr>\n<tr>\n<td>generate{variant}ResValues</td>\n<td>GenerateResValues</td>\n<td></td>\n</tr>\n<tr>\n<td>compile{variant}Renderscript</td>\n<td>RenderscriptCompile</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>merge{variant}Resources</td>\n<td>MergeResources</td>\n<td>generate{variant}Resources</td>\n</tr>\n<tr>\n<td>merge{variant}Shaders</td>\n<td>MergeSourceSetFolders</td>\n<td></td>\n</tr>\n<tr>\n<td>compile{variant}Shaders</td>\n<td>ShaderCompile</td>\n<td>merge{variant}Shaders</td>\n</tr>\n<tr>\n<td>merge{variant}Assets</td>\n<td>MergeSourceSetFolders</td>\n<td>generate{variant}Assets</td>\n</tr>\n<tr>\n<td>generate{variant}BuildConfig</td>\n<td>GenerateBuildConfig</td>\n<td>check{variant}Manifest</td>\n</tr>\n<tr>\n<td>splitsDiscoveryTask{variant}</td>\n<td>SplitsDiscovery</td>\n<td></td>\n</tr>\n<tr>\n<td>process{variant}JavaRes</td>\n<td>Sync</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>process{variant}Resources</td>\n<td>LinkApplicationAndroidResourcesTask</td>\n<td></td>\n</tr>\n<tr>\n<td>bundle{variant}Resources</td>\n<td>LinkAndroidResForBundleTask</td>\n<td></td>\n</tr>\n<tr>\n<td>compile{variant}Aidl</td>\n<td>AidlCompile</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>compile{variant}Ndk</td>\n<td>NdkCompile</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>merge{variant}JniLibFolders</td>\n<td>MergeSourceSetFolders</td>\n<td>generate{variant}Assets</td>\n</tr>\n<tr>\n<td>javaPreCompile{variant}</td>\n<td>JavaPreCompileTask</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>compile{variant}JavaWithJavac</td>\n<td>AndroidJavaCompile</td>\n<td>generate{variant}Sources</td>\n</tr>\n<tr>\n<td>bundleAppClasses{variant}</td>\n<td>Jar</td>\n<td></td>\n</tr>\n<tr>\n<td>transformResourcesWithMergeJavaResFor{variant}</td>\n<td>TransformTask</td>\n<td></td>\n</tr>\n<tr>\n<td>transformClassesWithMultidexlistFor{variant}</td>\n<td>TransformTask</td>\n<td></td>\n</tr>\n<tr>\n<td>transformClassesWithDexBuilderFor{variant}</td>\n<td>TransformTask</td>\n<td></td>\n</tr>\n<tr>\n<td>transformDexArchiveWithDexMergerFor{variant}</td>\n<td>TransformTask</td>\n<td>transformClassesWithMultidexlistFor{variant}</td>\n</tr>\n<tr>\n<td>preparePUBLISHED_JAVA_RES{variant}ForPublishing</td>\n<td>PipelineToPublicationTask</td>\n<td></td>\n</tr>\n<tr>\n<td>package{variant}</td>\n<td>PackageApplication</td>\n<td>merge{variant}Assets，process{variant}Resources，validateSigning{variant}，compile{variant}JavaWithJavac</td>\n</tr>\n<tr>\n<td>validateSigning{variant}</td>\n<td>ValidateSigningTask</td>\n<td></td>\n</tr>\n<tr>\n<td>install{variant}</td>\n<td>InstallVariantTask</td>\n<td>assemble{variant}</td>\n</tr>\n<tr>\n<td>uninstall{variant}</td>\n<td>UninstallTask</td>\n<td></td>\n</tr>\n<tr>\n<td>lint{variant}</td>\n<td>LintPerVariantTask</td>\n</tr>\n</tbody>\n</table>\n<p>以 <code>assembleProdRelease</code> 命令，依次执行的 task：</p>\n<blockquote>\n<p>prod 是 product flavor</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preBuild</span><br><span class=\"line\">extractProguardFiles</span><br><span class=\"line\">preProdReleaseBuild</span><br><span class=\"line\">compileProdReleaseRenderscript</span><br><span class=\"line\">checkProdReleaseManifest</span><br><span class=\"line\">generateProdReleaseBuildConfig</span><br><span class=\"line\">prepareLintJar</span><br><span class=\"line\">mainApkListPersistenceProdRelease</span><br><span class=\"line\">generateProdReleaseResValues</span><br><span class=\"line\">generateProdReleaseResources</span><br><span class=\"line\">compileProdReleaseAidl</span><br><span class=\"line\">createProdReleaseCompatibleScreenManifests</span><br><span class=\"line\">processProdReleaseManifest</span><br><span class=\"line\">mergeProdReleaseResources  // 合并资源</span><br><span class=\"line\">splitsDiscoveryTaskProdRelease</span><br><span class=\"line\">processProdReleaseResources</span><br><span class=\"line\">generateProdReleaseSources</span><br><span class=\"line\">javaPreCompileProdRelease</span><br><span class=\"line\">compileProdReleaseJavaWithJavac // javac</span><br><span class=\"line\">compileProdReleaseNdk</span><br><span class=\"line\">compileProdReleaseSources</span><br><span class=\"line\">mergeProdReleaseShaders</span><br><span class=\"line\">compileProdReleaseShaders</span><br><span class=\"line\">generateProdReleaseAssets</span><br><span class=\"line\">mergeProdReleaseAssets</span><br><span class=\"line\">transformClassesWithComponentCodeForProdRelease </span><br><span class=\"line\">processProdReleaseJavaRes</span><br><span class=\"line\">transformResourcesWithMergeJavaResForProdRelease</span><br><span class=\"line\">transformClassesAndResourcesWithProguardForProdRelease // 混淆</span><br><span class=\"line\">transformClassesWithMultidexlistForProdRelease</span><br><span class=\"line\">transformClassesWithDexForProdRelease\t\t\t\t// dex</span><br><span class=\"line\">transformClassesWithShrinkResForProdRelease</span><br><span class=\"line\">mergeProdReleaseJniLibFolders</span><br><span class=\"line\">transformNativeLibsWithMergeJniLibsForProdRelease</span><br><span class=\"line\">validateSigningProdRelease</span><br><span class=\"line\">packageProdRelease</span><br></pre></td></tr></table></figure>\n<p>接下来分析下比较重要的几个 task</p>\n<blockquote>\n<p>接下来的分析，因为对应的源码比较复杂，所以只会简短介绍结果，没有详细过程，推荐 debug 整个流程</p>\n</blockquote>\n<h3 id=\"CompileJavaWithJavac\"><a href=\"#CompileJavaWithJavac\" class=\"headerlink\" title=\"CompileJavaWithJavac\"></a>CompileJavaWithJavac</h3><p>首先找到执行的 AndroidJavaCompile</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AndroidJavaCompile.java</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                       </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">compile</span><span class=\"params\">(IncrementalTaskInputs inputs)</span> </span>&#123;                                          </span><br><span class=\"line\">    <span class=\"comment\">// compileSdkVersion &gt;= 24，需要使用 jdk1.8                                                     </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isPostN()) &#123;                                                                            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!JavaVersion.current().isJava8Compatible()) &#123;                                       </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"compileSdkVersion '\"</span> + compileSdkVersion + <span class=\"string\">\"' requires \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\"JDK 1.8 or later to compile.\"</span>);                                          </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 处理注解处理器，在之前 task 会将使用 annotationProcessor 标示的注解处理器写入到 annotationProcessors.json 中</span></span><br><span class=\"line\">    processAnalytics();                                                                         </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"comment\">// Create directory for output of annotation processor.                                     </span></span><br><span class=\"line\">    FileUtils.mkdirs(annotationProcessorOutputFolder);                                          </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    mInstantRunBuildContext.startRecording(InstantRunBuildContext.TaskType.JAVAC);</span><br><span class=\"line\">    <span class=\"comment\">// 调用 JavaCompile.compile</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.compile(inputs);                                                                      </span><br><span class=\"line\">    mInstantRunBuildContext.stopRecording(InstantRunBuildContext.TaskType.JAVAC);               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JavaCompile.java</span></span><br><span class=\"line\"><span class=\"meta\">@TaskAction</span>                                                                                                                                                                                                                                                                                                           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">compile</span><span class=\"params\">(IncrementalTaskInputs inputs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是否为增量编译</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.compileOptions.isIncremental()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.compile();                                                                                                                                                                                                                                                                                               </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                                                                                                                                                                                                                                          </span><br><span class=\"line\">        DefaultJavaCompileSpec spec = <span class=\"keyword\">this</span>.createSpec();                                                                                                                                                                                                                                                              </span><br><span class=\"line\">        CompileCaches compileCaches = <span class=\"keyword\">this</span>.createCompileCaches();                                                                                                                                                                                                                                                     </span><br><span class=\"line\">        IncrementalCompilerFactory factory = <span class=\"keyword\">new</span> IncrementalCompilerFactory(<span class=\"keyword\">this</span>.getFileOperations(), <span class=\"keyword\">this</span>.getStreamHasher(), <span class=\"keyword\">this</span>.getCachingFileHasher(), <span class=\"keyword\">this</span>.getPath(), <span class=\"keyword\">this</span>.createCompiler(spec), <span class=\"keyword\">this</span>.source, compileCaches, (IncrementalTaskInputsInternal)inputs, <span class=\"keyword\">this</span>.getEffectiveAnnotationProcessorPath()); </span><br><span class=\"line\">        Compiler&lt;JavaCompileSpec&gt; compiler = factory.createCompiler();                                                                                                                                                                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.performCompilation(spec, compiler);                                                                                                                                                                                                                                                                      </span><br><span class=\"line\">    &#125;                                                                                                                                                                                                                                                                                                                 </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不管是增量编译还是全量编译，最后都会调用 <code>performCompilation</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performCompilation</span><span class=\"params\">(JavaCompileSpec spec, Compiler&lt;JavaCompileSpec&gt; compiler)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 执行编译</span></span><br><span class=\"line\">    WorkResult result = compiler.execute(spec);                                             </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setDidWork(result.getDidWork());                                                   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Compiler 采用<strong>装饰者设计模式</strong>，最外层是 <code>CleaningJavaCompilerSupport</code> 会先删除编译目录，再调用 <code>JdkJavaCompiler</code> 执行 <code>javac</code> 过程，具体为，创建一个 <code>JavacTaskImpl</code> 然后 JavacTask 会调用 <code>com.sun.tools.javac.main.Main</code> 进行处理，其中创建 JavacTask 的任务是由 <code>JavacTool</code> 完成</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在使用 Android Studio 以后，基本新的 Android 项目都是用 Gradle 作为构建工具，关于 Gradle 的介绍不在本文范畴，当新建一个 Android 项目时，默认只会有个 module 使用<code>com.android.application</code> 插件，Gradle 的核心在于 task，即从 java 源文件和资源文件编译成 apk 文件（编译过程），就是由一系列的 task 组成，task 可以相互依赖，比如最基本的 <code>Task.dependsOn()</code>，所以理解 Android 编译过程就是理解各个 task 的作用。</p>\n<blockquote>\n<p>本文涉及的源码：</p>\n<ul>\n<li>com.android.tools.build:gradle:3.1.4</li>\n<li>gradle-api-4.4</li>\n</ul>\n</blockquote>\n<h3 id=\"AppPlugin\"><a href=\"#AppPlugin\" class=\"headerlink\" title=\"AppPlugin\"></a>AppPlugin</h3><p><code>com.android.application</code> 的源码位于 <code>com.android.build.gradle.AppPlugin</code>，AppPlugin 继承于 BasePlugin，BasePlugin 封装了大部分通用的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">apply</span><span class=\"params\">(@NonNull Project project)</span> </span>&#123;                                            </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 省略初始化步骤</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!projectOptions.get(BooleanOption.ENABLE_NEW_DSL_AND_API)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不使用新的 DSL API</span></span><br><span class=\"line\">        TaskInputHelper.enableBypass();                                                  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// threadRecorder 用于记录执行时间</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// configureProject 配置项目</span></span><br><span class=\"line\">        threadRecorder.record(                                                           </span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_CONFIGURE,                             </span><br><span class=\"line\">                project.getPath(),                                                       </span><br><span class=\"line\">                <span class=\"keyword\">null</span>,                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">this</span>::configureProject);                                                 </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// configureExtension 配置 Extension 后，我们才能使用 android &#123;&#125; 进行配置</span></span><br><span class=\"line\">        threadRecorder.record(                                                           </span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_BASE_EXTENSION_CREATION,               </span><br><span class=\"line\">                project.getPath(),                                                       </span><br><span class=\"line\">                <span class=\"keyword\">null</span>,                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">this</span>::configureExtension);                                               </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// createTasks 本文的重点，创建必须的 task</span></span><br><span class=\"line\">        threadRecorder.record(                                                           </span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_TASKS_CREATION,                        </span><br><span class=\"line\">                project.getPath(),                                                       </span><br><span class=\"line\">                <span class=\"keyword\">null</span>,                                                                    </span><br><span class=\"line\">                <span class=\"keyword\">this</span>::createTasks);                                                      </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                             </span><br><span class=\"line\">         <span class=\"comment\">// 省略                   </span></span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createTasks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// createTasksBeforeEvaluate</span></span><br><span class=\"line\">    threadRecorder.record(                                                   </span><br><span class=\"line\">            ExecutionType.TASK_MANAGER_CREATE_TASKS,                         </span><br><span class=\"line\">            project.getPath(),                                               </span><br><span class=\"line\">            <span class=\"keyword\">null</span>,                                                            </span><br><span class=\"line\">            () -&gt; taskManager.createTasksBeforeEvaluate());                  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// afterEvaluate 执行</span></span><br><span class=\"line\">    project.afterEvaluate(                                                   </span><br><span class=\"line\">            project -&gt;                                                       </span><br><span class=\"line\">                    threadRecorder.record(                                   </span><br><span class=\"line\">                            ExecutionType.BASE_PLUGIN_CREATE_ANDROID_TASKS,  </span><br><span class=\"line\">                            project.getPath(),                               </span><br><span class=\"line\">                            <span class=\"keyword\">null</span>,                                            </span><br><span class=\"line\">                            () -&gt; createAndroidTasks(<span class=\"keyword\">false</span>)));               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从 <code>createTasks()</code> 可以看到，<code>createAndroidTasks()</code> 是在 <code>afterEvaluate()</code> 中执行的，evaluate 是 Gradle  一个执行的过程</p>\n<blockquote>\n<p>Gradle 编译的三个阶段：Initialization、Configuration、Execution。具体可以阅读 <a href=\"https://docs.gradle.org/current/userguide/build_lifecycle.html\" target=\"_blank\" rel=\"noopener\">build_lifecycle</a></p>\n</blockquote>\n<p><code>createAndroidTasks()</code> 这个方法较长，但是我们关心的是 <code>VariantManager.createAndroidTasks()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createAndroidTasks</span><span class=\"params\">()</span> </span>&#123;                                                    </span><br><span class=\"line\">    variantFactory.validateModel(<span class=\"keyword\">this</span>);                                               </span><br><span class=\"line\">    variantFactory.preVariantWork(project);                                           </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (variantScopes.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 variantScopes</span></span><br><span class=\"line\">        recorder.record(                                                              </span><br><span class=\"line\">                ExecutionType.VARIANT_MANAGER_CREATE_VARIANTS,                        </span><br><span class=\"line\">                project.getPath(),                                                    </span><br><span class=\"line\">                <span class=\"keyword\">null</span> <span class=\"comment\">/*variantName*/</span>,                                                 </span><br><span class=\"line\">                <span class=\"keyword\">this</span>::populateVariantDataList);                                       </span><br><span class=\"line\">    &#125;                                                                                 </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">    <span class=\"comment\">// Create top level test tasks.                                                   </span></span><br><span class=\"line\">    recorder.record(                                                                  </span><br><span class=\"line\">            ExecutionType.VARIANT_MANAGER_CREATE_TESTS_TASKS,                         </span><br><span class=\"line\">            project.getPath(),                                                        </span><br><span class=\"line\">            <span class=\"keyword\">null</span> <span class=\"comment\">/*variantName*/</span>,                                                     </span><br><span class=\"line\">            () -&gt; taskManager.createTopLevelTestTasks(!productFlavors.isEmpty()));    </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> VariantScope variantScope : variantScopes) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为每个 variant 生成各自的 task</span></span><br><span class=\"line\">        recorder.record(                                                              </span><br><span class=\"line\">                ExecutionType.VARIANT_MANAGER_CREATE_TASKS_FOR_VARIANT,               </span><br><span class=\"line\">                project.getPath(),                                                    </span><br><span class=\"line\">                variantScope.getFullVariantName(),                                    </span><br><span class=\"line\">                () -&gt; createTasksForVariantData(variantScope));                       </span><br><span class=\"line\">    &#125;                                                                                 </span><br><span class=\"line\">                                                                                      </span><br><span class=\"line\">    taskManager.createReportTasks(variantScopes);                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用 <code>populateVariantDataList()</code> 来生成 VariantScopes，它是由 ProductFlavors、BuildType、VariantType 组合</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createTasksForVariantData</span><span class=\"params\">(<span class=\"keyword\">final</span> VariantScope variantScope)</span> </span>&#123;                                              </span><br><span class=\"line\">    <span class=\"keyword\">final</span> BaseVariantData variantData = variantScope.getVariantData();                                                </span><br><span class=\"line\">    <span class=\"keyword\">final</span> VariantType variantType = variantData.getType();                                                            </span><br><span class=\"line\">                                                                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> GradleVariantConfiguration variantConfig = variantScope.getVariantConfiguration();                          </span><br><span class=\"line\">                                                                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> BuildTypeData buildTypeData = buildTypes.get(variantConfig.getBuildType().getName());                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buildTypeData.getAssembleTask() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 BuildType 的 assemble task</span></span><br><span class=\"line\">        <span class=\"comment\">// 比如 assembleDebug 和 assembleRelease</span></span><br><span class=\"line\">        buildTypeData.setAssembleTask(taskManager.createAssembleTask(buildTypeData));                                 </span><br><span class=\"line\">    &#125;                                                                                                                 </span><br><span class=\"line\">                                                                                                                      </span><br><span class=\"line\">    <span class=\"comment\">// Add dependency of assemble task on assemble build type task.</span></span><br><span class=\"line\">    <span class=\"comment\">// assemble 依赖于 assembleDebug 和 assembleRelease</span></span><br><span class=\"line\">    taskManager                                                                                                       </span><br><span class=\"line\">            .getTaskFactory()                                                                                         </span><br><span class=\"line\">            .configure(                                                                                               </span><br><span class=\"line\">                    <span class=\"string\">\"assemble\"</span>,                                                                                       </span><br><span class=\"line\">                    task -&gt; &#123;                                                                                         </span><br><span class=\"line\">                        <span class=\"keyword\">assert</span> buildTypeData.getAssembleTask() != <span class=\"keyword\">null</span>;                                               </span><br><span class=\"line\">                        task.dependsOn(buildTypeData.getAssembleTask().getName());                                    </span><br><span class=\"line\">                    &#125;);                                                                                               </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 根据 variant 创建 assemble task</span></span><br><span class=\"line\">    createAssembleTaskForVariantData(variantData);                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (variantType.isForTesting()) &#123;                                                                                 </span><br><span class=\"line\">         <span class=\"comment\">// 省略代码                                                                       </span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据 variant 创建 task</span></span><br><span class=\"line\">        taskManager.createTasksForVariantScope(variantScope);                                                         </span><br><span class=\"line\">    &#125;                                                                                                                 </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>assemble task 用于将源文件编译为最终产物，比如 jar、aar、apk 等，在 <code>createTasksForVariantData()</code> 中会生成对应 BuildType 的 assemble task，比如 <code>assembleDebug</code> 和 <code>assembleRelease</code> ，接着设置 <code>assemble</code> 依赖于这两个 task，最后根据 variant 生成对应的 assemble task，比如 <code>assembleTestDebug</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createAssembleTaskForVariantData</span><span class=\"params\">(<span class=\"keyword\">final</span> BaseVariantData variantData)</span> </span>&#123;                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> VariantScope variantScope = variantData.getScope();                                           </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (variantData.getType().isForTesting()) &#123;                                                         </span><br><span class=\"line\">        variantScope.setAssembleTask(taskManager.createAssembleTask(variantData));                      </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                            </span><br><span class=\"line\">        BuildTypeData buildTypeData =                                                                   </span><br><span class=\"line\">                buildTypes.get(variantData.getVariantConfiguration().getBuildType().getName());         </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">        Preconditions.checkNotNull(buildTypeData.getAssembleTask());                                    </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (productFlavors.isEmpty()) &#123;                                                                 </span><br><span class=\"line\">            <span class=\"comment\">// Reuse assemble task for build type if there is no product flavor.                        </span></span><br><span class=\"line\">            variantScope.setAssembleTask(buildTypeData.getAssembleTask());                              </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">            variantData.addTask(                                                                        </span><br><span class=\"line\">                    TaskContainer.TaskKind.ASSEMBLE, buildTypeData.getAssembleTask());                  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据 variant 创建对应的 assemble task，比如 assembleTesDebug</span></span><br><span class=\"line\">            variantScope.setAssembleTask(taskManager.createAssembleTask(variantData));                  </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">            <span class=\"comment\">// setup the task dependencies                                                              </span></span><br><span class=\"line\">            <span class=\"comment\">// build type</span></span><br><span class=\"line\">            <span class=\"comment\">// build type assemble task 依赖于 具体的 assemble task</span></span><br><span class=\"line\">            buildTypeData.getAssembleTask().dependsOn(variantScope.getAssembleTask());                  </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">            <span class=\"comment\">// each flavor                                                                              </span></span><br><span class=\"line\">            GradleVariantConfiguration variantConfig = variantData.getVariantConfiguration();           </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (CoreProductFlavor flavor : variantConfig.getProductFlavors()) &#123;                        </span><br><span class=\"line\">                ProductFlavorData productFlavorData = productFlavors.get(flavor.getName());             </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">                DefaultTask flavorAssembleTask = productFlavorData.getAssembleTask();                   </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flavorAssembleTask == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 创建 flavor 的 assemble task</span></span><br><span class=\"line\">                    <span class=\"comment\">// 比如 assembleTes</span></span><br><span class=\"line\">                    flavorAssembleTask = taskManager.createAssembleTask(productFlavorData);             </span><br><span class=\"line\">                    productFlavorData.setAssembleTask(flavorAssembleTask);                              </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// flavor assemble task 依赖于具体的 assemble task</span></span><br><span class=\"line\">                flavorAssembleTask.dependsOn(variantScope.getAssembleTask());                           </span><br><span class=\"line\">            &#125;                                                                                           </span><br><span class=\"line\">                                                                                                        </span><br><span class=\"line\">            <span class=\"comment\">// assembleTask for this flavor(dimension), created on demand if needed.                    </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (variantConfig.getProductFlavors().size() &gt; <span class=\"number\">1</span>) &#123;                                         </span><br><span class=\"line\">                <span class=\"keyword\">final</span> String name = StringHelper.capitalize(variantConfig.getFlavorName());             </span><br><span class=\"line\">                <span class=\"keyword\">final</span> String variantAssembleTaskName =                                                  </span><br><span class=\"line\">                        StringHelper.appendCapitalized(<span class=\"string\">\"assemble\"</span>, name);                               </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!taskManager.getTaskFactory().containsKey(variantAssembleTaskName)) &#123;               </span><br><span class=\"line\">                    Task task = taskManager.getTaskFactory().create(variantAssembleTaskName);           </span><br><span class=\"line\">                    task.setDescription(<span class=\"string\">\"Assembles all builds for flavor combination: \"</span> + name);        </span><br><span class=\"line\">                    task.setGroup(<span class=\"string\">\"Build\"</span>);                                                             </span><br><span class=\"line\">                    task.dependsOn(variantScope.getAssembleTask().getName());                           </span><br><span class=\"line\">                &#125;                                                                                       </span><br><span class=\"line\">                taskManager                                                                             </span><br><span class=\"line\">                        .getTaskFactory()                                                               </span><br><span class=\"line\">                        .configure(                                                                     </span><br><span class=\"line\">                                <span class=\"string\">\"assemble\"</span>, task1 -&gt; task1.dependsOn(variantAssembleTaskName));         </span><br><span class=\"line\">            &#125;                                                                                           </span><br><span class=\"line\">        &#125;                                                                                               </span><br><span class=\"line\">    &#125;                                                                                                   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面会生成包括 BuildType、Flavor、BuildType + Flavor + VariantType 的 assemble task，同时 task 之间存在依赖关系：<code>assemble &gt; buildType/flavor &gt; 具体</code> </p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/assemble-task-demo.png?x-oss-process=style/doc-img\" alt=\"assemble-task-demo\"></p>\n<p>除了上面所说的 assemble task，还将生成以下 task：</p>\n<table>\n<thead>\n<tr>\n<th>task</th>\n<th>impl</th>\n<th>dependsOn</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>assemble{variant}</td>\n<td>DefaultTask</td>\n<td>compile{variant}Sources，package{variant}</td>\n</tr>\n<tr>\n<td>pre{variant}Build</td>\n<td>AppPreBuildTask</td>\n<td>preBuild，extractProguardFiles(可能)</td>\n</tr>\n<tr>\n<td>extractProguardFiles</td>\n<td>ExtractProguardFiles</td>\n<td></td>\n</tr>\n<tr>\n<td>generate{variant}Sources</td>\n<td>DefaultTask</td>\n<td>compile{variant}Renderscript，generate{variant}BuildConfig，bundle{variant}Resources，compile{variant}Aidl</td>\n</tr>\n<tr>\n<td>generate{variant}Resources</td>\n<td>DefaultTask</td>\n<td>generate{variant}ResValues，compile{variant}Renderscript</td>\n</tr>\n<tr>\n<td>generate{variant}Assets</td>\n<td>DefaultTask</td>\n<td>compile{variant}Shaders</td>\n</tr>\n<tr>\n<td>compile{variant}Sources</td>\n<td>DefaultTask</td>\n<td>compile{variant}Ndk，compile{variant}JavaWithJavac</td>\n</tr>\n<tr>\n<td>check{variant}Manifest</td>\n<td>CheckManifest</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>write{variant}ApplicationId</td>\n<td>ApplicationIdIdWriteTask</td>\n<td></td>\n</tr>\n<tr>\n<td>mainApkListPersistence{variant}</td>\n<td>MainApkListPersistence</td>\n<td></td>\n</tr>\n<tr>\n<td>reportBuildArtifacts{variant}</td>\n<td>BuildArtifactReportTask</td>\n<td></td>\n</tr>\n<tr>\n<td>create{variant}CompatibleScreenManifests</td>\n<td>CompatibleScreensManifest</td>\n<td></td>\n</tr>\n<tr>\n<td>process{variant}Manifest</td>\n<td>MergeManifests</td>\n<td>check{variant}Manifest</td>\n</tr>\n<tr>\n<td>generate{variant}ResValues</td>\n<td>GenerateResValues</td>\n<td></td>\n</tr>\n<tr>\n<td>compile{variant}Renderscript</td>\n<td>RenderscriptCompile</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>merge{variant}Resources</td>\n<td>MergeResources</td>\n<td>generate{variant}Resources</td>\n</tr>\n<tr>\n<td>merge{variant}Shaders</td>\n<td>MergeSourceSetFolders</td>\n<td></td>\n</tr>\n<tr>\n<td>compile{variant}Shaders</td>\n<td>ShaderCompile</td>\n<td>merge{variant}Shaders</td>\n</tr>\n<tr>\n<td>merge{variant}Assets</td>\n<td>MergeSourceSetFolders</td>\n<td>generate{variant}Assets</td>\n</tr>\n<tr>\n<td>generate{variant}BuildConfig</td>\n<td>GenerateBuildConfig</td>\n<td>check{variant}Manifest</td>\n</tr>\n<tr>\n<td>splitsDiscoveryTask{variant}</td>\n<td>SplitsDiscovery</td>\n<td></td>\n</tr>\n<tr>\n<td>process{variant}JavaRes</td>\n<td>Sync</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>process{variant}Resources</td>\n<td>LinkApplicationAndroidResourcesTask</td>\n<td></td>\n</tr>\n<tr>\n<td>bundle{variant}Resources</td>\n<td>LinkAndroidResForBundleTask</td>\n<td></td>\n</tr>\n<tr>\n<td>compile{variant}Aidl</td>\n<td>AidlCompile</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>compile{variant}Ndk</td>\n<td>NdkCompile</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>merge{variant}JniLibFolders</td>\n<td>MergeSourceSetFolders</td>\n<td>generate{variant}Assets</td>\n</tr>\n<tr>\n<td>javaPreCompile{variant}</td>\n<td>JavaPreCompileTask</td>\n<td>pre{variant}Build</td>\n</tr>\n<tr>\n<td>compile{variant}JavaWithJavac</td>\n<td>AndroidJavaCompile</td>\n<td>generate{variant}Sources</td>\n</tr>\n<tr>\n<td>bundleAppClasses{variant}</td>\n<td>Jar</td>\n<td></td>\n</tr>\n<tr>\n<td>transformResourcesWithMergeJavaResFor{variant}</td>\n<td>TransformTask</td>\n<td></td>\n</tr>\n<tr>\n<td>transformClassesWithMultidexlistFor{variant}</td>\n<td>TransformTask</td>\n<td></td>\n</tr>\n<tr>\n<td>transformClassesWithDexBuilderFor{variant}</td>\n<td>TransformTask</td>\n<td></td>\n</tr>\n<tr>\n<td>transformDexArchiveWithDexMergerFor{variant}</td>\n<td>TransformTask</td>\n<td>transformClassesWithMultidexlistFor{variant}</td>\n</tr>\n<tr>\n<td>preparePUBLISHED_JAVA_RES{variant}ForPublishing</td>\n<td>PipelineToPublicationTask</td>\n<td></td>\n</tr>\n<tr>\n<td>package{variant}</td>\n<td>PackageApplication</td>\n<td>merge{variant}Assets，process{variant}Resources，validateSigning{variant}，compile{variant}JavaWithJavac</td>\n</tr>\n<tr>\n<td>validateSigning{variant}</td>\n<td>ValidateSigningTask</td>\n<td></td>\n</tr>\n<tr>\n<td>install{variant}</td>\n<td>InstallVariantTask</td>\n<td>assemble{variant}</td>\n</tr>\n<tr>\n<td>uninstall{variant}</td>\n<td>UninstallTask</td>\n<td></td>\n</tr>\n<tr>\n<td>lint{variant}</td>\n<td>LintPerVariantTask</td>\n</tr>\n</tbody>\n</table>\n<p>以 <code>assembleProdRelease</code> 命令，依次执行的 task：</p>\n<blockquote>\n<p>prod 是 product flavor</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preBuild</span><br><span class=\"line\">extractProguardFiles</span><br><span class=\"line\">preProdReleaseBuild</span><br><span class=\"line\">compileProdReleaseRenderscript</span><br><span class=\"line\">checkProdReleaseManifest</span><br><span class=\"line\">generateProdReleaseBuildConfig</span><br><span class=\"line\">prepareLintJar</span><br><span class=\"line\">mainApkListPersistenceProdRelease</span><br><span class=\"line\">generateProdReleaseResValues</span><br><span class=\"line\">generateProdReleaseResources</span><br><span class=\"line\">compileProdReleaseAidl</span><br><span class=\"line\">createProdReleaseCompatibleScreenManifests</span><br><span class=\"line\">processProdReleaseManifest</span><br><span class=\"line\">mergeProdReleaseResources  // 合并资源</span><br><span class=\"line\">splitsDiscoveryTaskProdRelease</span><br><span class=\"line\">processProdReleaseResources</span><br><span class=\"line\">generateProdReleaseSources</span><br><span class=\"line\">javaPreCompileProdRelease</span><br><span class=\"line\">compileProdReleaseJavaWithJavac // javac</span><br><span class=\"line\">compileProdReleaseNdk</span><br><span class=\"line\">compileProdReleaseSources</span><br><span class=\"line\">mergeProdReleaseShaders</span><br><span class=\"line\">compileProdReleaseShaders</span><br><span class=\"line\">generateProdReleaseAssets</span><br><span class=\"line\">mergeProdReleaseAssets</span><br><span class=\"line\">transformClassesWithComponentCodeForProdRelease </span><br><span class=\"line\">processProdReleaseJavaRes</span><br><span class=\"line\">transformResourcesWithMergeJavaResForProdRelease</span><br><span class=\"line\">transformClassesAndResourcesWithProguardForProdRelease // 混淆</span><br><span class=\"line\">transformClassesWithMultidexlistForProdRelease</span><br><span class=\"line\">transformClassesWithDexForProdRelease\t\t\t\t// dex</span><br><span class=\"line\">transformClassesWithShrinkResForProdRelease</span><br><span class=\"line\">mergeProdReleaseJniLibFolders</span><br><span class=\"line\">transformNativeLibsWithMergeJniLibsForProdRelease</span><br><span class=\"line\">validateSigningProdRelease</span><br><span class=\"line\">packageProdRelease</span><br></pre></td></tr></table></figure>\n<p>接下来分析下比较重要的几个 task</p>\n<blockquote>\n<p>接下来的分析，因为对应的源码比较复杂，所以只会简短介绍结果，没有详细过程，推荐 debug 整个流程</p>\n</blockquote>\n<h3 id=\"CompileJavaWithJavac\"><a href=\"#CompileJavaWithJavac\" class=\"headerlink\" title=\"CompileJavaWithJavac\"></a>CompileJavaWithJavac</h3><p>首先找到执行的 AndroidJavaCompile</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AndroidJavaCompile.java</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                       </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">compile</span><span class=\"params\">(IncrementalTaskInputs inputs)</span> </span>&#123;                                          </span><br><span class=\"line\">    <span class=\"comment\">// compileSdkVersion &gt;= 24，需要使用 jdk1.8                                                     </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isPostN()) &#123;                                                                            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!JavaVersion.current().isJava8Compatible()) &#123;                                       </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"compileSdkVersion '\"</span> + compileSdkVersion + <span class=\"string\">\"' requires \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\"JDK 1.8 or later to compile.\"</span>);                                          </span><br><span class=\"line\">        &#125;                                                                                       </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 处理注解处理器，在之前 task 会将使用 annotationProcessor 标示的注解处理器写入到 annotationProcessors.json 中</span></span><br><span class=\"line\">    processAnalytics();                                                                         </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    <span class=\"comment\">// Create directory for output of annotation processor.                                     </span></span><br><span class=\"line\">    FileUtils.mkdirs(annotationProcessorOutputFolder);                                          </span><br><span class=\"line\">                                                                                                </span><br><span class=\"line\">    mInstantRunBuildContext.startRecording(InstantRunBuildContext.TaskType.JAVAC);</span><br><span class=\"line\">    <span class=\"comment\">// 调用 JavaCompile.compile</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.compile(inputs);                                                                      </span><br><span class=\"line\">    mInstantRunBuildContext.stopRecording(InstantRunBuildContext.TaskType.JAVAC);               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JavaCompile.java</span></span><br><span class=\"line\"><span class=\"meta\">@TaskAction</span>                                                                                                                                                                                                                                                                                                           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">compile</span><span class=\"params\">(IncrementalTaskInputs inputs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是否为增量编译</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.compileOptions.isIncremental()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.compile();                                                                                                                                                                                                                                                                                               </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                                                                                                                                                                                                                                                          </span><br><span class=\"line\">        DefaultJavaCompileSpec spec = <span class=\"keyword\">this</span>.createSpec();                                                                                                                                                                                                                                                              </span><br><span class=\"line\">        CompileCaches compileCaches = <span class=\"keyword\">this</span>.createCompileCaches();                                                                                                                                                                                                                                                     </span><br><span class=\"line\">        IncrementalCompilerFactory factory = <span class=\"keyword\">new</span> IncrementalCompilerFactory(<span class=\"keyword\">this</span>.getFileOperations(), <span class=\"keyword\">this</span>.getStreamHasher(), <span class=\"keyword\">this</span>.getCachingFileHasher(), <span class=\"keyword\">this</span>.getPath(), <span class=\"keyword\">this</span>.createCompiler(spec), <span class=\"keyword\">this</span>.source, compileCaches, (IncrementalTaskInputsInternal)inputs, <span class=\"keyword\">this</span>.getEffectiveAnnotationProcessorPath()); </span><br><span class=\"line\">        Compiler&lt;JavaCompileSpec&gt; compiler = factory.createCompiler();                                                                                                                                                                                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.performCompilation(spec, compiler);                                                                                                                                                                                                                                                                      </span><br><span class=\"line\">    &#125;                                                                                                                                                                                                                                                                                                                 </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不管是增量编译还是全量编译，最后都会调用 <code>performCompilation</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performCompilation</span><span class=\"params\">(JavaCompileSpec spec, Compiler&lt;JavaCompileSpec&gt; compiler)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 执行编译</span></span><br><span class=\"line\">    WorkResult result = compiler.execute(spec);                                             </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setDidWork(result.getDidWork());                                                   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Compiler 采用<strong>装饰者设计模式</strong>，最外层是 <code>CleaningJavaCompilerSupport</code> 会先删除编译目录，再调用 <code>JdkJavaCompiler</code> 执行 <code>javac</code> 过程，具体为，创建一个 <code>JavacTaskImpl</code> 然后 JavacTask 会调用 <code>com.sun.tools.javac.main.Main</code> 进行处理，其中创建 JavacTask 的任务是由 <code>JavacTool</code> 完成</p>\n"},{"title":"Gradle多项目实践","date":"2018-05-08T10:58:17.000Z","_content":"\n## 前言\n\n上篇文章中，我们说到了 [Gradle多项目构建](https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/) 的一些知识点，但这些总归只是纸上谈兵，今天我们在实际项目中通过之前学到的知识去改造下项目的 Gradle 构建脚本，充分利用 Gradle 带来的好处。\n\n虽然使用 Gradle 作为构建工具已经有一段时间了，但很多同学对它还是很陌生的，基本都是沿用 Android Studio 默认生成的配置，用的比较多的可能也只是 `dependencies` 配置，从不同的 `repositories` 去下载依赖，可能在需要实现一些自定义配置的时候，就去 google 后照搬代码，对其配置参数也是似懂非懂，出了问题不知道如何下手解决，所以这篇文章的主要目的是，实践 Gradle 在 Android 上的运用，对 Gradle 的使用有基本认识。\n\n[项目源码](https://github.com/LinXiaoTao/GradleCaseProject)\n\n## 改造开始\n\n### Gradle 知识\n\n我们先看下 Android Studio 默认帮我们生成的配置代码：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    // android 构建配置\n}\n\ndependencies {\n \t// 依赖配置\n}\n\n```\n\n先简单讲下上面各部分的配置含义，首先我们知道如果不先 `apply plugin: 'com.android.application'` 就不会有 `android` 配置选项，那么这个配置选项具体是什么内容呢？我们可以通过源码了解下，`com.android.application` 这个插件就是我们在根目录下的 *build.gradle* 中导入的：\n\n``` groovy\nbuildscript {\n    repositories {\n        // 构建脚本依赖源地址\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.1.2'\n    }\n}\n```\n\n对 Gradle Plugin 有点了解的同学都知道，Gradle Plugin 需要定义到 *META-INF* 中，浏览 *gradle-3.1.2.jar*，*META-INF* 目录如下：\n\n```\n├── MANIFEST.MF\n├── gradle-plugins\n│   ├── android-library.properties\n│   ├── android-reporting.properties\n│   ├── android.properties\n│   ├── com.android.application.properties\n│   ├── com.android.atom.properties\n│   ├── com.android.bundle.properties\n│   ├── com.android.debug.structure.properties\n│   ├── com.android.feature.properties\n│   ├── com.android.instantapp.properties\n│   ├── com.android.library.properties\n│   ├── com.android.lint.properties\n│   └── com.android.test.properties\n```\n\n这里对应的是提供的各个插件的配置，比如 *com.android.application.properties* 就表示 `com.android.application` 插件，其他也是一样，properties 的名称表示插件的名称。*com.android.application.properties* 的内容如下：\n\n```\nimplementation-class=com.android.build.gradle.AppPlugin\n```\n\n`com.android.build.gradle.AppPlugin` 这个类就是 Application Plugin 的源码。阅读 AppPlugin 源码，我们可以看到这一段：\n\n``` groovy\n\t@NonNull\n    @Override\n    protected BaseExtension createExtension(\n            @NonNull Project project,\n            @NonNull ProjectOptions projectOptions,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull SdkHandler sdkHandler,\n            @NonNull NamedDomainObjectContainer<BuildType> buildTypeContainer,\n            @NonNull NamedDomainObjectContainer<ProductFlavor> productFlavorContainer,\n            @NonNull NamedDomainObjectContainer<SigningConfig> signingConfigContainer,\n            @NonNull NamedDomainObjectContainer<BaseVariantOutput> buildOutputs,\n            @NonNull SourceSetManager sourceSetManager,\n            @NonNull ExtraModelInfo extraModelInfo) {\n        return project.getExtensions()\n                .create(\n                        \"android\",\n                        AppExtension.class,\n                        project,\n                        projectOptions,\n                        androidBuilder,\n                        sdkHandler,\n                        buildTypeContainer,\n                        productFlavorContainer,\n                        signingConfigContainer,\n                        buildOutputs,\n                        sourceSetManager,\n                        extraModelInfo);\n    }\n```\n\n首先我们先通过 API 文档了解下 [project.extensions](https://docs.gradle.org/current/dsl/org.gradle.api.Project.html) 的定义：\n\n```\n定义：\n\tExtensionContainer extensions (read-only)\n说明：\n\tAllows adding DSL extensions to the project. Useful for plugin authors.\n\t允许向项目添加 DSL 扩展，对插件作者很有用\n```\n\n接着我们看下 [`ExtensionContainer.create`](https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/ExtensionContainer.html#create-java.lang.String-java.lang.Class-java.lang.Object...-) 方法的定义：\n\n```\n定义：\n\t<T> T create(String name,Class<T> type,Object... constructionArguments)\n说明：\n\tCreates and adds a new extension to this container. A new instance of the given type will be created using the given constructionArguments. The extension will be exposed as type unless the extension itself declares a preferred public type via the HasPublicType protocol. The new instance will have been dynamically made ExtensionAware, which means that you can cast it to ExtensionAware.\n\t向项目创建并且添加一个新的扩展。通过给定的 type 创建一个新的实例，使用给定的 constructionArguments 构造函数参数。可以通过 HasPublicType 接口声明对外开放的类型，否则整个扩展将对外开放。新的实例将动态生成为 \nExtensionAware，这意味着你可以将它转换成 ExtensionAware\n```\n\n现在我们可以知道，为什么在引入 `com.android.application` 之后才能使用 `android` 配置块，这也意味着，`android` 所能提供的配置依赖于 `AppExtension` 这个类。\n\n这里我们简单就 `defaultConfig` 这个做下分析，先看下这个类在 `AppExtension` 中的配置，因为 `AppExtension` 直接调用超类 `TestedExtension` 的构造方法，而 `TestedExtension` 又会调用超类 `BaseExtension` 所以我们直接看到 `BaseExtension`：\n\n``` java\nprivate final DefaultConfig defaultConfig;\n\ndefaultConfig = objectFactory.newInstance(\n                        DefaultConfig.class,\n                        BuilderConstants.MAIN,\n                        project,\n                        objectFactory,\n                        extraModelInfo.getDeprecationReporter(),\n                        project.getLogger());\n```\n\n这里我们先不关心 `objectFactory.newInstance` 只需要知道，当我们在 `android` 配置块中，配置 `defaultConfig` 实质上也是，对 `DefaultConfig` 的配置，而 `DefaultConfig` 又继承于 `DefaultProductFlavor`，相关的配置同时也是 `DefaultProductFlavor` 的成员属性：\n\n> DefaultProductFlavor 位于 `builder-3.1.2.jar`\n>\n> Android Gradle Plugin 相关代码分别位于 `gradle-3.1.2.jar`、`gradle-api-3.1.2.jar`、`gradle-core-3.1.2.jar`\n>\n> 如果想查看源码，则下载 sources 包，比如 [builder-3.1.2-sources.jar](https://dl.google.com/dl/android/maven2/com/android/tools/build/builder/3.1.2/builder-3.1.2-sources.jar)，其他 jar 下载方法类似\n>\n> 心好累，各种继承。。。\n\n``` java\npublic class DefaultProductFlavor extends BaseConfigImpl implements ProductFlavor {\n    private static final long serialVersionUID = 1L;\n\n    @NonNull\n    private final String mName;\n    @Nullable\n    private String mDimension;\n    @Nullable\n    private ApiVersion mMinSdkVersion;\n    @Nullable\n    private ApiVersion mTargetSdkVersion;\n    @Nullable\n    private Integer mMaxSdkVersion;\n    @Nullable\n    private Integer mRenderscriptTargetApi;\n    @Nullable\n    private Boolean mRenderscriptSupportModeEnabled;\n    @Nullable\n    private Boolean mRenderscriptSupportModeBlasEnabled;\n    @Nullable\n    private Boolean mRenderscriptNdkModeEnabled;\n    @Nullable\n    private Integer mVersionCode;\n    @Nullable\n    private String mVersionName;\n    @Nullable\n    private String mApplicationId;\n    @Nullable\n    private String mTestApplicationId;\n    @Nullable\n    private String mTestInstrumentationRunner;\n    @NonNull\n    private Map<String, String> mTestInstrumentationRunnerArguments = Maps.newHashMap();\n    @Nullable\n    private Boolean mTestHandleProfiling;\n    @Nullable\n    private Boolean mTestFunctionalTest;\n    @Nullable\n    private SigningConfig mSigningConfig;\n    @Nullable\n    private Set<String> mResourceConfiguration;\n    @NonNull\n    private DefaultVectorDrawablesOptions mVectorDrawablesOptions;\n    @Nullable\n    private Boolean mWearAppUnbundled;\n}\n```\n\n### 重复配置处理\n\n当我们项目不止只有一个 app module 时，那么在其他 module 中，例如下面这些配置都需要去配置下：\n\n``` groovy\ndefaultConfig {\n        minSdkVersion 21\n        targetSdkVersion 27\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\n    }\n```\n\n这样就显得很繁琐又不灵活，比如现在很多项目都开始进行组件化，有的 module 有时候是 `com.android.application`，有的时候又是  `com.android.library` 这样又得根据条件写两套配置，如果其中一个更改了，还得去挨个 module 中更改。\n\n而利用 Gradle 多项目构建，我们可以将这些重复配置都统一处理，还可以根据属性自动导入不同的 plugin。首先为了统一管理各种版本号，我们先新建一个 *constants.gradle* 将一些常量写入到 ext 中：\n\n``` groovy\nproject.ext {\n    compileSdkVersion = 27\n    \n    minSdkVersion = 21\n    \n    targetSdkVersion = 27\n    \n    versionCode = 1\n    \n    versionName = \"1.0\"\n}\n```\n\n>  ext 实际上是 [ExtraPropertiesExtension](https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html) 类型，它类似 map，可以存储 key/value 键值对。ext 也是扩展的一种，可以通过 `project.extensions.getByName('ext')` 获取实例，所有的 [`ExtensionAware`](https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtensionAware.html) 都拥有一个 `ext`，而 Project 又是继承于  `ExtensionAware`\n\n接着我们在各个 module 中创建一个 `gradle.properties` ，这个文件默认会被读取，在其中定义一个属性 `isApplication`，根据这个属性导入不同的 plugin：\n\n``` groovy\n// library module\nisApplication=false\n\n// application module\nisApplication=true\n```\n\n接着创建 *init.gradle*，在 `subprojects` 中配置，这里的配置对所有的子项目都会生效：\n\n``` groovy\nsubprojects {\n    if (project.isApplication.toBoolean()) {\n        // 当前 module 导入 application plugin\n        project.plugins.apply(\"com.android.application\")\n    } else {\n        project.plugins.apply(\"com.android.library\")\n    }\n}\n```\n\n> 这里有点地方需要注意下，因为属性的获取都是通过 String 类型，所以我们需要明确使用 `toBoolean()` 去转化成布尔值\n\n最后要想使得这些 gradle 文件生效，需要将它们 apply 进去，因为 Gradle 默认只会识别 `build.gradle`，还记得我们在 [Gradle多项目构建](https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/) 中说到，*Gradle 是边读取边执行的* ，这意味着你需要在使用到 `android` 构建块之前，将 plugin apply 进去，所以我们将这些 gradle 文件在根目录的 *build.gradle* 中 apply，因为默认根目录的优先级最高：\n\n``` groovy\n// constants.gradle 需要在 init.gradle，因为 init.gradle 后面会使用到 constants.gradle 中定义的值，理由如上\napply from: 'gradle/constants.gradle'\napply from: 'gradle/init.gradle'\n```\n\n我们将 module 下 *build.gradle* 中的 apply 代码删除，重新同步下，可以发现 `android` 配置块依然生效，这意味着，我们 apply plugin 操作成功了。\n\n在处理完 plugin 之后，我们可以将 `android` 配置块中的重复配置也在 *init.gradle* 中去配置：\n\n``` groovy\nsubprojects {\n    if (project.isApplication.toBoolean()) {\n        // 当前 module 导入 application plugin\n        project.plugins.apply(\"com.android.application\")\n    } else {\n        project.plugins.apply(\"com.android.library\")\n    }\n    android {\n        compileSdkVersion rootProject.ext['compileSdkVersion']\n        defaultConfig {\n            minSdkVersion rootProject.ext['minSdkVersion']\n            targetSdkVersion rootProject.ext['targetSdkVersion']\n            versionCode rootProject.ext['versionCode']\n            versionName rootProject.ext['versionName']\n            testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n        }\n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            }\n        }\n    }\n\n}\n```\n\n是不是非常方便，这样统一的配置你只需要写一次，不只是 `android` 配置块可以这么处理，其他的配置也可以这么处理。\n\n### 依赖管理\n\n一般情况下，我们会在各个 module 下去编写所需的依赖配置，比如通过 `implementation 'com.android.support:appcompat-v7:27.1.1'` 去从 maven 中心仓库或者 jcenter 中下载依赖，但这样有个不好的地方就是依赖配置太分散了，只能到每个 module 目录中的 *build.gradle* 去管理，如果我们将这个写到统一的 Gradle 构建脚本中，是不是会更好点，我们同样创建个 *dependencies.gradle*，将共同的依赖写到 `subprojects` ，特有的依赖写到单独的项目配置中，同样这个文件需要在根目录的 *build.gradle* 中 apply：\n\n``` groovy\nsubprojects {\n    dependencies {\n        testImplementation rootProject.ext.dependencies['junit']\n        androidTestImplementation rootProject.ext.dependencies['runner']\n        androidTestImplementation rootProject.ext.dependencies['espresso-core']\n    }\n}\n\nproject(':mylibrary') {\n    dependencies {\n        api fileTree(dir: 'libs', include: ['*.jar'])\n        api rootProject.ext.dependencies['appcompat-v7']\n        api rootProject.ext.dependencies['constraint-layout']\n    }\n}\n\nproject(':app') {\n    dependencies {\n        implementation fileTree(dir: 'libs', include: ['*.jar'])\n        implementation project(\":mylibrary\")\n    }\n}\n```\n\n我们可以将共同的依赖写到 `subprojects` 块，单独项目的配置写到各自的配置块下。\n\n现在我们再来解决另外一个常见的问题：依赖冲突，比如不同的依赖项各自又依赖于同一个库的不同版本，默认 [Gradle 会用这个重复库的最高版本](https://docs.gradle.org/current/userguide/troubleshooting_dependency_resolution.html#sub:version_conflicts)，但如果你配置了 `resolutionStrategy.failOnVersionConflict()` 即当出现版本冲突则失败，或者版本选择不合适，等等，就会出现依赖冲突问题。\n\n我们通过个例子来证实默认的处理策略，我们在 app 模块中去依赖  `com.android.support:design:27.1.1` 和 `com.android.support:recyclerview-v7:26.1.0` ，而 `design` 会自动去依赖 `com.android.support:recyclerview-v7:27.1.1`，依赖关系我们可以通过 `./gradlew :app:dependencies` 这个 Task 去查看，这里我们只查看 *releaseCompileClasspath* 依赖配置中 `design` 和 `recyclerview` 的情况：\n\n```\n+--- project :mylibrary\n|    \\--- com.android.support:design:27.1.1\n|         +--- com.android.support:support-v4:27.1.1\n|         |    +--- com.android.support:support-compat:27.1.1 (*)\n|         |    +--- com.android.support:support-media-compat:27.1.1\n|         |    |    +--- com.android.support:support-annotations:27.1.1\n|         |    |    \\--- com.android.support:support-compat:27.1.1 (*)\n|         |    +--- com.android.support:support-core-utils:27.1.1 (*)\n|         |    +--- com.android.support:support-core-ui:27.1.1 (*)\n|         |    \\--- com.android.support:support-fragment:27.1.1 (*)\n|         +--- com.android.support:appcompat-v7:27.1.1 (*)\n|         +--- com.android.support:recyclerview-v7:27.1.1\n|         |    +--- com.android.support:support-annotations:27.1.1\n|         |    +--- com.android.support:support-compat:27.1.1 (*)\n|         |    \\--- com.android.support:support-core-ui:27.1.1 (*)\n|         \\--- com.android.support:transition:27.1.1\n|              +--- com.android.support:support-annotations:27.1.1\n|              \\--- com.android.support:support-compat:27.1.1 (*)\n\\--- com.android.support:recyclerview-v7:26.1.0 -> 27.1.1 (*)\n```\n\n可以看到我们依赖的 26.1.0 已经被替换成 27.1.1，如果这是我们想要的结果，那就很理想，但是如果我们想要去定义依赖冲突的策略呢？同样的，Gradle 也提供了相应的 API。\n\n还是上面的例子，如果我们不想要使用 `design` 中的 `recyclerview` 而想要我们单独依赖的 `recyclerview-v7:26.1.1` 这里我们有几种方式解决：\n\n1. 不传递依赖\n\n   ``` groovy\n   api(rootProject.ext.dependencies['design']) {\n               transitive = false\n   }\n   ```\n\n2. 强制使用当前版本\n\n   ``` groovy\n   implementation(rootProject.ext.dependencies['recyclerview']) {\n               force = true\n   }\n   ```\n\n其他的解决方案可以参考[官方文档](https://docs.gradle.org/current/userguide/introduction_dependency_management.html)\n\n这里我们使用 Gradle 提供的 [resolutionStrategy](https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html) 方案： \n\n``` groovy\nsubprojects {\n    configurations.all {\n        resolutionStrategy {\n            force rootProject.ext.dependencies['recyclerview']\n        }\n    }\n}\n```\n\n`configurations` 表示当前项目的依赖配置容器，`configurations.all` 表示当前项目的所有依赖配置，上面的配置表示，遍历当前项目的所有依赖配置，设置其依赖解决策略为 **强制使用指定的版本**\n\n## 改造结束\n\n现在我们再来对比下，默认生成的构建配置和改造后的构建配置：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 27\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n        minSdkVersion 21\n        targetSdkVersion 27\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.android.support:appcompat-v7:27.1.1'\n    implementation 'com.android.support.constraint:constraint-layout:1.1.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n}\n\n```\n\n``` groovy\nandroid {\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n    }\n}\n```\n\n是不是简洁了不少，重复的配置项我们交给统一的配置文件去做，依赖配置也是如此，包括依赖冲突的解决策略，但是 Gradle 能实现的不仅仅如此，还有强大的自定义 Gradle Plugin 我们还没讲到。\n\n## 总结\n\n通过这篇文章，不仅仅是教会大家如何去编写简单的 Gradle 构建脚本，更重要的想让大家对 Gradle 有个初步的认识，知道 Gradle 的配置块是如何生成的，更多知识可以通过[官方文档](https://docs.gradle.org/current/userguide/userguide.html)去获取。","source":"_posts/Gradle多项目实践.md","raw":"---\ntitle: Gradle多项目实践\ndate: 2018-05-08 18:58:17\ncategories: Gradle\ntags:\n---\n\n## 前言\n\n上篇文章中，我们说到了 [Gradle多项目构建](https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/) 的一些知识点，但这些总归只是纸上谈兵，今天我们在实际项目中通过之前学到的知识去改造下项目的 Gradle 构建脚本，充分利用 Gradle 带来的好处。\n\n虽然使用 Gradle 作为构建工具已经有一段时间了，但很多同学对它还是很陌生的，基本都是沿用 Android Studio 默认生成的配置，用的比较多的可能也只是 `dependencies` 配置，从不同的 `repositories` 去下载依赖，可能在需要实现一些自定义配置的时候，就去 google 后照搬代码，对其配置参数也是似懂非懂，出了问题不知道如何下手解决，所以这篇文章的主要目的是，实践 Gradle 在 Android 上的运用，对 Gradle 的使用有基本认识。\n\n[项目源码](https://github.com/LinXiaoTao/GradleCaseProject)\n\n## 改造开始\n\n### Gradle 知识\n\n我们先看下 Android Studio 默认帮我们生成的配置代码：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    // android 构建配置\n}\n\ndependencies {\n \t// 依赖配置\n}\n\n```\n\n先简单讲下上面各部分的配置含义，首先我们知道如果不先 `apply plugin: 'com.android.application'` 就不会有 `android` 配置选项，那么这个配置选项具体是什么内容呢？我们可以通过源码了解下，`com.android.application` 这个插件就是我们在根目录下的 *build.gradle* 中导入的：\n\n``` groovy\nbuildscript {\n    repositories {\n        // 构建脚本依赖源地址\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.1.2'\n    }\n}\n```\n\n对 Gradle Plugin 有点了解的同学都知道，Gradle Plugin 需要定义到 *META-INF* 中，浏览 *gradle-3.1.2.jar*，*META-INF* 目录如下：\n\n```\n├── MANIFEST.MF\n├── gradle-plugins\n│   ├── android-library.properties\n│   ├── android-reporting.properties\n│   ├── android.properties\n│   ├── com.android.application.properties\n│   ├── com.android.atom.properties\n│   ├── com.android.bundle.properties\n│   ├── com.android.debug.structure.properties\n│   ├── com.android.feature.properties\n│   ├── com.android.instantapp.properties\n│   ├── com.android.library.properties\n│   ├── com.android.lint.properties\n│   └── com.android.test.properties\n```\n\n这里对应的是提供的各个插件的配置，比如 *com.android.application.properties* 就表示 `com.android.application` 插件，其他也是一样，properties 的名称表示插件的名称。*com.android.application.properties* 的内容如下：\n\n```\nimplementation-class=com.android.build.gradle.AppPlugin\n```\n\n`com.android.build.gradle.AppPlugin` 这个类就是 Application Plugin 的源码。阅读 AppPlugin 源码，我们可以看到这一段：\n\n``` groovy\n\t@NonNull\n    @Override\n    protected BaseExtension createExtension(\n            @NonNull Project project,\n            @NonNull ProjectOptions projectOptions,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull SdkHandler sdkHandler,\n            @NonNull NamedDomainObjectContainer<BuildType> buildTypeContainer,\n            @NonNull NamedDomainObjectContainer<ProductFlavor> productFlavorContainer,\n            @NonNull NamedDomainObjectContainer<SigningConfig> signingConfigContainer,\n            @NonNull NamedDomainObjectContainer<BaseVariantOutput> buildOutputs,\n            @NonNull SourceSetManager sourceSetManager,\n            @NonNull ExtraModelInfo extraModelInfo) {\n        return project.getExtensions()\n                .create(\n                        \"android\",\n                        AppExtension.class,\n                        project,\n                        projectOptions,\n                        androidBuilder,\n                        sdkHandler,\n                        buildTypeContainer,\n                        productFlavorContainer,\n                        signingConfigContainer,\n                        buildOutputs,\n                        sourceSetManager,\n                        extraModelInfo);\n    }\n```\n\n首先我们先通过 API 文档了解下 [project.extensions](https://docs.gradle.org/current/dsl/org.gradle.api.Project.html) 的定义：\n\n```\n定义：\n\tExtensionContainer extensions (read-only)\n说明：\n\tAllows adding DSL extensions to the project. Useful for plugin authors.\n\t允许向项目添加 DSL 扩展，对插件作者很有用\n```\n\n接着我们看下 [`ExtensionContainer.create`](https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/ExtensionContainer.html#create-java.lang.String-java.lang.Class-java.lang.Object...-) 方法的定义：\n\n```\n定义：\n\t<T> T create(String name,Class<T> type,Object... constructionArguments)\n说明：\n\tCreates and adds a new extension to this container. A new instance of the given type will be created using the given constructionArguments. The extension will be exposed as type unless the extension itself declares a preferred public type via the HasPublicType protocol. The new instance will have been dynamically made ExtensionAware, which means that you can cast it to ExtensionAware.\n\t向项目创建并且添加一个新的扩展。通过给定的 type 创建一个新的实例，使用给定的 constructionArguments 构造函数参数。可以通过 HasPublicType 接口声明对外开放的类型，否则整个扩展将对外开放。新的实例将动态生成为 \nExtensionAware，这意味着你可以将它转换成 ExtensionAware\n```\n\n现在我们可以知道，为什么在引入 `com.android.application` 之后才能使用 `android` 配置块，这也意味着，`android` 所能提供的配置依赖于 `AppExtension` 这个类。\n\n这里我们简单就 `defaultConfig` 这个做下分析，先看下这个类在 `AppExtension` 中的配置，因为 `AppExtension` 直接调用超类 `TestedExtension` 的构造方法，而 `TestedExtension` 又会调用超类 `BaseExtension` 所以我们直接看到 `BaseExtension`：\n\n``` java\nprivate final DefaultConfig defaultConfig;\n\ndefaultConfig = objectFactory.newInstance(\n                        DefaultConfig.class,\n                        BuilderConstants.MAIN,\n                        project,\n                        objectFactory,\n                        extraModelInfo.getDeprecationReporter(),\n                        project.getLogger());\n```\n\n这里我们先不关心 `objectFactory.newInstance` 只需要知道，当我们在 `android` 配置块中，配置 `defaultConfig` 实质上也是，对 `DefaultConfig` 的配置，而 `DefaultConfig` 又继承于 `DefaultProductFlavor`，相关的配置同时也是 `DefaultProductFlavor` 的成员属性：\n\n> DefaultProductFlavor 位于 `builder-3.1.2.jar`\n>\n> Android Gradle Plugin 相关代码分别位于 `gradle-3.1.2.jar`、`gradle-api-3.1.2.jar`、`gradle-core-3.1.2.jar`\n>\n> 如果想查看源码，则下载 sources 包，比如 [builder-3.1.2-sources.jar](https://dl.google.com/dl/android/maven2/com/android/tools/build/builder/3.1.2/builder-3.1.2-sources.jar)，其他 jar 下载方法类似\n>\n> 心好累，各种继承。。。\n\n``` java\npublic class DefaultProductFlavor extends BaseConfigImpl implements ProductFlavor {\n    private static final long serialVersionUID = 1L;\n\n    @NonNull\n    private final String mName;\n    @Nullable\n    private String mDimension;\n    @Nullable\n    private ApiVersion mMinSdkVersion;\n    @Nullable\n    private ApiVersion mTargetSdkVersion;\n    @Nullable\n    private Integer mMaxSdkVersion;\n    @Nullable\n    private Integer mRenderscriptTargetApi;\n    @Nullable\n    private Boolean mRenderscriptSupportModeEnabled;\n    @Nullable\n    private Boolean mRenderscriptSupportModeBlasEnabled;\n    @Nullable\n    private Boolean mRenderscriptNdkModeEnabled;\n    @Nullable\n    private Integer mVersionCode;\n    @Nullable\n    private String mVersionName;\n    @Nullable\n    private String mApplicationId;\n    @Nullable\n    private String mTestApplicationId;\n    @Nullable\n    private String mTestInstrumentationRunner;\n    @NonNull\n    private Map<String, String> mTestInstrumentationRunnerArguments = Maps.newHashMap();\n    @Nullable\n    private Boolean mTestHandleProfiling;\n    @Nullable\n    private Boolean mTestFunctionalTest;\n    @Nullable\n    private SigningConfig mSigningConfig;\n    @Nullable\n    private Set<String> mResourceConfiguration;\n    @NonNull\n    private DefaultVectorDrawablesOptions mVectorDrawablesOptions;\n    @Nullable\n    private Boolean mWearAppUnbundled;\n}\n```\n\n### 重复配置处理\n\n当我们项目不止只有一个 app module 时，那么在其他 module 中，例如下面这些配置都需要去配置下：\n\n``` groovy\ndefaultConfig {\n        minSdkVersion 21\n        targetSdkVersion 27\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\n    }\n```\n\n这样就显得很繁琐又不灵活，比如现在很多项目都开始进行组件化，有的 module 有时候是 `com.android.application`，有的时候又是  `com.android.library` 这样又得根据条件写两套配置，如果其中一个更改了，还得去挨个 module 中更改。\n\n而利用 Gradle 多项目构建，我们可以将这些重复配置都统一处理，还可以根据属性自动导入不同的 plugin。首先为了统一管理各种版本号，我们先新建一个 *constants.gradle* 将一些常量写入到 ext 中：\n\n``` groovy\nproject.ext {\n    compileSdkVersion = 27\n    \n    minSdkVersion = 21\n    \n    targetSdkVersion = 27\n    \n    versionCode = 1\n    \n    versionName = \"1.0\"\n}\n```\n\n>  ext 实际上是 [ExtraPropertiesExtension](https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html) 类型，它类似 map，可以存储 key/value 键值对。ext 也是扩展的一种，可以通过 `project.extensions.getByName('ext')` 获取实例，所有的 [`ExtensionAware`](https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtensionAware.html) 都拥有一个 `ext`，而 Project 又是继承于  `ExtensionAware`\n\n接着我们在各个 module 中创建一个 `gradle.properties` ，这个文件默认会被读取，在其中定义一个属性 `isApplication`，根据这个属性导入不同的 plugin：\n\n``` groovy\n// library module\nisApplication=false\n\n// application module\nisApplication=true\n```\n\n接着创建 *init.gradle*，在 `subprojects` 中配置，这里的配置对所有的子项目都会生效：\n\n``` groovy\nsubprojects {\n    if (project.isApplication.toBoolean()) {\n        // 当前 module 导入 application plugin\n        project.plugins.apply(\"com.android.application\")\n    } else {\n        project.plugins.apply(\"com.android.library\")\n    }\n}\n```\n\n> 这里有点地方需要注意下，因为属性的获取都是通过 String 类型，所以我们需要明确使用 `toBoolean()` 去转化成布尔值\n\n最后要想使得这些 gradle 文件生效，需要将它们 apply 进去，因为 Gradle 默认只会识别 `build.gradle`，还记得我们在 [Gradle多项目构建](https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/) 中说到，*Gradle 是边读取边执行的* ，这意味着你需要在使用到 `android` 构建块之前，将 plugin apply 进去，所以我们将这些 gradle 文件在根目录的 *build.gradle* 中 apply，因为默认根目录的优先级最高：\n\n``` groovy\n// constants.gradle 需要在 init.gradle，因为 init.gradle 后面会使用到 constants.gradle 中定义的值，理由如上\napply from: 'gradle/constants.gradle'\napply from: 'gradle/init.gradle'\n```\n\n我们将 module 下 *build.gradle* 中的 apply 代码删除，重新同步下，可以发现 `android` 配置块依然生效，这意味着，我们 apply plugin 操作成功了。\n\n在处理完 plugin 之后，我们可以将 `android` 配置块中的重复配置也在 *init.gradle* 中去配置：\n\n``` groovy\nsubprojects {\n    if (project.isApplication.toBoolean()) {\n        // 当前 module 导入 application plugin\n        project.plugins.apply(\"com.android.application\")\n    } else {\n        project.plugins.apply(\"com.android.library\")\n    }\n    android {\n        compileSdkVersion rootProject.ext['compileSdkVersion']\n        defaultConfig {\n            minSdkVersion rootProject.ext['minSdkVersion']\n            targetSdkVersion rootProject.ext['targetSdkVersion']\n            versionCode rootProject.ext['versionCode']\n            versionName rootProject.ext['versionName']\n            testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n        }\n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            }\n        }\n    }\n\n}\n```\n\n是不是非常方便，这样统一的配置你只需要写一次，不只是 `android` 配置块可以这么处理，其他的配置也可以这么处理。\n\n### 依赖管理\n\n一般情况下，我们会在各个 module 下去编写所需的依赖配置，比如通过 `implementation 'com.android.support:appcompat-v7:27.1.1'` 去从 maven 中心仓库或者 jcenter 中下载依赖，但这样有个不好的地方就是依赖配置太分散了，只能到每个 module 目录中的 *build.gradle* 去管理，如果我们将这个写到统一的 Gradle 构建脚本中，是不是会更好点，我们同样创建个 *dependencies.gradle*，将共同的依赖写到 `subprojects` ，特有的依赖写到单独的项目配置中，同样这个文件需要在根目录的 *build.gradle* 中 apply：\n\n``` groovy\nsubprojects {\n    dependencies {\n        testImplementation rootProject.ext.dependencies['junit']\n        androidTestImplementation rootProject.ext.dependencies['runner']\n        androidTestImplementation rootProject.ext.dependencies['espresso-core']\n    }\n}\n\nproject(':mylibrary') {\n    dependencies {\n        api fileTree(dir: 'libs', include: ['*.jar'])\n        api rootProject.ext.dependencies['appcompat-v7']\n        api rootProject.ext.dependencies['constraint-layout']\n    }\n}\n\nproject(':app') {\n    dependencies {\n        implementation fileTree(dir: 'libs', include: ['*.jar'])\n        implementation project(\":mylibrary\")\n    }\n}\n```\n\n我们可以将共同的依赖写到 `subprojects` 块，单独项目的配置写到各自的配置块下。\n\n现在我们再来解决另外一个常见的问题：依赖冲突，比如不同的依赖项各自又依赖于同一个库的不同版本，默认 [Gradle 会用这个重复库的最高版本](https://docs.gradle.org/current/userguide/troubleshooting_dependency_resolution.html#sub:version_conflicts)，但如果你配置了 `resolutionStrategy.failOnVersionConflict()` 即当出现版本冲突则失败，或者版本选择不合适，等等，就会出现依赖冲突问题。\n\n我们通过个例子来证实默认的处理策略，我们在 app 模块中去依赖  `com.android.support:design:27.1.1` 和 `com.android.support:recyclerview-v7:26.1.0` ，而 `design` 会自动去依赖 `com.android.support:recyclerview-v7:27.1.1`，依赖关系我们可以通过 `./gradlew :app:dependencies` 这个 Task 去查看，这里我们只查看 *releaseCompileClasspath* 依赖配置中 `design` 和 `recyclerview` 的情况：\n\n```\n+--- project :mylibrary\n|    \\--- com.android.support:design:27.1.1\n|         +--- com.android.support:support-v4:27.1.1\n|         |    +--- com.android.support:support-compat:27.1.1 (*)\n|         |    +--- com.android.support:support-media-compat:27.1.1\n|         |    |    +--- com.android.support:support-annotations:27.1.1\n|         |    |    \\--- com.android.support:support-compat:27.1.1 (*)\n|         |    +--- com.android.support:support-core-utils:27.1.1 (*)\n|         |    +--- com.android.support:support-core-ui:27.1.1 (*)\n|         |    \\--- com.android.support:support-fragment:27.1.1 (*)\n|         +--- com.android.support:appcompat-v7:27.1.1 (*)\n|         +--- com.android.support:recyclerview-v7:27.1.1\n|         |    +--- com.android.support:support-annotations:27.1.1\n|         |    +--- com.android.support:support-compat:27.1.1 (*)\n|         |    \\--- com.android.support:support-core-ui:27.1.1 (*)\n|         \\--- com.android.support:transition:27.1.1\n|              +--- com.android.support:support-annotations:27.1.1\n|              \\--- com.android.support:support-compat:27.1.1 (*)\n\\--- com.android.support:recyclerview-v7:26.1.0 -> 27.1.1 (*)\n```\n\n可以看到我们依赖的 26.1.0 已经被替换成 27.1.1，如果这是我们想要的结果，那就很理想，但是如果我们想要去定义依赖冲突的策略呢？同样的，Gradle 也提供了相应的 API。\n\n还是上面的例子，如果我们不想要使用 `design` 中的 `recyclerview` 而想要我们单独依赖的 `recyclerview-v7:26.1.1` 这里我们有几种方式解决：\n\n1. 不传递依赖\n\n   ``` groovy\n   api(rootProject.ext.dependencies['design']) {\n               transitive = false\n   }\n   ```\n\n2. 强制使用当前版本\n\n   ``` groovy\n   implementation(rootProject.ext.dependencies['recyclerview']) {\n               force = true\n   }\n   ```\n\n其他的解决方案可以参考[官方文档](https://docs.gradle.org/current/userguide/introduction_dependency_management.html)\n\n这里我们使用 Gradle 提供的 [resolutionStrategy](https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html) 方案： \n\n``` groovy\nsubprojects {\n    configurations.all {\n        resolutionStrategy {\n            force rootProject.ext.dependencies['recyclerview']\n        }\n    }\n}\n```\n\n`configurations` 表示当前项目的依赖配置容器，`configurations.all` 表示当前项目的所有依赖配置，上面的配置表示，遍历当前项目的所有依赖配置，设置其依赖解决策略为 **强制使用指定的版本**\n\n## 改造结束\n\n现在我们再来对比下，默认生成的构建配置和改造后的构建配置：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 27\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n        minSdkVersion 21\n        targetSdkVersion 27\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.android.support:appcompat-v7:27.1.1'\n    implementation 'com.android.support.constraint:constraint-layout:1.1.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n}\n\n```\n\n``` groovy\nandroid {\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n    }\n}\n```\n\n是不是简洁了不少，重复的配置项我们交给统一的配置文件去做，依赖配置也是如此，包括依赖冲突的解决策略，但是 Gradle 能实现的不仅仅如此，还有强大的自定义 Gradle Plugin 我们还没讲到。\n\n## 总结\n\n通过这篇文章，不仅仅是教会大家如何去编写简单的 Gradle 构建脚本，更重要的想让大家对 Gradle 有个初步的认识，知道 Gradle 的配置块是如何生成的，更多知识可以通过[官方文档](https://docs.gradle.org/current/userguide/userguide.html)去获取。","slug":"Gradle多项目实践","published":1,"updated":"2018-05-09T12:27:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs0t0008e39kh2xkf5xy","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上篇文章中，我们说到了 <a href=\"https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/\">Gradle多项目构建</a> 的一些知识点，但这些总归只是纸上谈兵，今天我们在实际项目中通过之前学到的知识去改造下项目的 Gradle 构建脚本，充分利用 Gradle 带来的好处。</p>\n<p>虽然使用 Gradle 作为构建工具已经有一段时间了，但很多同学对它还是很陌生的，基本都是沿用 Android Studio 默认生成的配置，用的比较多的可能也只是 <code>dependencies</code> 配置，从不同的 <code>repositories</code> 去下载依赖，可能在需要实现一些自定义配置的时候，就去 google 后照搬代码，对其配置参数也是似懂非懂，出了问题不知道如何下手解决，所以这篇文章的主要目的是，实践 Gradle 在 Android 上的运用，对 Gradle 的使用有基本认识。</p>\n<p><a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">项目源码</a></p>\n<h2 id=\"改造开始\"><a href=\"#改造开始\" class=\"headerlink\" title=\"改造开始\"></a>改造开始</h2><h3 id=\"Gradle-知识\"><a href=\"#Gradle-知识\" class=\"headerlink\" title=\"Gradle 知识\"></a>Gradle 知识</h3><p>我们先看下 Android Studio 默认帮我们生成的配置代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    <span class=\"comment\">// android 构建配置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\"> \t<span class=\"comment\">// 依赖配置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先简单讲下上面各部分的配置含义，首先我们知道如果不先 <code>apply plugin: &#39;com.android.application&#39;</code> 就不会有 <code>android</code> 配置选项，那么这个配置选项具体是什么内容呢？我们可以通过源码了解下，<code>com.android.application</code> 这个插件就是我们在根目录下的 <em>build.gradle</em> 中导入的：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 构建脚本依赖源地址</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:3.1.2'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对 Gradle Plugin 有点了解的同学都知道，Gradle Plugin 需要定义到 <em>META-INF</em> 中，浏览 <em>gradle-3.1.2.jar</em>，<em>META-INF</em> 目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── MANIFEST.MF</span><br><span class=\"line\">├── gradle-plugins</span><br><span class=\"line\">│   ├── android-library.properties</span><br><span class=\"line\">│   ├── android-reporting.properties</span><br><span class=\"line\">│   ├── android.properties</span><br><span class=\"line\">│   ├── com.android.application.properties</span><br><span class=\"line\">│   ├── com.android.atom.properties</span><br><span class=\"line\">│   ├── com.android.bundle.properties</span><br><span class=\"line\">│   ├── com.android.debug.structure.properties</span><br><span class=\"line\">│   ├── com.android.feature.properties</span><br><span class=\"line\">│   ├── com.android.instantapp.properties</span><br><span class=\"line\">│   ├── com.android.library.properties</span><br><span class=\"line\">│   ├── com.android.lint.properties</span><br><span class=\"line\">│   └── com.android.test.properties</span><br></pre></td></tr></table></figure>\n<p>这里对应的是提供的各个插件的配置，比如 <em>com.android.application.properties</em> 就表示 <code>com.android.application</code> 插件，其他也是一样，properties 的名称表示插件的名称。<em>com.android.application.properties</em> 的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation-class=com.android.build.gradle.AppPlugin</span><br></pre></td></tr></table></figure>\n<p><code>com.android.build.gradle.AppPlugin</code> 这个类就是 Application Plugin 的源码。阅读 AppPlugin 源码，我们可以看到这一段：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">protected</span> BaseExtension createExtension(</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> Project project,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> ProjectOptions projectOptions,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> AndroidBuilder androidBuilder,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> SdkHandler sdkHandler,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> SourceSetManager sourceSetManager,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> ExtraModelInfo extraModelInfo) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> project.getExtensions()</span><br><span class=\"line\">               .create(</span><br><span class=\"line\">                       <span class=\"string\">\"android\"</span>,</span><br><span class=\"line\">                       AppExtension.<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                       project,</span><br><span class=\"line\">                       projectOptions,</span><br><span class=\"line\">                       androidBuilder,</span><br><span class=\"line\">                       sdkHandler,</span><br><span class=\"line\">                       buildTypeContainer,</span><br><span class=\"line\">                       productFlavorContainer,</span><br><span class=\"line\">                       signingConfigContainer,</span><br><span class=\"line\">                       buildOutputs,</span><br><span class=\"line\">                       sourceSetManager,</span><br><span class=\"line\">                       extraModelInfo);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们先通过 API 文档了解下 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.Project.html\" target=\"_blank\" rel=\"noopener\">project.extensions</a> 的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义：</span><br><span class=\"line\">\tExtensionContainer extensions (read-only)</span><br><span class=\"line\">说明：</span><br><span class=\"line\">\tAllows adding DSL extensions to the project. Useful for plugin authors.</span><br><span class=\"line\">\t允许向项目添加 DSL 扩展，对插件作者很有用</span><br></pre></td></tr></table></figure>\n<p>接着我们看下 <a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/ExtensionContainer.html#create-java.lang.String-java.lang.Class-java.lang.Object...-\" target=\"_blank\" rel=\"noopener\"><code>ExtensionContainer.create</code></a> 方法的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义：</span><br><span class=\"line\">\t&lt;T&gt; T create(String name,Class&lt;T&gt; type,Object... constructionArguments)</span><br><span class=\"line\">说明：</span><br><span class=\"line\">\tCreates and adds a new extension to this container. A new instance of the given type will be created using the given constructionArguments. The extension will be exposed as type unless the extension itself declares a preferred public type via the HasPublicType protocol. The new instance will have been dynamically made ExtensionAware, which means that you can cast it to ExtensionAware.</span><br><span class=\"line\">\t向项目创建并且添加一个新的扩展。通过给定的 type 创建一个新的实例，使用给定的 constructionArguments 构造函数参数。可以通过 HasPublicType 接口声明对外开放的类型，否则整个扩展将对外开放。新的实例将动态生成为 </span><br><span class=\"line\">ExtensionAware，这意味着你可以将它转换成 ExtensionAware</span><br></pre></td></tr></table></figure>\n<p>现在我们可以知道，为什么在引入 <code>com.android.application</code> 之后才能使用 <code>android</code> 配置块，这也意味着，<code>android</code> 所能提供的配置依赖于 <code>AppExtension</code> 这个类。</p>\n<p>这里我们简单就 <code>defaultConfig</code> 这个做下分析，先看下这个类在 <code>AppExtension</code> 中的配置，因为 <code>AppExtension</code> 直接调用超类 <code>TestedExtension</code> 的构造方法，而 <code>TestedExtension</code> 又会调用超类 <code>BaseExtension</code> 所以我们直接看到 <code>BaseExtension</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DefaultConfig defaultConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">defaultConfig = objectFactory.newInstance(</span><br><span class=\"line\">                        DefaultConfig.class,</span><br><span class=\"line\">                        BuilderConstants.MAIN,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        objectFactory,</span><br><span class=\"line\">                        extraModelInfo.getDeprecationReporter(),</span><br><span class=\"line\">                        project.getLogger());</span><br></pre></td></tr></table></figure>\n<p>这里我们先不关心 <code>objectFactory.newInstance</code> 只需要知道，当我们在 <code>android</code> 配置块中，配置 <code>defaultConfig</code> 实质上也是，对 <code>DefaultConfig</code> 的配置，而 <code>DefaultConfig</code> 又继承于 <code>DefaultProductFlavor</code>，相关的配置同时也是 <code>DefaultProductFlavor</code> 的成员属性：</p>\n<blockquote>\n<p>DefaultProductFlavor 位于 <code>builder-3.1.2.jar</code></p>\n<p>Android Gradle Plugin 相关代码分别位于 <code>gradle-3.1.2.jar</code>、<code>gradle-api-3.1.2.jar</code>、<code>gradle-core-3.1.2.jar</code></p>\n<p>如果想查看源码，则下载 sources 包，比如 <a href=\"https://dl.google.com/dl/android/maven2/com/android/tools/build/builder/3.1.2/builder-3.1.2-sources.jar\" target=\"_blank\" rel=\"noopener\">builder-3.1.2-sources.jar</a>，其他 jar 下载方法类似</p>\n<p>心好累，各种继承。。。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultProductFlavor</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseConfigImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProductFlavor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String mName;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mDimension;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiVersion mMinSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiVersion mTargetSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mMaxSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mRenderscriptTargetApi;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptSupportModeEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptSupportModeBlasEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptNdkModeEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mVersionCode;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mVersionName;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mApplicationId;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mTestApplicationId;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mTestInstrumentationRunner;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, String&gt; mTestInstrumentationRunnerArguments = Maps.newHashMap();</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mTestHandleProfiling;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mTestFunctionalTest;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SigningConfig mSigningConfig;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;String&gt; mResourceConfiguration;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DefaultVectorDrawablesOptions mVectorDrawablesOptions;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mWearAppUnbundled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重复配置处理\"><a href=\"#重复配置处理\" class=\"headerlink\" title=\"重复配置处理\"></a>重复配置处理</h3><p>当我们项目不止只有一个 app module 时，那么在其他 module 中，例如下面这些配置都需要去配置下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这样就显得很繁琐又不灵活，比如现在很多项目都开始进行组件化，有的 module 有时候是 <code>com.android.application</code>，有的时候又是  <code>com.android.library</code> 这样又得根据条件写两套配置，如果其中一个更改了，还得去挨个 module 中更改。</p>\n<p>而利用 Gradle 多项目构建，我们可以将这些重复配置都统一处理，还可以根据属性自动导入不同的 plugin。首先为了统一管理各种版本号，我们先新建一个 <em>constants.gradle</em> 将一些常量写入到 ext 中：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.ext &#123;</span><br><span class=\"line\">    compileSdkVersion = <span class=\"number\">27</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    minSdkVersion = <span class=\"number\">21</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    targetSdkVersion = <span class=\"number\">27</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    versionCode = <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    versionName = <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p> ext 实际上是 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html\" target=\"_blank\" rel=\"noopener\">ExtraPropertiesExtension</a> 类型，它类似 map，可以存储 key/value 键值对。ext 也是扩展的一种，可以通过 <code>project.extensions.getByName(&#39;ext&#39;)</code> 获取实例，所有的 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtensionAware.html\" target=\"_blank\" rel=\"noopener\"><code>ExtensionAware</code></a> 都拥有一个 <code>ext</code>，而 Project 又是继承于  <code>ExtensionAware</code></p>\n</blockquote>\n<p>接着我们在各个 module 中创建一个 <code>gradle.properties</code> ，这个文件默认会被读取，在其中定义一个属性 <code>isApplication</code>，根据这个属性导入不同的 plugin：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// library module</span></span><br><span class=\"line\">isApplication=<span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// application module</span></span><br><span class=\"line\">isApplication=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>接着创建 <em>init.gradle</em>，在 <code>subprojects</code> 中配置，这里的配置对所有的子项目都会生效：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (project.isApplication.toBoolean()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 module 导入 application plugin</span></span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.application\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.library\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里有点地方需要注意下，因为属性的获取都是通过 String 类型，所以我们需要明确使用 <code>toBoolean()</code> 去转化成布尔值</p>\n</blockquote>\n<p>最后要想使得这些 gradle 文件生效，需要将它们 apply 进去，因为 Gradle 默认只会识别 <code>build.gradle</code>，还记得我们在 <a href=\"https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/\">Gradle多项目构建</a> 中说到，<em>Gradle 是边读取边执行的</em> ，这意味着你需要在使用到 <code>android</code> 构建块之前，将 plugin apply 进去，所以我们将这些 gradle 文件在根目录的 <em>build.gradle</em> 中 apply，因为默认根目录的优先级最高：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// constants.gradle 需要在 init.gradle，因为 init.gradle 后面会使用到 constants.gradle 中定义的值，理由如上</span></span><br><span class=\"line\">apply <span class=\"string\">from:</span> <span class=\"string\">'gradle/constants.gradle'</span></span><br><span class=\"line\">apply <span class=\"string\">from:</span> <span class=\"string\">'gradle/init.gradle'</span></span><br></pre></td></tr></table></figure>\n<p>我们将 module 下 <em>build.gradle</em> 中的 apply 代码删除，重新同步下，可以发现 <code>android</code> 配置块依然生效，这意味着，我们 apply plugin 操作成功了。</p>\n<p>在处理完 plugin 之后，我们可以将 <code>android</code> 配置块中的重复配置也在 <em>init.gradle</em> 中去配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (project.isApplication.toBoolean()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 module 导入 application plugin</span></span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.application\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.library\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    android &#123;</span><br><span class=\"line\">        compileSdkVersion rootProject.ext[<span class=\"string\">'compileSdkVersion'</span>]</span><br><span class=\"line\">        defaultConfig &#123;</span><br><span class=\"line\">            minSdkVersion rootProject.ext[<span class=\"string\">'minSdkVersion'</span>]</span><br><span class=\"line\">            targetSdkVersion rootProject.ext[<span class=\"string\">'targetSdkVersion'</span>]</span><br><span class=\"line\">            versionCode rootProject.ext[<span class=\"string\">'versionCode'</span>]</span><br><span class=\"line\">            versionName rootProject.ext[<span class=\"string\">'versionName'</span>]</span><br><span class=\"line\">            testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        buildTypes &#123;</span><br><span class=\"line\">            release &#123;</span><br><span class=\"line\">                minifyEnabled <span class=\"literal\">false</span></span><br><span class=\"line\">                proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是不是非常方便，这样统一的配置你只需要写一次，不只是 <code>android</code> 配置块可以这么处理，其他的配置也可以这么处理。</p>\n<h3 id=\"依赖管理\"><a href=\"#依赖管理\" class=\"headerlink\" title=\"依赖管理\"></a>依赖管理</h3><p>一般情况下，我们会在各个 module 下去编写所需的依赖配置，比如通过 <code>implementation &#39;com.android.support:appcompat-v7:27.1.1&#39;</code> 去从 maven 中心仓库或者 jcenter 中下载依赖，但这样有个不好的地方就是依赖配置太分散了，只能到每个 module 目录中的 <em>build.gradle</em> 去管理，如果我们将这个写到统一的 Gradle 构建脚本中，是不是会更好点，我们同样创建个 <em>dependencies.gradle</em>，将共同的依赖写到 <code>subprojects</code> ，特有的依赖写到单独的项目配置中，同样这个文件需要在根目录的 <em>build.gradle</em> 中 apply：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        testImplementation rootProject.ext.dependencies[<span class=\"string\">'junit'</span>]</span><br><span class=\"line\">        androidTestImplementation rootProject.ext.dependencies[<span class=\"string\">'runner'</span>]</span><br><span class=\"line\">        androidTestImplementation rootProject.ext.dependencies[<span class=\"string\">'espresso-core'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">project(<span class=\"string\">':mylibrary'</span>) &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        api fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">        api rootProject.ext.dependencies[<span class=\"string\">'appcompat-v7'</span>]</span><br><span class=\"line\">        api rootProject.ext.dependencies[<span class=\"string\">'constraint-layout'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">project(<span class=\"string\">':app'</span>) &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">        implementation project(<span class=\"string\">\":mylibrary\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以将共同的依赖写到 <code>subprojects</code> 块，单独项目的配置写到各自的配置块下。</p>\n<p>现在我们再来解决另外一个常见的问题：依赖冲突，比如不同的依赖项各自又依赖于同一个库的不同版本，默认 <a href=\"https://docs.gradle.org/current/userguide/troubleshooting_dependency_resolution.html#sub:version_conflicts\" target=\"_blank\" rel=\"noopener\">Gradle 会用这个重复库的最高版本</a>，但如果你配置了 <code>resolutionStrategy.failOnVersionConflict()</code> 即当出现版本冲突则失败，或者版本选择不合适，等等，就会出现依赖冲突问题。</p>\n<p>我们通过个例子来证实默认的处理策略，我们在 app 模块中去依赖  <code>com.android.support:design:27.1.1</code> 和 <code>com.android.support:recyclerview-v7:26.1.0</code> ，而 <code>design</code> 会自动去依赖 <code>com.android.support:recyclerview-v7:27.1.1</code>，依赖关系我们可以通过 <code>./gradlew :app:dependencies</code> 这个 Task 去查看，这里我们只查看 <em>releaseCompileClasspath</em> 依赖配置中 <code>design</code> 和 <code>recyclerview</code> 的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--- project :mylibrary</span><br><span class=\"line\">|    \\--- com.android.support:design:27.1.1</span><br><span class=\"line\">|         +--- com.android.support:support-v4:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-media-compat:27.1.1</span><br><span class=\"line\">|         |    |    +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|         |    |    \\--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-core-utils:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-core-ui:27.1.1 (*)</span><br><span class=\"line\">|         |    \\--- com.android.support:support-fragment:27.1.1 (*)</span><br><span class=\"line\">|         +--- com.android.support:appcompat-v7:27.1.1 (*)</span><br><span class=\"line\">|         +--- com.android.support:recyclerview-v7:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    \\--- com.android.support:support-core-ui:27.1.1 (*)</span><br><span class=\"line\">|         \\--- com.android.support:transition:27.1.1</span><br><span class=\"line\">|              +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|              \\--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">\\--- com.android.support:recyclerview-v7:26.1.0 -&gt; 27.1.1 (*)</span><br></pre></td></tr></table></figure>\n<p>可以看到我们依赖的 26.1.0 已经被替换成 27.1.1，如果这是我们想要的结果，那就很理想，但是如果我们想要去定义依赖冲突的策略呢？同样的，Gradle 也提供了相应的 API。</p>\n<p>还是上面的例子，如果我们不想要使用 <code>design</code> 中的 <code>recyclerview</code> 而想要我们单独依赖的 <code>recyclerview-v7:26.1.1</code> 这里我们有几种方式解决：</p>\n<ol>\n<li><p>不传递依赖</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">api(rootProject.ext.dependencies[<span class=\"string\">'design'</span>]) &#123;</span><br><span class=\"line\">            transitive = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>强制使用当前版本</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation(rootProject.ext.dependencies[<span class=\"string\">'recyclerview'</span>]) &#123;</span><br><span class=\"line\">            force = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其他的解决方案可以参考<a href=\"https://docs.gradle.org/current/userguide/introduction_dependency_management.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p>这里我们使用 Gradle 提供的 <a href=\"https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html\" target=\"_blank\" rel=\"noopener\">resolutionStrategy</a> 方案： </p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    configurations.all &#123;</span><br><span class=\"line\">        resolutionStrategy &#123;</span><br><span class=\"line\">            force rootProject.ext.dependencies[<span class=\"string\">'recyclerview'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>configurations</code> 表示当前项目的依赖配置容器，<code>configurations.all</code> 表示当前项目的所有依赖配置，上面的配置表示，遍历当前项目的所有依赖配置，设置其依赖解决策略为 <strong>强制使用指定的版本</strong></p>\n<h2 id=\"改造结束\"><a href=\"#改造结束\" class=\"headerlink\" title=\"改造结束\"></a>改造结束</h2><p>现在我们再来对比下，默认生成的构建配置和改造后的构建配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">        minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"literal\">false</span></span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support:appcompat-v7:27.1.1'</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support.constraint:constraint-layout:1.1.0'</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">'junit:junit:4.12'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test:runner:1.0.2'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test.espresso:espresso-core:3.0.2'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是不是简洁了不少，重复的配置项我们交给统一的配置文件去做，依赖配置也是如此，包括依赖冲突的解决策略，但是 Gradle 能实现的不仅仅如此，还有强大的自定义 Gradle Plugin 我们还没讲到。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这篇文章，不仅仅是教会大家如何去编写简单的 Gradle 构建脚本，更重要的想让大家对 Gradle 有个初步的认识，知道 Gradle 的配置块是如何生成的，更多知识可以通过<a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>去获取。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上篇文章中，我们说到了 <a href=\"https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/\">Gradle多项目构建</a> 的一些知识点，但这些总归只是纸上谈兵，今天我们在实际项目中通过之前学到的知识去改造下项目的 Gradle 构建脚本，充分利用 Gradle 带来的好处。</p>\n<p>虽然使用 Gradle 作为构建工具已经有一段时间了，但很多同学对它还是很陌生的，基本都是沿用 Android Studio 默认生成的配置，用的比较多的可能也只是 <code>dependencies</code> 配置，从不同的 <code>repositories</code> 去下载依赖，可能在需要实现一些自定义配置的时候，就去 google 后照搬代码，对其配置参数也是似懂非懂，出了问题不知道如何下手解决，所以这篇文章的主要目的是，实践 Gradle 在 Android 上的运用，对 Gradle 的使用有基本认识。</p>\n<p><a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">项目源码</a></p>\n<h2 id=\"改造开始\"><a href=\"#改造开始\" class=\"headerlink\" title=\"改造开始\"></a>改造开始</h2><h3 id=\"Gradle-知识\"><a href=\"#Gradle-知识\" class=\"headerlink\" title=\"Gradle 知识\"></a>Gradle 知识</h3><p>我们先看下 Android Studio 默认帮我们生成的配置代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    <span class=\"comment\">// android 构建配置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\"> \t<span class=\"comment\">// 依赖配置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先简单讲下上面各部分的配置含义，首先我们知道如果不先 <code>apply plugin: &#39;com.android.application&#39;</code> 就不会有 <code>android</code> 配置选项，那么这个配置选项具体是什么内容呢？我们可以通过源码了解下，<code>com.android.application</code> 这个插件就是我们在根目录下的 <em>build.gradle</em> 中导入的：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 构建脚本依赖源地址</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:3.1.2'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对 Gradle Plugin 有点了解的同学都知道，Gradle Plugin 需要定义到 <em>META-INF</em> 中，浏览 <em>gradle-3.1.2.jar</em>，<em>META-INF</em> 目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── MANIFEST.MF</span><br><span class=\"line\">├── gradle-plugins</span><br><span class=\"line\">│   ├── android-library.properties</span><br><span class=\"line\">│   ├── android-reporting.properties</span><br><span class=\"line\">│   ├── android.properties</span><br><span class=\"line\">│   ├── com.android.application.properties</span><br><span class=\"line\">│   ├── com.android.atom.properties</span><br><span class=\"line\">│   ├── com.android.bundle.properties</span><br><span class=\"line\">│   ├── com.android.debug.structure.properties</span><br><span class=\"line\">│   ├── com.android.feature.properties</span><br><span class=\"line\">│   ├── com.android.instantapp.properties</span><br><span class=\"line\">│   ├── com.android.library.properties</span><br><span class=\"line\">│   ├── com.android.lint.properties</span><br><span class=\"line\">│   └── com.android.test.properties</span><br></pre></td></tr></table></figure>\n<p>这里对应的是提供的各个插件的配置，比如 <em>com.android.application.properties</em> 就表示 <code>com.android.application</code> 插件，其他也是一样，properties 的名称表示插件的名称。<em>com.android.application.properties</em> 的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation-class=com.android.build.gradle.AppPlugin</span><br></pre></td></tr></table></figure>\n<p><code>com.android.build.gradle.AppPlugin</code> 这个类就是 Application Plugin 的源码。阅读 AppPlugin 源码，我们可以看到这一段：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">protected</span> BaseExtension createExtension(</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> Project project,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> ProjectOptions projectOptions,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> AndroidBuilder androidBuilder,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> SdkHandler sdkHandler,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> SourceSetManager sourceSetManager,</span><br><span class=\"line\">           <span class=\"meta\">@NonNull</span> ExtraModelInfo extraModelInfo) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> project.getExtensions()</span><br><span class=\"line\">               .create(</span><br><span class=\"line\">                       <span class=\"string\">\"android\"</span>,</span><br><span class=\"line\">                       AppExtension.<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                       project,</span><br><span class=\"line\">                       projectOptions,</span><br><span class=\"line\">                       androidBuilder,</span><br><span class=\"line\">                       sdkHandler,</span><br><span class=\"line\">                       buildTypeContainer,</span><br><span class=\"line\">                       productFlavorContainer,</span><br><span class=\"line\">                       signingConfigContainer,</span><br><span class=\"line\">                       buildOutputs,</span><br><span class=\"line\">                       sourceSetManager,</span><br><span class=\"line\">                       extraModelInfo);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们先通过 API 文档了解下 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.Project.html\" target=\"_blank\" rel=\"noopener\">project.extensions</a> 的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义：</span><br><span class=\"line\">\tExtensionContainer extensions (read-only)</span><br><span class=\"line\">说明：</span><br><span class=\"line\">\tAllows adding DSL extensions to the project. Useful for plugin authors.</span><br><span class=\"line\">\t允许向项目添加 DSL 扩展，对插件作者很有用</span><br></pre></td></tr></table></figure>\n<p>接着我们看下 <a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/ExtensionContainer.html#create-java.lang.String-java.lang.Class-java.lang.Object...-\" target=\"_blank\" rel=\"noopener\"><code>ExtensionContainer.create</code></a> 方法的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义：</span><br><span class=\"line\">\t&lt;T&gt; T create(String name,Class&lt;T&gt; type,Object... constructionArguments)</span><br><span class=\"line\">说明：</span><br><span class=\"line\">\tCreates and adds a new extension to this container. A new instance of the given type will be created using the given constructionArguments. The extension will be exposed as type unless the extension itself declares a preferred public type via the HasPublicType protocol. The new instance will have been dynamically made ExtensionAware, which means that you can cast it to ExtensionAware.</span><br><span class=\"line\">\t向项目创建并且添加一个新的扩展。通过给定的 type 创建一个新的实例，使用给定的 constructionArguments 构造函数参数。可以通过 HasPublicType 接口声明对外开放的类型，否则整个扩展将对外开放。新的实例将动态生成为 </span><br><span class=\"line\">ExtensionAware，这意味着你可以将它转换成 ExtensionAware</span><br></pre></td></tr></table></figure>\n<p>现在我们可以知道，为什么在引入 <code>com.android.application</code> 之后才能使用 <code>android</code> 配置块，这也意味着，<code>android</code> 所能提供的配置依赖于 <code>AppExtension</code> 这个类。</p>\n<p>这里我们简单就 <code>defaultConfig</code> 这个做下分析，先看下这个类在 <code>AppExtension</code> 中的配置，因为 <code>AppExtension</code> 直接调用超类 <code>TestedExtension</code> 的构造方法，而 <code>TestedExtension</code> 又会调用超类 <code>BaseExtension</code> 所以我们直接看到 <code>BaseExtension</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DefaultConfig defaultConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">defaultConfig = objectFactory.newInstance(</span><br><span class=\"line\">                        DefaultConfig.class,</span><br><span class=\"line\">                        BuilderConstants.MAIN,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        objectFactory,</span><br><span class=\"line\">                        extraModelInfo.getDeprecationReporter(),</span><br><span class=\"line\">                        project.getLogger());</span><br></pre></td></tr></table></figure>\n<p>这里我们先不关心 <code>objectFactory.newInstance</code> 只需要知道，当我们在 <code>android</code> 配置块中，配置 <code>defaultConfig</code> 实质上也是，对 <code>DefaultConfig</code> 的配置，而 <code>DefaultConfig</code> 又继承于 <code>DefaultProductFlavor</code>，相关的配置同时也是 <code>DefaultProductFlavor</code> 的成员属性：</p>\n<blockquote>\n<p>DefaultProductFlavor 位于 <code>builder-3.1.2.jar</code></p>\n<p>Android Gradle Plugin 相关代码分别位于 <code>gradle-3.1.2.jar</code>、<code>gradle-api-3.1.2.jar</code>、<code>gradle-core-3.1.2.jar</code></p>\n<p>如果想查看源码，则下载 sources 包，比如 <a href=\"https://dl.google.com/dl/android/maven2/com/android/tools/build/builder/3.1.2/builder-3.1.2-sources.jar\" target=\"_blank\" rel=\"noopener\">builder-3.1.2-sources.jar</a>，其他 jar 下载方法类似</p>\n<p>心好累，各种继承。。。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultProductFlavor</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseConfigImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProductFlavor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String mName;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mDimension;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiVersion mMinSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiVersion mTargetSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mMaxSdkVersion;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mRenderscriptTargetApi;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptSupportModeEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptSupportModeBlasEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mRenderscriptNdkModeEnabled;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer mVersionCode;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mVersionName;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mApplicationId;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mTestApplicationId;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mTestInstrumentationRunner;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, String&gt; mTestInstrumentationRunnerArguments = Maps.newHashMap();</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mTestHandleProfiling;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mTestFunctionalTest;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SigningConfig mSigningConfig;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;String&gt; mResourceConfiguration;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DefaultVectorDrawablesOptions mVectorDrawablesOptions;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean mWearAppUnbundled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重复配置处理\"><a href=\"#重复配置处理\" class=\"headerlink\" title=\"重复配置处理\"></a>重复配置处理</h3><p>当我们项目不止只有一个 app module 时，那么在其他 module 中，例如下面这些配置都需要去配置下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这样就显得很繁琐又不灵活，比如现在很多项目都开始进行组件化，有的 module 有时候是 <code>com.android.application</code>，有的时候又是  <code>com.android.library</code> 这样又得根据条件写两套配置，如果其中一个更改了，还得去挨个 module 中更改。</p>\n<p>而利用 Gradle 多项目构建，我们可以将这些重复配置都统一处理，还可以根据属性自动导入不同的 plugin。首先为了统一管理各种版本号，我们先新建一个 <em>constants.gradle</em> 将一些常量写入到 ext 中：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.ext &#123;</span><br><span class=\"line\">    compileSdkVersion = <span class=\"number\">27</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    minSdkVersion = <span class=\"number\">21</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    targetSdkVersion = <span class=\"number\">27</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    versionCode = <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    versionName = <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p> ext 实际上是 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html\" target=\"_blank\" rel=\"noopener\">ExtraPropertiesExtension</a> 类型，它类似 map，可以存储 key/value 键值对。ext 也是扩展的一种，可以通过 <code>project.extensions.getByName(&#39;ext&#39;)</code> 获取实例，所有的 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtensionAware.html\" target=\"_blank\" rel=\"noopener\"><code>ExtensionAware</code></a> 都拥有一个 <code>ext</code>，而 Project 又是继承于  <code>ExtensionAware</code></p>\n</blockquote>\n<p>接着我们在各个 module 中创建一个 <code>gradle.properties</code> ，这个文件默认会被读取，在其中定义一个属性 <code>isApplication</code>，根据这个属性导入不同的 plugin：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// library module</span></span><br><span class=\"line\">isApplication=<span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// application module</span></span><br><span class=\"line\">isApplication=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>接着创建 <em>init.gradle</em>，在 <code>subprojects</code> 中配置，这里的配置对所有的子项目都会生效：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (project.isApplication.toBoolean()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 module 导入 application plugin</span></span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.application\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.library\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里有点地方需要注意下，因为属性的获取都是通过 String 类型，所以我们需要明确使用 <code>toBoolean()</code> 去转化成布尔值</p>\n</blockquote>\n<p>最后要想使得这些 gradle 文件生效，需要将它们 apply 进去，因为 Gradle 默认只会识别 <code>build.gradle</code>，还记得我们在 <a href=\"https://linxiaotao.github.io/2018/04/29/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/\">Gradle多项目构建</a> 中说到，<em>Gradle 是边读取边执行的</em> ，这意味着你需要在使用到 <code>android</code> 构建块之前，将 plugin apply 进去，所以我们将这些 gradle 文件在根目录的 <em>build.gradle</em> 中 apply，因为默认根目录的优先级最高：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// constants.gradle 需要在 init.gradle，因为 init.gradle 后面会使用到 constants.gradle 中定义的值，理由如上</span></span><br><span class=\"line\">apply <span class=\"string\">from:</span> <span class=\"string\">'gradle/constants.gradle'</span></span><br><span class=\"line\">apply <span class=\"string\">from:</span> <span class=\"string\">'gradle/init.gradle'</span></span><br></pre></td></tr></table></figure>\n<p>我们将 module 下 <em>build.gradle</em> 中的 apply 代码删除，重新同步下，可以发现 <code>android</code> 配置块依然生效，这意味着，我们 apply plugin 操作成功了。</p>\n<p>在处理完 plugin 之后，我们可以将 <code>android</code> 配置块中的重复配置也在 <em>init.gradle</em> 中去配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (project.isApplication.toBoolean()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前 module 导入 application plugin</span></span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.application\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        project.plugins.apply(<span class=\"string\">\"com.android.library\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    android &#123;</span><br><span class=\"line\">        compileSdkVersion rootProject.ext[<span class=\"string\">'compileSdkVersion'</span>]</span><br><span class=\"line\">        defaultConfig &#123;</span><br><span class=\"line\">            minSdkVersion rootProject.ext[<span class=\"string\">'minSdkVersion'</span>]</span><br><span class=\"line\">            targetSdkVersion rootProject.ext[<span class=\"string\">'targetSdkVersion'</span>]</span><br><span class=\"line\">            versionCode rootProject.ext[<span class=\"string\">'versionCode'</span>]</span><br><span class=\"line\">            versionName rootProject.ext[<span class=\"string\">'versionName'</span>]</span><br><span class=\"line\">            testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        buildTypes &#123;</span><br><span class=\"line\">            release &#123;</span><br><span class=\"line\">                minifyEnabled <span class=\"literal\">false</span></span><br><span class=\"line\">                proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是不是非常方便，这样统一的配置你只需要写一次，不只是 <code>android</code> 配置块可以这么处理，其他的配置也可以这么处理。</p>\n<h3 id=\"依赖管理\"><a href=\"#依赖管理\" class=\"headerlink\" title=\"依赖管理\"></a>依赖管理</h3><p>一般情况下，我们会在各个 module 下去编写所需的依赖配置，比如通过 <code>implementation &#39;com.android.support:appcompat-v7:27.1.1&#39;</code> 去从 maven 中心仓库或者 jcenter 中下载依赖，但这样有个不好的地方就是依赖配置太分散了，只能到每个 module 目录中的 <em>build.gradle</em> 去管理，如果我们将这个写到统一的 Gradle 构建脚本中，是不是会更好点，我们同样创建个 <em>dependencies.gradle</em>，将共同的依赖写到 <code>subprojects</code> ，特有的依赖写到单独的项目配置中，同样这个文件需要在根目录的 <em>build.gradle</em> 中 apply：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        testImplementation rootProject.ext.dependencies[<span class=\"string\">'junit'</span>]</span><br><span class=\"line\">        androidTestImplementation rootProject.ext.dependencies[<span class=\"string\">'runner'</span>]</span><br><span class=\"line\">        androidTestImplementation rootProject.ext.dependencies[<span class=\"string\">'espresso-core'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">project(<span class=\"string\">':mylibrary'</span>) &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        api fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">        api rootProject.ext.dependencies[<span class=\"string\">'appcompat-v7'</span>]</span><br><span class=\"line\">        api rootProject.ext.dependencies[<span class=\"string\">'constraint-layout'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">project(<span class=\"string\">':app'</span>) &#123;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">        implementation project(<span class=\"string\">\":mylibrary\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以将共同的依赖写到 <code>subprojects</code> 块，单独项目的配置写到各自的配置块下。</p>\n<p>现在我们再来解决另外一个常见的问题：依赖冲突，比如不同的依赖项各自又依赖于同一个库的不同版本，默认 <a href=\"https://docs.gradle.org/current/userguide/troubleshooting_dependency_resolution.html#sub:version_conflicts\" target=\"_blank\" rel=\"noopener\">Gradle 会用这个重复库的最高版本</a>，但如果你配置了 <code>resolutionStrategy.failOnVersionConflict()</code> 即当出现版本冲突则失败，或者版本选择不合适，等等，就会出现依赖冲突问题。</p>\n<p>我们通过个例子来证实默认的处理策略，我们在 app 模块中去依赖  <code>com.android.support:design:27.1.1</code> 和 <code>com.android.support:recyclerview-v7:26.1.0</code> ，而 <code>design</code> 会自动去依赖 <code>com.android.support:recyclerview-v7:27.1.1</code>，依赖关系我们可以通过 <code>./gradlew :app:dependencies</code> 这个 Task 去查看，这里我们只查看 <em>releaseCompileClasspath</em> 依赖配置中 <code>design</code> 和 <code>recyclerview</code> 的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--- project :mylibrary</span><br><span class=\"line\">|    \\--- com.android.support:design:27.1.1</span><br><span class=\"line\">|         +--- com.android.support:support-v4:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-media-compat:27.1.1</span><br><span class=\"line\">|         |    |    +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|         |    |    \\--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-core-utils:27.1.1 (*)</span><br><span class=\"line\">|         |    +--- com.android.support:support-core-ui:27.1.1 (*)</span><br><span class=\"line\">|         |    \\--- com.android.support:support-fragment:27.1.1 (*)</span><br><span class=\"line\">|         +--- com.android.support:appcompat-v7:27.1.1 (*)</span><br><span class=\"line\">|         +--- com.android.support:recyclerview-v7:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|         |    +--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">|         |    \\--- com.android.support:support-core-ui:27.1.1 (*)</span><br><span class=\"line\">|         \\--- com.android.support:transition:27.1.1</span><br><span class=\"line\">|              +--- com.android.support:support-annotations:27.1.1</span><br><span class=\"line\">|              \\--- com.android.support:support-compat:27.1.1 (*)</span><br><span class=\"line\">\\--- com.android.support:recyclerview-v7:26.1.0 -&gt; 27.1.1 (*)</span><br></pre></td></tr></table></figure>\n<p>可以看到我们依赖的 26.1.0 已经被替换成 27.1.1，如果这是我们想要的结果，那就很理想，但是如果我们想要去定义依赖冲突的策略呢？同样的，Gradle 也提供了相应的 API。</p>\n<p>还是上面的例子，如果我们不想要使用 <code>design</code> 中的 <code>recyclerview</code> 而想要我们单独依赖的 <code>recyclerview-v7:26.1.1</code> 这里我们有几种方式解决：</p>\n<ol>\n<li><p>不传递依赖</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">api(rootProject.ext.dependencies[<span class=\"string\">'design'</span>]) &#123;</span><br><span class=\"line\">            transitive = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>强制使用当前版本</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation(rootProject.ext.dependencies[<span class=\"string\">'recyclerview'</span>]) &#123;</span><br><span class=\"line\">            force = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其他的解决方案可以参考<a href=\"https://docs.gradle.org/current/userguide/introduction_dependency_management.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p>这里我们使用 Gradle 提供的 <a href=\"https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html\" target=\"_blank\" rel=\"noopener\">resolutionStrategy</a> 方案： </p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    configurations.all &#123;</span><br><span class=\"line\">        resolutionStrategy &#123;</span><br><span class=\"line\">            force rootProject.ext.dependencies[<span class=\"string\">'recyclerview'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>configurations</code> 表示当前项目的依赖配置容器，<code>configurations.all</code> 表示当前项目的所有依赖配置，上面的配置表示，遍历当前项目的所有依赖配置，设置其依赖解决策略为 <strong>强制使用指定的版本</strong></p>\n<h2 id=\"改造结束\"><a href=\"#改造结束\" class=\"headerlink\" title=\"改造结束\"></a>改造结束</h2><p>现在我们再来对比下，默认生成的构建配置和改造后的构建配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">        minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"literal\">false</span></span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support:appcompat-v7:27.1.1'</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support.constraint:constraint-layout:1.1.0'</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">'junit:junit:4.12'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test:runner:1.0.2'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test.espresso:espresso-core:3.0.2'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是不是简洁了不少，重复的配置项我们交给统一的配置文件去做，依赖配置也是如此，包括依赖冲突的解决策略，但是 Gradle 能实现的不仅仅如此，还有强大的自定义 Gradle Plugin 我们还没讲到。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这篇文章，不仅仅是教会大家如何去编写简单的 Gradle 构建脚本，更重要的想让大家对 Gradle 有个初步的认识，知道 Gradle 的配置块是如何生成的，更多知识可以通过<a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>去获取。</p>\n"},{"title":"Gradle多项目构建","date":"2018-04-29T01:57:51.000Z","_content":"\n## 参考\n\n[multi_project_builds](https://docs.gradle.org/current/userguide/multi_project_builds.html)\n\n## 概述\n\n在使用 Android Studio 作为 IDE 之后，Android 项目就开始使用 Gradle 作为构建脚本，Gradle 的优点就不用我多说了，使用 Groovy 作为开发语言，配合各种 Gradle 插件和 DSL 可以实现多样化的构建过程。\n\nGradle 能讲的知识点很多，本文主要讲的是 Gradle 在多项目构建上提供的一些便捷的功能，希望能给大家一些启发。\n\n## 名词解释\n\n* 构建脚本：本文所说的构建脚本指的是 Gradle 文件，以 `.gradle` 为后缀的文件\n* 项目：在多项目构建中，有根项目和子项目。根项目的称呼是相对的，以执行 gradle 命令的目录为根项目，当前目录的子目录称为子项目\n\n## Gradle 多项目构建\n\n首先我们对 Gradle 多项目构建先做下了解，这里所涉及的知识点大部分来源于参考文档。\n\n### 跨项目配置\n\nGradle 提供了在任何构建脚本中访问任何项目，比如可以使用 `allprojects` 来对所有项目进行配置：\n\n``` groovy\nallprojects {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n这个例子我们对所有项目都创建了一个叫 \"hello\" 的 task，如果你只是想对当前项目的子项目进行配置：\n\n``` groovy\nsubprojects {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n当然你也可以针对单个项目进行配置：\n\n``` groovy\nproject (':project') {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n上面所说的操作可以在任何一个构建脚本上执行，所以你可以选择统一写到单独的构建脚本上，再通过 `apply from: \"xxx.gradle\"` 应用进来。\n\n### 边读取边解释\n\n可能有的同学会问，为什么上面要用 doLast，可以不用 doLast，直接写可以吗？\n\n当前可以，但是执行的时机就不一样了，doLast 从字面意思来看，表示在最后执行，那么这个最后指的是什么之后呢。答案就是项目配置评测(evaluation)之后，简单来讲，当 Gradle 开始执行时，会先从根目录的 `settings.gradle` 中读取参与构建的项目，即只有将子项目 `include` 才能参与构建，接着 Gradle 会在每个项目的根目录下读取 `build.gradle` 如果存在的话，即 `build.gradle` 并不是必须的。默认情况下，Gradle 会先读取根项目的配置，即当你执行 Gradle 命令时所在目录的项目。接着按字母排序，读取子项目的配置，当项目配置评测完成之后，再执行对应的 task.doLast。\n\n那有的同学又会问了，那如果直接写，执行的顺序是什么呢？是在评测之后，doLast 之前吗？这可能是写习惯应用程序的同学最常见的误区了，之前博主也是这么想的，后来经过同事的点拨，**Gradle 是边读取边解释**，有点口语化，但确实如此，回到上面的问题，如果直接写在 task 的代码，会在 Gradle 读取到这一行的时候执行，即可能先于其他还没评测的项目执行，我们可以通过一个例子来看下：\n\n这是项目的目录结构：\n\n```\n├── build.gradle\n├── config.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradle.properties\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n├── sub1\n│   └── build.gradle\n└── sub2\n    └── build.gradle\n```\n\n这里我们包含了两个子项目，分别是 `sub1` 和 `sub2`，在每个项目的 `build.gradle` 我们都加上 Log 打印：\n\n``` groovy\nprintln \"$project.name init\"\n\nprintln \"$project.name  end\"\n```\n\n接着我们在根项目的 `build.gradle` 即最外层目录下，添加一个 task：\n\n``` groovy\ntask hello {\n    println \"我直接运行\"\n    doLast {\n        println \"我运行在 doLast\"\n    }\n}\n```\n\n记得在根目录下执行 `./gradlew -q hello`，参数 `-q` 只打印我们的 log，结果如下：\n\n```\nMyApplication init\n我直接运行\nMyApplication  end\nsub1 init\nsub1 end\nsub2 init\nsub2  end\n我运行在 doLast\n```\n\n结果是不是和我们想的一样。接着我们在 sub1 的 `build.gradle` 中增加以下代码：\n\n``` groovy\nprintln \"当前 sub2 是否存在 username 属性：\" + rootProject.project(\":sub2\").findProperty('username')\n\nrootProject.project(\":sub2\") {\n    ext {\n        username = \"Leo\"\n    }\n}\n\nprintln \"当前 sub2 是否存在 username 属性：\" + rootProject.project(\":sub2\").findProperty('username')\n```\n\n上面我们说到，在任何一个构建脚本中，都可以去配置其他项目，所以我们在 sub1 中往 sub2 添加一个变量，然后在 sub2 中将它打印出来：\n\n``` groovy\nprintln \"我的名字是 $project.ext.username\"\n```\n\n执行下：\n\n``` \nMyApplication init\n我直接运行\nMyApplication  end\nsub1 init\n当前 sub2 是否存在 username 属性：null\n当前 sub2 是否存在 username 属性：Leo\nsub1  end\nsub2 init\n我的名字是 Leo\nsub2  end\n我运行在 doLast\n```\n\n是不是非常有意思，要记住：**Gradle 边读取边解释，先评测项目配置，再执行相应的 Task.doLast**\n\n### 执行规则\n\nGradle 执行时，从当前执行的目录开始查看项目结构，即当前目录为根项目，根据目录下的 `setting.gradle` 去评估子项目的配置，执行相应的 Task，我们同样来看个例子：\n\n```\n.\n├── build.gradle\n├── config.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradle.properties\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n├── sub1\n│   └── build.gradle\n└── sub2\n    ├── build.gradle\n    ├── settings.gradle\n    └── sub3\n        └── build.gradle\n```\n\n我们在 sub2 目录下创建一个新的目录 sub3，其中的 `build.gradle` 如下：\n\n``` groovy\nprintln \"rootProject is $rootProject.name\"\n```\n\n代码非常简单，就是输出当前根项目的名称。我们先在最外层的目录下，执行 `./gradlew` 输出如下：\n\n```\nrootProject is MyApplication\n```\n\n记得将 sub3 `include` 到 `settings.gradle` 可以看到当前的根项目名称即为当前运行的目录，接着我们切换到 sub2 目录下执行同样的命令，输出如下：\n\n```\nrootProject is sub2\n```\n\n### 执行顺序\n\n这里我们所说的执行顺序，包括两个方面，第一是项目的评测顺序，第二是各个项目 Task 的执行顺序。\n\n上面我们提到了项目评测顺序是，先评测根项目，接着按字母顺序评测子项目。那我们如果想改变默认顺序，又不想修改名称呢。Gradle 提供了 `evaluationDependsOn` 用于声明某个项目的评测依赖于其他项目的评测，所以会在依赖项目评测完成之后进行。在上面的例子中，sub1 默认会在 sub2 之前执行，但是如果我们在 sub1 项目中增加如下配置：\n\n``` groovy\nprintln \"$project.name init\"\n\nevaluationDependsOn(':sub2')\n\nprintln \"$project.name  end\"\n```\n\n执行 `./gradlew -q` 输出如下：\n\n``` \nsub1 init\nsub2 init\nsub2  end\nsub1  end\n```\n\n结合我们之前说到的，Gradle 是边读取边解释的，那么 `sub1 end` 在最后输出就不难理解了。\n\nGradle 还提供了 `evaluationDependsOnChildren` 声明子项目先于根项目进行评测。\n\nTask 也是类似的，Gradle 提供了 `dependsOn` 去声明某个 Task 依赖于其他 Task，所以会在依赖 Task 执行后执行。使用例子如下：\n\n``` groovy\ntask hello(dependsOn: ':project:task') {\n    \n}\n```\n\n### 项目解耦\n\nGradle 允许任何项目去访问当前多项目构建中其他项目，虽然这很灵活，但使用不当却会导致项目耦合程度高。\n\n例如，我们通过会在根项目中使用 `allprojects` 或者 `subprojects` 进行项目配置注入，但如果我们在子项目中去对其他项目进行配置注入，就会导致项目耦合。同时如果在子项目构建时，去更改其他项目的配置，这同样也会导致项目耦合，并且这两个操作都可能会影响到 **并行模式** 和 **按需配置** 的正确性。\n\n为了更好的使用配置注入和其他优化选项，我们应该：\n\n* 避免在子项目 `build.gradle` 引用其他子项目，更适合在根项目中进行配置注入\n* 避免在构建时更改其他的项目的配置\n\n### 多项目编译和测试\n\n在 Java 插件的 `build` task 通常是用于对单个项目进行编译、测试和应用代码格式化检查等等。在多项目中构建中你可能想要将 task 作用于指定范围内的项目，那么 `buildNeeded` 和 `buildDependents` task 可以帮助你。\n\n> 接下来的例子都是从官方文档中翻译而来的\n\n比如在这个[例子](https://docs.gradle.org/current/userguide/multi_project_builds.html#javadependencies_2)中，`:services:personservice` 项目依赖于 `:api` 和 `:shared` 项目，同时 `:api` 项目也依赖于 `:shared`。\n\n当我们执行 `./gradlew :api:build` 时，输出可能如下：\n\n``` \n> gradle :api:build\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n\nBUILD SUCCESSFUL in 0s\n9 actionable tasks: 9 executed\n```\n\n可以看到，当我们只执行 `:api` 项目的 `build` task，同时也会执行其依赖项目 `:shared` 部分的 task，如果我们确定对 `:api` 项目的修改不会影响 `:share` 项目，可以使用 `-a` 选项参数，这个参数可以让 Gradle 去缓存依赖项目生成的 jars，不重新去编译依赖项目，现在我们增加 `-a` 参数，`./gradlew -a :api:build`，输出可能如下：\n\n```\n> gradle -a :api:build\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n\nBUILD SUCCESSFUL in 0s\n6 actionable tasks: 6 executed\n```\n\n可以看到 `-a` 选项起作用了。\n\n如果你刚刚从版本控制工具中更新了 `:api` 项目依赖的项目，你可能不仅仅想要只执行编译，可能想要去测试它们，那么 `buildNeeded` task 将测试所有依赖项目测试运行时的配置。执行 `./gradlew :api:buildNeeded`，可能输出如下：\n\n```\n> gradle :api:buildNeeded\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n> Task :shared:assemble\n> Task :shared:compileTestJava\n> Task :shared:processTestResources\n> Task :shared:testClasses\n> Task :shared:test\n> Task :shared:check\n> Task :shared:build\n> Task :shared:buildNeeded\n> Task :api:buildNeeded\n\nBUILD SUCCESSFUL in 0s\n12 actionable tasks: 12 executed\n```\n\n有时候你重构了 `:api` 的某些代码，想要测试依赖于 `:api` 项目的其他项目，那么可以使用 `buildDependents`，它可以测试编译依赖指定的项目的所有项目，运行 `./gradlew :api:buildDependents` 输出如下：\n\n``` \n> gradle :api:buildDependents\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n> Task :services:personService:compileJava\n> Task :services:personService:processResources\n> Task :services:personService:classes\n> Task :services:personService:jar\n> Task :services:personService:assemble\n> Task :services:personService:compileTestJava\n> Task :services:personService:processTestResources\n> Task :services:personService:testClasses\n> Task :services:personService:test\n> Task :services:personService:check\n> Task :services:personService:build\n> Task :services:personService:buildDependents\n> Task :api:buildDependents\n\nBUILD SUCCESSFUL in 0s\n17 actionable tasks: 17 executed\n```\n\n最后，如果你在根项目执行的任何 task 都会导致所有项目中存在同名的 task 的执行。\n\n### 属性和方法的继承\n\n在根项目中声明的属性和方法都会继承到子项目中，这是配置注入的替代方式。而配置注入不支持方法，\n\n### 其他选项\n\n#### 并行模式\n\n可以使用 `—parallel` 开启并行模式，这可以减少项目构建时间\n\n#### 按需配置\n\n可以使用 `--configure-on-demand` 开启按需配置，这同样可以减少构建配置时间\n\n## 总结\n\n在上面的篇幅我们着重讲解了 Gradle 对多项目构建的支持，包括跨项目配置，多项目的执行规则和执行顺序，配置注入等等。但理论知识毕竟只是纸上谈兵，下一篇文章会通过具体的项目配置，来讲解实际的使用。","source":"_posts/Gradle多项目构建.md","raw":"---\ntitle: Gradle多项目构建\ndate: 2018-04-29 09:57:51\ncategories: Gradle\ntags:\n---\n\n## 参考\n\n[multi_project_builds](https://docs.gradle.org/current/userguide/multi_project_builds.html)\n\n## 概述\n\n在使用 Android Studio 作为 IDE 之后，Android 项目就开始使用 Gradle 作为构建脚本，Gradle 的优点就不用我多说了，使用 Groovy 作为开发语言，配合各种 Gradle 插件和 DSL 可以实现多样化的构建过程。\n\nGradle 能讲的知识点很多，本文主要讲的是 Gradle 在多项目构建上提供的一些便捷的功能，希望能给大家一些启发。\n\n## 名词解释\n\n* 构建脚本：本文所说的构建脚本指的是 Gradle 文件，以 `.gradle` 为后缀的文件\n* 项目：在多项目构建中，有根项目和子项目。根项目的称呼是相对的，以执行 gradle 命令的目录为根项目，当前目录的子目录称为子项目\n\n## Gradle 多项目构建\n\n首先我们对 Gradle 多项目构建先做下了解，这里所涉及的知识点大部分来源于参考文档。\n\n### 跨项目配置\n\nGradle 提供了在任何构建脚本中访问任何项目，比如可以使用 `allprojects` 来对所有项目进行配置：\n\n``` groovy\nallprojects {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n这个例子我们对所有项目都创建了一个叫 \"hello\" 的 task，如果你只是想对当前项目的子项目进行配置：\n\n``` groovy\nsubprojects {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n当然你也可以针对单个项目进行配置：\n\n``` groovy\nproject (':project') {\n    task hello {\n        doLast {\n            println \"Hello Gradle\"\n        }\n    }\n}\n```\n\n上面所说的操作可以在任何一个构建脚本上执行，所以你可以选择统一写到单独的构建脚本上，再通过 `apply from: \"xxx.gradle\"` 应用进来。\n\n### 边读取边解释\n\n可能有的同学会问，为什么上面要用 doLast，可以不用 doLast，直接写可以吗？\n\n当前可以，但是执行的时机就不一样了，doLast 从字面意思来看，表示在最后执行，那么这个最后指的是什么之后呢。答案就是项目配置评测(evaluation)之后，简单来讲，当 Gradle 开始执行时，会先从根目录的 `settings.gradle` 中读取参与构建的项目，即只有将子项目 `include` 才能参与构建，接着 Gradle 会在每个项目的根目录下读取 `build.gradle` 如果存在的话，即 `build.gradle` 并不是必须的。默认情况下，Gradle 会先读取根项目的配置，即当你执行 Gradle 命令时所在目录的项目。接着按字母排序，读取子项目的配置，当项目配置评测完成之后，再执行对应的 task.doLast。\n\n那有的同学又会问了，那如果直接写，执行的顺序是什么呢？是在评测之后，doLast 之前吗？这可能是写习惯应用程序的同学最常见的误区了，之前博主也是这么想的，后来经过同事的点拨，**Gradle 是边读取边解释**，有点口语化，但确实如此，回到上面的问题，如果直接写在 task 的代码，会在 Gradle 读取到这一行的时候执行，即可能先于其他还没评测的项目执行，我们可以通过一个例子来看下：\n\n这是项目的目录结构：\n\n```\n├── build.gradle\n├── config.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradle.properties\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n├── sub1\n│   └── build.gradle\n└── sub2\n    └── build.gradle\n```\n\n这里我们包含了两个子项目，分别是 `sub1` 和 `sub2`，在每个项目的 `build.gradle` 我们都加上 Log 打印：\n\n``` groovy\nprintln \"$project.name init\"\n\nprintln \"$project.name  end\"\n```\n\n接着我们在根项目的 `build.gradle` 即最外层目录下，添加一个 task：\n\n``` groovy\ntask hello {\n    println \"我直接运行\"\n    doLast {\n        println \"我运行在 doLast\"\n    }\n}\n```\n\n记得在根目录下执行 `./gradlew -q hello`，参数 `-q` 只打印我们的 log，结果如下：\n\n```\nMyApplication init\n我直接运行\nMyApplication  end\nsub1 init\nsub1 end\nsub2 init\nsub2  end\n我运行在 doLast\n```\n\n结果是不是和我们想的一样。接着我们在 sub1 的 `build.gradle` 中增加以下代码：\n\n``` groovy\nprintln \"当前 sub2 是否存在 username 属性：\" + rootProject.project(\":sub2\").findProperty('username')\n\nrootProject.project(\":sub2\") {\n    ext {\n        username = \"Leo\"\n    }\n}\n\nprintln \"当前 sub2 是否存在 username 属性：\" + rootProject.project(\":sub2\").findProperty('username')\n```\n\n上面我们说到，在任何一个构建脚本中，都可以去配置其他项目，所以我们在 sub1 中往 sub2 添加一个变量，然后在 sub2 中将它打印出来：\n\n``` groovy\nprintln \"我的名字是 $project.ext.username\"\n```\n\n执行下：\n\n``` \nMyApplication init\n我直接运行\nMyApplication  end\nsub1 init\n当前 sub2 是否存在 username 属性：null\n当前 sub2 是否存在 username 属性：Leo\nsub1  end\nsub2 init\n我的名字是 Leo\nsub2  end\n我运行在 doLast\n```\n\n是不是非常有意思，要记住：**Gradle 边读取边解释，先评测项目配置，再执行相应的 Task.doLast**\n\n### 执行规则\n\nGradle 执行时，从当前执行的目录开始查看项目结构，即当前目录为根项目，根据目录下的 `setting.gradle` 去评估子项目的配置，执行相应的 Task，我们同样来看个例子：\n\n```\n.\n├── build.gradle\n├── config.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradle.properties\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n├── sub1\n│   └── build.gradle\n└── sub2\n    ├── build.gradle\n    ├── settings.gradle\n    └── sub3\n        └── build.gradle\n```\n\n我们在 sub2 目录下创建一个新的目录 sub3，其中的 `build.gradle` 如下：\n\n``` groovy\nprintln \"rootProject is $rootProject.name\"\n```\n\n代码非常简单，就是输出当前根项目的名称。我们先在最外层的目录下，执行 `./gradlew` 输出如下：\n\n```\nrootProject is MyApplication\n```\n\n记得将 sub3 `include` 到 `settings.gradle` 可以看到当前的根项目名称即为当前运行的目录，接着我们切换到 sub2 目录下执行同样的命令，输出如下：\n\n```\nrootProject is sub2\n```\n\n### 执行顺序\n\n这里我们所说的执行顺序，包括两个方面，第一是项目的评测顺序，第二是各个项目 Task 的执行顺序。\n\n上面我们提到了项目评测顺序是，先评测根项目，接着按字母顺序评测子项目。那我们如果想改变默认顺序，又不想修改名称呢。Gradle 提供了 `evaluationDependsOn` 用于声明某个项目的评测依赖于其他项目的评测，所以会在依赖项目评测完成之后进行。在上面的例子中，sub1 默认会在 sub2 之前执行，但是如果我们在 sub1 项目中增加如下配置：\n\n``` groovy\nprintln \"$project.name init\"\n\nevaluationDependsOn(':sub2')\n\nprintln \"$project.name  end\"\n```\n\n执行 `./gradlew -q` 输出如下：\n\n``` \nsub1 init\nsub2 init\nsub2  end\nsub1  end\n```\n\n结合我们之前说到的，Gradle 是边读取边解释的，那么 `sub1 end` 在最后输出就不难理解了。\n\nGradle 还提供了 `evaluationDependsOnChildren` 声明子项目先于根项目进行评测。\n\nTask 也是类似的，Gradle 提供了 `dependsOn` 去声明某个 Task 依赖于其他 Task，所以会在依赖 Task 执行后执行。使用例子如下：\n\n``` groovy\ntask hello(dependsOn: ':project:task') {\n    \n}\n```\n\n### 项目解耦\n\nGradle 允许任何项目去访问当前多项目构建中其他项目，虽然这很灵活，但使用不当却会导致项目耦合程度高。\n\n例如，我们通过会在根项目中使用 `allprojects` 或者 `subprojects` 进行项目配置注入，但如果我们在子项目中去对其他项目进行配置注入，就会导致项目耦合。同时如果在子项目构建时，去更改其他项目的配置，这同样也会导致项目耦合，并且这两个操作都可能会影响到 **并行模式** 和 **按需配置** 的正确性。\n\n为了更好的使用配置注入和其他优化选项，我们应该：\n\n* 避免在子项目 `build.gradle` 引用其他子项目，更适合在根项目中进行配置注入\n* 避免在构建时更改其他的项目的配置\n\n### 多项目编译和测试\n\n在 Java 插件的 `build` task 通常是用于对单个项目进行编译、测试和应用代码格式化检查等等。在多项目中构建中你可能想要将 task 作用于指定范围内的项目，那么 `buildNeeded` 和 `buildDependents` task 可以帮助你。\n\n> 接下来的例子都是从官方文档中翻译而来的\n\n比如在这个[例子](https://docs.gradle.org/current/userguide/multi_project_builds.html#javadependencies_2)中，`:services:personservice` 项目依赖于 `:api` 和 `:shared` 项目，同时 `:api` 项目也依赖于 `:shared`。\n\n当我们执行 `./gradlew :api:build` 时，输出可能如下：\n\n``` \n> gradle :api:build\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n\nBUILD SUCCESSFUL in 0s\n9 actionable tasks: 9 executed\n```\n\n可以看到，当我们只执行 `:api` 项目的 `build` task，同时也会执行其依赖项目 `:shared` 部分的 task，如果我们确定对 `:api` 项目的修改不会影响 `:share` 项目，可以使用 `-a` 选项参数，这个参数可以让 Gradle 去缓存依赖项目生成的 jars，不重新去编译依赖项目，现在我们增加 `-a` 参数，`./gradlew -a :api:build`，输出可能如下：\n\n```\n> gradle -a :api:build\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n\nBUILD SUCCESSFUL in 0s\n6 actionable tasks: 6 executed\n```\n\n可以看到 `-a` 选项起作用了。\n\n如果你刚刚从版本控制工具中更新了 `:api` 项目依赖的项目，你可能不仅仅想要只执行编译，可能想要去测试它们，那么 `buildNeeded` task 将测试所有依赖项目测试运行时的配置。执行 `./gradlew :api:buildNeeded`，可能输出如下：\n\n```\n> gradle :api:buildNeeded\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n> Task :shared:assemble\n> Task :shared:compileTestJava\n> Task :shared:processTestResources\n> Task :shared:testClasses\n> Task :shared:test\n> Task :shared:check\n> Task :shared:build\n> Task :shared:buildNeeded\n> Task :api:buildNeeded\n\nBUILD SUCCESSFUL in 0s\n12 actionable tasks: 12 executed\n```\n\n有时候你重构了 `:api` 的某些代码，想要测试依赖于 `:api` 项目的其他项目，那么可以使用 `buildDependents`，它可以测试编译依赖指定的项目的所有项目，运行 `./gradlew :api:buildDependents` 输出如下：\n\n``` \n> gradle :api:buildDependents\n> Task :shared:compileJava\n> Task :shared:processResources\n> Task :shared:classes\n> Task :shared:jar\n> Task :api:compileJava\n> Task :api:processResources\n> Task :api:classes\n> Task :api:jar\n> Task :api:assemble\n> Task :api:compileTestJava\n> Task :api:processTestResources\n> Task :api:testClasses\n> Task :api:test\n> Task :api:check\n> Task :api:build\n> Task :services:personService:compileJava\n> Task :services:personService:processResources\n> Task :services:personService:classes\n> Task :services:personService:jar\n> Task :services:personService:assemble\n> Task :services:personService:compileTestJava\n> Task :services:personService:processTestResources\n> Task :services:personService:testClasses\n> Task :services:personService:test\n> Task :services:personService:check\n> Task :services:personService:build\n> Task :services:personService:buildDependents\n> Task :api:buildDependents\n\nBUILD SUCCESSFUL in 0s\n17 actionable tasks: 17 executed\n```\n\n最后，如果你在根项目执行的任何 task 都会导致所有项目中存在同名的 task 的执行。\n\n### 属性和方法的继承\n\n在根项目中声明的属性和方法都会继承到子项目中，这是配置注入的替代方式。而配置注入不支持方法，\n\n### 其他选项\n\n#### 并行模式\n\n可以使用 `—parallel` 开启并行模式，这可以减少项目构建时间\n\n#### 按需配置\n\n可以使用 `--configure-on-demand` 开启按需配置，这同样可以减少构建配置时间\n\n## 总结\n\n在上面的篇幅我们着重讲解了 Gradle 对多项目构建的支持，包括跨项目配置，多项目的执行规则和执行顺序，配置注入等等。但理论知识毕竟只是纸上谈兵，下一篇文章会通过具体的项目配置，来讲解实际的使用。","slug":"Gradle多项目构建","published":1,"updated":"2018-05-06T14:43:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs0u0009e39kvxv17f1c","content":"<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://docs.gradle.org/current/userguide/multi_project_builds.html\" target=\"_blank\" rel=\"noopener\">multi_project_builds</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>在使用 Android Studio 作为 IDE 之后，Android 项目就开始使用 Gradle 作为构建脚本，Gradle 的优点就不用我多说了，使用 Groovy 作为开发语言，配合各种 Gradle 插件和 DSL 可以实现多样化的构建过程。</p>\n<p>Gradle 能讲的知识点很多，本文主要讲的是 Gradle 在多项目构建上提供的一些便捷的功能，希望能给大家一些启发。</p>\n<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><ul>\n<li>构建脚本：本文所说的构建脚本指的是 Gradle 文件，以 <code>.gradle</code> 为后缀的文件</li>\n<li>项目：在多项目构建中，有根项目和子项目。根项目的称呼是相对的，以执行 gradle 命令的目录为根项目，当前目录的子目录称为子项目</li>\n</ul>\n<h2 id=\"Gradle-多项目构建\"><a href=\"#Gradle-多项目构建\" class=\"headerlink\" title=\"Gradle 多项目构建\"></a>Gradle 多项目构建</h2><p>首先我们对 Gradle 多项目构建先做下了解，这里所涉及的知识点大部分来源于参考文档。</p>\n<h3 id=\"跨项目配置\"><a href=\"#跨项目配置\" class=\"headerlink\" title=\"跨项目配置\"></a>跨项目配置</h3><p>Gradle 提供了在任何构建脚本中访问任何项目，比如可以使用 <code>allprojects</code> 来对所有项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子我们对所有项目都创建了一个叫 “hello” 的 task，如果你只是想对当前项目的子项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然你也可以针对单个项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project (<span class=\"string\">':project'</span>) &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面所说的操作可以在任何一个构建脚本上执行，所以你可以选择统一写到单独的构建脚本上，再通过 <code>apply from: &quot;xxx.gradle&quot;</code> 应用进来。</p>\n<h3 id=\"边读取边解释\"><a href=\"#边读取边解释\" class=\"headerlink\" title=\"边读取边解释\"></a>边读取边解释</h3><p>可能有的同学会问，为什么上面要用 doLast，可以不用 doLast，直接写可以吗？</p>\n<p>当前可以，但是执行的时机就不一样了，doLast 从字面意思来看，表示在最后执行，那么这个最后指的是什么之后呢。答案就是项目配置评测(evaluation)之后，简单来讲，当 Gradle 开始执行时，会先从根目录的 <code>settings.gradle</code> 中读取参与构建的项目，即只有将子项目 <code>include</code> 才能参与构建，接着 Gradle 会在每个项目的根目录下读取 <code>build.gradle</code> 如果存在的话，即 <code>build.gradle</code> 并不是必须的。默认情况下，Gradle 会先读取根项目的配置，即当你执行 Gradle 命令时所在目录的项目。接着按字母排序，读取子项目的配置，当项目配置评测完成之后，再执行对应的 task.doLast。</p>\n<p>那有的同学又会问了，那如果直接写，执行的顺序是什么呢？是在评测之后，doLast 之前吗？这可能是写习惯应用程序的同学最常见的误区了，之前博主也是这么想的，后来经过同事的点拨，<strong>Gradle 是边读取边解释</strong>，有点口语化，但确实如此，回到上面的问题，如果直接写在 task 的代码，会在 Gradle 读取到这一行的时候执行，即可能先于其他还没评测的项目执行，我们可以通过一个例子来看下：</p>\n<p>这是项目的目录结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── config.gradle</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradle.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">├── settings.gradle</span><br><span class=\"line\">├── sub1</span><br><span class=\"line\">│   └── build.gradle</span><br><span class=\"line\">└── sub2</span><br><span class=\"line\">    └── build.gradle</span><br></pre></td></tr></table></figure>\n<p>这里我们包含了两个子项目，分别是 <code>sub1</code> 和 <code>sub2</code>，在每个项目的 <code>build.gradle</code> 我们都加上 Log 打印：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"$project.name init\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"$project.name  end\"</span></span><br></pre></td></tr></table></figure>\n<p>接着我们在根项目的 <code>build.gradle</code> 即最外层目录下，添加一个 task：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task hello &#123;</span><br><span class=\"line\">    println <span class=\"string\">\"我直接运行\"</span></span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        println <span class=\"string\">\"我运行在 doLast\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记得在根目录下执行 <code>./gradlew -q hello</code>，参数 <code>-q</code> 只打印我们的 log，结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyApplication init</span><br><span class=\"line\">我直接运行</span><br><span class=\"line\">MyApplication  end</span><br><span class=\"line\">sub1 init</span><br><span class=\"line\">sub1 end</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">我运行在 doLast</span><br></pre></td></tr></table></figure>\n<p>结果是不是和我们想的一样。接着我们在 sub1 的 <code>build.gradle</code> 中增加以下代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"当前 sub2 是否存在 username 属性：\"</span> + rootProject.project(<span class=\"string\">\":sub2\"</span>).findProperty(<span class=\"string\">'username'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">rootProject.project(<span class=\"string\">\":sub2\"</span>) &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"Leo\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"当前 sub2 是否存在 username 属性：\"</span> + rootProject.project(<span class=\"string\">\":sub2\"</span>).findProperty(<span class=\"string\">'username'</span>)</span><br></pre></td></tr></table></figure>\n<p>上面我们说到，在任何一个构建脚本中，都可以去配置其他项目，所以我们在 sub1 中往 sub2 添加一个变量，然后在 sub2 中将它打印出来：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"我的名字是 $project.ext.username\"</span></span><br></pre></td></tr></table></figure>\n<p>执行下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyApplication init</span><br><span class=\"line\">我直接运行</span><br><span class=\"line\">MyApplication  end</span><br><span class=\"line\">sub1 init</span><br><span class=\"line\">当前 sub2 是否存在 username 属性：null</span><br><span class=\"line\">当前 sub2 是否存在 username 属性：Leo</span><br><span class=\"line\">sub1  end</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">我的名字是 Leo</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">我运行在 doLast</span><br></pre></td></tr></table></figure>\n<p>是不是非常有意思，要记住：<strong>Gradle 边读取边解释，先评测项目配置，再执行相应的 Task.doLast</strong></p>\n<h3 id=\"执行规则\"><a href=\"#执行规则\" class=\"headerlink\" title=\"执行规则\"></a>执行规则</h3><p>Gradle 执行时，从当前执行的目录开始查看项目结构，即当前目录为根项目，根据目录下的 <code>setting.gradle</code> 去评估子项目的配置，执行相应的 Task，我们同样来看个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── config.gradle</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradle.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">├── settings.gradle</span><br><span class=\"line\">├── sub1</span><br><span class=\"line\">│   └── build.gradle</span><br><span class=\"line\">└── sub2</span><br><span class=\"line\">    ├── build.gradle</span><br><span class=\"line\">    ├── settings.gradle</span><br><span class=\"line\">    └── sub3</span><br><span class=\"line\">        └── build.gradle</span><br></pre></td></tr></table></figure>\n<p>我们在 sub2 目录下创建一个新的目录 sub3，其中的 <code>build.gradle</code> 如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"rootProject is $rootProject.name\"</span></span><br></pre></td></tr></table></figure>\n<p>代码非常简单，就是输出当前根项目的名称。我们先在最外层的目录下，执行 <code>./gradlew</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject is MyApplication</span><br></pre></td></tr></table></figure>\n<p>记得将 sub3 <code>include</code> 到 <code>settings.gradle</code> 可以看到当前的根项目名称即为当前运行的目录，接着我们切换到 sub2 目录下执行同样的命令，输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject is sub2</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><p>这里我们所说的执行顺序，包括两个方面，第一是项目的评测顺序，第二是各个项目 Task 的执行顺序。</p>\n<p>上面我们提到了项目评测顺序是，先评测根项目，接着按字母顺序评测子项目。那我们如果想改变默认顺序，又不想修改名称呢。Gradle 提供了 <code>evaluationDependsOn</code> 用于声明某个项目的评测依赖于其他项目的评测，所以会在依赖项目评测完成之后进行。在上面的例子中，sub1 默认会在 sub2 之前执行，但是如果我们在 sub1 项目中增加如下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"$project.name init\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">evaluationDependsOn(<span class=\"string\">':sub2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"$project.name  end\"</span></span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew -q</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sub1 init</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">sub1  end</span><br></pre></td></tr></table></figure>\n<p>结合我们之前说到的，Gradle 是边读取边解释的，那么 <code>sub1 end</code> 在最后输出就不难理解了。</p>\n<p>Gradle 还提供了 <code>evaluationDependsOnChildren</code> 声明子项目先于根项目进行评测。</p>\n<p>Task 也是类似的，Gradle 提供了 <code>dependsOn</code> 去声明某个 Task 依赖于其他 Task，所以会在依赖 Task 执行后执行。使用例子如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task hello(<span class=\"string\">dependsOn:</span> <span class=\"string\">':project:task'</span>) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"项目解耦\"><a href=\"#项目解耦\" class=\"headerlink\" title=\"项目解耦\"></a>项目解耦</h3><p>Gradle 允许任何项目去访问当前多项目构建中其他项目，虽然这很灵活，但使用不当却会导致项目耦合程度高。</p>\n<p>例如，我们通过会在根项目中使用 <code>allprojects</code> 或者 <code>subprojects</code> 进行项目配置注入，但如果我们在子项目中去对其他项目进行配置注入，就会导致项目耦合。同时如果在子项目构建时，去更改其他项目的配置，这同样也会导致项目耦合，并且这两个操作都可能会影响到 <strong>并行模式</strong> 和 <strong>按需配置</strong> 的正确性。</p>\n<p>为了更好的使用配置注入和其他优化选项，我们应该：</p>\n<ul>\n<li>避免在子项目 <code>build.gradle</code> 引用其他子项目，更适合在根项目中进行配置注入</li>\n<li>避免在构建时更改其他的项目的配置</li>\n</ul>\n<h3 id=\"多项目编译和测试\"><a href=\"#多项目编译和测试\" class=\"headerlink\" title=\"多项目编译和测试\"></a>多项目编译和测试</h3><p>在 Java 插件的 <code>build</code> task 通常是用于对单个项目进行编译、测试和应用代码格式化检查等等。在多项目中构建中你可能想要将 task 作用于指定范围内的项目，那么 <code>buildNeeded</code> 和 <code>buildDependents</code> task 可以帮助你。</p>\n<blockquote>\n<p>接下来的例子都是从官方文档中翻译而来的</p>\n</blockquote>\n<p>比如在这个<a href=\"https://docs.gradle.org/current/userguide/multi_project_builds.html#javadependencies_2\" target=\"_blank\" rel=\"noopener\">例子</a>中，<code>:services:personservice</code> 项目依赖于 <code>:api</code> 和 <code>:shared</code> 项目，同时 <code>:api</code> 项目也依赖于 <code>:shared</code>。</p>\n<p>当我们执行 <code>./gradlew :api:build</code> 时，输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:build</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">9 actionable tasks: 9 executed</span><br></pre></td></tr></table></figure>\n<p>可以看到，当我们只执行 <code>:api</code> 项目的 <code>build</code> task，同时也会执行其依赖项目 <code>:shared</code> 部分的 task，如果我们确定对 <code>:api</code> 项目的修改不会影响 <code>:share</code> 项目，可以使用 <code>-a</code> 选项参数，这个参数可以让 Gradle 去缓存依赖项目生成的 jars，不重新去编译依赖项目，现在我们增加 <code>-a</code> 参数，<code>./gradlew -a :api:build</code>，输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle -a :api:build</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">6 actionable tasks: 6 executed</span><br></pre></td></tr></table></figure>\n<p>可以看到 <code>-a</code> 选项起作用了。</p>\n<p>如果你刚刚从版本控制工具中更新了 <code>:api</code> 项目依赖的项目，你可能不仅仅想要只执行编译，可能想要去测试它们，那么 <code>buildNeeded</code> task 将测试所有依赖项目测试运行时的配置。执行 <code>./gradlew :api:buildNeeded</code>，可能输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:buildNeeded</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\">&gt; Task :shared:assemble</span><br><span class=\"line\">&gt; Task :shared:compileTestJava</span><br><span class=\"line\">&gt; Task :shared:processTestResources</span><br><span class=\"line\">&gt; Task :shared:testClasses</span><br><span class=\"line\">&gt; Task :shared:test</span><br><span class=\"line\">&gt; Task :shared:check</span><br><span class=\"line\">&gt; Task :shared:build</span><br><span class=\"line\">&gt; Task :shared:buildNeeded</span><br><span class=\"line\">&gt; Task :api:buildNeeded</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">12 actionable tasks: 12 executed</span><br></pre></td></tr></table></figure>\n<p>有时候你重构了 <code>:api</code> 的某些代码，想要测试依赖于 <code>:api</code> 项目的其他项目，那么可以使用 <code>buildDependents</code>，它可以测试编译依赖指定的项目的所有项目，运行 <code>./gradlew :api:buildDependents</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:buildDependents</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\">&gt; Task :services:personService:compileJava</span><br><span class=\"line\">&gt; Task :services:personService:processResources</span><br><span class=\"line\">&gt; Task :services:personService:classes</span><br><span class=\"line\">&gt; Task :services:personService:jar</span><br><span class=\"line\">&gt; Task :services:personService:assemble</span><br><span class=\"line\">&gt; Task :services:personService:compileTestJava</span><br><span class=\"line\">&gt; Task :services:personService:processTestResources</span><br><span class=\"line\">&gt; Task :services:personService:testClasses</span><br><span class=\"line\">&gt; Task :services:personService:test</span><br><span class=\"line\">&gt; Task :services:personService:check</span><br><span class=\"line\">&gt; Task :services:personService:build</span><br><span class=\"line\">&gt; Task :services:personService:buildDependents</span><br><span class=\"line\">&gt; Task :api:buildDependents</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">17 actionable tasks: 17 executed</span><br></pre></td></tr></table></figure>\n<p>最后，如果你在根项目执行的任何 task 都会导致所有项目中存在同名的 task 的执行。</p>\n<h3 id=\"属性和方法的继承\"><a href=\"#属性和方法的继承\" class=\"headerlink\" title=\"属性和方法的继承\"></a>属性和方法的继承</h3><p>在根项目中声明的属性和方法都会继承到子项目中，这是配置注入的替代方式。而配置注入不支持方法，</p>\n<h3 id=\"其他选项\"><a href=\"#其他选项\" class=\"headerlink\" title=\"其他选项\"></a>其他选项</h3><h4 id=\"并行模式\"><a href=\"#并行模式\" class=\"headerlink\" title=\"并行模式\"></a>并行模式</h4><p>可以使用 <code>—parallel</code> 开启并行模式，这可以减少项目构建时间</p>\n<h4 id=\"按需配置\"><a href=\"#按需配置\" class=\"headerlink\" title=\"按需配置\"></a>按需配置</h4><p>可以使用 <code>--configure-on-demand</code> 开启按需配置，这同样可以减少构建配置时间</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在上面的篇幅我们着重讲解了 Gradle 对多项目构建的支持，包括跨项目配置，多项目的执行规则和执行顺序，配置注入等等。但理论知识毕竟只是纸上谈兵，下一篇文章会通过具体的项目配置，来讲解实际的使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://docs.gradle.org/current/userguide/multi_project_builds.html\" target=\"_blank\" rel=\"noopener\">multi_project_builds</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>在使用 Android Studio 作为 IDE 之后，Android 项目就开始使用 Gradle 作为构建脚本，Gradle 的优点就不用我多说了，使用 Groovy 作为开发语言，配合各种 Gradle 插件和 DSL 可以实现多样化的构建过程。</p>\n<p>Gradle 能讲的知识点很多，本文主要讲的是 Gradle 在多项目构建上提供的一些便捷的功能，希望能给大家一些启发。</p>\n<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><ul>\n<li>构建脚本：本文所说的构建脚本指的是 Gradle 文件，以 <code>.gradle</code> 为后缀的文件</li>\n<li>项目：在多项目构建中，有根项目和子项目。根项目的称呼是相对的，以执行 gradle 命令的目录为根项目，当前目录的子目录称为子项目</li>\n</ul>\n<h2 id=\"Gradle-多项目构建\"><a href=\"#Gradle-多项目构建\" class=\"headerlink\" title=\"Gradle 多项目构建\"></a>Gradle 多项目构建</h2><p>首先我们对 Gradle 多项目构建先做下了解，这里所涉及的知识点大部分来源于参考文档。</p>\n<h3 id=\"跨项目配置\"><a href=\"#跨项目配置\" class=\"headerlink\" title=\"跨项目配置\"></a>跨项目配置</h3><p>Gradle 提供了在任何构建脚本中访问任何项目，比如可以使用 <code>allprojects</code> 来对所有项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子我们对所有项目都创建了一个叫 “hello” 的 task，如果你只是想对当前项目的子项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然你也可以针对单个项目进行配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project (<span class=\"string\">':project'</span>) &#123;</span><br><span class=\"line\">    task hello &#123;</span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            println <span class=\"string\">\"Hello Gradle\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面所说的操作可以在任何一个构建脚本上执行，所以你可以选择统一写到单独的构建脚本上，再通过 <code>apply from: &quot;xxx.gradle&quot;</code> 应用进来。</p>\n<h3 id=\"边读取边解释\"><a href=\"#边读取边解释\" class=\"headerlink\" title=\"边读取边解释\"></a>边读取边解释</h3><p>可能有的同学会问，为什么上面要用 doLast，可以不用 doLast，直接写可以吗？</p>\n<p>当前可以，但是执行的时机就不一样了，doLast 从字面意思来看，表示在最后执行，那么这个最后指的是什么之后呢。答案就是项目配置评测(evaluation)之后，简单来讲，当 Gradle 开始执行时，会先从根目录的 <code>settings.gradle</code> 中读取参与构建的项目，即只有将子项目 <code>include</code> 才能参与构建，接着 Gradle 会在每个项目的根目录下读取 <code>build.gradle</code> 如果存在的话，即 <code>build.gradle</code> 并不是必须的。默认情况下，Gradle 会先读取根项目的配置，即当你执行 Gradle 命令时所在目录的项目。接着按字母排序，读取子项目的配置，当项目配置评测完成之后，再执行对应的 task.doLast。</p>\n<p>那有的同学又会问了，那如果直接写，执行的顺序是什么呢？是在评测之后，doLast 之前吗？这可能是写习惯应用程序的同学最常见的误区了，之前博主也是这么想的，后来经过同事的点拨，<strong>Gradle 是边读取边解释</strong>，有点口语化，但确实如此，回到上面的问题，如果直接写在 task 的代码，会在 Gradle 读取到这一行的时候执行，即可能先于其他还没评测的项目执行，我们可以通过一个例子来看下：</p>\n<p>这是项目的目录结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── config.gradle</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradle.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">├── settings.gradle</span><br><span class=\"line\">├── sub1</span><br><span class=\"line\">│   └── build.gradle</span><br><span class=\"line\">└── sub2</span><br><span class=\"line\">    └── build.gradle</span><br></pre></td></tr></table></figure>\n<p>这里我们包含了两个子项目，分别是 <code>sub1</code> 和 <code>sub2</code>，在每个项目的 <code>build.gradle</code> 我们都加上 Log 打印：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"$project.name init\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"$project.name  end\"</span></span><br></pre></td></tr></table></figure>\n<p>接着我们在根项目的 <code>build.gradle</code> 即最外层目录下，添加一个 task：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task hello &#123;</span><br><span class=\"line\">    println <span class=\"string\">\"我直接运行\"</span></span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        println <span class=\"string\">\"我运行在 doLast\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记得在根目录下执行 <code>./gradlew -q hello</code>，参数 <code>-q</code> 只打印我们的 log，结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyApplication init</span><br><span class=\"line\">我直接运行</span><br><span class=\"line\">MyApplication  end</span><br><span class=\"line\">sub1 init</span><br><span class=\"line\">sub1 end</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">我运行在 doLast</span><br></pre></td></tr></table></figure>\n<p>结果是不是和我们想的一样。接着我们在 sub1 的 <code>build.gradle</code> 中增加以下代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"当前 sub2 是否存在 username 属性：\"</span> + rootProject.project(<span class=\"string\">\":sub2\"</span>).findProperty(<span class=\"string\">'username'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">rootProject.project(<span class=\"string\">\":sub2\"</span>) &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"Leo\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"当前 sub2 是否存在 username 属性：\"</span> + rootProject.project(<span class=\"string\">\":sub2\"</span>).findProperty(<span class=\"string\">'username'</span>)</span><br></pre></td></tr></table></figure>\n<p>上面我们说到，在任何一个构建脚本中，都可以去配置其他项目，所以我们在 sub1 中往 sub2 添加一个变量，然后在 sub2 中将它打印出来：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"我的名字是 $project.ext.username\"</span></span><br></pre></td></tr></table></figure>\n<p>执行下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyApplication init</span><br><span class=\"line\">我直接运行</span><br><span class=\"line\">MyApplication  end</span><br><span class=\"line\">sub1 init</span><br><span class=\"line\">当前 sub2 是否存在 username 属性：null</span><br><span class=\"line\">当前 sub2 是否存在 username 属性：Leo</span><br><span class=\"line\">sub1  end</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">我的名字是 Leo</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">我运行在 doLast</span><br></pre></td></tr></table></figure>\n<p>是不是非常有意思，要记住：<strong>Gradle 边读取边解释，先评测项目配置，再执行相应的 Task.doLast</strong></p>\n<h3 id=\"执行规则\"><a href=\"#执行规则\" class=\"headerlink\" title=\"执行规则\"></a>执行规则</h3><p>Gradle 执行时，从当前执行的目录开始查看项目结构，即当前目录为根项目，根据目录下的 <code>setting.gradle</code> 去评估子项目的配置，执行相应的 Task，我们同样来看个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── config.gradle</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradle.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">├── settings.gradle</span><br><span class=\"line\">├── sub1</span><br><span class=\"line\">│   └── build.gradle</span><br><span class=\"line\">└── sub2</span><br><span class=\"line\">    ├── build.gradle</span><br><span class=\"line\">    ├── settings.gradle</span><br><span class=\"line\">    └── sub3</span><br><span class=\"line\">        └── build.gradle</span><br></pre></td></tr></table></figure>\n<p>我们在 sub2 目录下创建一个新的目录 sub3，其中的 <code>build.gradle</code> 如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"rootProject is $rootProject.name\"</span></span><br></pre></td></tr></table></figure>\n<p>代码非常简单，就是输出当前根项目的名称。我们先在最外层的目录下，执行 <code>./gradlew</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject is MyApplication</span><br></pre></td></tr></table></figure>\n<p>记得将 sub3 <code>include</code> 到 <code>settings.gradle</code> 可以看到当前的根项目名称即为当前运行的目录，接着我们切换到 sub2 目录下执行同样的命令，输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject is sub2</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><p>这里我们所说的执行顺序，包括两个方面，第一是项目的评测顺序，第二是各个项目 Task 的执行顺序。</p>\n<p>上面我们提到了项目评测顺序是，先评测根项目，接着按字母顺序评测子项目。那我们如果想改变默认顺序，又不想修改名称呢。Gradle 提供了 <code>evaluationDependsOn</code> 用于声明某个项目的评测依赖于其他项目的评测，所以会在依赖项目评测完成之后进行。在上面的例子中，sub1 默认会在 sub2 之前执行，但是如果我们在 sub1 项目中增加如下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">\"$project.name init\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">evaluationDependsOn(<span class=\"string\">':sub2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">println <span class=\"string\">\"$project.name  end\"</span></span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew -q</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sub1 init</span><br><span class=\"line\">sub2 init</span><br><span class=\"line\">sub2  end</span><br><span class=\"line\">sub1  end</span><br></pre></td></tr></table></figure>\n<p>结合我们之前说到的，Gradle 是边读取边解释的，那么 <code>sub1 end</code> 在最后输出就不难理解了。</p>\n<p>Gradle 还提供了 <code>evaluationDependsOnChildren</code> 声明子项目先于根项目进行评测。</p>\n<p>Task 也是类似的，Gradle 提供了 <code>dependsOn</code> 去声明某个 Task 依赖于其他 Task，所以会在依赖 Task 执行后执行。使用例子如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task hello(<span class=\"string\">dependsOn:</span> <span class=\"string\">':project:task'</span>) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"项目解耦\"><a href=\"#项目解耦\" class=\"headerlink\" title=\"项目解耦\"></a>项目解耦</h3><p>Gradle 允许任何项目去访问当前多项目构建中其他项目，虽然这很灵活，但使用不当却会导致项目耦合程度高。</p>\n<p>例如，我们通过会在根项目中使用 <code>allprojects</code> 或者 <code>subprojects</code> 进行项目配置注入，但如果我们在子项目中去对其他项目进行配置注入，就会导致项目耦合。同时如果在子项目构建时，去更改其他项目的配置，这同样也会导致项目耦合，并且这两个操作都可能会影响到 <strong>并行模式</strong> 和 <strong>按需配置</strong> 的正确性。</p>\n<p>为了更好的使用配置注入和其他优化选项，我们应该：</p>\n<ul>\n<li>避免在子项目 <code>build.gradle</code> 引用其他子项目，更适合在根项目中进行配置注入</li>\n<li>避免在构建时更改其他的项目的配置</li>\n</ul>\n<h3 id=\"多项目编译和测试\"><a href=\"#多项目编译和测试\" class=\"headerlink\" title=\"多项目编译和测试\"></a>多项目编译和测试</h3><p>在 Java 插件的 <code>build</code> task 通常是用于对单个项目进行编译、测试和应用代码格式化检查等等。在多项目中构建中你可能想要将 task 作用于指定范围内的项目，那么 <code>buildNeeded</code> 和 <code>buildDependents</code> task 可以帮助你。</p>\n<blockquote>\n<p>接下来的例子都是从官方文档中翻译而来的</p>\n</blockquote>\n<p>比如在这个<a href=\"https://docs.gradle.org/current/userguide/multi_project_builds.html#javadependencies_2\" target=\"_blank\" rel=\"noopener\">例子</a>中，<code>:services:personservice</code> 项目依赖于 <code>:api</code> 和 <code>:shared</code> 项目，同时 <code>:api</code> 项目也依赖于 <code>:shared</code>。</p>\n<p>当我们执行 <code>./gradlew :api:build</code> 时，输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:build</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">9 actionable tasks: 9 executed</span><br></pre></td></tr></table></figure>\n<p>可以看到，当我们只执行 <code>:api</code> 项目的 <code>build</code> task，同时也会执行其依赖项目 <code>:shared</code> 部分的 task，如果我们确定对 <code>:api</code> 项目的修改不会影响 <code>:share</code> 项目，可以使用 <code>-a</code> 选项参数，这个参数可以让 Gradle 去缓存依赖项目生成的 jars，不重新去编译依赖项目，现在我们增加 <code>-a</code> 参数，<code>./gradlew -a :api:build</code>，输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle -a :api:build</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">6 actionable tasks: 6 executed</span><br></pre></td></tr></table></figure>\n<p>可以看到 <code>-a</code> 选项起作用了。</p>\n<p>如果你刚刚从版本控制工具中更新了 <code>:api</code> 项目依赖的项目，你可能不仅仅想要只执行编译，可能想要去测试它们，那么 <code>buildNeeded</code> task 将测试所有依赖项目测试运行时的配置。执行 <code>./gradlew :api:buildNeeded</code>，可能输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:buildNeeded</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\">&gt; Task :shared:assemble</span><br><span class=\"line\">&gt; Task :shared:compileTestJava</span><br><span class=\"line\">&gt; Task :shared:processTestResources</span><br><span class=\"line\">&gt; Task :shared:testClasses</span><br><span class=\"line\">&gt; Task :shared:test</span><br><span class=\"line\">&gt; Task :shared:check</span><br><span class=\"line\">&gt; Task :shared:build</span><br><span class=\"line\">&gt; Task :shared:buildNeeded</span><br><span class=\"line\">&gt; Task :api:buildNeeded</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">12 actionable tasks: 12 executed</span><br></pre></td></tr></table></figure>\n<p>有时候你重构了 <code>:api</code> 的某些代码，想要测试依赖于 <code>:api</code> 项目的其他项目，那么可以使用 <code>buildDependents</code>，它可以测试编译依赖指定的项目的所有项目，运行 <code>./gradlew :api:buildDependents</code> 输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradle :api:buildDependents</span><br><span class=\"line\">&gt; Task :shared:compileJava</span><br><span class=\"line\">&gt; Task :shared:processResources</span><br><span class=\"line\">&gt; Task :shared:classes</span><br><span class=\"line\">&gt; Task :shared:jar</span><br><span class=\"line\">&gt; Task :api:compileJava</span><br><span class=\"line\">&gt; Task :api:processResources</span><br><span class=\"line\">&gt; Task :api:classes</span><br><span class=\"line\">&gt; Task :api:jar</span><br><span class=\"line\">&gt; Task :api:assemble</span><br><span class=\"line\">&gt; Task :api:compileTestJava</span><br><span class=\"line\">&gt; Task :api:processTestResources</span><br><span class=\"line\">&gt; Task :api:testClasses</span><br><span class=\"line\">&gt; Task :api:test</span><br><span class=\"line\">&gt; Task :api:check</span><br><span class=\"line\">&gt; Task :api:build</span><br><span class=\"line\">&gt; Task :services:personService:compileJava</span><br><span class=\"line\">&gt; Task :services:personService:processResources</span><br><span class=\"line\">&gt; Task :services:personService:classes</span><br><span class=\"line\">&gt; Task :services:personService:jar</span><br><span class=\"line\">&gt; Task :services:personService:assemble</span><br><span class=\"line\">&gt; Task :services:personService:compileTestJava</span><br><span class=\"line\">&gt; Task :services:personService:processTestResources</span><br><span class=\"line\">&gt; Task :services:personService:testClasses</span><br><span class=\"line\">&gt; Task :services:personService:test</span><br><span class=\"line\">&gt; Task :services:personService:check</span><br><span class=\"line\">&gt; Task :services:personService:build</span><br><span class=\"line\">&gt; Task :services:personService:buildDependents</span><br><span class=\"line\">&gt; Task :api:buildDependents</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 0s</span><br><span class=\"line\">17 actionable tasks: 17 executed</span><br></pre></td></tr></table></figure>\n<p>最后，如果你在根项目执行的任何 task 都会导致所有项目中存在同名的 task 的执行。</p>\n<h3 id=\"属性和方法的继承\"><a href=\"#属性和方法的继承\" class=\"headerlink\" title=\"属性和方法的继承\"></a>属性和方法的继承</h3><p>在根项目中声明的属性和方法都会继承到子项目中，这是配置注入的替代方式。而配置注入不支持方法，</p>\n<h3 id=\"其他选项\"><a href=\"#其他选项\" class=\"headerlink\" title=\"其他选项\"></a>其他选项</h3><h4 id=\"并行模式\"><a href=\"#并行模式\" class=\"headerlink\" title=\"并行模式\"></a>并行模式</h4><p>可以使用 <code>—parallel</code> 开启并行模式，这可以减少项目构建时间</p>\n<h4 id=\"按需配置\"><a href=\"#按需配置\" class=\"headerlink\" title=\"按需配置\"></a>按需配置</h4><p>可以使用 <code>--configure-on-demand</code> 开启按需配置，这同样可以减少构建配置时间</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在上面的篇幅我们着重讲解了 Gradle 对多项目构建的支持，包括跨项目配置，多项目的执行规则和执行顺序，配置注入等等。但理论知识毕竟只是纸上谈兵，下一篇文章会通过具体的项目配置，来讲解实际的使用。</p>\n"},{"title":"Gradle插件-基础篇","date":"2018-05-16T01:20:58.000Z","_content":"\n## 前言\n\n本文是 Gradle 系列的第三篇，前两篇都是关于 Gradle 多项目构建，有兴趣的同学可以去翻看下。Gradle 系列作者会一直更新下去，这些知识大部分都来自于 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html)，但我并不想写成翻译类型的文章，从最基础的知识开始深入，因为这样前期枯燥的理论知识会让人感到厌倦，所以从用户最常用的知识入手，再穿插必要的基础知识，最终达到知识的融会贯通。因为作者从事 Android 开发，所以会更多提及 Android 中关于 Gradle 的知识。\n\n> 博客中的[源码地址](https://github.com/LinXiaoTao/GradleCaseProject)\n\n## Gradle插件\n\nGradle 是非常强大的构建工具，所有的知识都围绕着 project 和 task 这两个知识点。project 在前面的文章中我们已经简单介绍了，task 现在是穿插着讲，后续会考虑单独写成文章。而我们今天讲的 plugin 对于大部分的 Gradle 使用者来说，可能是一个熟悉又陌生的知识点，熟悉是因为用的太频繁了，比如 Android 项目中，我们都会使用以下配置：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion xxx\n    buildToolsVersion xxx\n    defaultConfig {\n        \n    }\n}\n```\n\n但另外一方面，我们对 plugin 的实现又似懂非懂，使用 Android Application Plugin 后，`android {}` 配置块是如何生成的，又有哪些配置可以用。现在有很多自定义的 Gradle Plugin，比如使用 AOP 实现的代码插桩，打点等等功能的库，那么这些库又是如何通过 Plugin 功能实现的。\n\n接下来，我们将基于 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html) 中关于 Plugin 的知识，从 Plugin 的理论知识到自定义实现 Plugin 写一系列文章。\n\n> 友情提示：如果想深入理解 Gradle 知识，最好还是从 Gradle 官方文档入手，比如 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html)，[API 文档](https://docs.gradle.org/current/javadoc/) 等等，如果只是想快速了解，那么可以继续往下读。\n\n### 设计\n\nGradle Plugin 的设计应该符合以下准则：\n\n#### 架构\n\n* 可复用的逻辑应该写成二进制形式\n\n  Gradle Plugin 有两种形式：脚本插件和二进制插件。脚本插件就是普通的构建脚本，虽然脚本插件也可以组织构建逻辑，但是它不能进行测试，也不能定义可复用的类型，难于长期维护。\n\n* 考虑性能影响\n\n  虽然在设计 Gradle Plugin 时，可以实现你能想到的任何逻辑，但是应该考虑对构建时间的影响。\n\n* 约定大于配置\n\n  Gradle Plugin 的设计应该秉承**约定大于配置**的准则，尽量减少用户陷入繁琐的配置中，又提供配置入口给具有自定义需求的用户。比如 Android Application Plugin 的 ***sourceSets*** 配置，如果不进行配置，会使用默认的目录，可以使用  `./gradlew :app:sourceSets` 打印默认使用的目录。\n\n* 功能与约定\n\n  为了让用户能够更灵活地使用你设计的 Plugin，你应该提供更为灵活的使用方式，其中一个方式就是，将实现功能与通用配置分离开来。比如： [Java Base Plugin](https://docs.gradle.org/current/userguide/standard_plugins.html?_ga=2.84655903.747719590.1526541985-590693097.1523454314#sec:base_plugins) 和 [Java Plugin](https://docs.gradle.org/current/userguide/java_plugin.html?_ga=2.72588053.747719590.1526541985-590693097.1523454314)：\n\n  * Java Base Plugin：提供了 ***sourceSets*** 配置属性，用于定义源文件的目录，但它并不会被用于任何构建任务\n  * Java Plugin：则是在 Java Base Plugin 提供的 ***sourceSets*** 配置上读取源文件，同时定义了具体的构建任务\n\n  如果用户想实现更深层次的定制，则可以继承于 Java Base Plugin 实现自定义构建任务。\n\n  在实现自定义 Plugin 可以这样实现：\n\n  假设 `BasePlugin` 实现了通用配置：\n\n  ``` groovy\n  public class BasePlugin implements Plugin<Project> {\n      public void apply(Project project) {\n          \n      }\n  }\n  ```\n\n  `MyPlugin` 则是基于 `BasePlugin` 实现了特定功能：\n\n  ``` groovy\n  public class MyPlugin implements Plugin<Project> {\n      public void apply(Project project) {\n          proejct.getPlugins().apply(BasePlugin.class);\n      }\n  }\n  ```\n\n  #### 技术实现\n\n* 倾向于使用静态类型语言来实现\n\n  Gradle Plugin 的实现语言可以是任何 JVM 语言（即编译产物能在 JVM 上运行），可以是 Java、Kotlin、Groovy 等等。\n\n  但建议使用 Java 或 Kotlin 等静态类型语言来实现，以降低出现不兼容的可能。\n\n* 使用 Gradle 公开 API 实现\n\n  当实现 Gradle Plugin，需要指定使用的 Gradle API 版本，例如以下配置：\n\n  ``` groovy\n  dependencies {\n      compile gradleAPi()\n  }\n  ```\n\n  但因为 Gradle 的历史原因，公开和内部的 API 并没有分离开来，为了确保与各个 Gradle 版本的兼容性，请尽量使用公开的 API\n\n  > 能在 [DSL 文档](https://docs.gradle.org/current/dsl/?_ga=2.131010252.258862271.1526633053-590693097.1523454314) 和  [DOC 文档](https://docs.gradle.org/current/javadoc/?_ga=2.131010252.258862271.1526633053-590693097.1523454314) 中找到的，即为公开的 API\n\n* 最大程度地减少外部库的依赖\n\n  当我们在编写 Plugin 时，可能会习惯性地去引入某个功能齐全的外部库，比如：Guave，但是这同时也会带来一些问题，可以使用 `buildEnvironment` task 查看构建环境依赖关系，包括 Plugin：\n\n  ```\n  classpath\n  +--- com.android.tools.build:gradle:2.3.3\n  |    \\--- com.android.tools.build:gradle-core:2.3.3\n  |         +--- com.android.tools.build:builder:2.3.3\n  ```\n\n  因为 Gradle Plugin 并没有独立的类加载器运行环境，所以这些依赖可能会与其他 Plugin 的依赖发生冲突。\n\n### 例子\n\n上面是自定义 Gradle Plugin 的一些规范和注意事项，下面我们通过一个比较简单的自定义 Plugin 来实践下。\n\n这个 Plugin 的功能很简单，创建一个 task，获取配置的属性，再打印出来。\n\n上面我们说到，Plugin 可以分为脚本插件和二进制插件两种，脚本插件就是 Gradle 文件，而二进制文件的可以像普通依赖一样，从中央仓库上下载，还有一种方式是，将源码存放到当前项目下的 ***buildSrc*** module，当应用插件时，会从中查找。为了方便起见，我们使用后面那种方式。\n\n* 首先，我们创建一个名为 ***buildSrc*** 的 module，记得在 `setting.gradle` 中配置，在该 module 的根目录下创建 `build.gradle`，因为我们打算用 Java 实现，所以先引入 Java Plugin，同时依赖 Gradle API。\n\n  > Gradle 同时也提供了一个 Plugin 用于简化这些步骤，具体可以查看 [java-gradle-plugin](https://docs.gradle.org/4.7/userguide/java_gradle_plugin.html?_ga=2.132564685.258862271.1526633053-590693097.1523454314)\n\n  ``` groovy\n  apply plugin: 'java-library'\n  \n  dependencies {\n      implementation fileTree(dir: 'libs', include: ['*.jar'])\n      implementation gradleApi()\n  }\n  \n  sourceCompatibility = \"1.8\"\n  targetCompatibility = \"1.8\"\n  ```\n\n* 接着，创建一个 Task 类型，命名为 `HelloWorld`：\n\n  ``` java\n  public class HelloWorld extends DefaultTask {\n      \n      public String userName;\n  \n      @TaskAction\n      public void run() {\n          System.out.println(\"Hello World，\" + userName);\n      }\n  }\n  ```\n\n  一般继承于 `DefaultTask` 也可以选择其他 Task 基类，`@TaskAction` 是必须的，用于注解方法为 Task 运行时执行的代码，`userName` 是可选配置。\n\n* 其实上一步做完，我们已经可以在其他 module 下的 gradle 文件中直接引用这个 Task 类型，比如：\n\n  ``` groovy\n  import com.example.gradle.HelloWorld\n  \n  task hello(type: HelloWorld) {\n      userName = \"leo\"\n  }\n  ```\n\n  执行 `./gradlew :app:hello` 输出 \"Hello World，leo\"\n\n  > 注意：上面这样做的前提是，这部分的代码位于 ***buildSrc*** module，这也是约定配置，符合**约定大于配置**规范\n\n  在我们这个例子中，我们通过 Plugin 去动态创建一个 Task：\n\n  ``` java\n  public final class HelloWorldPlugin implements Plugin<Project> {\n      @Override\n      public void apply(Project project) {\n          project.getTasks().create(\"pluginHello\", HelloWorld.class, helloWorld ->\n                  helloWorld.userName = \"leo\");\n      }\n  }\n  ```\n\n  实现自定义 Plugin 需要实现于 Plugin，接着在 `apply()` 中添加一个名为 \"pluginHello\"，类型为 `HelloWorld` 的 Task。\n\n* 至此，我们已经写好了 Plugin 的逻辑代码，要想在当前项目中的其他 module 中引用 ***buildSrc*** 中的 Plugin，需要给 `HelloWorldPlugin` 指定一个 ID，注：直接写在构建脚本中的插件则不需要。具体配置如下：\n\n  在 `src/main/resources/META-INF/gradle-plugins/` 目录下创建一个配置文件，命名规则为：***[PluginID].properties***，在我们这个例子中为：`com.example.hello.properties`：\n\n  ``` properties\n  implementation-class=com.example.gradle.HelloWorldPlugin\n  ```\n\n  `implementation-class` 表示 Plugin 类\n\n  > Plugin ID 应该符合以下规定：\n  >\n  > * 可以包含任何字母、字符，'.'、'-'\n  > * 必须至少包含一个 '.' 分隔命名空间和插件名称\n  > * 按照惯例，使用域名反向小写作为命名空间\n  > * 按照惯例，命名空间只使用小写字母\n  > * `org.gradle` 和 `com.gradleware` 命名空间不能被使用\n  > * 不能使用 '.' 作为开始或结束字符\n  > * 不能使用连续的 '.' 字符\n\n* 至此，我们已经写好了一个简单自定义 Plugin，我们在 app module 下的 `build.gradle` 引入这个它：\n\n  ```\n  apply plugin: 'com.example.hello'\n  ```\n\n  执行 `./gradlew :app:pluginHello` 输出 \"Hello World，leo\"\n\n  > 上面我们提到了 java-gradle-plugin，如果使用这个 Plugin 的话，可以无需手动配置 properties，只需在 gradle 中配置如下即可：\n  >\n  > ``` groovy\n  > gradlePlugin {\n  >     plugins {\n  >         helloPlugin {\n  >             id = 'com.example.hello'\n  >             implementationClass = 'com.example.gradle.HelloWorldPlugin'\n  >         }\n  >     }\n  > }\n  > ```\n\n### 插件源码\n\n在上面的例子中，我们将代码写在了 ***buildSrc*** module 中，那么除此之外还有：\n\n* 构建脚本\n\n  可以将 Plugin 的源码直接包含在构建脚本中，这样子可以方便地在当前构建脚本直接使用该 Plugin，但是无法在其他构建脚本中使用。\n\n  ***build.gradle***\n\n  ``` groovy\n  class TestPlugin implements Plugin<Project> {\n      void apply(Project project) {\n          project.tasks.create('pluginTest') {\n              doLast {\n                  println \"This is Test\"\n              }\n          }\n      }\n  }\n  \n  apply plugin: TestPlugin\n  ```\n\n  > 需要注意：上面的书写顺序，还记得我们之前说的**边读取边解释**\n\n* 单独的项目\n\n  你可以为 Gradle Plugin 创建一个单独的项目，这种方式和 ***buildSrc*** 类似，并且可以生成 JAR 上传到中央仓库提供给其他开发者使用，而 ***buildSrc*** 只能在当前项目中使用。\n\n### 结束语\n\n由于篇幅的限制，基础篇我们就讲到这里，后续的文章还会更深入地讲解 Gradle Plugin 知识。","source":"_posts/Gradle插件-基础篇.md","raw":"---\ntitle: Gradle插件-基础篇\ndate: 2018-05-16 09:20:58\ncategories: Gradle\ntags: \n---\n\n## 前言\n\n本文是 Gradle 系列的第三篇，前两篇都是关于 Gradle 多项目构建，有兴趣的同学可以去翻看下。Gradle 系列作者会一直更新下去，这些知识大部分都来自于 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html)，但我并不想写成翻译类型的文章，从最基础的知识开始深入，因为这样前期枯燥的理论知识会让人感到厌倦，所以从用户最常用的知识入手，再穿插必要的基础知识，最终达到知识的融会贯通。因为作者从事 Android 开发，所以会更多提及 Android 中关于 Gradle 的知识。\n\n> 博客中的[源码地址](https://github.com/LinXiaoTao/GradleCaseProject)\n\n## Gradle插件\n\nGradle 是非常强大的构建工具，所有的知识都围绕着 project 和 task 这两个知识点。project 在前面的文章中我们已经简单介绍了，task 现在是穿插着讲，后续会考虑单独写成文章。而我们今天讲的 plugin 对于大部分的 Gradle 使用者来说，可能是一个熟悉又陌生的知识点，熟悉是因为用的太频繁了，比如 Android 项目中，我们都会使用以下配置：\n\n``` groovy\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion xxx\n    buildToolsVersion xxx\n    defaultConfig {\n        \n    }\n}\n```\n\n但另外一方面，我们对 plugin 的实现又似懂非懂，使用 Android Application Plugin 后，`android {}` 配置块是如何生成的，又有哪些配置可以用。现在有很多自定义的 Gradle Plugin，比如使用 AOP 实现的代码插桩，打点等等功能的库，那么这些库又是如何通过 Plugin 功能实现的。\n\n接下来，我们将基于 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html) 中关于 Plugin 的知识，从 Plugin 的理论知识到自定义实现 Plugin 写一系列文章。\n\n> 友情提示：如果想深入理解 Gradle 知识，最好还是从 Gradle 官方文档入手，比如 [Gradle 用户手册](https://docs.gradle.org/current/userguide/userguide.html)，[API 文档](https://docs.gradle.org/current/javadoc/) 等等，如果只是想快速了解，那么可以继续往下读。\n\n### 设计\n\nGradle Plugin 的设计应该符合以下准则：\n\n#### 架构\n\n* 可复用的逻辑应该写成二进制形式\n\n  Gradle Plugin 有两种形式：脚本插件和二进制插件。脚本插件就是普通的构建脚本，虽然脚本插件也可以组织构建逻辑，但是它不能进行测试，也不能定义可复用的类型，难于长期维护。\n\n* 考虑性能影响\n\n  虽然在设计 Gradle Plugin 时，可以实现你能想到的任何逻辑，但是应该考虑对构建时间的影响。\n\n* 约定大于配置\n\n  Gradle Plugin 的设计应该秉承**约定大于配置**的准则，尽量减少用户陷入繁琐的配置中，又提供配置入口给具有自定义需求的用户。比如 Android Application Plugin 的 ***sourceSets*** 配置，如果不进行配置，会使用默认的目录，可以使用  `./gradlew :app:sourceSets` 打印默认使用的目录。\n\n* 功能与约定\n\n  为了让用户能够更灵活地使用你设计的 Plugin，你应该提供更为灵活的使用方式，其中一个方式就是，将实现功能与通用配置分离开来。比如： [Java Base Plugin](https://docs.gradle.org/current/userguide/standard_plugins.html?_ga=2.84655903.747719590.1526541985-590693097.1523454314#sec:base_plugins) 和 [Java Plugin](https://docs.gradle.org/current/userguide/java_plugin.html?_ga=2.72588053.747719590.1526541985-590693097.1523454314)：\n\n  * Java Base Plugin：提供了 ***sourceSets*** 配置属性，用于定义源文件的目录，但它并不会被用于任何构建任务\n  * Java Plugin：则是在 Java Base Plugin 提供的 ***sourceSets*** 配置上读取源文件，同时定义了具体的构建任务\n\n  如果用户想实现更深层次的定制，则可以继承于 Java Base Plugin 实现自定义构建任务。\n\n  在实现自定义 Plugin 可以这样实现：\n\n  假设 `BasePlugin` 实现了通用配置：\n\n  ``` groovy\n  public class BasePlugin implements Plugin<Project> {\n      public void apply(Project project) {\n          \n      }\n  }\n  ```\n\n  `MyPlugin` 则是基于 `BasePlugin` 实现了特定功能：\n\n  ``` groovy\n  public class MyPlugin implements Plugin<Project> {\n      public void apply(Project project) {\n          proejct.getPlugins().apply(BasePlugin.class);\n      }\n  }\n  ```\n\n  #### 技术实现\n\n* 倾向于使用静态类型语言来实现\n\n  Gradle Plugin 的实现语言可以是任何 JVM 语言（即编译产物能在 JVM 上运行），可以是 Java、Kotlin、Groovy 等等。\n\n  但建议使用 Java 或 Kotlin 等静态类型语言来实现，以降低出现不兼容的可能。\n\n* 使用 Gradle 公开 API 实现\n\n  当实现 Gradle Plugin，需要指定使用的 Gradle API 版本，例如以下配置：\n\n  ``` groovy\n  dependencies {\n      compile gradleAPi()\n  }\n  ```\n\n  但因为 Gradle 的历史原因，公开和内部的 API 并没有分离开来，为了确保与各个 Gradle 版本的兼容性，请尽量使用公开的 API\n\n  > 能在 [DSL 文档](https://docs.gradle.org/current/dsl/?_ga=2.131010252.258862271.1526633053-590693097.1523454314) 和  [DOC 文档](https://docs.gradle.org/current/javadoc/?_ga=2.131010252.258862271.1526633053-590693097.1523454314) 中找到的，即为公开的 API\n\n* 最大程度地减少外部库的依赖\n\n  当我们在编写 Plugin 时，可能会习惯性地去引入某个功能齐全的外部库，比如：Guave，但是这同时也会带来一些问题，可以使用 `buildEnvironment` task 查看构建环境依赖关系，包括 Plugin：\n\n  ```\n  classpath\n  +--- com.android.tools.build:gradle:2.3.3\n  |    \\--- com.android.tools.build:gradle-core:2.3.3\n  |         +--- com.android.tools.build:builder:2.3.3\n  ```\n\n  因为 Gradle Plugin 并没有独立的类加载器运行环境，所以这些依赖可能会与其他 Plugin 的依赖发生冲突。\n\n### 例子\n\n上面是自定义 Gradle Plugin 的一些规范和注意事项，下面我们通过一个比较简单的自定义 Plugin 来实践下。\n\n这个 Plugin 的功能很简单，创建一个 task，获取配置的属性，再打印出来。\n\n上面我们说到，Plugin 可以分为脚本插件和二进制插件两种，脚本插件就是 Gradle 文件，而二进制文件的可以像普通依赖一样，从中央仓库上下载，还有一种方式是，将源码存放到当前项目下的 ***buildSrc*** module，当应用插件时，会从中查找。为了方便起见，我们使用后面那种方式。\n\n* 首先，我们创建一个名为 ***buildSrc*** 的 module，记得在 `setting.gradle` 中配置，在该 module 的根目录下创建 `build.gradle`，因为我们打算用 Java 实现，所以先引入 Java Plugin，同时依赖 Gradle API。\n\n  > Gradle 同时也提供了一个 Plugin 用于简化这些步骤，具体可以查看 [java-gradle-plugin](https://docs.gradle.org/4.7/userguide/java_gradle_plugin.html?_ga=2.132564685.258862271.1526633053-590693097.1523454314)\n\n  ``` groovy\n  apply plugin: 'java-library'\n  \n  dependencies {\n      implementation fileTree(dir: 'libs', include: ['*.jar'])\n      implementation gradleApi()\n  }\n  \n  sourceCompatibility = \"1.8\"\n  targetCompatibility = \"1.8\"\n  ```\n\n* 接着，创建一个 Task 类型，命名为 `HelloWorld`：\n\n  ``` java\n  public class HelloWorld extends DefaultTask {\n      \n      public String userName;\n  \n      @TaskAction\n      public void run() {\n          System.out.println(\"Hello World，\" + userName);\n      }\n  }\n  ```\n\n  一般继承于 `DefaultTask` 也可以选择其他 Task 基类，`@TaskAction` 是必须的，用于注解方法为 Task 运行时执行的代码，`userName` 是可选配置。\n\n* 其实上一步做完，我们已经可以在其他 module 下的 gradle 文件中直接引用这个 Task 类型，比如：\n\n  ``` groovy\n  import com.example.gradle.HelloWorld\n  \n  task hello(type: HelloWorld) {\n      userName = \"leo\"\n  }\n  ```\n\n  执行 `./gradlew :app:hello` 输出 \"Hello World，leo\"\n\n  > 注意：上面这样做的前提是，这部分的代码位于 ***buildSrc*** module，这也是约定配置，符合**约定大于配置**规范\n\n  在我们这个例子中，我们通过 Plugin 去动态创建一个 Task：\n\n  ``` java\n  public final class HelloWorldPlugin implements Plugin<Project> {\n      @Override\n      public void apply(Project project) {\n          project.getTasks().create(\"pluginHello\", HelloWorld.class, helloWorld ->\n                  helloWorld.userName = \"leo\");\n      }\n  }\n  ```\n\n  实现自定义 Plugin 需要实现于 Plugin，接着在 `apply()` 中添加一个名为 \"pluginHello\"，类型为 `HelloWorld` 的 Task。\n\n* 至此，我们已经写好了 Plugin 的逻辑代码，要想在当前项目中的其他 module 中引用 ***buildSrc*** 中的 Plugin，需要给 `HelloWorldPlugin` 指定一个 ID，注：直接写在构建脚本中的插件则不需要。具体配置如下：\n\n  在 `src/main/resources/META-INF/gradle-plugins/` 目录下创建一个配置文件，命名规则为：***[PluginID].properties***，在我们这个例子中为：`com.example.hello.properties`：\n\n  ``` properties\n  implementation-class=com.example.gradle.HelloWorldPlugin\n  ```\n\n  `implementation-class` 表示 Plugin 类\n\n  > Plugin ID 应该符合以下规定：\n  >\n  > * 可以包含任何字母、字符，'.'、'-'\n  > * 必须至少包含一个 '.' 分隔命名空间和插件名称\n  > * 按照惯例，使用域名反向小写作为命名空间\n  > * 按照惯例，命名空间只使用小写字母\n  > * `org.gradle` 和 `com.gradleware` 命名空间不能被使用\n  > * 不能使用 '.' 作为开始或结束字符\n  > * 不能使用连续的 '.' 字符\n\n* 至此，我们已经写好了一个简单自定义 Plugin，我们在 app module 下的 `build.gradle` 引入这个它：\n\n  ```\n  apply plugin: 'com.example.hello'\n  ```\n\n  执行 `./gradlew :app:pluginHello` 输出 \"Hello World，leo\"\n\n  > 上面我们提到了 java-gradle-plugin，如果使用这个 Plugin 的话，可以无需手动配置 properties，只需在 gradle 中配置如下即可：\n  >\n  > ``` groovy\n  > gradlePlugin {\n  >     plugins {\n  >         helloPlugin {\n  >             id = 'com.example.hello'\n  >             implementationClass = 'com.example.gradle.HelloWorldPlugin'\n  >         }\n  >     }\n  > }\n  > ```\n\n### 插件源码\n\n在上面的例子中，我们将代码写在了 ***buildSrc*** module 中，那么除此之外还有：\n\n* 构建脚本\n\n  可以将 Plugin 的源码直接包含在构建脚本中，这样子可以方便地在当前构建脚本直接使用该 Plugin，但是无法在其他构建脚本中使用。\n\n  ***build.gradle***\n\n  ``` groovy\n  class TestPlugin implements Plugin<Project> {\n      void apply(Project project) {\n          project.tasks.create('pluginTest') {\n              doLast {\n                  println \"This is Test\"\n              }\n          }\n      }\n  }\n  \n  apply plugin: TestPlugin\n  ```\n\n  > 需要注意：上面的书写顺序，还记得我们之前说的**边读取边解释**\n\n* 单独的项目\n\n  你可以为 Gradle Plugin 创建一个单独的项目，这种方式和 ***buildSrc*** 类似，并且可以生成 JAR 上传到中央仓库提供给其他开发者使用，而 ***buildSrc*** 只能在当前项目中使用。\n\n### 结束语\n\n由于篇幅的限制，基础篇我们就讲到这里，后续的文章还会更深入地讲解 Gradle Plugin 知识。","slug":"Gradle插件-基础篇","published":1,"updated":"2018-11-11T13:06:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs0w000ce39k5fgp0lso","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文是 Gradle 系列的第三篇，前两篇都是关于 Gradle 多项目构建，有兴趣的同学可以去翻看下。Gradle 系列作者会一直更新下去，这些知识大部分都来自于 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a>，但我并不想写成翻译类型的文章，从最基础的知识开始深入，因为这样前期枯燥的理论知识会让人感到厌倦，所以从用户最常用的知识入手，再穿插必要的基础知识，最终达到知识的融会贯通。因为作者从事 Android 开发，所以会更多提及 Android 中关于 Gradle 的知识。</p>\n<blockquote>\n<p>博客中的<a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n</blockquote>\n<h2 id=\"Gradle插件\"><a href=\"#Gradle插件\" class=\"headerlink\" title=\"Gradle插件\"></a>Gradle插件</h2><p>Gradle 是非常强大的构建工具，所有的知识都围绕着 project 和 task 这两个知识点。project 在前面的文章中我们已经简单介绍了，task 现在是穿插着讲，后续会考虑单独写成文章。而我们今天讲的 plugin 对于大部分的 Gradle 使用者来说，可能是一个熟悉又陌生的知识点，熟悉是因为用的太频繁了，比如 Android 项目中，我们都会使用以下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion xxx</span><br><span class=\"line\">    buildToolsVersion xxx</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但另外一方面，我们对 plugin 的实现又似懂非懂，使用 Android Application Plugin 后，<code>android {}</code> 配置块是如何生成的，又有哪些配置可以用。现在有很多自定义的 Gradle Plugin，比如使用 AOP 实现的代码插桩，打点等等功能的库，那么这些库又是如何通过 Plugin 功能实现的。</p>\n<p>接下来，我们将基于 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a> 中关于 Plugin 的知识，从 Plugin 的理论知识到自定义实现 Plugin 写一系列文章。</p>\n<blockquote>\n<p>友情提示：如果想深入理解 Gradle 知识，最好还是从 Gradle 官方文档入手，比如 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a>，<a href=\"https://docs.gradle.org/current/javadoc/\" target=\"_blank\" rel=\"noopener\">API 文档</a> 等等，如果只是想快速了解，那么可以继续往下读。</p>\n</blockquote>\n<h3 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h3><p>Gradle Plugin 的设计应该符合以下准则：</p>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><p>可复用的逻辑应该写成二进制形式</p>\n<p>Gradle Plugin 有两种形式：脚本插件和二进制插件。脚本插件就是普通的构建脚本，虽然脚本插件也可以组织构建逻辑，但是它不能进行测试，也不能定义可复用的类型，难于长期维护。</p>\n</li>\n<li><p>考虑性能影响</p>\n<p>虽然在设计 Gradle Plugin 时，可以实现你能想到的任何逻辑，但是应该考虑对构建时间的影响。</p>\n</li>\n<li><p>约定大于配置</p>\n<p>Gradle Plugin 的设计应该秉承<strong>约定大于配置</strong>的准则，尽量减少用户陷入繁琐的配置中，又提供配置入口给具有自定义需求的用户。比如 Android Application Plugin 的 <strong><em>sourceSets</em></strong> 配置，如果不进行配置，会使用默认的目录，可以使用  <code>./gradlew :app:sourceSets</code> 打印默认使用的目录。</p>\n</li>\n<li><p>功能与约定</p>\n<p>为了让用户能够更灵活地使用你设计的 Plugin，你应该提供更为灵活的使用方式，其中一个方式就是，将实现功能与通用配置分离开来。比如： <a href=\"https://docs.gradle.org/current/userguide/standard_plugins.html?_ga=2.84655903.747719590.1526541985-590693097.1523454314#sec:base_plugins\" target=\"_blank\" rel=\"noopener\">Java Base Plugin</a> 和 <a href=\"https://docs.gradle.org/current/userguide/java_plugin.html?_ga=2.72588053.747719590.1526541985-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">Java Plugin</a>：</p>\n<ul>\n<li>Java Base Plugin：提供了 <strong><em>sourceSets</em></strong> 配置属性，用于定义源文件的目录，但它并不会被用于任何构建任务</li>\n<li>Java Plugin：则是在 Java Base Plugin 提供的 <strong><em>sourceSets</em></strong> 配置上读取源文件，同时定义了具体的构建任务</li>\n</ul>\n<p>如果用户想实现更深层次的定制，则可以继承于 Java Base Plugin 实现自定义构建任务。</p>\n<p>在实现自定义 Plugin 可以这样实现：</p>\n<p>假设 <code>BasePlugin</code> 实现了通用配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasePlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MyPlugin</code> 则是基于 <code>BasePlugin</code> 实现了特定功能：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        proejct.getPlugins().apply(BasePlugin.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h4></li>\n<li><p>倾向于使用静态类型语言来实现</p>\n<p>Gradle Plugin 的实现语言可以是任何 JVM 语言（即编译产物能在 JVM 上运行），可以是 Java、Kotlin、Groovy 等等。</p>\n<p>但建议使用 Java 或 Kotlin 等静态类型语言来实现，以降低出现不兼容的可能。</p>\n</li>\n<li><p>使用 Gradle 公开 API 实现</p>\n<p>当实现 Gradle Plugin，需要指定使用的 Gradle API 版本，例如以下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile gradleAPi()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但因为 Gradle 的历史原因，公开和内部的 API 并没有分离开来，为了确保与各个 Gradle 版本的兼容性，请尽量使用公开的 API</p>\n<blockquote>\n<p>能在 <a href=\"https://docs.gradle.org/current/dsl/?_ga=2.131010252.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">DSL 文档</a> 和  <a href=\"https://docs.gradle.org/current/javadoc/?_ga=2.131010252.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">DOC 文档</a> 中找到的，即为公开的 API</p>\n</blockquote>\n</li>\n<li><p>最大程度地减少外部库的依赖</p>\n<p>当我们在编写 Plugin 时，可能会习惯性地去引入某个功能齐全的外部库，比如：Guave，但是这同时也会带来一些问题，可以使用 <code>buildEnvironment</code> task 查看构建环境依赖关系，包括 Plugin：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classpath</span><br><span class=\"line\">+--- com.android.tools.build:gradle:2.3.3</span><br><span class=\"line\">|    \\--- com.android.tools.build:gradle-core:2.3.3</span><br><span class=\"line\">|         +--- com.android.tools.build:builder:2.3.3</span><br></pre></td></tr></table></figure>\n<p>因为 Gradle Plugin 并没有独立的类加载器运行环境，所以这些依赖可能会与其他 Plugin 的依赖发生冲突。</p>\n</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>上面是自定义 Gradle Plugin 的一些规范和注意事项，下面我们通过一个比较简单的自定义 Plugin 来实践下。</p>\n<p>这个 Plugin 的功能很简单，创建一个 task，获取配置的属性，再打印出来。</p>\n<p>上面我们说到，Plugin 可以分为脚本插件和二进制插件两种，脚本插件就是 Gradle 文件，而二进制文件的可以像普通依赖一样，从中央仓库上下载，还有一种方式是，将源码存放到当前项目下的 <strong><em>buildSrc</em></strong> module，当应用插件时，会从中查找。为了方便起见，我们使用后面那种方式。</p>\n<ul>\n<li><p>首先，我们创建一个名为 <strong><em>buildSrc</em></strong> 的 module，记得在 <code>setting.gradle</code> 中配置，在该 module 的根目录下创建 <code>build.gradle</code>，因为我们打算用 Java 实现，所以先引入 Java Plugin，同时依赖 Gradle API。</p>\n<blockquote>\n<p>Gradle 同时也提供了一个 Plugin 用于简化这些步骤，具体可以查看 <a href=\"https://docs.gradle.org/4.7/userguide/java_gradle_plugin.html?_ga=2.132564685.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">java-gradle-plugin</a></p>\n</blockquote>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation gradleApi()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = <span class=\"string\">\"1.8\"</span></span><br><span class=\"line\">targetCompatibility = <span class=\"string\">\"1.8\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接着，创建一个 Task 类型，命名为 <code>HelloWorld</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String userName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@TaskAction</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello World，\"</span> + userName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般继承于 <code>DefaultTask</code> 也可以选择其他 Task 基类，<code>@TaskAction</code> 是必须的，用于注解方法为 Task 运行时执行的代码，<code>userName</code> 是可选配置。</p>\n</li>\n<li><p>其实上一步做完，我们已经可以在其他 module 下的 gradle 文件中直接引用这个 Task 类型，比如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.gradle.HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">task hello(<span class=\"string\">type:</span> HelloWorld) &#123;</span><br><span class=\"line\">    userName = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew :app:hello</code> 输出 “Hello World，leo”</p>\n<blockquote>\n<p>注意：上面这样做的前提是，这部分的代码位于 <strong><em>buildSrc</em></strong> module，这也是约定配置，符合<strong>约定大于配置</strong>规范</p>\n</blockquote>\n<p>在我们这个例子中，我们通过 Plugin 去动态创建一个 Task：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorldPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">apply</span><span class=\"params\">(Project project)</span> </span>&#123;</span><br><span class=\"line\">        project.getTasks().create(<span class=\"string\">\"pluginHello\"</span>, HelloWorld.class, helloWorld -&gt;</span><br><span class=\"line\">                helloWorld.userName = <span class=\"string\">\"leo\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现自定义 Plugin 需要实现于 Plugin，接着在 <code>apply()</code> 中添加一个名为 “pluginHello”，类型为 <code>HelloWorld</code> 的 Task。</p>\n</li>\n<li><p>至此，我们已经写好了 Plugin 的逻辑代码，要想在当前项目中的其他 module 中引用 <strong><em>buildSrc</em></strong> 中的 Plugin，需要给 <code>HelloWorldPlugin</code> 指定一个 ID，注：直接写在构建脚本中的插件则不需要。具体配置如下：</p>\n<p>在 <code>src/main/resources/META-INF/gradle-plugins/</code> 目录下创建一个配置文件，命名规则为：<strong><em>[PluginID].properties</em></strong>，在我们这个例子中为：<code>com.example.hello.properties</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation-class=com.example.gradle.HelloWorldPlugin</span><br></pre></td></tr></table></figure>\n<p><code>implementation-class</code> 表示 Plugin 类</p>\n<blockquote>\n<p>Plugin ID 应该符合以下规定：</p>\n<ul>\n<li>可以包含任何字母、字符，’.’、’-‘</li>\n<li>必须至少包含一个 ‘.’ 分隔命名空间和插件名称</li>\n<li>按照惯例，使用域名反向小写作为命名空间</li>\n<li>按照惯例，命名空间只使用小写字母</li>\n<li><code>org.gradle</code> 和 <code>com.gradleware</code> 命名空间不能被使用</li>\n<li>不能使用 ‘.’ 作为开始或结束字符</li>\n<li>不能使用连续的 ‘.’ 字符</li>\n</ul>\n</blockquote>\n</li>\n<li><p>至此，我们已经写好了一个简单自定义 Plugin，我们在 app module 下的 <code>build.gradle</code> 引入这个它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;com.example.hello&apos;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew :app:pluginHello</code> 输出 “Hello World，leo”</p>\n<blockquote>\n<p>上面我们提到了 java-gradle-plugin，如果使用这个 Plugin 的话，可以无需手动配置 properties，只需在 gradle 中配置如下即可：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradlePlugin &#123;</span><br><span class=\"line\">&gt;     plugins &#123;</span><br><span class=\"line\">&gt;         helloPlugin &#123;</span><br><span class=\"line\">&gt;             id = <span class=\"string\">'com.example.hello'</span></span><br><span class=\"line\">&gt;             implementationClass = <span class=\"string\">'com.example.gradle.HelloWorldPlugin'</span></span><br><span class=\"line\">&gt;         &#125;</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"插件源码\"><a href=\"#插件源码\" class=\"headerlink\" title=\"插件源码\"></a>插件源码</h3><p>在上面的例子中，我们将代码写在了 <strong><em>buildSrc</em></strong> module 中，那么除此之外还有：</p>\n<ul>\n<li><p>构建脚本</p>\n<p>可以将 Plugin 的源码直接包含在构建脚本中，这样子可以方便地在当前构建脚本直接使用该 Plugin，但是无法在其他构建脚本中使用。</p>\n<p><strong><em>build.gradle</em></strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        project.tasks.create(<span class=\"string\">'pluginTest'</span>) &#123;</span><br><span class=\"line\">            doLast &#123;</span><br><span class=\"line\">                println <span class=\"string\">\"This is Test\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> TestPlugin</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>需要注意：上面的书写顺序，还记得我们之前说的<strong>边读取边解释</strong></p>\n</blockquote>\n</li>\n<li><p>单独的项目</p>\n<p>你可以为 Gradle Plugin 创建一个单独的项目，这种方式和 <strong><em>buildSrc</em></strong> 类似，并且可以生成 JAR 上传到中央仓库提供给其他开发者使用，而 <strong><em>buildSrc</em></strong> 只能在当前项目中使用。</p>\n</li>\n</ul>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>由于篇幅的限制，基础篇我们就讲到这里，后续的文章还会更深入地讲解 Gradle Plugin 知识。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文是 Gradle 系列的第三篇，前两篇都是关于 Gradle 多项目构建，有兴趣的同学可以去翻看下。Gradle 系列作者会一直更新下去，这些知识大部分都来自于 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a>，但我并不想写成翻译类型的文章，从最基础的知识开始深入，因为这样前期枯燥的理论知识会让人感到厌倦，所以从用户最常用的知识入手，再穿插必要的基础知识，最终达到知识的融会贯通。因为作者从事 Android 开发，所以会更多提及 Android 中关于 Gradle 的知识。</p>\n<blockquote>\n<p>博客中的<a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n</blockquote>\n<h2 id=\"Gradle插件\"><a href=\"#Gradle插件\" class=\"headerlink\" title=\"Gradle插件\"></a>Gradle插件</h2><p>Gradle 是非常强大的构建工具，所有的知识都围绕着 project 和 task 这两个知识点。project 在前面的文章中我们已经简单介绍了，task 现在是穿插着讲，后续会考虑单独写成文章。而我们今天讲的 plugin 对于大部分的 Gradle 使用者来说，可能是一个熟悉又陌生的知识点，熟悉是因为用的太频繁了，比如 Android 项目中，我们都会使用以下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion xxx</span><br><span class=\"line\">    buildToolsVersion xxx</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但另外一方面，我们对 plugin 的实现又似懂非懂，使用 Android Application Plugin 后，<code>android {}</code> 配置块是如何生成的，又有哪些配置可以用。现在有很多自定义的 Gradle Plugin，比如使用 AOP 实现的代码插桩，打点等等功能的库，那么这些库又是如何通过 Plugin 功能实现的。</p>\n<p>接下来，我们将基于 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a> 中关于 Plugin 的知识，从 Plugin 的理论知识到自定义实现 Plugin 写一系列文章。</p>\n<blockquote>\n<p>友情提示：如果想深入理解 Gradle 知识，最好还是从 Gradle 官方文档入手，比如 <a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 用户手册</a>，<a href=\"https://docs.gradle.org/current/javadoc/\" target=\"_blank\" rel=\"noopener\">API 文档</a> 等等，如果只是想快速了解，那么可以继续往下读。</p>\n</blockquote>\n<h3 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h3><p>Gradle Plugin 的设计应该符合以下准则：</p>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><p>可复用的逻辑应该写成二进制形式</p>\n<p>Gradle Plugin 有两种形式：脚本插件和二进制插件。脚本插件就是普通的构建脚本，虽然脚本插件也可以组织构建逻辑，但是它不能进行测试，也不能定义可复用的类型，难于长期维护。</p>\n</li>\n<li><p>考虑性能影响</p>\n<p>虽然在设计 Gradle Plugin 时，可以实现你能想到的任何逻辑，但是应该考虑对构建时间的影响。</p>\n</li>\n<li><p>约定大于配置</p>\n<p>Gradle Plugin 的设计应该秉承<strong>约定大于配置</strong>的准则，尽量减少用户陷入繁琐的配置中，又提供配置入口给具有自定义需求的用户。比如 Android Application Plugin 的 <strong><em>sourceSets</em></strong> 配置，如果不进行配置，会使用默认的目录，可以使用  <code>./gradlew :app:sourceSets</code> 打印默认使用的目录。</p>\n</li>\n<li><p>功能与约定</p>\n<p>为了让用户能够更灵活地使用你设计的 Plugin，你应该提供更为灵活的使用方式，其中一个方式就是，将实现功能与通用配置分离开来。比如： <a href=\"https://docs.gradle.org/current/userguide/standard_plugins.html?_ga=2.84655903.747719590.1526541985-590693097.1523454314#sec:base_plugins\" target=\"_blank\" rel=\"noopener\">Java Base Plugin</a> 和 <a href=\"https://docs.gradle.org/current/userguide/java_plugin.html?_ga=2.72588053.747719590.1526541985-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">Java Plugin</a>：</p>\n<ul>\n<li>Java Base Plugin：提供了 <strong><em>sourceSets</em></strong> 配置属性，用于定义源文件的目录，但它并不会被用于任何构建任务</li>\n<li>Java Plugin：则是在 Java Base Plugin 提供的 <strong><em>sourceSets</em></strong> 配置上读取源文件，同时定义了具体的构建任务</li>\n</ul>\n<p>如果用户想实现更深层次的定制，则可以继承于 Java Base Plugin 实现自定义构建任务。</p>\n<p>在实现自定义 Plugin 可以这样实现：</p>\n<p>假设 <code>BasePlugin</code> 实现了通用配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasePlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MyPlugin</code> 则是基于 <code>BasePlugin</code> 实现了特定功能：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        proejct.getPlugins().apply(BasePlugin.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h4></li>\n<li><p>倾向于使用静态类型语言来实现</p>\n<p>Gradle Plugin 的实现语言可以是任何 JVM 语言（即编译产物能在 JVM 上运行），可以是 Java、Kotlin、Groovy 等等。</p>\n<p>但建议使用 Java 或 Kotlin 等静态类型语言来实现，以降低出现不兼容的可能。</p>\n</li>\n<li><p>使用 Gradle 公开 API 实现</p>\n<p>当实现 Gradle Plugin，需要指定使用的 Gradle API 版本，例如以下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile gradleAPi()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但因为 Gradle 的历史原因，公开和内部的 API 并没有分离开来，为了确保与各个 Gradle 版本的兼容性，请尽量使用公开的 API</p>\n<blockquote>\n<p>能在 <a href=\"https://docs.gradle.org/current/dsl/?_ga=2.131010252.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">DSL 文档</a> 和  <a href=\"https://docs.gradle.org/current/javadoc/?_ga=2.131010252.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">DOC 文档</a> 中找到的，即为公开的 API</p>\n</blockquote>\n</li>\n<li><p>最大程度地减少外部库的依赖</p>\n<p>当我们在编写 Plugin 时，可能会习惯性地去引入某个功能齐全的外部库，比如：Guave，但是这同时也会带来一些问题，可以使用 <code>buildEnvironment</code> task 查看构建环境依赖关系，包括 Plugin：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classpath</span><br><span class=\"line\">+--- com.android.tools.build:gradle:2.3.3</span><br><span class=\"line\">|    \\--- com.android.tools.build:gradle-core:2.3.3</span><br><span class=\"line\">|         +--- com.android.tools.build:builder:2.3.3</span><br></pre></td></tr></table></figure>\n<p>因为 Gradle Plugin 并没有独立的类加载器运行环境，所以这些依赖可能会与其他 Plugin 的依赖发生冲突。</p>\n</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>上面是自定义 Gradle Plugin 的一些规范和注意事项，下面我们通过一个比较简单的自定义 Plugin 来实践下。</p>\n<p>这个 Plugin 的功能很简单，创建一个 task，获取配置的属性，再打印出来。</p>\n<p>上面我们说到，Plugin 可以分为脚本插件和二进制插件两种，脚本插件就是 Gradle 文件，而二进制文件的可以像普通依赖一样，从中央仓库上下载，还有一种方式是，将源码存放到当前项目下的 <strong><em>buildSrc</em></strong> module，当应用插件时，会从中查找。为了方便起见，我们使用后面那种方式。</p>\n<ul>\n<li><p>首先，我们创建一个名为 <strong><em>buildSrc</em></strong> 的 module，记得在 <code>setting.gradle</code> 中配置，在该 module 的根目录下创建 <code>build.gradle</code>，因为我们打算用 Java 实现，所以先引入 Java Plugin，同时依赖 Gradle API。</p>\n<blockquote>\n<p>Gradle 同时也提供了一个 Plugin 用于简化这些步骤，具体可以查看 <a href=\"https://docs.gradle.org/4.7/userguide/java_gradle_plugin.html?_ga=2.132564685.258862271.1526633053-590693097.1523454314\" target=\"_blank\" rel=\"noopener\">java-gradle-plugin</a></p>\n</blockquote>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation gradleApi()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = <span class=\"string\">\"1.8\"</span></span><br><span class=\"line\">targetCompatibility = <span class=\"string\">\"1.8\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接着，创建一个 Task 类型，命名为 <code>HelloWorld</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String userName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@TaskAction</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello World，\"</span> + userName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般继承于 <code>DefaultTask</code> 也可以选择其他 Task 基类，<code>@TaskAction</code> 是必须的，用于注解方法为 Task 运行时执行的代码，<code>userName</code> 是可选配置。</p>\n</li>\n<li><p>其实上一步做完，我们已经可以在其他 module 下的 gradle 文件中直接引用这个 Task 类型，比如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.gradle.HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">task hello(<span class=\"string\">type:</span> HelloWorld) &#123;</span><br><span class=\"line\">    userName = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew :app:hello</code> 输出 “Hello World，leo”</p>\n<blockquote>\n<p>注意：上面这样做的前提是，这部分的代码位于 <strong><em>buildSrc</em></strong> module，这也是约定配置，符合<strong>约定大于配置</strong>规范</p>\n</blockquote>\n<p>在我们这个例子中，我们通过 Plugin 去动态创建一个 Task：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorldPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">apply</span><span class=\"params\">(Project project)</span> </span>&#123;</span><br><span class=\"line\">        project.getTasks().create(<span class=\"string\">\"pluginHello\"</span>, HelloWorld.class, helloWorld -&gt;</span><br><span class=\"line\">                helloWorld.userName = <span class=\"string\">\"leo\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现自定义 Plugin 需要实现于 Plugin，接着在 <code>apply()</code> 中添加一个名为 “pluginHello”，类型为 <code>HelloWorld</code> 的 Task。</p>\n</li>\n<li><p>至此，我们已经写好了 Plugin 的逻辑代码，要想在当前项目中的其他 module 中引用 <strong><em>buildSrc</em></strong> 中的 Plugin，需要给 <code>HelloWorldPlugin</code> 指定一个 ID，注：直接写在构建脚本中的插件则不需要。具体配置如下：</p>\n<p>在 <code>src/main/resources/META-INF/gradle-plugins/</code> 目录下创建一个配置文件，命名规则为：<strong><em>[PluginID].properties</em></strong>，在我们这个例子中为：<code>com.example.hello.properties</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation-class=com.example.gradle.HelloWorldPlugin</span><br></pre></td></tr></table></figure>\n<p><code>implementation-class</code> 表示 Plugin 类</p>\n<blockquote>\n<p>Plugin ID 应该符合以下规定：</p>\n<ul>\n<li>可以包含任何字母、字符，’.’、’-‘</li>\n<li>必须至少包含一个 ‘.’ 分隔命名空间和插件名称</li>\n<li>按照惯例，使用域名反向小写作为命名空间</li>\n<li>按照惯例，命名空间只使用小写字母</li>\n<li><code>org.gradle</code> 和 <code>com.gradleware</code> 命名空间不能被使用</li>\n<li>不能使用 ‘.’ 作为开始或结束字符</li>\n<li>不能使用连续的 ‘.’ 字符</li>\n</ul>\n</blockquote>\n</li>\n<li><p>至此，我们已经写好了一个简单自定义 Plugin，我们在 app module 下的 <code>build.gradle</code> 引入这个它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;com.example.hello&apos;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>./gradlew :app:pluginHello</code> 输出 “Hello World，leo”</p>\n<blockquote>\n<p>上面我们提到了 java-gradle-plugin，如果使用这个 Plugin 的话，可以无需手动配置 properties，只需在 gradle 中配置如下即可：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; gradlePlugin &#123;</span><br><span class=\"line\">&gt;     plugins &#123;</span><br><span class=\"line\">&gt;         helloPlugin &#123;</span><br><span class=\"line\">&gt;             id = <span class=\"string\">'com.example.hello'</span></span><br><span class=\"line\">&gt;             implementationClass = <span class=\"string\">'com.example.gradle.HelloWorldPlugin'</span></span><br><span class=\"line\">&gt;         &#125;</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"插件源码\"><a href=\"#插件源码\" class=\"headerlink\" title=\"插件源码\"></a>插件源码</h3><p>在上面的例子中，我们将代码写在了 <strong><em>buildSrc</em></strong> module 中，那么除此之外还有：</p>\n<ul>\n<li><p>构建脚本</p>\n<p>可以将 Plugin 的源码直接包含在构建脚本中，这样子可以方便地在当前构建脚本直接使用该 Plugin，但是无法在其他构建脚本中使用。</p>\n<p><strong><em>build.gradle</em></strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        project.tasks.create(<span class=\"string\">'pluginTest'</span>) &#123;</span><br><span class=\"line\">            doLast &#123;</span><br><span class=\"line\">                println <span class=\"string\">\"This is Test\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> TestPlugin</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>需要注意：上面的书写顺序，还记得我们之前说的<strong>边读取边解释</strong></p>\n</blockquote>\n</li>\n<li><p>单独的项目</p>\n<p>你可以为 Gradle Plugin 创建一个单独的项目，这种方式和 <strong><em>buildSrc</em></strong> 类似，并且可以生成 JAR 上传到中央仓库提供给其他开发者使用，而 <strong><em>buildSrc</em></strong> 只能在当前项目中使用。</p>\n</li>\n</ul>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>由于篇幅的限制，基础篇我们就讲到这里，后续的文章还会更深入地讲解 Gradle Plugin 知识。</p>\n"},{"title":"HashMap源码分析","date":"2018-11-07T03:39:06.000Z","_content":"\n### 构造方法\n\n从构造方法来看，我们可以指定初始化容量（initialCapacity）和负载因子（loadFactor），其中 loadFactor 的默认值为 0.75，如果指定了 initialCapacity，就会计算容量阙值（threshold）：\n\n``` java\n// tableSizeFor 会计算一个大于或等于 initialCapacity 的 2 的 N 次方的值\nthis.threshold = tableSizeFor(initialCapacity);\n\nstatic final int tableSizeFor(int cap) {                                     \n    int n = cap - 1;                                                         \n    n |= n >>> 1;                                                            \n    n |= n >>> 2;                                                            \n    n |= n >>> 4;                                                            \n    n |= n >>> 8;                                                            \n    n |= n >>> 16;                                                           \n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; \n}                                                                            \n```\n\n> initialCapacity 只会在构造函数中用到，用于计算 threshold\n\n### put 操作\n\n当调用 `put(key,value)` 的时候：\n\n``` java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n首先会根据 key 调用 `hash()` 计算哈希值，可以看到 `hash()` 中我们不仅使用 `key.hashCode()` 还将哈希值无符号右移 16 位再做一次异或操作\n\n> 在 HashMap 中，容量（capacity）是 2 的 N 次方，所以在**取余**的时候，可以用 `key & (capacity - 1)` 来代替，当 capacity 较小时，参与计算的位也比较少，比如，使用默认初始化容量 1<<4（即 16），那么计算下标：`key & (0x1111)` 参与计算的位只有 4 位，发生碰撞的概率也比较大\n\n``` java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,                  \n               boolean evict) {                                                 \n    Node<K,V>[] tab; Node<K,V> p; int n, i;                                     \n    if ((tab = table) == null || (n = tab.length) == 0) // 当 table 为空时候，需要调用 resize()                         \n        n = (tab = resize()).length;                                            \n    if ((p = tab[i = (n - 1) & hash]) == null)  // 如果当前对应 Node 为空，直接添加新的 Node 即可                                  \n        tab[i] = newNode(hash, key, value, null);                               \n    else {                                                                      \n        Node<K,V> e; K k;                                                       \n        if (p.hash == hash &&                                                   \n            ((k = p.key) == key || (key != null && key.equals(k))))  // 如果 Head Node 为结果           \n            e = p;                                                              \n        else if (p instanceof TreeNode)    // 如果是红黑树                                     \n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);     \n        else {\n            // 遍历链表\n            for (int binCount = 0; ; ++binCount) {                              \n                if ((e = p.next) == null) {\n                    // 如果没有找到匹配的 Node，添加一个新的 Node\n                    p.next = newNode(hash, key, value, null);                   \n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st \n                        // 转换为红黑树\n                        treeifyBin(tab, hash);                                  \n                    break;                                                      \n                }                                                               \n                if (e.hash == hash &&                                           \n                    ((k = e.key) == key || (key != null && key.equals(k)))) // 找到已存在的 Node    \n                    break;                                                      \n                p = e;                                                          \n            }                                                                   \n        }                                                                       \n        if (e != null) { // existing mapping for key\n            // key 对应的 Node 已存在\n            V oldValue = e.value;                                               \n            if (!onlyIfAbsent || oldValue == null)                              \n                e.value = value;                                                \n            afterNodeAccess(e);                                                 \n            return oldValue;                                                    \n        }                                                                       \n    }\n    // 添加新的 Node，modCount 改变\n    ++modCount;                                                                 \n    if (++size > threshold) // size 大于阙值，需要扩容                                                     \n        resize();                                                               \n    afterNodeInsertion(evict);                                                  \n    return null;                                                                \n}                                                                               \n```\n\n如果 table 为空的时候，会先调用 `resize()` 来做初始化\n\n``` java\nfinal Node<K,V>[] resize() {                                                    \n    Node<K,V>[] oldTab = table;                                                 \n    int oldCap = (oldTab == null) ? 0 : oldTab.length;                          \n    int oldThr = threshold;                                                     \n    int newCap, newThr = 0;                                                     \n    if (oldCap > 0) {\n        // 如果为扩容操作\n        if (oldCap >= MAXIMUM_CAPACITY) {                                       \n            threshold = Integer.MAX_VALUE;                                      \n            return oldTab;                                                      \n        }\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&                   \n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            // capacity 左移一位，双倍\n            // 调用 resize 初始化的时候，会将 capacity 设置为默认值 16\n            newThr = oldThr << 1; // double threshold                           \n    }                                                                           \n    else if (oldThr > 0) // initial capacity was placed in threshold\n        // 当使用指定 capacity 的构造方法时，会使用 tableSizeFor 初始化 threshold，2 的 N 次方\n        newCap = oldThr;                                                        \n    else {               // zero initial threshold signifies using defaults\n        // 初始化\n        newCap = DEFAULT_INITIAL_CAPACITY;                                      \n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);         \n    }                                                                           \n    if (newThr == 0) {\n        // 计算 threshold = capacity * loadFactor\n        float ft = (float)newCap * loadFactor;                                  \n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?   \n                  (int)ft : Integer.MAX_VALUE);                                 \n    }                                                                           \n    threshold = newThr;                                                         \n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    // 创建新的 table\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];                     \n    table = newTab;                                                             \n    if (oldTab != null) {\n        // 拷贝旧的 table\n        for (int j = 0; j < oldCap; ++j) {                                      \n            Node<K,V> e;                                                        \n            if ((e = oldTab[j]) != null) {                                      \n                oldTab[j] = null;                                               \n                if (e.next == null) // 如果只有一个 Node                                             \n                    newTab[e.hash & (newCap - 1)] = e;                          \n                else if (e instanceof TreeNode)  // 如果为红黑树                               \n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);          \n                else { // preserve order  保持顺序\n                    // 旧下标的链表\n                    Node<K,V> loHead = null, loTail = null;                     \n                    // 新下标（oldIndex + oldCapacity）的链表\n                    Node<K,V> hiHead = null, hiTail = null;                     \n                    Node<K,V> next;                                             \n                    do {                                                        \n                        next = e.next;                                          \n                        if ((e.hash & oldCap) == 0) {                           \n                            if (loTail == null)                                 \n                                loHead = e;                                     \n                            else                                                \n                                loTail.next = e;                                \n                            loTail = e;                                         \n                        }                                                       \n                        else {                                                  \n                            if (hiTail == null)                                 \n                                hiHead = e;                                     \n                            else                                                \n                                hiTail.next = e;                                \n                            hiTail = e;                                         \n                        }                                                       \n                    } while ((e = next) != null);                               \n                    if (loTail != null) {                                       \n                        loTail.next = null;                                     \n                        newTab[j] = loHead;                                     \n                    }                                                           \n                    if (hiTail != null) {                                       \n                        hiTail.next = null;                                     \n                        newTab[j + oldCap] = hiHead;                            \n                    }                                                           \n                }                                                               \n            }                                                                   \n        }                                                                       \n    }                                                                           \n    return newTab;                                                              \n}                                                                               \n```\n\n`resize()` 时如果需要扩容，会发生 table 拷贝，如果 Head Node 存储数据结构为链表时，会保持原来链表的顺序，同时使用两个新的链表去保存，一个链表为旧下标位置，一个链表为 旧下标+旧容量 位置\n\n> 新下标要么为旧值，要么为旧值 + 旧容量，根据 (hash & oldCap == 0)，如果为 1，表示旧值+ 旧容量，因为容量为 2 的 N 次方，当 hash(key) 中和 capacity 的最高 1 位相对应的位为 1，则新容量时这个位会更新为 1，即添加 oldCap\n>\n> 举个例子：hash(key) = 17 即 0x10001，容量为 16，下标为 `hash(key) & (cap - 1) = 1` ，扩容后，新容量为 32，下标为 `hash(key) & (cap - 1) = 17`\n\n在查找是否存在 key 对应的值时，先判断引用是否相等，否则，如果 key 不为 null，则调用 `equals()` 去比较 \n\n```java\n((k = p.key) == key || (key != null && key.equals(k)))\n```\n\n### remove 操作\n\n根据 key 删除键值队，同样的先对 key 进行 hash ，再调用 `removeNode()`\n\n``` java\nfinal Node<K,V> removeNode(int hash, Object key, Object value,                 \n                           boolean matchValue, boolean movable) {              \n    Node<K,V>[] tab; Node<K,V> p; int n, index;                                \n    if ((tab = table) != null && (n = tab.length) > 0 &&                       \n        (p = tab[index = (n - 1) & hash]) != null) {                           \n        Node<K,V> node = null, e; K k; V v;                                    \n        if (p.hash == hash &&                                                  \n            ((k = p.key) == key || (key != null && key.equals(k))))    // 如果头部节点 即为需要删除的节点         \n            node = p;                                                          \n        else if ((e = p.next) != null) {                                       \n            if (p instanceof TreeNode)                                         \n                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);    // 红黑树节点          \n            else {                                                             \n                do {                                                           \n                    if (e.hash == hash &&                                      \n                        ((k = e.key) == key ||                                 \n                         (key != null && key.equals(k)))) {                    \n                        node = e;                                              \n                        break;                                                 \n                    }                                                          \n                    p = e;                                                     \n                } while ((e = e.next) != null);                                \n            }                                                                  \n        }                                                                      \n        if (node != null && (!matchValue || (v = node.value) == value ||       \n                             (value != null && value.equals(v)))) {\n            // 存在需要删除的节点\n            if (node instanceof TreeNode)                                      \n                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);  // 红黑树    \n            else if (node == p)         // 删除节点为头部节点                                       \n                tab[index] = node.next;                                        \n            else                        // p 为删除节点的父节点                                       \n                p.next = node.next;                                            \n            ++modCount;                                                        \n            --size;                                                            \n            afterNodeRemoval(node);                                            \n            return node;                                                       \n        }                                                                      \n    }                                                                          \n    return null;                                                               \n}                                                                              \n```\n\n\n\n","source":"_posts/HashMap源码分析.md","raw":"---\ntitle: HashMap源码分析\ndate: 2018-11-07 11:39:06\ncategories: Java\ntags:\n---\n\n### 构造方法\n\n从构造方法来看，我们可以指定初始化容量（initialCapacity）和负载因子（loadFactor），其中 loadFactor 的默认值为 0.75，如果指定了 initialCapacity，就会计算容量阙值（threshold）：\n\n``` java\n// tableSizeFor 会计算一个大于或等于 initialCapacity 的 2 的 N 次方的值\nthis.threshold = tableSizeFor(initialCapacity);\n\nstatic final int tableSizeFor(int cap) {                                     \n    int n = cap - 1;                                                         \n    n |= n >>> 1;                                                            \n    n |= n >>> 2;                                                            \n    n |= n >>> 4;                                                            \n    n |= n >>> 8;                                                            \n    n |= n >>> 16;                                                           \n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; \n}                                                                            \n```\n\n> initialCapacity 只会在构造函数中用到，用于计算 threshold\n\n### put 操作\n\n当调用 `put(key,value)` 的时候：\n\n``` java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n首先会根据 key 调用 `hash()` 计算哈希值，可以看到 `hash()` 中我们不仅使用 `key.hashCode()` 还将哈希值无符号右移 16 位再做一次异或操作\n\n> 在 HashMap 中，容量（capacity）是 2 的 N 次方，所以在**取余**的时候，可以用 `key & (capacity - 1)` 来代替，当 capacity 较小时，参与计算的位也比较少，比如，使用默认初始化容量 1<<4（即 16），那么计算下标：`key & (0x1111)` 参与计算的位只有 4 位，发生碰撞的概率也比较大\n\n``` java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,                  \n               boolean evict) {                                                 \n    Node<K,V>[] tab; Node<K,V> p; int n, i;                                     \n    if ((tab = table) == null || (n = tab.length) == 0) // 当 table 为空时候，需要调用 resize()                         \n        n = (tab = resize()).length;                                            \n    if ((p = tab[i = (n - 1) & hash]) == null)  // 如果当前对应 Node 为空，直接添加新的 Node 即可                                  \n        tab[i] = newNode(hash, key, value, null);                               \n    else {                                                                      \n        Node<K,V> e; K k;                                                       \n        if (p.hash == hash &&                                                   \n            ((k = p.key) == key || (key != null && key.equals(k))))  // 如果 Head Node 为结果           \n            e = p;                                                              \n        else if (p instanceof TreeNode)    // 如果是红黑树                                     \n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);     \n        else {\n            // 遍历链表\n            for (int binCount = 0; ; ++binCount) {                              \n                if ((e = p.next) == null) {\n                    // 如果没有找到匹配的 Node，添加一个新的 Node\n                    p.next = newNode(hash, key, value, null);                   \n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st \n                        // 转换为红黑树\n                        treeifyBin(tab, hash);                                  \n                    break;                                                      \n                }                                                               \n                if (e.hash == hash &&                                           \n                    ((k = e.key) == key || (key != null && key.equals(k)))) // 找到已存在的 Node    \n                    break;                                                      \n                p = e;                                                          \n            }                                                                   \n        }                                                                       \n        if (e != null) { // existing mapping for key\n            // key 对应的 Node 已存在\n            V oldValue = e.value;                                               \n            if (!onlyIfAbsent || oldValue == null)                              \n                e.value = value;                                                \n            afterNodeAccess(e);                                                 \n            return oldValue;                                                    \n        }                                                                       \n    }\n    // 添加新的 Node，modCount 改变\n    ++modCount;                                                                 \n    if (++size > threshold) // size 大于阙值，需要扩容                                                     \n        resize();                                                               \n    afterNodeInsertion(evict);                                                  \n    return null;                                                                \n}                                                                               \n```\n\n如果 table 为空的时候，会先调用 `resize()` 来做初始化\n\n``` java\nfinal Node<K,V>[] resize() {                                                    \n    Node<K,V>[] oldTab = table;                                                 \n    int oldCap = (oldTab == null) ? 0 : oldTab.length;                          \n    int oldThr = threshold;                                                     \n    int newCap, newThr = 0;                                                     \n    if (oldCap > 0) {\n        // 如果为扩容操作\n        if (oldCap >= MAXIMUM_CAPACITY) {                                       \n            threshold = Integer.MAX_VALUE;                                      \n            return oldTab;                                                      \n        }\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&                   \n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            // capacity 左移一位，双倍\n            // 调用 resize 初始化的时候，会将 capacity 设置为默认值 16\n            newThr = oldThr << 1; // double threshold                           \n    }                                                                           \n    else if (oldThr > 0) // initial capacity was placed in threshold\n        // 当使用指定 capacity 的构造方法时，会使用 tableSizeFor 初始化 threshold，2 的 N 次方\n        newCap = oldThr;                                                        \n    else {               // zero initial threshold signifies using defaults\n        // 初始化\n        newCap = DEFAULT_INITIAL_CAPACITY;                                      \n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);         \n    }                                                                           \n    if (newThr == 0) {\n        // 计算 threshold = capacity * loadFactor\n        float ft = (float)newCap * loadFactor;                                  \n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?   \n                  (int)ft : Integer.MAX_VALUE);                                 \n    }                                                                           \n    threshold = newThr;                                                         \n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    // 创建新的 table\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];                     \n    table = newTab;                                                             \n    if (oldTab != null) {\n        // 拷贝旧的 table\n        for (int j = 0; j < oldCap; ++j) {                                      \n            Node<K,V> e;                                                        \n            if ((e = oldTab[j]) != null) {                                      \n                oldTab[j] = null;                                               \n                if (e.next == null) // 如果只有一个 Node                                             \n                    newTab[e.hash & (newCap - 1)] = e;                          \n                else if (e instanceof TreeNode)  // 如果为红黑树                               \n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);          \n                else { // preserve order  保持顺序\n                    // 旧下标的链表\n                    Node<K,V> loHead = null, loTail = null;                     \n                    // 新下标（oldIndex + oldCapacity）的链表\n                    Node<K,V> hiHead = null, hiTail = null;                     \n                    Node<K,V> next;                                             \n                    do {                                                        \n                        next = e.next;                                          \n                        if ((e.hash & oldCap) == 0) {                           \n                            if (loTail == null)                                 \n                                loHead = e;                                     \n                            else                                                \n                                loTail.next = e;                                \n                            loTail = e;                                         \n                        }                                                       \n                        else {                                                  \n                            if (hiTail == null)                                 \n                                hiHead = e;                                     \n                            else                                                \n                                hiTail.next = e;                                \n                            hiTail = e;                                         \n                        }                                                       \n                    } while ((e = next) != null);                               \n                    if (loTail != null) {                                       \n                        loTail.next = null;                                     \n                        newTab[j] = loHead;                                     \n                    }                                                           \n                    if (hiTail != null) {                                       \n                        hiTail.next = null;                                     \n                        newTab[j + oldCap] = hiHead;                            \n                    }                                                           \n                }                                                               \n            }                                                                   \n        }                                                                       \n    }                                                                           \n    return newTab;                                                              \n}                                                                               \n```\n\n`resize()` 时如果需要扩容，会发生 table 拷贝，如果 Head Node 存储数据结构为链表时，会保持原来链表的顺序，同时使用两个新的链表去保存，一个链表为旧下标位置，一个链表为 旧下标+旧容量 位置\n\n> 新下标要么为旧值，要么为旧值 + 旧容量，根据 (hash & oldCap == 0)，如果为 1，表示旧值+ 旧容量，因为容量为 2 的 N 次方，当 hash(key) 中和 capacity 的最高 1 位相对应的位为 1，则新容量时这个位会更新为 1，即添加 oldCap\n>\n> 举个例子：hash(key) = 17 即 0x10001，容量为 16，下标为 `hash(key) & (cap - 1) = 1` ，扩容后，新容量为 32，下标为 `hash(key) & (cap - 1) = 17`\n\n在查找是否存在 key 对应的值时，先判断引用是否相等，否则，如果 key 不为 null，则调用 `equals()` 去比较 \n\n```java\n((k = p.key) == key || (key != null && key.equals(k)))\n```\n\n### remove 操作\n\n根据 key 删除键值队，同样的先对 key 进行 hash ，再调用 `removeNode()`\n\n``` java\nfinal Node<K,V> removeNode(int hash, Object key, Object value,                 \n                           boolean matchValue, boolean movable) {              \n    Node<K,V>[] tab; Node<K,V> p; int n, index;                                \n    if ((tab = table) != null && (n = tab.length) > 0 &&                       \n        (p = tab[index = (n - 1) & hash]) != null) {                           \n        Node<K,V> node = null, e; K k; V v;                                    \n        if (p.hash == hash &&                                                  \n            ((k = p.key) == key || (key != null && key.equals(k))))    // 如果头部节点 即为需要删除的节点         \n            node = p;                                                          \n        else if ((e = p.next) != null) {                                       \n            if (p instanceof TreeNode)                                         \n                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);    // 红黑树节点          \n            else {                                                             \n                do {                                                           \n                    if (e.hash == hash &&                                      \n                        ((k = e.key) == key ||                                 \n                         (key != null && key.equals(k)))) {                    \n                        node = e;                                              \n                        break;                                                 \n                    }                                                          \n                    p = e;                                                     \n                } while ((e = e.next) != null);                                \n            }                                                                  \n        }                                                                      \n        if (node != null && (!matchValue || (v = node.value) == value ||       \n                             (value != null && value.equals(v)))) {\n            // 存在需要删除的节点\n            if (node instanceof TreeNode)                                      \n                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);  // 红黑树    \n            else if (node == p)         // 删除节点为头部节点                                       \n                tab[index] = node.next;                                        \n            else                        // p 为删除节点的父节点                                       \n                p.next = node.next;                                            \n            ++modCount;                                                        \n            --size;                                                            \n            afterNodeRemoval(node);                                            \n            return node;                                                       \n        }                                                                      \n    }                                                                          \n    return null;                                                               \n}                                                                              \n```\n\n\n\n","slug":"HashMap源码分析","published":1,"updated":"2018-11-08T06:07:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs0y000de39keb5dxhq1","content":"<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p>从构造方法来看，我们可以指定初始化容量（initialCapacity）和负载因子（loadFactor），其中 loadFactor 的默认值为 0.75，如果指定了 initialCapacity，就会计算容量阙值（threshold）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tableSizeFor 会计算一个大于或等于 initialCapacity 的 2 的 N 次方的值</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;                                                         </span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;                                                            </span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;                                                            </span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;                                                            </span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;                                                            </span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;                                                           </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>initialCapacity 只会在构造函数中用到，用于计算 threshold</p>\n</blockquote>\n<h3 id=\"put-操作\"><a href=\"#put-操作\" class=\"headerlink\" title=\"put 操作\"></a>put 操作</h3><p>当调用 <code>put(key,value)</code> 的时候：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先会根据 key 调用 <code>hash()</code> 计算哈希值，可以看到 <code>hash()</code> 中我们不仅使用 <code>key.hashCode()</code> 还将哈希值无符号右移 16 位再做一次异或操作</p>\n<blockquote>\n<p>在 HashMap 中，容量（capacity）是 2 的 N 次方，所以在<strong>取余</strong>的时候，可以用 <code>key &amp; (capacity - 1)</code> 来代替，当 capacity 较小时，参与计算的位也比较少，比如，使用默认初始化容量 1&lt;&lt;4（即 16），那么计算下标：<code>key &amp; (0x1111)</code> 参与计算的位只有 4 位，发生碰撞的概率也比较大</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,                  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;                                                 </span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>) <span class=\"comment\">// 当 table 为空时候，需要调用 resize()                         </span></span><br><span class=\"line\">        n = (tab = resize()).length;                                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)  <span class=\"comment\">// 如果当前对应 Node 为空，直接添加新的 Node 即可                                  </span></span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);                               </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;                                                                      </span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;                                                   </span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))  <span class=\"comment\">// 如果 Head Node 为结果           </span></span><br><span class=\"line\">            e = p;                                                              </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)    <span class=\"comment\">// 如果是红黑树                                     </span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);     </span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果没有找到匹配的 Node，添加一个新的 Node</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);                   </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st </span></span><br><span class=\"line\">                        <span class=\"comment\">// 转换为红黑树</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);                                  </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                      </span><br><span class=\"line\">                &#125;                                                               </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;                                           </span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) <span class=\"comment\">// 找到已存在的 Node    </span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                      </span><br><span class=\"line\">                p = e;                                                          </span><br><span class=\"line\">            &#125;                                                                   </span><br><span class=\"line\">        &#125;                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            <span class=\"comment\">// key 对应的 Node 已存在</span></span><br><span class=\"line\">            V oldValue = e.value;                                               </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)                              </span><br><span class=\"line\">                e.value = value;                                                </span><br><span class=\"line\">            afterNodeAccess(e);                                                 </span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;                                                    </span><br><span class=\"line\">        &#125;                                                                       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 添加新的 Node，modCount 改变</span></span><br><span class=\"line\">    ++modCount;                                                                 </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold) <span class=\"comment\">// size 大于阙值，需要扩容                                                     </span></span><br><span class=\"line\">        resize();                                                               </span><br><span class=\"line\">    afterNodeInsertion(evict);                                                  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果 table 为空的时候，会先调用 <code>resize()</code> 来做初始化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;                                                    </span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;                                                 </span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;                          </span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;                                                     </span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;                                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果为扩容操作</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;                                       </span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;                                      </span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;                                                      </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                   </span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            <span class=\"comment\">// capacity 左移一位，双倍</span></span><br><span class=\"line\">            <span class=\"comment\">// 调用 resize 初始化的时候，会将 capacity 设置为默认值 16</span></span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold                           </span></span><br><span class=\"line\">    &#125;                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        <span class=\"comment\">// 当使用指定 capacity 的构造方法时，会使用 tableSizeFor 初始化 threshold，2 的 N 次方</span></span><br><span class=\"line\">        newCap = oldThr;                                                        </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;                                      </span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);         </span><br><span class=\"line\">    &#125;                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算 threshold = capacity * loadFactor</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;                                  </span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?   </span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);                                 </span><br><span class=\"line\">    &#125;                                                                           </span><br><span class=\"line\">    threshold = newThr;                                                         </span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 创建新的 table</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];                     </span><br><span class=\"line\">    table = newTab;                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拷贝旧的 table</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;                                      </span><br><span class=\"line\">            Node&lt;K,V&gt; e;                                                        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;                                      </span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;                                               </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>) <span class=\"comment\">// 如果只有一个 Node                                             </span></span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;                          </span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)  <span class=\"comment\">// 如果为红黑树                               </span></span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);          </span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order  保持顺序</span></span><br><span class=\"line\">                    <span class=\"comment\">// 旧下标的链表</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;                     </span><br><span class=\"line\">                    <span class=\"comment\">// 新下标（oldIndex + oldCapacity）的链表</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;                     </span><br><span class=\"line\">                    Node&lt;K,V&gt; next;                                             </span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;                                                        </span><br><span class=\"line\">                        next = e.next;                                          </span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;                           </span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)                                 </span><br><span class=\"line\">                                loHead = e;                                     </span><br><span class=\"line\">                            <span class=\"keyword\">else</span>                                                </span><br><span class=\"line\">                                loTail.next = e;                                </span><br><span class=\"line\">                            loTail = e;                                         </span><br><span class=\"line\">                        &#125;                                                       </span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;                                                  </span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)                                 </span><br><span class=\"line\">                                hiHead = e;                                     </span><br><span class=\"line\">                            <span class=\"keyword\">else</span>                                                </span><br><span class=\"line\">                                hiTail.next = e;                                </span><br><span class=\"line\">                            hiTail = e;                                         </span><br><span class=\"line\">                        &#125;                                                       </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);                               </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;                                     </span><br><span class=\"line\">                        newTab[j] = loHead;                                     </span><br><span class=\"line\">                    &#125;                                                           </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;                                     </span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;                            </span><br><span class=\"line\">                    &#125;                                                           </span><br><span class=\"line\">                &#125;                                                               </span><br><span class=\"line\">            &#125;                                                                   </span><br><span class=\"line\">        &#125;                                                                       </span><br><span class=\"line\">    &#125;                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;                                                              </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>resize()</code> 时如果需要扩容，会发生 table 拷贝，如果 Head Node 存储数据结构为链表时，会保持原来链表的顺序，同时使用两个新的链表去保存，一个链表为旧下标位置，一个链表为 旧下标+旧容量 位置</p>\n<blockquote>\n<p>新下标要么为旧值，要么为旧值 + 旧容量，根据 (hash &amp; oldCap == 0)，如果为 1，表示旧值+ 旧容量，因为容量为 2 的 N 次方，当 hash(key) 中和 capacity 的最高 1 位相对应的位为 1，则新容量时这个位会更新为 1，即添加 oldCap</p>\n<p>举个例子：hash(key) = 17 即 0x10001，容量为 16，下标为 <code>hash(key) &amp; (cap - 1) = 1</code> ，扩容后，新容量为 32，下标为 <code>hash(key) &amp; (cap - 1) = 17</code></p>\n</blockquote>\n<p>在查找是否存在 key 对应的值时，先判断引用是否相等，否则，如果 key 不为 null，则调用 <code>equals()</code> 去比较 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"remove-操作\"><a href=\"#remove-操作\" class=\"headerlink\" title=\"remove 操作\"></a>remove 操作</h3><p>根据 key 删除键值队，同样的先对 key 进行 hash ，再调用 <code>removeNode()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,                 </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;              </span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;                       </span><br><span class=\"line\">        (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;                           </span><br><span class=\"line\">        Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;                                                  </span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))    <span class=\"comment\">// 如果头部节点 即为需要删除的节点         </span></span><br><span class=\"line\">            node = p;                                                          </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)                                         </span><br><span class=\"line\">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);    <span class=\"comment\">// 红黑树节点          </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;                                                             </span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;                                                           </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;                                      </span><br><span class=\"line\">                        ((k = e.key) == key ||                                 </span><br><span class=\"line\">                         (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;                    </span><br><span class=\"line\">                        node = e;                                              </span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;                                                 </span><br><span class=\"line\">                    &#125;                                                          </span><br><span class=\"line\">                    p = e;                                                     </span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);                                </span><br><span class=\"line\">            &#125;                                                                  </span><br><span class=\"line\">        &#125;                                                                      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||       </span><br><span class=\"line\">                             (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 存在需要删除的节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)                                      </span><br><span class=\"line\">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);  <span class=\"comment\">// 红黑树    </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)         <span class=\"comment\">// 删除节点为头部节点                                       </span></span><br><span class=\"line\">                tab[index] = node.next;                                        </span><br><span class=\"line\">            <span class=\"keyword\">else</span>                        <span class=\"comment\">// p 为删除节点的父节点                                       </span></span><br><span class=\"line\">                p.next = node.next;                                            </span><br><span class=\"line\">            ++modCount;                                                        </span><br><span class=\"line\">            --size;                                                            </span><br><span class=\"line\">            afterNodeRemoval(node);                                            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;                                                       </span><br><span class=\"line\">        &#125;                                                                      </span><br><span class=\"line\">    &#125;                                                                          </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p>从构造方法来看，我们可以指定初始化容量（initialCapacity）和负载因子（loadFactor），其中 loadFactor 的默认值为 0.75，如果指定了 initialCapacity，就会计算容量阙值（threshold）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tableSizeFor 会计算一个大于或等于 initialCapacity 的 2 的 N 次方的值</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;                                                         </span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;                                                            </span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;                                                            </span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;                                                            </span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;                                                            </span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;                                                           </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>initialCapacity 只会在构造函数中用到，用于计算 threshold</p>\n</blockquote>\n<h3 id=\"put-操作\"><a href=\"#put-操作\" class=\"headerlink\" title=\"put 操作\"></a>put 操作</h3><p>当调用 <code>put(key,value)</code> 的时候：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先会根据 key 调用 <code>hash()</code> 计算哈希值，可以看到 <code>hash()</code> 中我们不仅使用 <code>key.hashCode()</code> 还将哈希值无符号右移 16 位再做一次异或操作</p>\n<blockquote>\n<p>在 HashMap 中，容量（capacity）是 2 的 N 次方，所以在<strong>取余</strong>的时候，可以用 <code>key &amp; (capacity - 1)</code> 来代替，当 capacity 较小时，参与计算的位也比较少，比如，使用默认初始化容量 1&lt;&lt;4（即 16），那么计算下标：<code>key &amp; (0x1111)</code> 参与计算的位只有 4 位，发生碰撞的概率也比较大</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,                  </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;                                                 </span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>) <span class=\"comment\">// 当 table 为空时候，需要调用 resize()                         </span></span><br><span class=\"line\">        n = (tab = resize()).length;                                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)  <span class=\"comment\">// 如果当前对应 Node 为空，直接添加新的 Node 即可                                  </span></span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);                               </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;                                                                      </span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;                                                   </span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))  <span class=\"comment\">// 如果 Head Node 为结果           </span></span><br><span class=\"line\">            e = p;                                                              </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)    <span class=\"comment\">// 如果是红黑树                                     </span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);     </span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;                              </span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果没有找到匹配的 Node，添加一个新的 Node</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);                   </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st </span></span><br><span class=\"line\">                        <span class=\"comment\">// 转换为红黑树</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);                                  </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                      </span><br><span class=\"line\">                &#125;                                                               </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;                                           </span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) <span class=\"comment\">// 找到已存在的 Node    </span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                      </span><br><span class=\"line\">                p = e;                                                          </span><br><span class=\"line\">            &#125;                                                                   </span><br><span class=\"line\">        &#125;                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            <span class=\"comment\">// key 对应的 Node 已存在</span></span><br><span class=\"line\">            V oldValue = e.value;                                               </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)                              </span><br><span class=\"line\">                e.value = value;                                                </span><br><span class=\"line\">            afterNodeAccess(e);                                                 </span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;                                                    </span><br><span class=\"line\">        &#125;                                                                       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 添加新的 Node，modCount 改变</span></span><br><span class=\"line\">    ++modCount;                                                                 </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold) <span class=\"comment\">// size 大于阙值，需要扩容                                                     </span></span><br><span class=\"line\">        resize();                                                               </span><br><span class=\"line\">    afterNodeInsertion(evict);                                                  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果 table 为空的时候，会先调用 <code>resize()</code> 来做初始化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;                                                    </span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;                                                 </span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;                          </span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;                                                     </span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;                                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果为扩容操作</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;                                       </span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;                                      </span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;                                                      </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                   </span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            <span class=\"comment\">// capacity 左移一位，双倍</span></span><br><span class=\"line\">            <span class=\"comment\">// 调用 resize 初始化的时候，会将 capacity 设置为默认值 16</span></span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold                           </span></span><br><span class=\"line\">    &#125;                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        <span class=\"comment\">// 当使用指定 capacity 的构造方法时，会使用 tableSizeFor 初始化 threshold，2 的 N 次方</span></span><br><span class=\"line\">        newCap = oldThr;                                                        </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;                                      </span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);         </span><br><span class=\"line\">    &#125;                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算 threshold = capacity * loadFactor</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;                                  </span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?   </span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);                                 </span><br><span class=\"line\">    &#125;                                                                           </span><br><span class=\"line\">    threshold = newThr;                                                         </span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 创建新的 table</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];                     </span><br><span class=\"line\">    table = newTab;                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拷贝旧的 table</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;                                      </span><br><span class=\"line\">            Node&lt;K,V&gt; e;                                                        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;                                      </span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;                                               </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>) <span class=\"comment\">// 如果只有一个 Node                                             </span></span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;                          </span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)  <span class=\"comment\">// 如果为红黑树                               </span></span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);          </span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order  保持顺序</span></span><br><span class=\"line\">                    <span class=\"comment\">// 旧下标的链表</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;                     </span><br><span class=\"line\">                    <span class=\"comment\">// 新下标（oldIndex + oldCapacity）的链表</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;                     </span><br><span class=\"line\">                    Node&lt;K,V&gt; next;                                             </span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;                                                        </span><br><span class=\"line\">                        next = e.next;                                          </span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;                           </span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)                                 </span><br><span class=\"line\">                                loHead = e;                                     </span><br><span class=\"line\">                            <span class=\"keyword\">else</span>                                                </span><br><span class=\"line\">                                loTail.next = e;                                </span><br><span class=\"line\">                            loTail = e;                                         </span><br><span class=\"line\">                        &#125;                                                       </span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;                                                  </span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)                                 </span><br><span class=\"line\">                                hiHead = e;                                     </span><br><span class=\"line\">                            <span class=\"keyword\">else</span>                                                </span><br><span class=\"line\">                                hiTail.next = e;                                </span><br><span class=\"line\">                            hiTail = e;                                         </span><br><span class=\"line\">                        &#125;                                                       </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);                               </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;                                     </span><br><span class=\"line\">                        newTab[j] = loHead;                                     </span><br><span class=\"line\">                    &#125;                                                           </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;                                     </span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;                            </span><br><span class=\"line\">                    &#125;                                                           </span><br><span class=\"line\">                &#125;                                                               </span><br><span class=\"line\">            &#125;                                                                   </span><br><span class=\"line\">        &#125;                                                                       </span><br><span class=\"line\">    &#125;                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;                                                              </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>resize()</code> 时如果需要扩容，会发生 table 拷贝，如果 Head Node 存储数据结构为链表时，会保持原来链表的顺序，同时使用两个新的链表去保存，一个链表为旧下标位置，一个链表为 旧下标+旧容量 位置</p>\n<blockquote>\n<p>新下标要么为旧值，要么为旧值 + 旧容量，根据 (hash &amp; oldCap == 0)，如果为 1，表示旧值+ 旧容量，因为容量为 2 的 N 次方，当 hash(key) 中和 capacity 的最高 1 位相对应的位为 1，则新容量时这个位会更新为 1，即添加 oldCap</p>\n<p>举个例子：hash(key) = 17 即 0x10001，容量为 16，下标为 <code>hash(key) &amp; (cap - 1) = 1</code> ，扩容后，新容量为 32，下标为 <code>hash(key) &amp; (cap - 1) = 17</code></p>\n</blockquote>\n<p>在查找是否存在 key 对应的值时，先判断引用是否相等，否则，如果 key 不为 null，则调用 <code>equals()</code> 去比较 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"remove-操作\"><a href=\"#remove-操作\" class=\"headerlink\" title=\"remove 操作\"></a>remove 操作</h3><p>根据 key 删除键值队，同样的先对 key 进行 hash ，再调用 <code>removeNode()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,                 </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;              </span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;                       </span><br><span class=\"line\">        (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;                           </span><br><span class=\"line\">        Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;                                    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;                                                  </span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))    <span class=\"comment\">// 如果头部节点 即为需要删除的节点         </span></span><br><span class=\"line\">            node = p;                                                          </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;                                       </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)                                         </span><br><span class=\"line\">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);    <span class=\"comment\">// 红黑树节点          </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;                                                             </span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;                                                           </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;                                      </span><br><span class=\"line\">                        ((k = e.key) == key ||                                 </span><br><span class=\"line\">                         (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;                    </span><br><span class=\"line\">                        node = e;                                              </span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;                                                 </span><br><span class=\"line\">                    &#125;                                                          </span><br><span class=\"line\">                    p = e;                                                     </span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);                                </span><br><span class=\"line\">            &#125;                                                                  </span><br><span class=\"line\">        &#125;                                                                      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||       </span><br><span class=\"line\">                             (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 存在需要删除的节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)                                      </span><br><span class=\"line\">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);  <span class=\"comment\">// 红黑树    </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)         <span class=\"comment\">// 删除节点为头部节点                                       </span></span><br><span class=\"line\">                tab[index] = node.next;                                        </span><br><span class=\"line\">            <span class=\"keyword\">else</span>                        <span class=\"comment\">// p 为删除节点的父节点                                       </span></span><br><span class=\"line\">                p.next = node.next;                                            </span><br><span class=\"line\">            ++modCount;                                                        </span><br><span class=\"line\">            --size;                                                            </span><br><span class=\"line\">            afterNodeRemoval(node);                                            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;                                                       </span><br><span class=\"line\">        &#125;                                                                      </span><br><span class=\"line\">    &#125;                                                                          </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Gradle插件-提高篇","date":"2018-05-21T00:44:35.000Z","_content":"\n## 前言\n\n在上一篇文章 [Gradle插件-基础篇](https://linxiaotao.github.io/2018/05/16/Gradle%E6%8F%92%E4%BB%B6-%E5%9F%BA%E7%A1%80%E7%AF%87/) 中，我们学习了 Plugin 的设计规范，并且通过一个非常简单的例子对自定义 Plugin 有了初步认识，在这篇文章中，我们来继续学习 Gradle Plugin 更为深入的知识点。\n\n> 本文参考 [Gradle用户手册](https://guides.gradle.org/implementing-gradle-plugins/?_ga=2.31320828.258862271.1526633053-590693097.1523454314#writing-and-using-custom-task-types) \n\n## Gradle插件\n\n> 本文涉及的所有源码都位于 [github](https://github.com/LinXiaoTao/GradleCaseProject)\n\n### 简单扩展\n\n当我们引入 Android Plugin 时，在 `android{}` 有一些常用的配置，比如：\n\n``` groovy\nandroid {\n    compileSdkVersion 27\n}\n```\n\n如果我们想在自定义的 Plugin 中也使用这样的配置，可以使用 Gradle 提供的扩展功能：`Extensions` ，在第一篇文章中我们自定义了一个简单的 `com.example.hello` 插件，我们现在就在这个基础上添加一个扩展功能，最终实现的配置如下：\n\n``` groovy\nhello {\n    outFile 'hello'\n}\n```\n\n向 outFile 指定的文件中写入一句 \"Hello World\"，如文件不存在则创建它。\n\n为了创建扩展，我们先定义一个数据模型用于读取配置：\n\n``` java\npublic class HelloModel {\n    \n    private String outFile;\n\n    public String getOutFile() {\n        return outFile;\n    }\n\n    public void setOutFile(String outFile) {\n        this.outFile = outFile;\n    }\n}\n```\n\n接着使用 `ExtensionContainer` 创建一个扩展：\n\n``` java\nproject.getExtensions().create(\"hello\", HelloModel.class);\n```\n\n`getExtensions(String,Class,Object...)` 这个方法有三个参数，第一个参数为扩展的名称即在 ***gradle*** 文件中使用的配置块，第二个参数为扩展的模型，用于定义可配置的属性，在上面的例子上，只有一个简单的 `outFile` 表示输出文件，第三个参数为可变长参数，表示模型的构造参数，在这个例子中，我们使用默认的无参构造函数。\n\n经过上面的步骤，我们已经创建好了扩展，接下来是读取扩展的属性值，还记得我们之前说的，**Gradle 是边读取边解释**，所以当我们 `apply plugin` 时，会创建好扩展，而扩展的属性值配置只能在 `apply plugin` 之后，所以我们在 plugin 中直接读取扩展属性值是不行的，必须在项目评估完成之后：\n\n``` java \nproject.afterEvaluate(project1 -> {\n            HelloModel helloModel = project1.getExtensions().getByType(HelloModel.class);\n            mLogger.quiet(\"hello : \" + helloModel);\n            if (helloModel.getOutFile() == null || helloModel.getOutFile().isEmpty()) {\n                throw new GradleException(\"outFile 不能等于空\");\n            }\n            FileOutputStream fileOutputStream = null;\n            try {\n                File outFile = project1.file(helloModel.getOutFile());\n                if (!outFile.exists()) {\n                    outFile.createNewFile();\n                }\n                fileOutputStream = new FileOutputStream(outFile);\n                fileOutputStream.write(\"Hello World\".getBytes());\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (fileOutputStream != null) {\n                    try {\n                        fileOutputStream.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n```\n\n逻辑比较简单，我们现在直接运行在 `.gradlew` 即可，可以看到在 app 目录下生成一个 ***hello*** 文件：\n\n```\nHello World\n```\n\n### 嵌套扩展\n\n如果要想实现如下 DSL 配置：\n\n``` groovy\nandroid {\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n    }\n}\n```\n\nGradle 也支持这种嵌套扩展，同样是上面的例子，我们现在想添加一个 `info` 配置块，将这部分的信息也写入到文件中，最终配置如下：\n\n``` groovy\nhello {\n    outFile = 'hello'\n    info {\n        username = \"leo\"\n        email = \"linxiaotao1993@vip.qq.com\"\n    }\n}\n```\n\n首先我们先创建一个 InfoModel，这里有个要注意的地方：用于实现扩展的类不能是 `final`，因为最终用于扩展的实现类就是继承于这个类。\n\n``` java\nstatic class InfoModel {\n        private String username;\n        private String email;\n\n        @Inject\n        public InfoModel() {\n        }\n\n        public String getUsername() {\n            return username;\n        }\n\n        public void setUsername(String username) {\n            this.username = username;\n        }\n\n        public String getEmail() {\n            return email;\n        }\n\n        public void setEmail(String email) {\n            this.email = email;\n        }\n\n        @Override\n        public String toString() {\n            return \"InfoModel{\" +\n                    \"username='\" + username + '\\'' +\n                    \", email='\" + email + '\\'' +\n                    '}';\n        }\n    }\n```\n\n上面在构造方法中添加 `@Inject` 注解是为了能用 Gradle 提供的 `ObjectFactor` 用于实现依赖注入功能。而在原来的 `HelloModel` 中，我们增加了 `private final InfoModel info;` 同时在构建函数中增加了 `ObjectFactory` 参数：\n\n``` java\npublic HelloModel(ObjectFactory objectFactory) {\n        info = objectFactory.newInstance(InfoModel.class);\n}\n```\n\n但这样还不够，还需要当 `info` 配置块被调用时所传递的实例：\n\n``` java\npublic void info(Action<InfoModel> action) {\n        action.execute(info);\n}\n```\n\n注意：这里的方法名和 DSL 中的使用的配置块名称一致。\n\n最后我们在写入文件时，将这部分配置的信息也写入，同时在生成扩展时提供 `ObjectFactor` 实例：\n\n``` java\nproject.getExtensions().create(\"hello\", HelloModel.class, project.getObjects());\n\nfileOutputStream.write(String.format(\n                        Locale.getDefault(),\n                        \"Hello World\\ncreate by %s %s\",\n                        helloModel.getInfo().getUsername(),\n                        helloModel.getInfo().getEmail()).getBytes()\n                      );\n```\n\n最后执行下就可以看到结果了。\n\n> 可以看到 Gradle 可以很方便地使用依赖注入。\n\n### 配置容器\n\n在 Android 项目中，我们可以去配置不同的构建变体：\n\n``` groovy\nflavorDimensions \"api\", \"mode\"\n    productFlavors {\n        demo {\n            dimension \"mode\"\n        }\n        full {\n            dimension \"mode\"\n        }\n        minApi24 {\n            dimension \"api\"\n        }\n        minApi23 {\n            dimension \"api\"\n        }\n    }\n```\n\n如果我们想要实现类似 `productFlavors` 这种动态生成的 DSL 配置块，我们可以使用 `NamedDomainObjectContainer` 来实现，接着上面的例子，我们最终的配置如下：\n\n``` groovy\nhello {\n    outFile = 'hello'\n    info {\n        username = \"leo\"\n        email = \"linxiaotao1993@vip.qq.com\"\n    }\n    other {\n        time {\n            value = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date())\n        }\n    }\n}\n```\n\n我们先创建 `ValueModel` 用于表示容器中每一项的格式，注意：这个类必须有个字段为 `name` ，比如上面的例子中，`name` 就是我们配置的 `time`：\n\n``` java\npublic class ValueModel {\n\n    private final String name;\n    private String value;\n\n    public ValueModel(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"ValueModel{\" +\n                \"name='\" + name + '\\'' +\n                \", value='\" + value + '\\'' +\n                '}';\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n```\n\n> 这个类不能写成内部类，静态内部类也不行\n\n接着，我们在 `HelloModel` 中同样创建 `other` 配置块，需要注意的是，这里我们要使用 `NamedDomainObjectContainer` ：\n\n``` java\npublic void other(Action<NamedDomainObjectContainer<ValueModel>> action) {\n        action.execute(other);\n}\n```\n\n而 `other` 则是这样子创建的：\n\n``` java\nother = project.container(ValueModel.class);\n```\n\n最后，同样的，我们将这块的配置也写入到 `hello` 文件中：\n\n``` java\nStringBuilder otherString = new StringBuilder();\n                helloModel.getOther().forEach(valueModel ->\n                        otherString.append(valueModel.getName())\n                                .append(\"：\")\n                                .append(valueModel.getValue())\n                                .append(\"\\n\"));\n                fileOutputStream.write(String.format(\n                        Locale.getDefault(),\n                        \"Hello World\\ncreate by %s %s\\n%s\",\n                        helloModel.getInfo().getUsername(),\n                        helloModel.getInfo().getEmail(),\n                        otherString.toString()).getBytes()\n);\n```\n\n### 懒加载属性\n\n在上面的例子中，我们都是通过使用原始数据类型去映射在构建脚本中的配置，这种方式会在配置完成之后直接映射，Gradle 4.0 提供了 `Provider` 和 `Property` 来提供懒加载属性，其中 `Provider` 表示不可变属性，`Property` 表示可变属性。这个 API 提供了两个好处：\n\n1. 可以放心地连接不同的数据模型，而不用担心某个数据模型的值是否已经知道。举个例子，比如你想将扩展中的属性映射到 task 中的属性，但扩展的属性值只有在构建脚本配置后才能知道。\n2. 避免在构建阶段进行资源密集型工作，比如当属性值时从文件中解析时\n\n使用也比较简单，首先我们先声明一个`Property<String>` 然后使用 `ObjectFactor` 去创建：\n\n``` java\nprivate final Property<String> testProperty;\n\ntestProperty = project.getObjects().property(String.class);\n```\n\n> Gradle 会自动为 `Property` 生成 setter 方法，同时允许你使用 \"=\" 操作符来设置属性值\n\n## 总结\n\n在这篇文章中，我们主要讲的是，在自定义 Plugin 中经常用的到扩展功能，下一篇文章中，我们就开始进入 Plugin 的编写。","source":"_posts/Gradle插件-提高篇.md","raw":"---\ntitle: Gradle插件-提高篇\ndate: 2018-05-21 08:44:35\ncategories: Gradle\ntags:\n---\n\n## 前言\n\n在上一篇文章 [Gradle插件-基础篇](https://linxiaotao.github.io/2018/05/16/Gradle%E6%8F%92%E4%BB%B6-%E5%9F%BA%E7%A1%80%E7%AF%87/) 中，我们学习了 Plugin 的设计规范，并且通过一个非常简单的例子对自定义 Plugin 有了初步认识，在这篇文章中，我们来继续学习 Gradle Plugin 更为深入的知识点。\n\n> 本文参考 [Gradle用户手册](https://guides.gradle.org/implementing-gradle-plugins/?_ga=2.31320828.258862271.1526633053-590693097.1523454314#writing-and-using-custom-task-types) \n\n## Gradle插件\n\n> 本文涉及的所有源码都位于 [github](https://github.com/LinXiaoTao/GradleCaseProject)\n\n### 简单扩展\n\n当我们引入 Android Plugin 时，在 `android{}` 有一些常用的配置，比如：\n\n``` groovy\nandroid {\n    compileSdkVersion 27\n}\n```\n\n如果我们想在自定义的 Plugin 中也使用这样的配置，可以使用 Gradle 提供的扩展功能：`Extensions` ，在第一篇文章中我们自定义了一个简单的 `com.example.hello` 插件，我们现在就在这个基础上添加一个扩展功能，最终实现的配置如下：\n\n``` groovy\nhello {\n    outFile 'hello'\n}\n```\n\n向 outFile 指定的文件中写入一句 \"Hello World\"，如文件不存在则创建它。\n\n为了创建扩展，我们先定义一个数据模型用于读取配置：\n\n``` java\npublic class HelloModel {\n    \n    private String outFile;\n\n    public String getOutFile() {\n        return outFile;\n    }\n\n    public void setOutFile(String outFile) {\n        this.outFile = outFile;\n    }\n}\n```\n\n接着使用 `ExtensionContainer` 创建一个扩展：\n\n``` java\nproject.getExtensions().create(\"hello\", HelloModel.class);\n```\n\n`getExtensions(String,Class,Object...)` 这个方法有三个参数，第一个参数为扩展的名称即在 ***gradle*** 文件中使用的配置块，第二个参数为扩展的模型，用于定义可配置的属性，在上面的例子上，只有一个简单的 `outFile` 表示输出文件，第三个参数为可变长参数，表示模型的构造参数，在这个例子中，我们使用默认的无参构造函数。\n\n经过上面的步骤，我们已经创建好了扩展，接下来是读取扩展的属性值，还记得我们之前说的，**Gradle 是边读取边解释**，所以当我们 `apply plugin` 时，会创建好扩展，而扩展的属性值配置只能在 `apply plugin` 之后，所以我们在 plugin 中直接读取扩展属性值是不行的，必须在项目评估完成之后：\n\n``` java \nproject.afterEvaluate(project1 -> {\n            HelloModel helloModel = project1.getExtensions().getByType(HelloModel.class);\n            mLogger.quiet(\"hello : \" + helloModel);\n            if (helloModel.getOutFile() == null || helloModel.getOutFile().isEmpty()) {\n                throw new GradleException(\"outFile 不能等于空\");\n            }\n            FileOutputStream fileOutputStream = null;\n            try {\n                File outFile = project1.file(helloModel.getOutFile());\n                if (!outFile.exists()) {\n                    outFile.createNewFile();\n                }\n                fileOutputStream = new FileOutputStream(outFile);\n                fileOutputStream.write(\"Hello World\".getBytes());\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (fileOutputStream != null) {\n                    try {\n                        fileOutputStream.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n```\n\n逻辑比较简单，我们现在直接运行在 `.gradlew` 即可，可以看到在 app 目录下生成一个 ***hello*** 文件：\n\n```\nHello World\n```\n\n### 嵌套扩展\n\n如果要想实现如下 DSL 配置：\n\n``` groovy\nandroid {\n    defaultConfig {\n        applicationId \"com.example.leo.gradlecaseproject\"\n    }\n}\n```\n\nGradle 也支持这种嵌套扩展，同样是上面的例子，我们现在想添加一个 `info` 配置块，将这部分的信息也写入到文件中，最终配置如下：\n\n``` groovy\nhello {\n    outFile = 'hello'\n    info {\n        username = \"leo\"\n        email = \"linxiaotao1993@vip.qq.com\"\n    }\n}\n```\n\n首先我们先创建一个 InfoModel，这里有个要注意的地方：用于实现扩展的类不能是 `final`，因为最终用于扩展的实现类就是继承于这个类。\n\n``` java\nstatic class InfoModel {\n        private String username;\n        private String email;\n\n        @Inject\n        public InfoModel() {\n        }\n\n        public String getUsername() {\n            return username;\n        }\n\n        public void setUsername(String username) {\n            this.username = username;\n        }\n\n        public String getEmail() {\n            return email;\n        }\n\n        public void setEmail(String email) {\n            this.email = email;\n        }\n\n        @Override\n        public String toString() {\n            return \"InfoModel{\" +\n                    \"username='\" + username + '\\'' +\n                    \", email='\" + email + '\\'' +\n                    '}';\n        }\n    }\n```\n\n上面在构造方法中添加 `@Inject` 注解是为了能用 Gradle 提供的 `ObjectFactor` 用于实现依赖注入功能。而在原来的 `HelloModel` 中，我们增加了 `private final InfoModel info;` 同时在构建函数中增加了 `ObjectFactory` 参数：\n\n``` java\npublic HelloModel(ObjectFactory objectFactory) {\n        info = objectFactory.newInstance(InfoModel.class);\n}\n```\n\n但这样还不够，还需要当 `info` 配置块被调用时所传递的实例：\n\n``` java\npublic void info(Action<InfoModel> action) {\n        action.execute(info);\n}\n```\n\n注意：这里的方法名和 DSL 中的使用的配置块名称一致。\n\n最后我们在写入文件时，将这部分配置的信息也写入，同时在生成扩展时提供 `ObjectFactor` 实例：\n\n``` java\nproject.getExtensions().create(\"hello\", HelloModel.class, project.getObjects());\n\nfileOutputStream.write(String.format(\n                        Locale.getDefault(),\n                        \"Hello World\\ncreate by %s %s\",\n                        helloModel.getInfo().getUsername(),\n                        helloModel.getInfo().getEmail()).getBytes()\n                      );\n```\n\n最后执行下就可以看到结果了。\n\n> 可以看到 Gradle 可以很方便地使用依赖注入。\n\n### 配置容器\n\n在 Android 项目中，我们可以去配置不同的构建变体：\n\n``` groovy\nflavorDimensions \"api\", \"mode\"\n    productFlavors {\n        demo {\n            dimension \"mode\"\n        }\n        full {\n            dimension \"mode\"\n        }\n        minApi24 {\n            dimension \"api\"\n        }\n        minApi23 {\n            dimension \"api\"\n        }\n    }\n```\n\n如果我们想要实现类似 `productFlavors` 这种动态生成的 DSL 配置块，我们可以使用 `NamedDomainObjectContainer` 来实现，接着上面的例子，我们最终的配置如下：\n\n``` groovy\nhello {\n    outFile = 'hello'\n    info {\n        username = \"leo\"\n        email = \"linxiaotao1993@vip.qq.com\"\n    }\n    other {\n        time {\n            value = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date())\n        }\n    }\n}\n```\n\n我们先创建 `ValueModel` 用于表示容器中每一项的格式，注意：这个类必须有个字段为 `name` ，比如上面的例子中，`name` 就是我们配置的 `time`：\n\n``` java\npublic class ValueModel {\n\n    private final String name;\n    private String value;\n\n    public ValueModel(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"ValueModel{\" +\n                \"name='\" + name + '\\'' +\n                \", value='\" + value + '\\'' +\n                '}';\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n```\n\n> 这个类不能写成内部类，静态内部类也不行\n\n接着，我们在 `HelloModel` 中同样创建 `other` 配置块，需要注意的是，这里我们要使用 `NamedDomainObjectContainer` ：\n\n``` java\npublic void other(Action<NamedDomainObjectContainer<ValueModel>> action) {\n        action.execute(other);\n}\n```\n\n而 `other` 则是这样子创建的：\n\n``` java\nother = project.container(ValueModel.class);\n```\n\n最后，同样的，我们将这块的配置也写入到 `hello` 文件中：\n\n``` java\nStringBuilder otherString = new StringBuilder();\n                helloModel.getOther().forEach(valueModel ->\n                        otherString.append(valueModel.getName())\n                                .append(\"：\")\n                                .append(valueModel.getValue())\n                                .append(\"\\n\"));\n                fileOutputStream.write(String.format(\n                        Locale.getDefault(),\n                        \"Hello World\\ncreate by %s %s\\n%s\",\n                        helloModel.getInfo().getUsername(),\n                        helloModel.getInfo().getEmail(),\n                        otherString.toString()).getBytes()\n);\n```\n\n### 懒加载属性\n\n在上面的例子中，我们都是通过使用原始数据类型去映射在构建脚本中的配置，这种方式会在配置完成之后直接映射，Gradle 4.0 提供了 `Provider` 和 `Property` 来提供懒加载属性，其中 `Provider` 表示不可变属性，`Property` 表示可变属性。这个 API 提供了两个好处：\n\n1. 可以放心地连接不同的数据模型，而不用担心某个数据模型的值是否已经知道。举个例子，比如你想将扩展中的属性映射到 task 中的属性，但扩展的属性值只有在构建脚本配置后才能知道。\n2. 避免在构建阶段进行资源密集型工作，比如当属性值时从文件中解析时\n\n使用也比较简单，首先我们先声明一个`Property<String>` 然后使用 `ObjectFactor` 去创建：\n\n``` java\nprivate final Property<String> testProperty;\n\ntestProperty = project.getObjects().property(String.class);\n```\n\n> Gradle 会自动为 `Property` 生成 setter 方法，同时允许你使用 \"=\" 操作符来设置属性值\n\n## 总结\n\n在这篇文章中，我们主要讲的是，在自定义 Plugin 中经常用的到扩展功能，下一篇文章中，我们就开始进入 Plugin 的编写。","slug":"Gradle插件-提高篇","published":1,"updated":"2018-05-27T04:41:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs10000ge39k65ryytu4","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在上一篇文章 <a href=\"https://linxiaotao.github.io/2018/05/16/Gradle%E6%8F%92%E4%BB%B6-%E5%9F%BA%E7%A1%80%E7%AF%87/\">Gradle插件-基础篇</a> 中，我们学习了 Plugin 的设计规范，并且通过一个非常简单的例子对自定义 Plugin 有了初步认识，在这篇文章中，我们来继续学习 Gradle Plugin 更为深入的知识点。</p>\n<blockquote>\n<p>本文参考 <a href=\"https://guides.gradle.org/implementing-gradle-plugins/?_ga=2.31320828.258862271.1526633053-590693097.1523454314#writing-and-using-custom-task-types\" target=\"_blank\" rel=\"noopener\">Gradle用户手册</a> </p>\n</blockquote>\n<h2 id=\"Gradle插件\"><a href=\"#Gradle插件\" class=\"headerlink\" title=\"Gradle插件\"></a>Gradle插件</h2><blockquote>\n<p>本文涉及的所有源码都位于 <a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">github</a></p>\n</blockquote>\n<h3 id=\"简单扩展\"><a href=\"#简单扩展\" class=\"headerlink\" title=\"简单扩展\"></a>简单扩展</h3><p>当我们引入 Android Plugin 时，在 <code>android{}</code> 有一些常用的配置，比如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想在自定义的 Plugin 中也使用这样的配置，可以使用 Gradle 提供的扩展功能：<code>Extensions</code> ，在第一篇文章中我们自定义了一个简单的 <code>com.example.hello</code> 插件，我们现在就在这个基础上添加一个扩展功能，最终实现的配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>向 outFile 指定的文件中写入一句 “Hello World”，如文件不存在则创建它。</p>\n<p>为了创建扩展，我们先定义一个数据模型用于读取配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloModel</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String outFile;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getOutFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outFile;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOutFile</span><span class=\"params\">(String outFile)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.outFile = outFile;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着使用 <code>ExtensionContainer</code> 创建一个扩展：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.getExtensions().create(<span class=\"string\">\"hello\"</span>, HelloModel.class);</span><br></pre></td></tr></table></figure>\n<p><code>getExtensions(String,Class,Object...)</code> 这个方法有三个参数，第一个参数为扩展的名称即在 <strong><em>gradle</em></strong> 文件中使用的配置块，第二个参数为扩展的模型，用于定义可配置的属性，在上面的例子上，只有一个简单的 <code>outFile</code> 表示输出文件，第三个参数为可变长参数，表示模型的构造参数，在这个例子中，我们使用默认的无参构造函数。</p>\n<p>经过上面的步骤，我们已经创建好了扩展，接下来是读取扩展的属性值，还记得我们之前说的，<strong>Gradle 是边读取边解释</strong>，所以当我们 <code>apply plugin</code> 时，会创建好扩展，而扩展的属性值配置只能在 <code>apply plugin</code> 之后，所以我们在 plugin 中直接读取扩展属性值是不行的，必须在项目评估完成之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.afterEvaluate(project1 -&gt; &#123;</span><br><span class=\"line\">            HelloModel helloModel = project1.getExtensions().getByType(HelloModel.class);</span><br><span class=\"line\">            mLogger.quiet(<span class=\"string\">\"hello : \"</span> + helloModel);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (helloModel.getOutFile() == <span class=\"keyword\">null</span> || helloModel.getOutFile().isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> GradleException(<span class=\"string\">\"outFile 不能等于空\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            FileOutputStream fileOutputStream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                File outFile = project1.file(helloModel.getOutFile());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!outFile.exists()) &#123;</span><br><span class=\"line\">                    outFile.createNewFile();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                fileOutputStream = <span class=\"keyword\">new</span> FileOutputStream(outFile);</span><br><span class=\"line\">                fileOutputStream.write(<span class=\"string\">\"Hello World\"</span>.getBytes());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fileOutputStream != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        fileOutputStream.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<p>逻辑比较简单，我们现在直接运行在 <code>.gradlew</code> 即可，可以看到在 app 目录下生成一个 <strong><em>hello</em></strong> 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌套扩展\"><a href=\"#嵌套扩展\" class=\"headerlink\" title=\"嵌套扩展\"></a>嵌套扩展</h3><p>如果要想实现如下 DSL 配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Gradle 也支持这种嵌套扩展，同样是上面的例子，我们现在想添加一个 <code>info</code> 配置块，将这部分的信息也写入到文件中，最终配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile = <span class=\"string\">'hello'</span></span><br><span class=\"line\">    info &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">        email = <span class=\"string\">\"linxiaotao1993@vip.qq.com\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们先创建一个 InfoModel，这里有个要注意的地方：用于实现扩展的类不能是 <code>final</code>，因为最终用于扩展的实现类就是继承于这个类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InfoModel</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Inject</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InfoModel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUsername</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> username;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.username = username;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> email;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(String email)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.email = email;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"InfoModel&#123;\"</span> +</span><br><span class=\"line\">                    <span class=\"string\">\"username='\"</span> + username + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                    <span class=\"string\">\", email='\"</span> + email + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                    <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面在构造方法中添加 <code>@Inject</code> 注解是为了能用 Gradle 提供的 <code>ObjectFactor</code> 用于实现依赖注入功能。而在原来的 <code>HelloModel</code> 中，我们增加了 <code>private final InfoModel info;</code> 同时在构建函数中增加了 <code>ObjectFactory</code> 参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloModel</span><span class=\"params\">(ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class=\"line\">        info = objectFactory.newInstance(InfoModel.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但这样还不够，还需要当 <code>info</code> 配置块被调用时所传递的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">info</span><span class=\"params\">(Action&lt;InfoModel&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        action.execute(info);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：这里的方法名和 DSL 中的使用的配置块名称一致。</p>\n<p>最后我们在写入文件时，将这部分配置的信息也写入，同时在生成扩展时提供 <code>ObjectFactor</code> 实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.getExtensions().create(<span class=\"string\">\"hello\"</span>, HelloModel.class, project.getObjects());</span><br><span class=\"line\"></span><br><span class=\"line\">fileOutputStream.write(String.format(</span><br><span class=\"line\">                        Locale.getDefault(),</span><br><span class=\"line\">                        <span class=\"string\">\"Hello World\\ncreate by %s %s\"</span>,</span><br><span class=\"line\">                        helloModel.getInfo().getUsername(),</span><br><span class=\"line\">                        helloModel.getInfo().getEmail()).getBytes()</span><br><span class=\"line\">                      );</span><br></pre></td></tr></table></figure>\n<p>最后执行下就可以看到结果了。</p>\n<blockquote>\n<p>可以看到 Gradle 可以很方便地使用依赖注入。</p>\n</blockquote>\n<h3 id=\"配置容器\"><a href=\"#配置容器\" class=\"headerlink\" title=\"配置容器\"></a>配置容器</h3><p>在 Android 项目中，我们可以去配置不同的构建变体：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flavorDimensions <span class=\"string\">\"api\"</span>, <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">    productFlavors &#123;</span><br><span class=\"line\">        demo &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        full &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        minApi24 &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"api\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        minApi23 &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"api\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想要实现类似 <code>productFlavors</code> 这种动态生成的 DSL 配置块，我们可以使用 <code>NamedDomainObjectContainer</code> 来实现，接着上面的例子，我们最终的配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile = <span class=\"string\">'hello'</span></span><br><span class=\"line\">    info &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">        email = <span class=\"string\">\"linxiaotao1993@vip.qq.com\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    other &#123;</span><br><span class=\"line\">        time &#123;</span><br><span class=\"line\">            value = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd\"</span>).format(<span class=\"keyword\">new</span> Date())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们先创建 <code>ValueModel</code> 用于表示容器中每一项的格式，注意：这个类必须有个字段为 <code>name</code> ，比如上面的例子中，<code>name</code> 就是我们配置的 <code>time</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValueModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ValueModel</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"ValueModel&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"name='\"</span> + name + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">\", value='\"</span> + value + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(String value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这个类不能写成内部类，静态内部类也不行</p>\n</blockquote>\n<p>接着，我们在 <code>HelloModel</code> 中同样创建 <code>other</code> 配置块，需要注意的是，这里我们要使用 <code>NamedDomainObjectContainer</code> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">other</span><span class=\"params\">(Action&lt;NamedDomainObjectContainer&lt;ValueModel&gt;&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        action.execute(other);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 <code>other</code> 则是这样子创建的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">other = project.container(ValueModel.class);</span><br></pre></td></tr></table></figure>\n<p>最后，同样的，我们将这块的配置也写入到 <code>hello</code> 文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder otherString = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                helloModel.getOther().forEach(valueModel -&gt;</span><br><span class=\"line\">                        otherString.append(valueModel.getName())</span><br><span class=\"line\">                                .append(<span class=\"string\">\"：\"</span>)</span><br><span class=\"line\">                                .append(valueModel.getValue())</span><br><span class=\"line\">                                .append(<span class=\"string\">\"\\n\"</span>));</span><br><span class=\"line\">                fileOutputStream.write(String.format(</span><br><span class=\"line\">                        Locale.getDefault(),</span><br><span class=\"line\">                        <span class=\"string\">\"Hello World\\ncreate by %s %s\\n%s\"</span>,</span><br><span class=\"line\">                        helloModel.getInfo().getUsername(),</span><br><span class=\"line\">                        helloModel.getInfo().getEmail(),</span><br><span class=\"line\">                        otherString.toString()).getBytes()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"懒加载属性\"><a href=\"#懒加载属性\" class=\"headerlink\" title=\"懒加载属性\"></a>懒加载属性</h3><p>在上面的例子中，我们都是通过使用原始数据类型去映射在构建脚本中的配置，这种方式会在配置完成之后直接映射，Gradle 4.0 提供了 <code>Provider</code> 和 <code>Property</code> 来提供懒加载属性，其中 <code>Provider</code> 表示不可变属性，<code>Property</code> 表示可变属性。这个 API 提供了两个好处：</p>\n<ol>\n<li>可以放心地连接不同的数据模型，而不用担心某个数据模型的值是否已经知道。举个例子，比如你想将扩展中的属性映射到 task 中的属性，但扩展的属性值只有在构建脚本配置后才能知道。</li>\n<li>避免在构建阶段进行资源密集型工作，比如当属性值时从文件中解析时</li>\n</ol>\n<p>使用也比较简单，首先我们先声明一个<code>Property&lt;String&gt;</code> 然后使用 <code>ObjectFactor</code> 去创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Property&lt;String&gt; testProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">testProperty = project.getObjects().property(String.class);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Gradle 会自动为 <code>Property</code> 生成 setter 方法，同时允许你使用 “=” 操作符来设置属性值</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在这篇文章中，我们主要讲的是，在自定义 Plugin 中经常用的到扩展功能，下一篇文章中，我们就开始进入 Plugin 的编写。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在上一篇文章 <a href=\"https://linxiaotao.github.io/2018/05/16/Gradle%E6%8F%92%E4%BB%B6-%E5%9F%BA%E7%A1%80%E7%AF%87/\">Gradle插件-基础篇</a> 中，我们学习了 Plugin 的设计规范，并且通过一个非常简单的例子对自定义 Plugin 有了初步认识，在这篇文章中，我们来继续学习 Gradle Plugin 更为深入的知识点。</p>\n<blockquote>\n<p>本文参考 <a href=\"https://guides.gradle.org/implementing-gradle-plugins/?_ga=2.31320828.258862271.1526633053-590693097.1523454314#writing-and-using-custom-task-types\" target=\"_blank\" rel=\"noopener\">Gradle用户手册</a> </p>\n</blockquote>\n<h2 id=\"Gradle插件\"><a href=\"#Gradle插件\" class=\"headerlink\" title=\"Gradle插件\"></a>Gradle插件</h2><blockquote>\n<p>本文涉及的所有源码都位于 <a href=\"https://github.com/LinXiaoTao/GradleCaseProject\" target=\"_blank\" rel=\"noopener\">github</a></p>\n</blockquote>\n<h3 id=\"简单扩展\"><a href=\"#简单扩展\" class=\"headerlink\" title=\"简单扩展\"></a>简单扩展</h3><p>当我们引入 Android Plugin 时，在 <code>android{}</code> 有一些常用的配置，比如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想在自定义的 Plugin 中也使用这样的配置，可以使用 Gradle 提供的扩展功能：<code>Extensions</code> ，在第一篇文章中我们自定义了一个简单的 <code>com.example.hello</code> 插件，我们现在就在这个基础上添加一个扩展功能，最终实现的配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>向 outFile 指定的文件中写入一句 “Hello World”，如文件不存在则创建它。</p>\n<p>为了创建扩展，我们先定义一个数据模型用于读取配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloModel</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String outFile;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getOutFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outFile;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOutFile</span><span class=\"params\">(String outFile)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.outFile = outFile;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着使用 <code>ExtensionContainer</code> 创建一个扩展：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.getExtensions().create(<span class=\"string\">\"hello\"</span>, HelloModel.class);</span><br></pre></td></tr></table></figure>\n<p><code>getExtensions(String,Class,Object...)</code> 这个方法有三个参数，第一个参数为扩展的名称即在 <strong><em>gradle</em></strong> 文件中使用的配置块，第二个参数为扩展的模型，用于定义可配置的属性，在上面的例子上，只有一个简单的 <code>outFile</code> 表示输出文件，第三个参数为可变长参数，表示模型的构造参数，在这个例子中，我们使用默认的无参构造函数。</p>\n<p>经过上面的步骤，我们已经创建好了扩展，接下来是读取扩展的属性值，还记得我们之前说的，<strong>Gradle 是边读取边解释</strong>，所以当我们 <code>apply plugin</code> 时，会创建好扩展，而扩展的属性值配置只能在 <code>apply plugin</code> 之后，所以我们在 plugin 中直接读取扩展属性值是不行的，必须在项目评估完成之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.afterEvaluate(project1 -&gt; &#123;</span><br><span class=\"line\">            HelloModel helloModel = project1.getExtensions().getByType(HelloModel.class);</span><br><span class=\"line\">            mLogger.quiet(<span class=\"string\">\"hello : \"</span> + helloModel);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (helloModel.getOutFile() == <span class=\"keyword\">null</span> || helloModel.getOutFile().isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> GradleException(<span class=\"string\">\"outFile 不能等于空\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            FileOutputStream fileOutputStream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                File outFile = project1.file(helloModel.getOutFile());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!outFile.exists()) &#123;</span><br><span class=\"line\">                    outFile.createNewFile();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                fileOutputStream = <span class=\"keyword\">new</span> FileOutputStream(outFile);</span><br><span class=\"line\">                fileOutputStream.write(<span class=\"string\">\"Hello World\"</span>.getBytes());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fileOutputStream != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        fileOutputStream.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<p>逻辑比较简单，我们现在直接运行在 <code>.gradlew</code> 即可，可以看到在 app 目录下生成一个 <strong><em>hello</em></strong> 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌套扩展\"><a href=\"#嵌套扩展\" class=\"headerlink\" title=\"嵌套扩展\"></a>嵌套扩展</h3><p>如果要想实现如下 DSL 配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.example.leo.gradlecaseproject\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Gradle 也支持这种嵌套扩展，同样是上面的例子，我们现在想添加一个 <code>info</code> 配置块，将这部分的信息也写入到文件中，最终配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile = <span class=\"string\">'hello'</span></span><br><span class=\"line\">    info &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">        email = <span class=\"string\">\"linxiaotao1993@vip.qq.com\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们先创建一个 InfoModel，这里有个要注意的地方：用于实现扩展的类不能是 <code>final</code>，因为最终用于扩展的实现类就是继承于这个类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InfoModel</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Inject</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InfoModel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUsername</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> username;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.username = username;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> email;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(String email)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.email = email;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"InfoModel&#123;\"</span> +</span><br><span class=\"line\">                    <span class=\"string\">\"username='\"</span> + username + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                    <span class=\"string\">\", email='\"</span> + email + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                    <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面在构造方法中添加 <code>@Inject</code> 注解是为了能用 Gradle 提供的 <code>ObjectFactor</code> 用于实现依赖注入功能。而在原来的 <code>HelloModel</code> 中，我们增加了 <code>private final InfoModel info;</code> 同时在构建函数中增加了 <code>ObjectFactory</code> 参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloModel</span><span class=\"params\">(ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class=\"line\">        info = objectFactory.newInstance(InfoModel.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但这样还不够，还需要当 <code>info</code> 配置块被调用时所传递的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">info</span><span class=\"params\">(Action&lt;InfoModel&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        action.execute(info);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：这里的方法名和 DSL 中的使用的配置块名称一致。</p>\n<p>最后我们在写入文件时，将这部分配置的信息也写入，同时在生成扩展时提供 <code>ObjectFactor</code> 实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project.getExtensions().create(<span class=\"string\">\"hello\"</span>, HelloModel.class, project.getObjects());</span><br><span class=\"line\"></span><br><span class=\"line\">fileOutputStream.write(String.format(</span><br><span class=\"line\">                        Locale.getDefault(),</span><br><span class=\"line\">                        <span class=\"string\">\"Hello World\\ncreate by %s %s\"</span>,</span><br><span class=\"line\">                        helloModel.getInfo().getUsername(),</span><br><span class=\"line\">                        helloModel.getInfo().getEmail()).getBytes()</span><br><span class=\"line\">                      );</span><br></pre></td></tr></table></figure>\n<p>最后执行下就可以看到结果了。</p>\n<blockquote>\n<p>可以看到 Gradle 可以很方便地使用依赖注入。</p>\n</blockquote>\n<h3 id=\"配置容器\"><a href=\"#配置容器\" class=\"headerlink\" title=\"配置容器\"></a>配置容器</h3><p>在 Android 项目中，我们可以去配置不同的构建变体：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flavorDimensions <span class=\"string\">\"api\"</span>, <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">    productFlavors &#123;</span><br><span class=\"line\">        demo &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        full &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        minApi24 &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"api\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        minApi23 &#123;</span><br><span class=\"line\">            dimension <span class=\"string\">\"api\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想要实现类似 <code>productFlavors</code> 这种动态生成的 DSL 配置块，我们可以使用 <code>NamedDomainObjectContainer</code> 来实现，接着上面的例子，我们最终的配置如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello &#123;</span><br><span class=\"line\">    outFile = <span class=\"string\">'hello'</span></span><br><span class=\"line\">    info &#123;</span><br><span class=\"line\">        username = <span class=\"string\">\"leo\"</span></span><br><span class=\"line\">        email = <span class=\"string\">\"linxiaotao1993@vip.qq.com\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    other &#123;</span><br><span class=\"line\">        time &#123;</span><br><span class=\"line\">            value = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd\"</span>).format(<span class=\"keyword\">new</span> Date())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们先创建 <code>ValueModel</code> 用于表示容器中每一项的格式，注意：这个类必须有个字段为 <code>name</code> ，比如上面的例子中，<code>name</code> 就是我们配置的 <code>time</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValueModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ValueModel</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"ValueModel&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"name='\"</span> + name + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">\", value='\"</span> + value + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(String value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这个类不能写成内部类，静态内部类也不行</p>\n</blockquote>\n<p>接着，我们在 <code>HelloModel</code> 中同样创建 <code>other</code> 配置块，需要注意的是，这里我们要使用 <code>NamedDomainObjectContainer</code> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">other</span><span class=\"params\">(Action&lt;NamedDomainObjectContainer&lt;ValueModel&gt;&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        action.execute(other);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 <code>other</code> 则是这样子创建的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">other = project.container(ValueModel.class);</span><br></pre></td></tr></table></figure>\n<p>最后，同样的，我们将这块的配置也写入到 <code>hello</code> 文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder otherString = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                helloModel.getOther().forEach(valueModel -&gt;</span><br><span class=\"line\">                        otherString.append(valueModel.getName())</span><br><span class=\"line\">                                .append(<span class=\"string\">\"：\"</span>)</span><br><span class=\"line\">                                .append(valueModel.getValue())</span><br><span class=\"line\">                                .append(<span class=\"string\">\"\\n\"</span>));</span><br><span class=\"line\">                fileOutputStream.write(String.format(</span><br><span class=\"line\">                        Locale.getDefault(),</span><br><span class=\"line\">                        <span class=\"string\">\"Hello World\\ncreate by %s %s\\n%s\"</span>,</span><br><span class=\"line\">                        helloModel.getInfo().getUsername(),</span><br><span class=\"line\">                        helloModel.getInfo().getEmail(),</span><br><span class=\"line\">                        otherString.toString()).getBytes()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"懒加载属性\"><a href=\"#懒加载属性\" class=\"headerlink\" title=\"懒加载属性\"></a>懒加载属性</h3><p>在上面的例子中，我们都是通过使用原始数据类型去映射在构建脚本中的配置，这种方式会在配置完成之后直接映射，Gradle 4.0 提供了 <code>Provider</code> 和 <code>Property</code> 来提供懒加载属性，其中 <code>Provider</code> 表示不可变属性，<code>Property</code> 表示可变属性。这个 API 提供了两个好处：</p>\n<ol>\n<li>可以放心地连接不同的数据模型，而不用担心某个数据模型的值是否已经知道。举个例子，比如你想将扩展中的属性映射到 task 中的属性，但扩展的属性值只有在构建脚本配置后才能知道。</li>\n<li>避免在构建阶段进行资源密集型工作，比如当属性值时从文件中解析时</li>\n</ol>\n<p>使用也比较简单，首先我们先声明一个<code>Property&lt;String&gt;</code> 然后使用 <code>ObjectFactor</code> 去创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Property&lt;String&gt; testProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">testProperty = project.getObjects().property(String.class);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Gradle 会自动为 <code>Property</code> 生成 setter 方法，同时允许你使用 “=” 操作符来设置属性值</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在这篇文章中，我们主要讲的是，在自定义 Plugin 中经常用的到扩展功能，下一篇文章中，我们就开始进入 Plugin 的编写。</p>\n"},{"title":"JavaScript正则表达式","date":"2018-09-08T15:20:22.000Z","_content":"\n* 快速字符\n\n  | 字符 | 说明                                                |\n  | ---- | --------------------------------------------------- |\n  | \\d   | 所有数字，相当于 [0-9]                              |\n  | \\D   | 非数字，相当于 ``[^0-9]``                           |\n  | \\s   | 空白字符，包括空格、制表符、换页符、换行符          |\n  | \\S   | 非空白字符                                          |\n  | \\w   | 单字符（字母、数字或者下划线），相当于 [A-Za-z0-9_] |\n  | \\W   | 非单字符                                            |\n\n* 使用 {} 表示出现的次数\n\n  ``` javascript\n  /s{2,6}/   // s 字符出现 2 到 6 次，要注意这些情况：ssssssss，这里会当作 ssssss ss，而匹配成功\n  ```\n\n  ``` javascript\n  /s{2,}/    // s 字符至少出现 2 次以上\n  ```\n\n  ``` javascript\n  /s {2}/\t   // s 字符精确出现 2 次\n  ```\n\n* 使用 ? 表示出现 0 次或者 1 次，等价于 {0,1}\n\n  ``` javascript\n  /apples?/\t// 匹配 aaple 和 apples\n  ```\n\n  注意：如果紧跟在任何量词 *、+、? 或 {} 的后面，将会湿的量词变为非贪婪（匹配尽量少的字符），缺省使用的是贪婪模式\n\n  ``` javascript\n  /\\d+/;\t// 对于 123abc 将会返回 123\n  /\\d+?/;\t// 对于 123abc 将会返回 1\n  ```\n\n* 使用 ^ 表示开头匹配，使用 $ 表示末尾匹配\n\n  ``` javascript\n  /^a/\t// 匹配 apple 不匹配 banana\n  /e$/\t// 匹配 apple 不匹配 element\n  ```\n\n  注意和 反向字符集 的区别\n\n  ``` javascript\n  /[^abc]/\t// 匹配不包括 abc 的字符\n  ```\n\n* 使用 /i 表示忽略大小写\n\n  ``` javascript\n  /abc/i\n  ```\n\n* 使用 /g 表示全局搜索\n\n  ``` javascript\n  /abc/g\n  ```\n\n* 使用 x(?=y) 正向肯定查找，匹配'x'仅仅当'x'后面跟着'y'.\n\n  ``` javascript\n  /Jack(?=Sprat)/\t// 会匹配到 Jack 仅当它后面跟着 Sprat，但 Sprat 不作为匹配项返回\n  ```\n\n* 使用 x(?!y) 反向否定查找，匹配'x'仅仅当'x'后面不跟着'y'\n\n  ``` javascript\n  /Jack(?!Sprat)/\t//\t会匹配到 Jack 仅当它后面不跟着 Sprat\n  ```\n\n* 使用 (x) 匹配 'x' 并且记住匹配项，括号被称为 *捕获括号*\n\n  ``` javascript\n  /(foo) (bar) \\1 \\2/;\t// 匹配 foo bar foo bar，注意空格\n  ```\n\n  如果使用 replace 功能，则需要使用 $1 等\n\n* 使用 (?:x) 匹配 'x' 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式\n\n  ``` javascript\n  /foo{2}/;\t\t// 将匹配 fooo，将 {2} 作用到 o\n  /(?:foo){2}/;\t// 将匹配 foofoo，将 {2} 作用到 foo\n  ```","source":"_posts/JavaScript正则表达式.md","raw":"---\ntitle: JavaScript正则表达式\ndate: 2018-09-08 23:20:22\ncategories:\ntags: JavaScript\n---\n\n* 快速字符\n\n  | 字符 | 说明                                                |\n  | ---- | --------------------------------------------------- |\n  | \\d   | 所有数字，相当于 [0-9]                              |\n  | \\D   | 非数字，相当于 ``[^0-9]``                           |\n  | \\s   | 空白字符，包括空格、制表符、换页符、换行符          |\n  | \\S   | 非空白字符                                          |\n  | \\w   | 单字符（字母、数字或者下划线），相当于 [A-Za-z0-9_] |\n  | \\W   | 非单字符                                            |\n\n* 使用 {} 表示出现的次数\n\n  ``` javascript\n  /s{2,6}/   // s 字符出现 2 到 6 次，要注意这些情况：ssssssss，这里会当作 ssssss ss，而匹配成功\n  ```\n\n  ``` javascript\n  /s{2,}/    // s 字符至少出现 2 次以上\n  ```\n\n  ``` javascript\n  /s {2}/\t   // s 字符精确出现 2 次\n  ```\n\n* 使用 ? 表示出现 0 次或者 1 次，等价于 {0,1}\n\n  ``` javascript\n  /apples?/\t// 匹配 aaple 和 apples\n  ```\n\n  注意：如果紧跟在任何量词 *、+、? 或 {} 的后面，将会湿的量词变为非贪婪（匹配尽量少的字符），缺省使用的是贪婪模式\n\n  ``` javascript\n  /\\d+/;\t// 对于 123abc 将会返回 123\n  /\\d+?/;\t// 对于 123abc 将会返回 1\n  ```\n\n* 使用 ^ 表示开头匹配，使用 $ 表示末尾匹配\n\n  ``` javascript\n  /^a/\t// 匹配 apple 不匹配 banana\n  /e$/\t// 匹配 apple 不匹配 element\n  ```\n\n  注意和 反向字符集 的区别\n\n  ``` javascript\n  /[^abc]/\t// 匹配不包括 abc 的字符\n  ```\n\n* 使用 /i 表示忽略大小写\n\n  ``` javascript\n  /abc/i\n  ```\n\n* 使用 /g 表示全局搜索\n\n  ``` javascript\n  /abc/g\n  ```\n\n* 使用 x(?=y) 正向肯定查找，匹配'x'仅仅当'x'后面跟着'y'.\n\n  ``` javascript\n  /Jack(?=Sprat)/\t// 会匹配到 Jack 仅当它后面跟着 Sprat，但 Sprat 不作为匹配项返回\n  ```\n\n* 使用 x(?!y) 反向否定查找，匹配'x'仅仅当'x'后面不跟着'y'\n\n  ``` javascript\n  /Jack(?!Sprat)/\t//\t会匹配到 Jack 仅当它后面不跟着 Sprat\n  ```\n\n* 使用 (x) 匹配 'x' 并且记住匹配项，括号被称为 *捕获括号*\n\n  ``` javascript\n  /(foo) (bar) \\1 \\2/;\t// 匹配 foo bar foo bar，注意空格\n  ```\n\n  如果使用 replace 功能，则需要使用 $1 等\n\n* 使用 (?:x) 匹配 'x' 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式\n\n  ``` javascript\n  /foo{2}/;\t\t// 将匹配 fooo，将 {2} 作用到 o\n  /(?:foo){2}/;\t// 将匹配 foofoo，将 {2} 作用到 foo\n  ```","slug":"JavaScript正则表达式","published":1,"updated":"2018-09-08T15:20:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs11000he39k7tz9rihl","content":"<ul>\n<li><p>快速字符</p>\n<p>| 字符 | 说明                                                |<br>| —- | ————————————————— |<br>| \\d   | 所有数字，相当于 [0-9]                              |<br>| \\D   | 非数字，相当于 <code>[^0-9]</code>                           |<br>| \\s   | 空白字符，包括空格、制表符、换页符、换行符          |<br>| \\S   | 非空白字符                                          |<br>| \\w   | 单字符（字母、数字或者下划线），相当于 [A-Za-z0-9_] |<br>| \\W   | 非单字符                                            |</p>\n</li>\n<li><p>使用 {} 表示出现的次数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/s&#123;<span class=\"number\">2</span>,<span class=\"number\">6</span>&#125;/   <span class=\"comment\">// s 字符出现 2 到 6 次，要注意这些情况：ssssssss，这里会当作 ssssss ss，而匹配成功</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/s&#123;<span class=\"number\">2</span>,&#125;/    <span class=\"comment\">// s 字符至少出现 2 次以上</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/s &#123;<span class=\"number\">2</span>&#125;/\t   <span class=\"comment\">// s 字符精确出现 2 次</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 ? 表示出现 0 次或者 1 次，等价于 {0,1}</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/apples?<span class=\"regexp\">/\t/</span><span class=\"regexp\">/ 匹配 aaple 和 apples</span></span><br></pre></td></tr></table></figure>\n<p>注意：如果紧跟在任何量词 *、+、? 或 {} 的后面，将会湿的量词变为非贪婪（匹配尽量少的字符），缺省使用的是贪婪模式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/\\d+<span class=\"regexp\">/;\t/</span><span class=\"regexp\">/ 对于 123abc 将会返回 123</span></span><br><span class=\"line\"><span class=\"regexp\">/</span>\\d+?<span class=\"regexp\">/;\t/</span><span class=\"regexp\">/ 对于 123abc 将会返回 1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 ^ 表示开头匹配，使用 $ 表示末尾匹配</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^a/\t<span class=\"comment\">// 匹配 apple 不匹配 banana</span></span><br><span class=\"line\">/e$/\t<span class=\"comment\">// 匹配 apple 不匹配 element</span></span><br></pre></td></tr></table></figure>\n<p>注意和 反向字符集 的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/[^abc]/\t<span class=\"comment\">// 匹配不包括 abc 的字符</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 /i 表示忽略大小写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/abc/i</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 /g 表示全局搜索</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/abc/g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 x(?=y) 正向肯定查找，匹配’x’仅仅当’x’后面跟着’y’.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Jack(?=Sprat)/\t<span class=\"comment\">// 会匹配到 Jack 仅当它后面跟着 Sprat，但 Sprat 不作为匹配项返回</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 x(?!y) 反向否定查找，匹配’x’仅仅当’x’后面不跟着’y’</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Jack(?!Sprat)/\t<span class=\"comment\">//\t会匹配到 Jack 仅当它后面不跟着 Sprat</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 (x) 匹配 ‘x’ 并且记住匹配项，括号被称为 <em>捕获括号</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/(foo) (bar) \\<span class=\"number\">1</span> \\<span class=\"number\">2</span>/;\t<span class=\"comment\">// 匹配 foo bar foo bar，注意空格</span></span><br></pre></td></tr></table></figure>\n<p>如果使用 replace 功能，则需要使用 $1 等</p>\n</li>\n<li><p>使用 (?:x) 匹配 ‘x’ 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/foo&#123;<span class=\"number\">2</span>&#125;/;\t\t<span class=\"comment\">// 将匹配 fooo，将 &#123;2&#125; 作用到 o</span></span><br><span class=\"line\">/(?:foo)&#123;<span class=\"number\">2</span>&#125;/;\t<span class=\"comment\">// 将匹配 foofoo，将 &#123;2&#125; 作用到 foo</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>快速字符</p>\n<p>| 字符 | 说明                                                |<br>| —- | ————————————————— |<br>| \\d   | 所有数字，相当于 [0-9]                              |<br>| \\D   | 非数字，相当于 <code>[^0-9]</code>                           |<br>| \\s   | 空白字符，包括空格、制表符、换页符、换行符          |<br>| \\S   | 非空白字符                                          |<br>| \\w   | 单字符（字母、数字或者下划线），相当于 [A-Za-z0-9_] |<br>| \\W   | 非单字符                                            |</p>\n</li>\n<li><p>使用 {} 表示出现的次数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/s&#123;<span class=\"number\">2</span>,<span class=\"number\">6</span>&#125;/   <span class=\"comment\">// s 字符出现 2 到 6 次，要注意这些情况：ssssssss，这里会当作 ssssss ss，而匹配成功</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/s&#123;<span class=\"number\">2</span>,&#125;/    <span class=\"comment\">// s 字符至少出现 2 次以上</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/s &#123;<span class=\"number\">2</span>&#125;/\t   <span class=\"comment\">// s 字符精确出现 2 次</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 ? 表示出现 0 次或者 1 次，等价于 {0,1}</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/apples?<span class=\"regexp\">/\t/</span><span class=\"regexp\">/ 匹配 aaple 和 apples</span></span><br></pre></td></tr></table></figure>\n<p>注意：如果紧跟在任何量词 *、+、? 或 {} 的后面，将会湿的量词变为非贪婪（匹配尽量少的字符），缺省使用的是贪婪模式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/\\d+<span class=\"regexp\">/;\t/</span><span class=\"regexp\">/ 对于 123abc 将会返回 123</span></span><br><span class=\"line\"><span class=\"regexp\">/</span>\\d+?<span class=\"regexp\">/;\t/</span><span class=\"regexp\">/ 对于 123abc 将会返回 1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 ^ 表示开头匹配，使用 $ 表示末尾匹配</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^a/\t<span class=\"comment\">// 匹配 apple 不匹配 banana</span></span><br><span class=\"line\">/e$/\t<span class=\"comment\">// 匹配 apple 不匹配 element</span></span><br></pre></td></tr></table></figure>\n<p>注意和 反向字符集 的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/[^abc]/\t<span class=\"comment\">// 匹配不包括 abc 的字符</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 /i 表示忽略大小写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/abc/i</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 /g 表示全局搜索</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/abc/g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 x(?=y) 正向肯定查找，匹配’x’仅仅当’x’后面跟着’y’.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Jack(?=Sprat)/\t<span class=\"comment\">// 会匹配到 Jack 仅当它后面跟着 Sprat，但 Sprat 不作为匹配项返回</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 x(?!y) 反向否定查找，匹配’x’仅仅当’x’后面不跟着’y’</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Jack(?!Sprat)/\t<span class=\"comment\">//\t会匹配到 Jack 仅当它后面不跟着 Sprat</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 (x) 匹配 ‘x’ 并且记住匹配项，括号被称为 <em>捕获括号</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/(foo) (bar) \\<span class=\"number\">1</span> \\<span class=\"number\">2</span>/;\t<span class=\"comment\">// 匹配 foo bar foo bar，注意空格</span></span><br></pre></td></tr></table></figure>\n<p>如果使用 replace 功能，则需要使用 $1 等</p>\n</li>\n<li><p>使用 (?:x) 匹配 ‘x’ 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/foo&#123;<span class=\"number\">2</span>&#125;/;\t\t<span class=\"comment\">// 将匹配 fooo，将 &#123;2&#125; 作用到 o</span></span><br><span class=\"line\">/(?:foo)&#123;<span class=\"number\">2</span>&#125;/;\t<span class=\"comment\">// 将匹配 foofoo，将 &#123;2&#125; 作用到 foo</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Jetpack中的ViewModel","date":"2019-01-05T03:36:18.000Z","_content":"\n### 前言\n\n首先祝大家在新的一年中，身体健康，心想事成。\n\n算了下，去年技术类博客写了 15 篇，看下数量还算比较满意，可是基本都是前半年写的，那时候刚刚下定决心要好好写博客，后半年因为工作上还有自己偷懒心理，基本都没怎么写了，真是惭愧。\n\n不过经过去年写了这些文章，慢慢也学习到了一些写技术文章上的技巧，希望今年能方得始终，提升文章的质量。\n\n### 关于 Jetpack\n\n相信已经有不少人对 Google 推出的 Jetpack 系列组件都有所耳闻，现在网上已经有不少的分析文章了，涵盖了用法和源码解析，所以我就不重复造轮子，在这个系列文章中，不会涉及使用教程等，只写一些个人的使用体会，也当作给自己做笔记。\n\n### 关于本文\n\n这篇文章主要讲 Jetpack 中的 ViewModel\n\n### ViewModel\n\n> The [`ViewModel`](https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html) class is designed to store and manage UI-related data in a lifecycle conscious way. \n\n简而言之，就是在生命周期中管理数据。说到生命周期，我们都知道 Android 中 `Activity` 和 `Fragment` 都有各自对应的生命周期，比如 `Activity`，它的生命周期如下图：\n\n![activity_lifecycle](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/activity_lifecycle.png?x-oss-process=style/doc-img)\n\n通常我们会在 `onCreate()` 初始化数据，在 `onResume()` 中展示数据，`onDestroy()` 中释放数据，类似下面这些伪代码：\n\n``` java\nonCreate() {\n    initData();\n}\n\nonResume() {\n    displayData()\n}\n\nonDestory() {\n    recycleData();\n}\n```\n\n如果没有在 `onDestory()` 中及时释放某些资源，可能还会导致内存泄漏，这是第一个问题。\n\n第二个问题，Android 系统可能会在内存不足的情况下，回收了 `Activity`，导致 `Activity` 重建时数据会丢失，对于这种情况，Android 提供了 `onSaveInstanceState` 中保存数据，在 `onRestoreInstanceState` 和 `onCreate` 中获取。类似下面这些伪代码：\n\n``` java\nonSaveInstanceState(Bundle outState) {\n \toutState.putData();   \n}\n\nonRestoreInstanceState(Bundle outState) {\n    outState.getData();\n}\n\nonCreate(Bundle savedInstanceState) {\n    if (savedInstanceState != null) {\n        savedInstanceState.getData();\n    }\n}\n```\n\n这种方式除了重复的胶水代码以外，还存在 `Bundle` 存储只适用于支持序列化（Serializable 和 Parcelable）的少量数据，当然除了使用 Android SDK 提供的这种方案以外，我们也可以自己实现类似的方案，类似以下伪代码：\n\n``` java\n// Data Repository\nMap<String,Data> map;\n\ngetData(String id) {\n    if (map.get(id) == null){\n        Data data = createData();\n        map.put(id,data);\n    }\n    return map.get(id);\n}\n\nremoveData(String id) {\n    map.removeByKey(id);\n}\n\n// Activity\nonCreate() {\n    getData(this);\n}\n\nonDestory() {\n    if (!isChangingConfigurations){\n            removeData(this);\n    }\n}\n```\n\n看了上面解决思路后，我们再来看看 Google 提供的 `ViewModel`，它是如何解决上面提到的两个问题的。首先看下，`ViewModel` 的典型用法，来源于官方文档：\n\n首先定义一个 `MyViewModel` 继承于 `ViewModel`，这里使用 `LiveData` 作为数据源，这里我们只需要知道 `LiveData` 和 `RxJava` 是差不多的东西就可以了\n\n``` java\npublic class MyViewModel extends ViewModel {\n    private MutableLiveData<List<User>> users;\n    public LiveData<List<User>> getUsers() {\n        if (users == null) {\n            users = new MutableLiveData<List<User>>();\n            loadUsers();\n        }\n        return users;\n    }\n\n    private void loadUsers() {\n        // Do an asynchronous operation to fetch users.\n    }\n}\n```\n\n定义好 `ViewModel` 之后，我们在 `Activity` 中使用它：\n\n``` java\npublic class MyActivity extends AppCompatActivity {\n    public void onCreate(Bundle savedInstanceState) {\n        // Create a ViewModel the first time the system calls an activity's onCreate() method.\n        // Re-created activities receive the same MyViewModel instance created by the first activity.\n\n        MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class);\n        model.getUsers().observe(this, users -> {\n            // update UI\n        });\n    }\n}\n```\n\n我们先看下 `ViewModelProviders.of` 的函数签名：\n\n``` java\npublic static ViewModelProvider of(@NonNull Fragment fragment);\npublic static ViewModelProvider of(@NonNull FragmentActivity activity);\npublic static ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory);\npublic static ViewModelProvider of(@NonNull FragmentActivity activity,\n            @Nullable Factory factory);\n```\n\n需要将当前 `Activity` 或 `Fragment` 作为参数，这也是 `ViewModel` 将数据与生命周期结合起来的地方。那具体也是如何实现的呢？\n\n``` java\n@NonNull                                                                             \n@MainThread                                                                          \npublic static ViewModelProvider of(@NonNull FragmentActivity activity,               \n        @Nullable Factory factory) {                                                 \n    Application application = checkApplication(activity);                            \n    if (factory == null) {                                                           \n        factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);\n    }                                                                                \n    return new ViewModelProvider(activity.getViewModelStore(), factory);             \n}                                                                                    \n```\n\n`factory` 顾名思义就是 `ViewModel` 的工厂类，这里默认使用 `AndroidViewModelFactory` 最后返回 `ViewModelProvider` 实例\n\n``` java\n// ViewModelProvider\n@NonNull                                                                                 \n@MainThread                                                                              \npublic <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {  \n    ViewModel viewModel = mViewModelStore.get(key);                                      \n                                                                                         \n    if (modelClass.isInstance(viewModel)) {                                              \n        //noinspection unchecked                                                         \n        return (T) viewModel;                                                            \n    } else {                                                                             \n        //noinspection StatementWithEmptyBody                                            \n        if (viewModel != null) {                                                         \n            // TODO: log a warning.                                                      \n        }                                                                                \n    }                                                                                    \n                                                                                         \n    viewModel = mFactory.create(modelClass);                                             \n    mViewModelStore.put(key, viewModel);                                                 \n    //noinspection unchecked                                                             \n    return (T) viewModel;                                                                \n}\n\n// AndroidViewModelFactory\n@NonNull                                                                                   \n@Override                                                                                  \npublic <T extends ViewModel> T create(@NonNull Class<T> modelClass) {                      \n    if (AndroidViewModel.class.isAssignableFrom(modelClass)) {                             \n        //noinspection TryWithIdenticalCatches                                             \n        try {                                                                              \n            return modelClass.getConstructor(Application.class).newInstance(mApplication); \n        } catch (NoSuchMethodException e) {                                                \n            throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e);   \n        } catch (IllegalAccessException e) {                                               \n            throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e);   \n        } catch (InstantiationException e) {                                               \n            throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e);   \n        } catch (InvocationTargetException e) {                                            \n            throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e);   \n        }                                                                                  \n    }                                                                                      \n    return super.create(modelClass);                                                       \n}                                                                                          \n```\n\n我们将以上两段代码合起来看，其实逻辑是比较清晰的：\n\n![ViewModelProvider#create](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/viewmodel/ViewModelProvider%23create.png?x-oss-process=style/doc-img)\n\n`Factor` 的实现可以通过反射来实现，比如默认的 `AndroidViewModelFactory` 会优先调用使用 `Application` 作为参数的构造方法，来创建实例。所以，如果自定义的 `ViewModel` 构造方法有其他参数，就需要自定义 `Factor`\n\n而 `ViewModelStore` 则是 `Activity` 重建时还能拥有之前数据的保障。\n\n``` java\nprivate final HashMap<String, ViewModel> mMap = new HashMap<>();                  \n                                                                                  \nfinal void put(String key, ViewModel viewModel) {                                 \n    ViewModel oldViewModel = mMap.put(key, viewModel);                            \n    if (oldViewModel != null) {                                                   \n        oldViewModel.onCleared();                                                 \n    }                                                                             \n}                                                                                 \n                                                                                  \nfinal ViewModel get(String key) {                                                 \n    return mMap.get(key);                                                         \n}                                                                                 \n                                                                                  \n/**                                                                               \n *  Clears internal storage and notifies ViewModels that they are no longer used. \n */                                                                               \npublic final void clear() {                                                       \n    for (ViewModel vm : mMap.values()) {                                          \n        vm.onCleared();                                                           \n    }                                                                             \n    mMap.clear();                                                                 \n}                                                                                 \n```\n\n`ViewModelStore` 的源码很短，可以看到其实就是使用 `HashMap` 作为数据载体。既然有使用，那就需要清理操作，可以看到有个 `clear` 它会清除 `HashMap` 中的缓存数据。我们首先看下 `ViewModelProvider` 中的 `mViewModelStore` 是在哪里赋值的：\n\n``` java\npublic ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) { \n    this(owner.getViewModelStore(), factory);                                            \n}                                                                                        \n                                                                                                                                                                             \npublic ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) {      \n    mFactory = factory;                                                                  \n    this.mViewModelStore = store;                                                        \n}                                                                                        \n```\n\n通过 `ViewModelStoreOwner.getViewModelStore` 获取 `ViewModelStore` 实例对象，而 `ViewModelStoreOwner` 实际就是我们调用 `ViewModelProviders.of` 中传递的 `FragmentActivity` 和 `Fragment`\n\n> `FragmentActivity` 中会通过 `onRetainNonConfigurationInstance` 和 `getLastNonConfigurationInstance` 去保持 `Activity` 因为屏幕旋转等配置发生改变而导致重建时，数据的唯一性\n\n而 `Fragment` 和 `FragmentActivity` 会在 `onDestory` 时判断是否需要调用 `ViewModelStore.clear`\n\n``` java\n@Override                                                            \nprotected void onDestroy() {                                         \n    super.onDestroy();                                               \n                                                                     \n    if (mViewModelStore != null && !isChangingConfigurations()) {    \n        mViewModelStore.clear();                                     \n    }                                                                \n                                                                     \n    mFragments.dispatchDestroy();                                    \n}                                                                    \n```\n\n讲完 `ViewModelStore` 的缓存功能之后，我们再来看下，`ViewModelProvider.of` 不同签名的方法：\n\n``` java\n@NonNull                                                         \n@MainThread                                                      \npublic static ViewModelProvider of(@NonNull Fragment fragment) { \n    return of(fragment, null);                                   \n}\n\n@NonNull                                                                    \n@MainThread                                                                 \npublic static ViewModelProvider of(@NonNull FragmentActivity activity) {    \n    return of(activity, null);                                              \n}                                                                           \n```\n\n这里需要注意的是，`ViewModel` 在不同作用域下的实例，首先，`FragmentActivity` 和 `Fragment` 都实现了 `ViewModelStoreOwner` 即它们都有各自的 `ViewModelStore` 简单来说，如果想在 `Fragment` 中获取依附的 `Activity` 的 `ViewModel` 实例，那需要使用 `of(FragmentActivity)` 的方法，这也是一种 `Activity` 和 `Fragment` 之间通信的好方式。\n\n### 总结\n\n现在我们来比较下自定义实现的方案和 `ViewModel` ，可以发现其实核心思想是共通，首先我们需要一个保存于 `Activity` 和 `Fragment` 生命周期之外的存储空间，在 `ViewModel` 中是 `ViewModelStore`，其次我们需要在 `Activity` 和 `Fragment` 对应的生命周期中，去初始化和清理这个 `ViewModelStore`","source":"_posts/Jetpack中的ViewModel.md","raw":"---\ntitle: Jetpack中的ViewModel\ndate: 2019-01-05 11:36:18\ncategories: Android Application\ntags:\n---\n\n### 前言\n\n首先祝大家在新的一年中，身体健康，心想事成。\n\n算了下，去年技术类博客写了 15 篇，看下数量还算比较满意，可是基本都是前半年写的，那时候刚刚下定决心要好好写博客，后半年因为工作上还有自己偷懒心理，基本都没怎么写了，真是惭愧。\n\n不过经过去年写了这些文章，慢慢也学习到了一些写技术文章上的技巧，希望今年能方得始终，提升文章的质量。\n\n### 关于 Jetpack\n\n相信已经有不少人对 Google 推出的 Jetpack 系列组件都有所耳闻，现在网上已经有不少的分析文章了，涵盖了用法和源码解析，所以我就不重复造轮子，在这个系列文章中，不会涉及使用教程等，只写一些个人的使用体会，也当作给自己做笔记。\n\n### 关于本文\n\n这篇文章主要讲 Jetpack 中的 ViewModel\n\n### ViewModel\n\n> The [`ViewModel`](https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html) class is designed to store and manage UI-related data in a lifecycle conscious way. \n\n简而言之，就是在生命周期中管理数据。说到生命周期，我们都知道 Android 中 `Activity` 和 `Fragment` 都有各自对应的生命周期，比如 `Activity`，它的生命周期如下图：\n\n![activity_lifecycle](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/activity_lifecycle.png?x-oss-process=style/doc-img)\n\n通常我们会在 `onCreate()` 初始化数据，在 `onResume()` 中展示数据，`onDestroy()` 中释放数据，类似下面这些伪代码：\n\n``` java\nonCreate() {\n    initData();\n}\n\nonResume() {\n    displayData()\n}\n\nonDestory() {\n    recycleData();\n}\n```\n\n如果没有在 `onDestory()` 中及时释放某些资源，可能还会导致内存泄漏，这是第一个问题。\n\n第二个问题，Android 系统可能会在内存不足的情况下，回收了 `Activity`，导致 `Activity` 重建时数据会丢失，对于这种情况，Android 提供了 `onSaveInstanceState` 中保存数据，在 `onRestoreInstanceState` 和 `onCreate` 中获取。类似下面这些伪代码：\n\n``` java\nonSaveInstanceState(Bundle outState) {\n \toutState.putData();   \n}\n\nonRestoreInstanceState(Bundle outState) {\n    outState.getData();\n}\n\nonCreate(Bundle savedInstanceState) {\n    if (savedInstanceState != null) {\n        savedInstanceState.getData();\n    }\n}\n```\n\n这种方式除了重复的胶水代码以外，还存在 `Bundle` 存储只适用于支持序列化（Serializable 和 Parcelable）的少量数据，当然除了使用 Android SDK 提供的这种方案以外，我们也可以自己实现类似的方案，类似以下伪代码：\n\n``` java\n// Data Repository\nMap<String,Data> map;\n\ngetData(String id) {\n    if (map.get(id) == null){\n        Data data = createData();\n        map.put(id,data);\n    }\n    return map.get(id);\n}\n\nremoveData(String id) {\n    map.removeByKey(id);\n}\n\n// Activity\nonCreate() {\n    getData(this);\n}\n\nonDestory() {\n    if (!isChangingConfigurations){\n            removeData(this);\n    }\n}\n```\n\n看了上面解决思路后，我们再来看看 Google 提供的 `ViewModel`，它是如何解决上面提到的两个问题的。首先看下，`ViewModel` 的典型用法，来源于官方文档：\n\n首先定义一个 `MyViewModel` 继承于 `ViewModel`，这里使用 `LiveData` 作为数据源，这里我们只需要知道 `LiveData` 和 `RxJava` 是差不多的东西就可以了\n\n``` java\npublic class MyViewModel extends ViewModel {\n    private MutableLiveData<List<User>> users;\n    public LiveData<List<User>> getUsers() {\n        if (users == null) {\n            users = new MutableLiveData<List<User>>();\n            loadUsers();\n        }\n        return users;\n    }\n\n    private void loadUsers() {\n        // Do an asynchronous operation to fetch users.\n    }\n}\n```\n\n定义好 `ViewModel` 之后，我们在 `Activity` 中使用它：\n\n``` java\npublic class MyActivity extends AppCompatActivity {\n    public void onCreate(Bundle savedInstanceState) {\n        // Create a ViewModel the first time the system calls an activity's onCreate() method.\n        // Re-created activities receive the same MyViewModel instance created by the first activity.\n\n        MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class);\n        model.getUsers().observe(this, users -> {\n            // update UI\n        });\n    }\n}\n```\n\n我们先看下 `ViewModelProviders.of` 的函数签名：\n\n``` java\npublic static ViewModelProvider of(@NonNull Fragment fragment);\npublic static ViewModelProvider of(@NonNull FragmentActivity activity);\npublic static ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory);\npublic static ViewModelProvider of(@NonNull FragmentActivity activity,\n            @Nullable Factory factory);\n```\n\n需要将当前 `Activity` 或 `Fragment` 作为参数，这也是 `ViewModel` 将数据与生命周期结合起来的地方。那具体也是如何实现的呢？\n\n``` java\n@NonNull                                                                             \n@MainThread                                                                          \npublic static ViewModelProvider of(@NonNull FragmentActivity activity,               \n        @Nullable Factory factory) {                                                 \n    Application application = checkApplication(activity);                            \n    if (factory == null) {                                                           \n        factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);\n    }                                                                                \n    return new ViewModelProvider(activity.getViewModelStore(), factory);             \n}                                                                                    \n```\n\n`factory` 顾名思义就是 `ViewModel` 的工厂类，这里默认使用 `AndroidViewModelFactory` 最后返回 `ViewModelProvider` 实例\n\n``` java\n// ViewModelProvider\n@NonNull                                                                                 \n@MainThread                                                                              \npublic <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {  \n    ViewModel viewModel = mViewModelStore.get(key);                                      \n                                                                                         \n    if (modelClass.isInstance(viewModel)) {                                              \n        //noinspection unchecked                                                         \n        return (T) viewModel;                                                            \n    } else {                                                                             \n        //noinspection StatementWithEmptyBody                                            \n        if (viewModel != null) {                                                         \n            // TODO: log a warning.                                                      \n        }                                                                                \n    }                                                                                    \n                                                                                         \n    viewModel = mFactory.create(modelClass);                                             \n    mViewModelStore.put(key, viewModel);                                                 \n    //noinspection unchecked                                                             \n    return (T) viewModel;                                                                \n}\n\n// AndroidViewModelFactory\n@NonNull                                                                                   \n@Override                                                                                  \npublic <T extends ViewModel> T create(@NonNull Class<T> modelClass) {                      \n    if (AndroidViewModel.class.isAssignableFrom(modelClass)) {                             \n        //noinspection TryWithIdenticalCatches                                             \n        try {                                                                              \n            return modelClass.getConstructor(Application.class).newInstance(mApplication); \n        } catch (NoSuchMethodException e) {                                                \n            throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e);   \n        } catch (IllegalAccessException e) {                                               \n            throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e);   \n        } catch (InstantiationException e) {                                               \n            throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e);   \n        } catch (InvocationTargetException e) {                                            \n            throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e);   \n        }                                                                                  \n    }                                                                                      \n    return super.create(modelClass);                                                       \n}                                                                                          \n```\n\n我们将以上两段代码合起来看，其实逻辑是比较清晰的：\n\n![ViewModelProvider#create](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/viewmodel/ViewModelProvider%23create.png?x-oss-process=style/doc-img)\n\n`Factor` 的实现可以通过反射来实现，比如默认的 `AndroidViewModelFactory` 会优先调用使用 `Application` 作为参数的构造方法，来创建实例。所以，如果自定义的 `ViewModel` 构造方法有其他参数，就需要自定义 `Factor`\n\n而 `ViewModelStore` 则是 `Activity` 重建时还能拥有之前数据的保障。\n\n``` java\nprivate final HashMap<String, ViewModel> mMap = new HashMap<>();                  \n                                                                                  \nfinal void put(String key, ViewModel viewModel) {                                 \n    ViewModel oldViewModel = mMap.put(key, viewModel);                            \n    if (oldViewModel != null) {                                                   \n        oldViewModel.onCleared();                                                 \n    }                                                                             \n}                                                                                 \n                                                                                  \nfinal ViewModel get(String key) {                                                 \n    return mMap.get(key);                                                         \n}                                                                                 \n                                                                                  \n/**                                                                               \n *  Clears internal storage and notifies ViewModels that they are no longer used. \n */                                                                               \npublic final void clear() {                                                       \n    for (ViewModel vm : mMap.values()) {                                          \n        vm.onCleared();                                                           \n    }                                                                             \n    mMap.clear();                                                                 \n}                                                                                 \n```\n\n`ViewModelStore` 的源码很短，可以看到其实就是使用 `HashMap` 作为数据载体。既然有使用，那就需要清理操作，可以看到有个 `clear` 它会清除 `HashMap` 中的缓存数据。我们首先看下 `ViewModelProvider` 中的 `mViewModelStore` 是在哪里赋值的：\n\n``` java\npublic ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) { \n    this(owner.getViewModelStore(), factory);                                            \n}                                                                                        \n                                                                                                                                                                             \npublic ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) {      \n    mFactory = factory;                                                                  \n    this.mViewModelStore = store;                                                        \n}                                                                                        \n```\n\n通过 `ViewModelStoreOwner.getViewModelStore` 获取 `ViewModelStore` 实例对象，而 `ViewModelStoreOwner` 实际就是我们调用 `ViewModelProviders.of` 中传递的 `FragmentActivity` 和 `Fragment`\n\n> `FragmentActivity` 中会通过 `onRetainNonConfigurationInstance` 和 `getLastNonConfigurationInstance` 去保持 `Activity` 因为屏幕旋转等配置发生改变而导致重建时，数据的唯一性\n\n而 `Fragment` 和 `FragmentActivity` 会在 `onDestory` 时判断是否需要调用 `ViewModelStore.clear`\n\n``` java\n@Override                                                            \nprotected void onDestroy() {                                         \n    super.onDestroy();                                               \n                                                                     \n    if (mViewModelStore != null && !isChangingConfigurations()) {    \n        mViewModelStore.clear();                                     \n    }                                                                \n                                                                     \n    mFragments.dispatchDestroy();                                    \n}                                                                    \n```\n\n讲完 `ViewModelStore` 的缓存功能之后，我们再来看下，`ViewModelProvider.of` 不同签名的方法：\n\n``` java\n@NonNull                                                         \n@MainThread                                                      \npublic static ViewModelProvider of(@NonNull Fragment fragment) { \n    return of(fragment, null);                                   \n}\n\n@NonNull                                                                    \n@MainThread                                                                 \npublic static ViewModelProvider of(@NonNull FragmentActivity activity) {    \n    return of(activity, null);                                              \n}                                                                           \n```\n\n这里需要注意的是，`ViewModel` 在不同作用域下的实例，首先，`FragmentActivity` 和 `Fragment` 都实现了 `ViewModelStoreOwner` 即它们都有各自的 `ViewModelStore` 简单来说，如果想在 `Fragment` 中获取依附的 `Activity` 的 `ViewModel` 实例，那需要使用 `of(FragmentActivity)` 的方法，这也是一种 `Activity` 和 `Fragment` 之间通信的好方式。\n\n### 总结\n\n现在我们来比较下自定义实现的方案和 `ViewModel` ，可以发现其实核心思想是共通，首先我们需要一个保存于 `Activity` 和 `Fragment` 生命周期之外的存储空间，在 `ViewModel` 中是 `ViewModelStore`，其次我们需要在 `Activity` 和 `Fragment` 对应的生命周期中，去初始化和清理这个 `ViewModelStore`","slug":"Jetpack中的ViewModel","published":1,"updated":"2019-04-24T23:36:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs12000ke39khuop5os1","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>首先祝大家在新的一年中，身体健康，心想事成。</p>\n<p>算了下，去年技术类博客写了 15 篇，看下数量还算比较满意，可是基本都是前半年写的，那时候刚刚下定决心要好好写博客，后半年因为工作上还有自己偷懒心理，基本都没怎么写了，真是惭愧。</p>\n<p>不过经过去年写了这些文章，慢慢也学习到了一些写技术文章上的技巧，希望今年能方得始终，提升文章的质量。</p>\n<h3 id=\"关于-Jetpack\"><a href=\"#关于-Jetpack\" class=\"headerlink\" title=\"关于 Jetpack\"></a>关于 Jetpack</h3><p>相信已经有不少人对 Google 推出的 Jetpack 系列组件都有所耳闻，现在网上已经有不少的分析文章了，涵盖了用法和源码解析，所以我就不重复造轮子，在这个系列文章中，不会涉及使用教程等，只写一些个人的使用体会，也当作给自己做笔记。</p>\n<h3 id=\"关于本文\"><a href=\"#关于本文\" class=\"headerlink\" title=\"关于本文\"></a>关于本文</h3><p>这篇文章主要讲 Jetpack 中的 ViewModel</p>\n<h3 id=\"ViewModel\"><a href=\"#ViewModel\" class=\"headerlink\" title=\"ViewModel\"></a>ViewModel</h3><blockquote>\n<p>The <a href=\"https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html\" target=\"_blank\" rel=\"noopener\"><code>ViewModel</code></a> class is designed to store and manage UI-related data in a lifecycle conscious way. </p>\n</blockquote>\n<p>简而言之，就是在生命周期中管理数据。说到生命周期，我们都知道 Android 中 <code>Activity</code> 和 <code>Fragment</code> 都有各自对应的生命周期，比如 <code>Activity</code>，它的生命周期如下图：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/activity_lifecycle.png?x-oss-process=style/doc-img\" alt=\"activity_lifecycle\"></p>\n<p>通常我们会在 <code>onCreate()</code> 初始化数据，在 <code>onResume()</code> 中展示数据，<code>onDestroy()</code> 中释放数据，类似下面这些伪代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onCreate() &#123;</span><br><span class=\"line\">    initData();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onResume() &#123;</span><br><span class=\"line\">    displayData()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onDestory() &#123;</span><br><span class=\"line\">    recycleData();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有在 <code>onDestory()</code> 中及时释放某些资源，可能还会导致内存泄漏，这是第一个问题。</p>\n<p>第二个问题，Android 系统可能会在内存不足的情况下，回收了 <code>Activity</code>，导致 <code>Activity</code> 重建时数据会丢失，对于这种情况，Android 提供了 <code>onSaveInstanceState</code> 中保存数据，在 <code>onRestoreInstanceState</code> 和 <code>onCreate</code> 中获取。类似下面这些伪代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onSaveInstanceState(Bundle outState) &#123;</span><br><span class=\"line\"> \toutState.putData();   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onRestoreInstanceState(Bundle outState) &#123;</span><br><span class=\"line\">    outState.getData();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (savedInstanceState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        savedInstanceState.getData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式除了重复的胶水代码以外，还存在 <code>Bundle</code> 存储只适用于支持序列化（Serializable 和 Parcelable）的少量数据，当然除了使用 Android SDK 提供的这种方案以外，我们也可以自己实现类似的方案，类似以下伪代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Data Repository</span></span><br><span class=\"line\">Map&lt;String,Data&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">getData(String id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map.get(id) == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        Data data = createData();</span><br><span class=\"line\">        map.put(id,data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.get(id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">removeData(String id) &#123;</span><br><span class=\"line\">    map.removeByKey(id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Activity</span></span><br><span class=\"line\">onCreate() &#123;</span><br><span class=\"line\">    getData(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onDestory() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isChangingConfigurations)&#123;</span><br><span class=\"line\">            removeData(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看了上面解决思路后，我们再来看看 Google 提供的 <code>ViewModel</code>，它是如何解决上面提到的两个问题的。首先看下，<code>ViewModel</code> 的典型用法，来源于官方文档：</p>\n<p>首先定义一个 <code>MyViewModel</code> 继承于 <code>ViewModel</code>，这里使用 <code>LiveData</code> 作为数据源，这里我们只需要知道 <code>LiveData</code> 和 <code>RxJava</code> 是差不多的东西就可以了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (users == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            users = <span class=\"keyword\">new</span> MutableLiveData&lt;List&lt;User&gt;&gt;();</span><br><span class=\"line\">            loadUsers();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> users;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadUsers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Do an asynchronous operation to fetch users.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义好 <code>ViewModel</code> 之后，我们在 <code>Activity</code> 中使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class=\"line\">        <span class=\"comment\">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        MyViewModel model = ViewModelProviders.of(<span class=\"keyword\">this</span>).get(MyViewModel.class);</span><br><span class=\"line\">        model.getUsers().observe(<span class=\"keyword\">this</span>, users -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// update UI</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们先看下 <code>ViewModelProviders.of</code> 的函数签名：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull Fragment fragment)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull Fragment fragment, @Nullable Factory factory)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @Nullable Factory factory)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>需要将当前 <code>Activity</code> 或 <code>Fragment</code> 作为参数，这也是 <code>ViewModel</code> 将数据与生命周期结合起来的地方。那具体也是如何实现的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                             </span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity,               </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Nullable Factory factory)</span> </span>&#123;                                                 </span><br><span class=\"line\">    Application application = checkApplication(activity);                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (factory == <span class=\"keyword\">null</span>) &#123;                                                           </span><br><span class=\"line\">        factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);</span><br><span class=\"line\">    &#125;                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ViewModelProvider(activity.getViewModelStore(), factory);             </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>factory</code> 顾名思义就是 <code>ViewModel</code> 的工厂类，这里默认使用 <code>AndroidViewModelFactory</code> 最后返回 <code>ViewModelProvider</code> 实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ViewModelProvider</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                                 </span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                                              </span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;  </span><br><span class=\"line\">    ViewModel viewModel = mViewModelStore.get(key);                                      </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modelClass.isInstance(viewModel)) &#123;                                              </span><br><span class=\"line\">        <span class=\"comment\">//noinspection unchecked                                                         </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) viewModel;                                                            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                             </span><br><span class=\"line\">        <span class=\"comment\">//noinspection StatementWithEmptyBody                                            </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (viewModel != <span class=\"keyword\">null</span>) &#123;                                                         </span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> log a warning.                                                      </span></span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    viewModel = mFactory.create(modelClass);                                             </span><br><span class=\"line\">    mViewModelStore.put(key, viewModel);                                                 </span><br><span class=\"line\">    <span class=\"comment\">//noinspection unchecked                                                             </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) viewModel;                                                                </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AndroidViewModelFactory</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                                   </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                  </span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123;                             </span><br><span class=\"line\">        <span class=\"comment\">//noinspection TryWithIdenticalCatches                                             </span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">return</span> modelClass.getConstructor(Application.class).newInstance(mApplication); </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;                                                </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Cannot create an instance of \"</span> + modelClass, e);   </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;                                               </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Cannot create an instance of \"</span> + modelClass, e);   </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;                                               </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Cannot create an instance of \"</span> + modelClass, e);   </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;                                            </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Cannot create an instance of \"</span> + modelClass, e);   </span><br><span class=\"line\">        &#125;                                                                                  </span><br><span class=\"line\">    &#125;                                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.create(modelClass);                                                       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将以上两段代码合起来看，其实逻辑是比较清晰的：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/viewmodel/ViewModelProvider%23create.png?x-oss-process=style/doc-img\" alt=\"ViewModelProvider#create\"></p>\n<p><code>Factor</code> 的实现可以通过反射来实现，比如默认的 <code>AndroidViewModelFactory</code> 会优先调用使用 <code>Application</code> 作为参数的构造方法，来创建实例。所以，如果自定义的 <code>ViewModel</code> 构造方法有其他参数，就需要自定义 <code>Factor</code></p>\n<p>而 <code>ViewModelStore</code> 则是 <code>Activity</code> 重建时还能拥有之前数据的保障。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();                  </span><br><span class=\"line\">                                                                                  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(String key, ViewModel viewModel)</span> </span>&#123;                                 </span><br><span class=\"line\">    ViewModel oldViewModel = mMap.put(key, viewModel);                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldViewModel != <span class=\"keyword\">null</span>) &#123;                                                   </span><br><span class=\"line\">        oldViewModel.onCleared();                                                 </span><br><span class=\"line\">    &#125;                                                                             </span><br><span class=\"line\">&#125;                                                                                 </span><br><span class=\"line\">                                                                                  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> ViewModel <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;                                                 </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mMap.get(key);                                                         </span><br><span class=\"line\">&#125;                                                                                 </span><br><span class=\"line\">                                                                                  </span><br><span class=\"line\"><span class=\"comment\">/**                                                                               </span></span><br><span class=\"line\"><span class=\"comment\"> *  Clears internal storage and notifies ViewModels that they are no longer used. </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>                                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;                                                       </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ViewModel vm : mMap.values()) &#123;                                          </span><br><span class=\"line\">        vm.onCleared();                                                           </span><br><span class=\"line\">    &#125;                                                                             </span><br><span class=\"line\">    mMap.clear();                                                                 </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ViewModelStore</code> 的源码很短，可以看到其实就是使用 <code>HashMap</code> 作为数据载体。既然有使用，那就需要清理操作，可以看到有个 <code>clear</code> 它会清除 <code>HashMap</code> 中的缓存数据。我们首先看下 <code>ViewModelProvider</code> 中的 <code>mViewModelStore</code> 是在哪里赋值的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewModelProvider</span><span class=\"params\">(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(owner.getViewModelStore(), factory);                                            </span><br><span class=\"line\">&#125;                                                                                        </span><br><span class=\"line\">                                                                                                                                                                             </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewModelProvider</span><span class=\"params\">(@NonNull ViewModelStore store, @NonNull Factory factory)</span> </span>&#123;      </span><br><span class=\"line\">    mFactory = factory;                                                                  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mViewModelStore = store;                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 <code>ViewModelStoreOwner.getViewModelStore</code> 获取 <code>ViewModelStore</code> 实例对象，而 <code>ViewModelStoreOwner</code> 实际就是我们调用 <code>ViewModelProviders.of</code> 中传递的 <code>FragmentActivity</code> 和 <code>Fragment</code></p>\n<blockquote>\n<p><code>FragmentActivity</code> 中会通过 <code>onRetainNonConfigurationInstance</code> 和 <code>getLastNonConfigurationInstance</code> 去保持 <code>Activity</code> 因为屏幕旋转等配置发生改变而导致重建时，数据的唯一性</p>\n</blockquote>\n<p>而 <code>Fragment</code> 和 <code>FragmentActivity</code> 会在 <code>onDestory</code> 时判断是否需要调用 <code>ViewModelStore.clear</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                            </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();                                               </span><br><span class=\"line\">                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mViewModelStore != <span class=\"keyword\">null</span> &amp;&amp; !isChangingConfigurations()) &#123;    </span><br><span class=\"line\">        mViewModelStore.clear();                                     </span><br><span class=\"line\">    &#125;                                                                </span><br><span class=\"line\">                                                                     </span><br><span class=\"line\">    mFragments.dispatchDestroy();                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>讲完 <code>ViewModelStore</code> 的缓存功能之后，我们再来看下，<code>ViewModelProvider.of</code> 不同签名的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                         </span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                      </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull Fragment fragment)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> of(fragment, <span class=\"keyword\">null</span>);                                   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                    </span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                                 </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span> </span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> of(activity, <span class=\"keyword\">null</span>);                                              </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是，<code>ViewModel</code> 在不同作用域下的实例，首先，<code>FragmentActivity</code> 和 <code>Fragment</code> 都实现了 <code>ViewModelStoreOwner</code> 即它们都有各自的 <code>ViewModelStore</code> 简单来说，如果想在 <code>Fragment</code> 中获取依附的 <code>Activity</code> 的 <code>ViewModel</code> 实例，那需要使用 <code>of(FragmentActivity)</code> 的方法，这也是一种 <code>Activity</code> 和 <code>Fragment</code> 之间通信的好方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>现在我们来比较下自定义实现的方案和 <code>ViewModel</code> ，可以发现其实核心思想是共通，首先我们需要一个保存于 <code>Activity</code> 和 <code>Fragment</code> 生命周期之外的存储空间，在 <code>ViewModel</code> 中是 <code>ViewModelStore</code>，其次我们需要在 <code>Activity</code> 和 <code>Fragment</code> 对应的生命周期中，去初始化和清理这个 <code>ViewModelStore</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>首先祝大家在新的一年中，身体健康，心想事成。</p>\n<p>算了下，去年技术类博客写了 15 篇，看下数量还算比较满意，可是基本都是前半年写的，那时候刚刚下定决心要好好写博客，后半年因为工作上还有自己偷懒心理，基本都没怎么写了，真是惭愧。</p>\n<p>不过经过去年写了这些文章，慢慢也学习到了一些写技术文章上的技巧，希望今年能方得始终，提升文章的质量。</p>\n<h3 id=\"关于-Jetpack\"><a href=\"#关于-Jetpack\" class=\"headerlink\" title=\"关于 Jetpack\"></a>关于 Jetpack</h3><p>相信已经有不少人对 Google 推出的 Jetpack 系列组件都有所耳闻，现在网上已经有不少的分析文章了，涵盖了用法和源码解析，所以我就不重复造轮子，在这个系列文章中，不会涉及使用教程等，只写一些个人的使用体会，也当作给自己做笔记。</p>\n<h3 id=\"关于本文\"><a href=\"#关于本文\" class=\"headerlink\" title=\"关于本文\"></a>关于本文</h3><p>这篇文章主要讲 Jetpack 中的 ViewModel</p>\n<h3 id=\"ViewModel\"><a href=\"#ViewModel\" class=\"headerlink\" title=\"ViewModel\"></a>ViewModel</h3><blockquote>\n<p>The <a href=\"https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html\" target=\"_blank\" rel=\"noopener\"><code>ViewModel</code></a> class is designed to store and manage UI-related data in a lifecycle conscious way. </p>\n</blockquote>\n<p>简而言之，就是在生命周期中管理数据。说到生命周期，我们都知道 Android 中 <code>Activity</code> 和 <code>Fragment</code> 都有各自对应的生命周期，比如 <code>Activity</code>，它的生命周期如下图：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/activity_lifecycle.png?x-oss-process=style/doc-img\" alt=\"activity_lifecycle\"></p>\n<p>通常我们会在 <code>onCreate()</code> 初始化数据，在 <code>onResume()</code> 中展示数据，<code>onDestroy()</code> 中释放数据，类似下面这些伪代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onCreate() &#123;</span><br><span class=\"line\">    initData();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onResume() &#123;</span><br><span class=\"line\">    displayData()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onDestory() &#123;</span><br><span class=\"line\">    recycleData();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有在 <code>onDestory()</code> 中及时释放某些资源，可能还会导致内存泄漏，这是第一个问题。</p>\n<p>第二个问题，Android 系统可能会在内存不足的情况下，回收了 <code>Activity</code>，导致 <code>Activity</code> 重建时数据会丢失，对于这种情况，Android 提供了 <code>onSaveInstanceState</code> 中保存数据，在 <code>onRestoreInstanceState</code> 和 <code>onCreate</code> 中获取。类似下面这些伪代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onSaveInstanceState(Bundle outState) &#123;</span><br><span class=\"line\"> \toutState.putData();   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onRestoreInstanceState(Bundle outState) &#123;</span><br><span class=\"line\">    outState.getData();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (savedInstanceState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        savedInstanceState.getData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式除了重复的胶水代码以外，还存在 <code>Bundle</code> 存储只适用于支持序列化（Serializable 和 Parcelable）的少量数据，当然除了使用 Android SDK 提供的这种方案以外，我们也可以自己实现类似的方案，类似以下伪代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Data Repository</span></span><br><span class=\"line\">Map&lt;String,Data&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">getData(String id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map.get(id) == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        Data data = createData();</span><br><span class=\"line\">        map.put(id,data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.get(id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">removeData(String id) &#123;</span><br><span class=\"line\">    map.removeByKey(id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Activity</span></span><br><span class=\"line\">onCreate() &#123;</span><br><span class=\"line\">    getData(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">onDestory() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isChangingConfigurations)&#123;</span><br><span class=\"line\">            removeData(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看了上面解决思路后，我们再来看看 Google 提供的 <code>ViewModel</code>，它是如何解决上面提到的两个问题的。首先看下，<code>ViewModel</code> 的典型用法，来源于官方文档：</p>\n<p>首先定义一个 <code>MyViewModel</code> 继承于 <code>ViewModel</code>，这里使用 <code>LiveData</code> 作为数据源，这里我们只需要知道 <code>LiveData</code> 和 <code>RxJava</code> 是差不多的东西就可以了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (users == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            users = <span class=\"keyword\">new</span> MutableLiveData&lt;List&lt;User&gt;&gt;();</span><br><span class=\"line\">            loadUsers();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> users;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadUsers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Do an asynchronous operation to fetch users.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义好 <code>ViewModel</code> 之后，我们在 <code>Activity</code> 中使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class=\"line\">        <span class=\"comment\">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        MyViewModel model = ViewModelProviders.of(<span class=\"keyword\">this</span>).get(MyViewModel.class);</span><br><span class=\"line\">        model.getUsers().observe(<span class=\"keyword\">this</span>, users -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// update UI</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们先看下 <code>ViewModelProviders.of</code> 的函数签名：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull Fragment fragment)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull Fragment fragment, @Nullable Factory factory)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @Nullable Factory factory)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>需要将当前 <code>Activity</code> 或 <code>Fragment</code> 作为参数，这也是 <code>ViewModel</code> 将数据与生命周期结合起来的地方。那具体也是如何实现的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                             </span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity,               </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Nullable Factory factory)</span> </span>&#123;                                                 </span><br><span class=\"line\">    Application application = checkApplication(activity);                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (factory == <span class=\"keyword\">null</span>) &#123;                                                           </span><br><span class=\"line\">        factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);</span><br><span class=\"line\">    &#125;                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ViewModelProvider(activity.getViewModelStore(), factory);             </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>factory</code> 顾名思义就是 <code>ViewModel</code> 的工厂类，这里默认使用 <code>AndroidViewModelFactory</code> 最后返回 <code>ViewModelProvider</code> 实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ViewModelProvider</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                                 </span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                                              </span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;  </span><br><span class=\"line\">    ViewModel viewModel = mViewModelStore.get(key);                                      </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modelClass.isInstance(viewModel)) &#123;                                              </span><br><span class=\"line\">        <span class=\"comment\">//noinspection unchecked                                                         </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) viewModel;                                                            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                             </span><br><span class=\"line\">        <span class=\"comment\">//noinspection StatementWithEmptyBody                                            </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (viewModel != <span class=\"keyword\">null</span>) &#123;                                                         </span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> log a warning.                                                      </span></span><br><span class=\"line\">        &#125;                                                                                </span><br><span class=\"line\">    &#125;                                                                                    </span><br><span class=\"line\">                                                                                         </span><br><span class=\"line\">    viewModel = mFactory.create(modelClass);                                             </span><br><span class=\"line\">    mViewModelStore.put(key, viewModel);                                                 </span><br><span class=\"line\">    <span class=\"comment\">//noinspection unchecked                                                             </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) viewModel;                                                                </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AndroidViewModelFactory</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                                   </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                  </span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123;                             </span><br><span class=\"line\">        <span class=\"comment\">//noinspection TryWithIdenticalCatches                                             </span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">return</span> modelClass.getConstructor(Application.class).newInstance(mApplication); </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;                                                </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Cannot create an instance of \"</span> + modelClass, e);   </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;                                               </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Cannot create an instance of \"</span> + modelClass, e);   </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;                                               </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Cannot create an instance of \"</span> + modelClass, e);   </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;                                            </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Cannot create an instance of \"</span> + modelClass, e);   </span><br><span class=\"line\">        &#125;                                                                                  </span><br><span class=\"line\">    &#125;                                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.create(modelClass);                                                       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将以上两段代码合起来看，其实逻辑是比较清晰的：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/viewmodel/ViewModelProvider%23create.png?x-oss-process=style/doc-img\" alt=\"ViewModelProvider#create\"></p>\n<p><code>Factor</code> 的实现可以通过反射来实现，比如默认的 <code>AndroidViewModelFactory</code> 会优先调用使用 <code>Application</code> 作为参数的构造方法，来创建实例。所以，如果自定义的 <code>ViewModel</code> 构造方法有其他参数，就需要自定义 <code>Factor</code></p>\n<p>而 <code>ViewModelStore</code> 则是 <code>Activity</code> 重建时还能拥有之前数据的保障。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();                  </span><br><span class=\"line\">                                                                                  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(String key, ViewModel viewModel)</span> </span>&#123;                                 </span><br><span class=\"line\">    ViewModel oldViewModel = mMap.put(key, viewModel);                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldViewModel != <span class=\"keyword\">null</span>) &#123;                                                   </span><br><span class=\"line\">        oldViewModel.onCleared();                                                 </span><br><span class=\"line\">    &#125;                                                                             </span><br><span class=\"line\">&#125;                                                                                 </span><br><span class=\"line\">                                                                                  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> ViewModel <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;                                                 </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mMap.get(key);                                                         </span><br><span class=\"line\">&#125;                                                                                 </span><br><span class=\"line\">                                                                                  </span><br><span class=\"line\"><span class=\"comment\">/**                                                                               </span></span><br><span class=\"line\"><span class=\"comment\"> *  Clears internal storage and notifies ViewModels that they are no longer used. </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>                                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;                                                       </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ViewModel vm : mMap.values()) &#123;                                          </span><br><span class=\"line\">        vm.onCleared();                                                           </span><br><span class=\"line\">    &#125;                                                                             </span><br><span class=\"line\">    mMap.clear();                                                                 </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ViewModelStore</code> 的源码很短，可以看到其实就是使用 <code>HashMap</code> 作为数据载体。既然有使用，那就需要清理操作，可以看到有个 <code>clear</code> 它会清除 <code>HashMap</code> 中的缓存数据。我们首先看下 <code>ViewModelProvider</code> 中的 <code>mViewModelStore</code> 是在哪里赋值的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewModelProvider</span><span class=\"params\">(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(owner.getViewModelStore(), factory);                                            </span><br><span class=\"line\">&#125;                                                                                        </span><br><span class=\"line\">                                                                                                                                                                             </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewModelProvider</span><span class=\"params\">(@NonNull ViewModelStore store, @NonNull Factory factory)</span> </span>&#123;      </span><br><span class=\"line\">    mFactory = factory;                                                                  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mViewModelStore = store;                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 <code>ViewModelStoreOwner.getViewModelStore</code> 获取 <code>ViewModelStore</code> 实例对象，而 <code>ViewModelStoreOwner</code> 实际就是我们调用 <code>ViewModelProviders.of</code> 中传递的 <code>FragmentActivity</code> 和 <code>Fragment</code></p>\n<blockquote>\n<p><code>FragmentActivity</code> 中会通过 <code>onRetainNonConfigurationInstance</code> 和 <code>getLastNonConfigurationInstance</code> 去保持 <code>Activity</code> 因为屏幕旋转等配置发生改变而导致重建时，数据的唯一性</p>\n</blockquote>\n<p>而 <code>Fragment</code> 和 <code>FragmentActivity</code> 会在 <code>onDestory</code> 时判断是否需要调用 <code>ViewModelStore.clear</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                            </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();                                               </span><br><span class=\"line\">                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mViewModelStore != <span class=\"keyword\">null</span> &amp;&amp; !isChangingConfigurations()) &#123;    </span><br><span class=\"line\">        mViewModelStore.clear();                                     </span><br><span class=\"line\">    &#125;                                                                </span><br><span class=\"line\">                                                                     </span><br><span class=\"line\">    mFragments.dispatchDestroy();                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>讲完 <code>ViewModelStore</code> 的缓存功能之后，我们再来看下，<code>ViewModelProvider.of</code> 不同签名的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                         </span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                      </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull Fragment fragment)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> of(fragment, <span class=\"keyword\">null</span>);                                   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                    </span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                                 </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span> </span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> of(activity, <span class=\"keyword\">null</span>);                                              </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是，<code>ViewModel</code> 在不同作用域下的实例，首先，<code>FragmentActivity</code> 和 <code>Fragment</code> 都实现了 <code>ViewModelStoreOwner</code> 即它们都有各自的 <code>ViewModelStore</code> 简单来说，如果想在 <code>Fragment</code> 中获取依附的 <code>Activity</code> 的 <code>ViewModel</code> 实例，那需要使用 <code>of(FragmentActivity)</code> 的方法，这也是一种 <code>Activity</code> 和 <code>Fragment</code> 之间通信的好方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>现在我们来比较下自定义实现的方案和 <code>ViewModel</code> ，可以发现其实核心思想是共通，首先我们需要一个保存于 <code>Activity</code> 和 <code>Fragment</code> 生命周期之外的存储空间，在 <code>ViewModel</code> 中是 <code>ViewModelStore</code>，其次我们需要在 <code>Activity</code> 和 <code>Fragment</code> 对应的生命周期中，去初始化和清理这个 <code>ViewModelStore</code></p>\n"},{"title":"Looper中的死循环","date":"2019-04-24T23:35:09.000Z","_content":"\nHandler 应该是每个 Android 开发同学都非常熟悉的组件了，和大部分的 GUI 程序类似，Android 上的 UI 绘制只允许在单个线程上进行。这也是 Google 提供了 Handler 的原因之一，为了方便在其他线程使用 Handler 来通知 UI 线程更新。关于 Handler 的使用和源码解析不是本文的主题，网上已经有很多不错的文章了。本文的主题是探讨下 Looper 类中的 `loop()` 方法。\n\n我们知道，`loop()` 实质上是在一个无限的 `for` 循环中，从 `MessageQueue` 中不断地取出消息，再交由对应的 `Handler` 进行分发。这里实际上就涉及到了三个问题：\n\n1. 为什么要是死循环？\n2. 既然是死循环，那为什么不会阻塞应用？\n3. 这种死循环，会不会非常消耗资源？\n\n在写这篇文章之前，我也从网上看到很多答案，大致上是说，Handler 基于 Epoll 模型实现，只有在有新消息进来时，才会重新唤醒等待的线程，这里指 UI 线程。当时并没有去深究这些答案，觉得好像说的挺对的。实际上，这些答案确实是对的，但并没有回答完整，只回答了上面的第三个问题。\n\n当我在 Java 程序上，仿照 Handler 实现了一个简易版本的 Handler，这是我实现的 `loop()`：\n\n```java\npublic static void loop() {                                              \n    if (sThreadLocal.get() == null) {                                    \n        throw new IllegalStateException(\"must call prepare() before\");   \n    }                                                                    \n    final Looper curLooper = sThreadLocal.get();                         \n    while (true) {                                                       \n        Message message = curLooper.messageQueue.next();                 \n        if (message == null) {                                           \n            // error                                                     \n            System.out.println(\"message is null\");                       \n            return;                                                      \n        }                                                                \n        message.target.dispatchMessage(message);                         \n    }                                                                    \n}                                                                        \n```\n\n大家不用去深究每个方法的具体实现，从命名理解即可，和 Android 版的 Handler 一样，在一个死循环中，不断从 MessageQueue 中取出消息。但当我使用以下代码执行时，却发现完全按预期那样打印，\n\n```java\npublic static void main(String[] args) {\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        Looper.prepare();\n        Looper.loop();\n        Handler handler = new Handler() {\n            @Override\n            protected void handleMessage(Message msg) {\n                System.out.println(Thread.currentThread().getName() + \": handle \" + msg.getData());\n            }\n        };\n        service.execute(() -> handler.sendMessage(new Message(\"Hello World\")));\n}\n```\n\n`loop()` 方法阻塞了当前线程，无法执行后面的代码。也就是说，Android Handler 应该也是这样的效果的。有疑惑的同学可以尝试以下代码，可以发现 \"After\" 不会被打印的。\n\n```kotlin\nval thread = Thread(Runnable {      \n    println(\"Before\")               \n    Looper.prepare()                \n    Looper.loop()                   \n    println(\"After\")                \n})                                  \nthread.start()                      \n```\n\n为了一探究竟，我们看下执行主线程的 `Looper.loop()` 方法执行，它位于 `ActivityThread.main()` 方法中，和普通的 Java 程序一样，Android 的入口也是 `main()` 方法，执行该方法的线程就是我们说的主线程，即 UI 线程。\n\n```java\n                                                                                                                                  \nLooper.prepareMainLooper();                                                          \n                                                                                                                                                                 \nActivityThread thread = new ActivityThread();                                        \nthread.attach(false, startSeq);                                                      \n                                                                                     \nif (sMainThreadHandler == null) {                                                    \n    sMainThreadHandler = thread.getHandler();                                        \n}                                                                                    \n                                                                                                                                                                                                                                                        \n                                    \nLooper.loop();                                                                       \n                                                                                     \nthrow new RuntimeException(\"Main thread loop unexpectedly exited\");                  \n```\n\n这段代码位于 `main()` 方法的最后，注意最后一句 `throw new RuntimeException(\"Main thread loop unexpectedly exited\");` 也就是说，`Looper.loop()` 之后一般情况下并不会执行到那里。\n\n接下来，就可以来回答第一个问题了，为什么是死循环？我们知道应用在执行完任务后就会退出，但 Android 应用开始运行后，即使没任务也应该保持执行，所以使用死循环来使得应用不结束。\n\n第二个问题，为什么不会阻塞应用。其实是会的，更确切地说，是阻塞了主线程。但 Android 的 UI 事件都是通过 Handler 来调度的，比如启动 Activity，Activity 的生命周期调用等等，这一块有兴趣的同学，可以去看下 Activity 的启动流程，具体可以看看 `ActivityThread.H` 这个类。\n\n### 总结\n\n总结下上面我们讨论的，`Looper.loop()` 方法开始执行后，会阻塞了当前执行的线程，主线程也是这样，这样做的原因之一是，保持当前应用执行不退出。 ","source":"_posts/Looper中的死循环.md","raw":"---\ntitle: Looper中的死循环\ndate: 2019-04-25 07:35:09\ncategories: Android Application\ntags:\n---\n\nHandler 应该是每个 Android 开发同学都非常熟悉的组件了，和大部分的 GUI 程序类似，Android 上的 UI 绘制只允许在单个线程上进行。这也是 Google 提供了 Handler 的原因之一，为了方便在其他线程使用 Handler 来通知 UI 线程更新。关于 Handler 的使用和源码解析不是本文的主题，网上已经有很多不错的文章了。本文的主题是探讨下 Looper 类中的 `loop()` 方法。\n\n我们知道，`loop()` 实质上是在一个无限的 `for` 循环中，从 `MessageQueue` 中不断地取出消息，再交由对应的 `Handler` 进行分发。这里实际上就涉及到了三个问题：\n\n1. 为什么要是死循环？\n2. 既然是死循环，那为什么不会阻塞应用？\n3. 这种死循环，会不会非常消耗资源？\n\n在写这篇文章之前，我也从网上看到很多答案，大致上是说，Handler 基于 Epoll 模型实现，只有在有新消息进来时，才会重新唤醒等待的线程，这里指 UI 线程。当时并没有去深究这些答案，觉得好像说的挺对的。实际上，这些答案确实是对的，但并没有回答完整，只回答了上面的第三个问题。\n\n当我在 Java 程序上，仿照 Handler 实现了一个简易版本的 Handler，这是我实现的 `loop()`：\n\n```java\npublic static void loop() {                                              \n    if (sThreadLocal.get() == null) {                                    \n        throw new IllegalStateException(\"must call prepare() before\");   \n    }                                                                    \n    final Looper curLooper = sThreadLocal.get();                         \n    while (true) {                                                       \n        Message message = curLooper.messageQueue.next();                 \n        if (message == null) {                                           \n            // error                                                     \n            System.out.println(\"message is null\");                       \n            return;                                                      \n        }                                                                \n        message.target.dispatchMessage(message);                         \n    }                                                                    \n}                                                                        \n```\n\n大家不用去深究每个方法的具体实现，从命名理解即可，和 Android 版的 Handler 一样，在一个死循环中，不断从 MessageQueue 中取出消息。但当我使用以下代码执行时，却发现完全按预期那样打印，\n\n```java\npublic static void main(String[] args) {\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        Looper.prepare();\n        Looper.loop();\n        Handler handler = new Handler() {\n            @Override\n            protected void handleMessage(Message msg) {\n                System.out.println(Thread.currentThread().getName() + \": handle \" + msg.getData());\n            }\n        };\n        service.execute(() -> handler.sendMessage(new Message(\"Hello World\")));\n}\n```\n\n`loop()` 方法阻塞了当前线程，无法执行后面的代码。也就是说，Android Handler 应该也是这样的效果的。有疑惑的同学可以尝试以下代码，可以发现 \"After\" 不会被打印的。\n\n```kotlin\nval thread = Thread(Runnable {      \n    println(\"Before\")               \n    Looper.prepare()                \n    Looper.loop()                   \n    println(\"After\")                \n})                                  \nthread.start()                      \n```\n\n为了一探究竟，我们看下执行主线程的 `Looper.loop()` 方法执行，它位于 `ActivityThread.main()` 方法中，和普通的 Java 程序一样，Android 的入口也是 `main()` 方法，执行该方法的线程就是我们说的主线程，即 UI 线程。\n\n```java\n                                                                                                                                  \nLooper.prepareMainLooper();                                                          \n                                                                                                                                                                 \nActivityThread thread = new ActivityThread();                                        \nthread.attach(false, startSeq);                                                      \n                                                                                     \nif (sMainThreadHandler == null) {                                                    \n    sMainThreadHandler = thread.getHandler();                                        \n}                                                                                    \n                                                                                                                                                                                                                                                        \n                                    \nLooper.loop();                                                                       \n                                                                                     \nthrow new RuntimeException(\"Main thread loop unexpectedly exited\");                  \n```\n\n这段代码位于 `main()` 方法的最后，注意最后一句 `throw new RuntimeException(\"Main thread loop unexpectedly exited\");` 也就是说，`Looper.loop()` 之后一般情况下并不会执行到那里。\n\n接下来，就可以来回答第一个问题了，为什么是死循环？我们知道应用在执行完任务后就会退出，但 Android 应用开始运行后，即使没任务也应该保持执行，所以使用死循环来使得应用不结束。\n\n第二个问题，为什么不会阻塞应用。其实是会的，更确切地说，是阻塞了主线程。但 Android 的 UI 事件都是通过 Handler 来调度的，比如启动 Activity，Activity 的生命周期调用等等，这一块有兴趣的同学，可以去看下 Activity 的启动流程，具体可以看看 `ActivityThread.H` 这个类。\n\n### 总结\n\n总结下上面我们讨论的，`Looper.loop()` 方法开始执行后，会阻塞了当前执行的线程，主线程也是这样，这样做的原因之一是，保持当前应用执行不退出。 ","slug":"Looper中的死循环","published":1,"updated":"2019-04-24T23:35:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs14000ne39kzwtccq6k","content":"<p>Handler 应该是每个 Android 开发同学都非常熟悉的组件了，和大部分的 GUI 程序类似，Android 上的 UI 绘制只允许在单个线程上进行。这也是 Google 提供了 Handler 的原因之一，为了方便在其他线程使用 Handler 来通知 UI 线程更新。关于 Handler 的使用和源码解析不是本文的主题，网上已经有很多不错的文章了。本文的主题是探讨下 Looper 类中的 <code>loop()</code> 方法。</p>\n<p>我们知道，<code>loop()</code> 实质上是在一个无限的 <code>for</code> 循环中，从 <code>MessageQueue</code> 中不断地取出消息，再交由对应的 <code>Handler</code> 进行分发。这里实际上就涉及到了三个问题：</p>\n<ol>\n<li>为什么要是死循环？</li>\n<li>既然是死循环，那为什么不会阻塞应用？</li>\n<li>这种死循环，会不会非常消耗资源？</li>\n</ol>\n<p>在写这篇文章之前，我也从网上看到很多答案，大致上是说，Handler 基于 Epoll 模型实现，只有在有新消息进来时，才会重新唤醒等待的线程，这里指 UI 线程。当时并没有去深究这些答案，觉得好像说的挺对的。实际上，这些答案确实是对的，但并没有回答完整，只回答了上面的第三个问题。</p>\n<p>当我在 Java 程序上，仿照 Handler 实现了一个简易版本的 Handler，这是我实现的 <code>loop()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() == <span class=\"keyword\">null</span>) &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"must call prepare() before\"</span>);   </span><br><span class=\"line\">    &#125;                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper curLooper = sThreadLocal.get();                         </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;                                                       </span><br><span class=\"line\">        Message message = curLooper.messageQueue.next();                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (message == <span class=\"keyword\">null</span>) &#123;                                           </span><br><span class=\"line\">            <span class=\"comment\">// error                                                     </span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"message is null\"</span>);                       </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                      </span><br><span class=\"line\">        &#125;                                                                </span><br><span class=\"line\">        message.target.dispatchMessage(message);                         </span><br><span class=\"line\">    &#125;                                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家不用去深究每个方法的具体实现，从命名理解即可，和 Android 版的 Handler 一样，在一个死循环中，不断从 MessageQueue 中取出消息。但当我使用以下代码执行时，却发现完全按预期那样打印，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService service = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">        Handler handler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\": handle \"</span> + msg.getData());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        service.execute(() -&gt; handler.sendMessage(<span class=\"keyword\">new</span> Message(<span class=\"string\">\"Hello World\"</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>loop()</code> 方法阻塞了当前线程，无法执行后面的代码。也就是说，Android Handler 应该也是这样的效果的。有疑惑的同学可以尝试以下代码，可以发现 “After” 不会被打印的。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> thread = Thread(Runnable &#123;      </span><br><span class=\"line\">    println(<span class=\"string\">\"Before\"</span>)               </span><br><span class=\"line\">    Looper.prepare()                </span><br><span class=\"line\">    Looper.loop()                   </span><br><span class=\"line\">    println(<span class=\"string\">\"After\"</span>)                </span><br><span class=\"line\">&#125;)                                  </span><br><span class=\"line\">thread.start()</span><br></pre></td></tr></table></figure>\n<p>为了一探究竟，我们看下执行主线程的 <code>Looper.loop()</code> 方法执行，它位于 <code>ActivityThread.main()</code> 方法中，和普通的 Java 程序一样，Android 的入口也是 <code>main()</code> 方法，执行该方法的线程就是我们说的主线程，即 UI 线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                                                                                                                  </span><br><span class=\"line\">Looper.prepareMainLooper();                                                          </span><br><span class=\"line\">                                                                                                                                                                 </span><br><span class=\"line\">ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();                                        </span><br><span class=\"line\">thread.attach(<span class=\"keyword\">false</span>, startSeq);                                                      </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\"><span class=\"keyword\">if</span> (sMainThreadHandler == <span class=\"keyword\">null</span>) &#123;                                                    </span><br><span class=\"line\">    sMainThreadHandler = thread.getHandler();                                        </span><br><span class=\"line\">&#125;                                                                                    </span><br><span class=\"line\">                                                                                                                                                                                                                                                        </span><br><span class=\"line\">                                    </span><br><span class=\"line\">Looper.loop();                                                                       </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这段代码位于 <code>main()</code> 方法的最后，注意最后一句 <code>throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</code> 也就是说，<code>Looper.loop()</code> 之后一般情况下并不会执行到那里。</p>\n<p>接下来，就可以来回答第一个问题了，为什么是死循环？我们知道应用在执行完任务后就会退出，但 Android 应用开始运行后，即使没任务也应该保持执行，所以使用死循环来使得应用不结束。</p>\n<p>第二个问题，为什么不会阻塞应用。其实是会的，更确切地说，是阻塞了主线程。但 Android 的 UI 事件都是通过 Handler 来调度的，比如启动 Activity，Activity 的生命周期调用等等，这一块有兴趣的同学，可以去看下 Activity 的启动流程，具体可以看看 <code>ActivityThread.H</code> 这个类。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>总结下上面我们讨论的，<code>Looper.loop()</code> 方法开始执行后，会阻塞了当前执行的线程，主线程也是这样，这样做的原因之一是，保持当前应用执行不退出。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>Handler 应该是每个 Android 开发同学都非常熟悉的组件了，和大部分的 GUI 程序类似，Android 上的 UI 绘制只允许在单个线程上进行。这也是 Google 提供了 Handler 的原因之一，为了方便在其他线程使用 Handler 来通知 UI 线程更新。关于 Handler 的使用和源码解析不是本文的主题，网上已经有很多不错的文章了。本文的主题是探讨下 Looper 类中的 <code>loop()</code> 方法。</p>\n<p>我们知道，<code>loop()</code> 实质上是在一个无限的 <code>for</code> 循环中，从 <code>MessageQueue</code> 中不断地取出消息，再交由对应的 <code>Handler</code> 进行分发。这里实际上就涉及到了三个问题：</p>\n<ol>\n<li>为什么要是死循环？</li>\n<li>既然是死循环，那为什么不会阻塞应用？</li>\n<li>这种死循环，会不会非常消耗资源？</li>\n</ol>\n<p>在写这篇文章之前，我也从网上看到很多答案，大致上是说，Handler 基于 Epoll 模型实现，只有在有新消息进来时，才会重新唤醒等待的线程，这里指 UI 线程。当时并没有去深究这些答案，觉得好像说的挺对的。实际上，这些答案确实是对的，但并没有回答完整，只回答了上面的第三个问题。</p>\n<p>当我在 Java 程序上，仿照 Handler 实现了一个简易版本的 Handler，这是我实现的 <code>loop()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() == <span class=\"keyword\">null</span>) &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"must call prepare() before\"</span>);   </span><br><span class=\"line\">    &#125;                                                                    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper curLooper = sThreadLocal.get();                         </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;                                                       </span><br><span class=\"line\">        Message message = curLooper.messageQueue.next();                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (message == <span class=\"keyword\">null</span>) &#123;                                           </span><br><span class=\"line\">            <span class=\"comment\">// error                                                     </span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"message is null\"</span>);                       </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                      </span><br><span class=\"line\">        &#125;                                                                </span><br><span class=\"line\">        message.target.dispatchMessage(message);                         </span><br><span class=\"line\">    &#125;                                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家不用去深究每个方法的具体实现，从命名理解即可，和 Android 版的 Handler 一样，在一个死循环中，不断从 MessageQueue 中取出消息。但当我使用以下代码执行时，却发现完全按预期那样打印，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService service = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">        Handler handler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\": handle \"</span> + msg.getData());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        service.execute(() -&gt; handler.sendMessage(<span class=\"keyword\">new</span> Message(<span class=\"string\">\"Hello World\"</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>loop()</code> 方法阻塞了当前线程，无法执行后面的代码。也就是说，Android Handler 应该也是这样的效果的。有疑惑的同学可以尝试以下代码，可以发现 “After” 不会被打印的。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> thread = Thread(Runnable &#123;      </span><br><span class=\"line\">    println(<span class=\"string\">\"Before\"</span>)               </span><br><span class=\"line\">    Looper.prepare()                </span><br><span class=\"line\">    Looper.loop()                   </span><br><span class=\"line\">    println(<span class=\"string\">\"After\"</span>)                </span><br><span class=\"line\">&#125;)                                  </span><br><span class=\"line\">thread.start()</span><br></pre></td></tr></table></figure>\n<p>为了一探究竟，我们看下执行主线程的 <code>Looper.loop()</code> 方法执行，它位于 <code>ActivityThread.main()</code> 方法中，和普通的 Java 程序一样，Android 的入口也是 <code>main()</code> 方法，执行该方法的线程就是我们说的主线程，即 UI 线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                                                                                                                  </span><br><span class=\"line\">Looper.prepareMainLooper();                                                          </span><br><span class=\"line\">                                                                                                                                                                 </span><br><span class=\"line\">ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();                                        </span><br><span class=\"line\">thread.attach(<span class=\"keyword\">false</span>, startSeq);                                                      </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\"><span class=\"keyword\">if</span> (sMainThreadHandler == <span class=\"keyword\">null</span>) &#123;                                                    </span><br><span class=\"line\">    sMainThreadHandler = thread.getHandler();                                        </span><br><span class=\"line\">&#125;                                                                                    </span><br><span class=\"line\">                                                                                                                                                                                                                                                        </span><br><span class=\"line\">                                    </span><br><span class=\"line\">Looper.loop();                                                                       </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这段代码位于 <code>main()</code> 方法的最后，注意最后一句 <code>throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</code> 也就是说，<code>Looper.loop()</code> 之后一般情况下并不会执行到那里。</p>\n<p>接下来，就可以来回答第一个问题了，为什么是死循环？我们知道应用在执行完任务后就会退出，但 Android 应用开始运行后，即使没任务也应该保持执行，所以使用死循环来使得应用不结束。</p>\n<p>第二个问题，为什么不会阻塞应用。其实是会的，更确切地说，是阻塞了主线程。但 Android 的 UI 事件都是通过 Handler 来调度的，比如启动 Activity，Activity 的生命周期调用等等，这一块有兴趣的同学，可以去看下 Activity 的启动流程，具体可以看看 <code>ActivityThread.H</code> 这个类。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>总结下上面我们讨论的，<code>Looper.loop()</code> 方法开始执行后，会阻塞了当前执行的线程，主线程也是这样，这样做的原因之一是，保持当前应用执行不退出。 </p>\n"},{"title":"Hello World","_content":"## 面朝大海，春暖花开\n\n从明天起，做一个幸福的人\n\n喂马、劈柴、周游世界\n\n从明天起，关心粮食和蔬菜\n\n我有一所房子，面朝大海，春暖花开\n\n\n\n从明天起，和每一个亲人通信\n\n告诉他们我的幸福\n\n那幸福的闪电告诉我的\n\n我将告诉每一个人\n\n\n\n给每一条河每一座山取一个温暖的名字\n\n陌生人，我也为你祝福\n\n愿你有一个灿烂的前程\n\n愿你有情人总成眷属\n\n愿你在尘世获得幸福\n\n我只愿面朝大海，春暖花开\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategories: 随笔\n---\n## 面朝大海，春暖花开\n\n从明天起，做一个幸福的人\n\n喂马、劈柴、周游世界\n\n从明天起，关心粮食和蔬菜\n\n我有一所房子，面朝大海，春暖花开\n\n\n\n从明天起，和每一个亲人通信\n\n告诉他们我的幸福\n\n那幸福的闪电告诉我的\n\n我将告诉每一个人\n\n\n\n给每一条河每一座山取一个温暖的名字\n\n陌生人，我也为你祝福\n\n愿你有一个灿烂的前程\n\n愿你有情人总成眷属\n\n愿你在尘世获得幸福\n\n我只愿面朝大海，春暖花开\n","slug":"hello-world","published":1,"date":"2018-04-11T14:05:30.000Z","updated":"2018-04-11T14:05:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs15000qe39krh8adtfv","content":"<h2 id=\"面朝大海，春暖花开\"><a href=\"#面朝大海，春暖花开\" class=\"headerlink\" title=\"面朝大海，春暖花开\"></a>面朝大海，春暖花开</h2><p>从明天起，做一个幸福的人</p>\n<p>喂马、劈柴、周游世界</p>\n<p>从明天起，关心粮食和蔬菜</p>\n<p>我有一所房子，面朝大海，春暖花开</p>\n<p>从明天起，和每一个亲人通信</p>\n<p>告诉他们我的幸福</p>\n<p>那幸福的闪电告诉我的</p>\n<p>我将告诉每一个人</p>\n<p>给每一条河每一座山取一个温暖的名字</p>\n<p>陌生人，我也为你祝福</p>\n<p>愿你有一个灿烂的前程</p>\n<p>愿你有情人总成眷属</p>\n<p>愿你在尘世获得幸福</p>\n<p>我只愿面朝大海，春暖花开</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"面朝大海，春暖花开\"><a href=\"#面朝大海，春暖花开\" class=\"headerlink\" title=\"面朝大海，春暖花开\"></a>面朝大海，春暖花开</h2><p>从明天起，做一个幸福的人</p>\n<p>喂马、劈柴、周游世界</p>\n<p>从明天起，关心粮食和蔬菜</p>\n<p>我有一所房子，面朝大海，春暖花开</p>\n<p>从明天起，和每一个亲人通信</p>\n<p>告诉他们我的幸福</p>\n<p>那幸福的闪电告诉我的</p>\n<p>我将告诉每一个人</p>\n<p>给每一条河每一座山取一个温暖的名字</p>\n<p>陌生人，我也为你祝福</p>\n<p>愿你有一个灿烂的前程</p>\n<p>愿你有情人总成眷属</p>\n<p>愿你在尘世获得幸福</p>\n<p>我只愿面朝大海，春暖花开</p>\n"},{"title":"Jetpack中的LiveData","date":"2019-02-05T06:54:08.000Z","_content":"\n### 关于LiveData\n\n`LiveData` 是一种可观察的数据持有类，下面是常用的写法：\n\n``` kotlin\nclass DataViewModel(application: Application) : AndroidViewModel(application) {\n\n    val dataSource: LiveData<String> = MutableLiveData()\n\n    fun postValue(text: String? = \"Hello World\") {\n        (dataSource as MutableLiveData).postValue(text)\n    }\n}\n\nviewModel.dataSource.observe(this, object : Observer<String> {\n\n            override fun onChanged(t: String?) {\n                println(\"onChange: ${t}\")\n            }\n\n})\n```\n\n一般情况下，`LiveData` 和 `ViewModel` 都是搭配使用的，可以在 `Activity` 和 `Fragment` 范围内提供复用，并处理因配置发生改变，而重建的情况。\n\n> 关于 `ViewModel` 更详细的理解，可以阅读之前的文章：[Jetpack中的ViewModel](https://linxiaotao.github.io/2019/01/05/Jetpack%E4%B8%AD%E7%9A%84ViewModel/)\n\n如果了解过 [RxJava](https://github.com/ReactiveX/RxJava) 的同学，对这种**观察者**的设计模式应该有点了解，`LiveData` 也是同样的思想，不过和 RxJava 不同的是：`LiveData` 使用 `Lifecycle` 将数据源和 `Activity` 和 `Fragment` 的生命周期结合起来，避免内存泄漏等情况。这个特性也是本文的重点。\n\n> 关于 Lifecycle 更详细的理解，可以阅读之前的文章：[Jetpack中的Lifecycle](https://linxiaotao.github.io/2019/01/14/Jetpack%E4%B8%AD%E7%9A%84Lifecycle/)\n\n建议在阅读以下内容时，先理解下 `Lifecycle`，因为 `LiveData` 能感应 `Activity` 和 `Fragment` 的生命周期就是基于 `Lifecycle` 实现的。\n\n### 源码解析\n\n#### 各个模块的作用\n\n在理解源码之前，我们先理清组成 `LiveData` 各个模块的作用。\n\n##### LiveData\n\n`LiveData` 表示一个可观察的数据源。在 `LiveData` 的设计中，它被设计为一个纯粹的数据源，对外只提供了：\n\n* observe(LifecycleOwner,Observer)\n\n  表示注册一个观察者（`Observer`），这里同时需要提供一个 `LifecycleOwner` 用于提供 `Lifecycle`\n\n* observeForever(Observer)\n\n  功能和 `observe(LifecycleOwner,Observer)` 类似，但缺少感应生命周期的功能\n\n* removeObserver(Observer) 和 removeObservers(LifecycleOwner)\n\n  表示删除观察者，后者则是删除同个 `LifecycleOwner` 范围的 `Observer`\n\n* getValue()\n\n  表示获取当前值\n\n* hasObservers()\n\n  表示是否存在 `Observer`\n\n* hasActiveObservers()\n\n  表示是否存在活动的 `Observer`，至于怎么去定义为活动的，后面会讲到\n\n`LiveData` 是一个纯粹的数据源，不包含添加数据的公开 API，只能通过使用 `MutableLiveData` 去添加数据\n\n> 这是一种不错的设计理念，单个组件功能越纯粹，代码的耦合度就越低。\n\n##### Observer\n\n`Observer` 表示观察者，响应数据发生变化。API 也非常简单：`onChange(T)`，这里需要注意的是：`onChange()` 中数据可以为 `NULL`，这和 `RxJava2` 的设计是不一样的，这个很难说，哪个设计更优。但根据 [JakeWharton](https://github.com/JakeWharton) 的回答是：It's not RxJava's choice, it's in the reactive streams spec.\n\n> 关于 `RxJava2` 不能传递 `NULL` 的讨论，可以参考这篇[文章](https://github.com/ReactiveX/RxJava/issues/4644)\n\n#### observe\n\n调用 `LiveData.observe(LifecycleOwner,Observer)` 去注册一个订阅者：\n\n``` java\n@MainThread                                                                                 \npublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {\n    // 注意，只能主线程调用\n    assertMainThread(\"observe\");                                                            \n    if (owner.getLifecycle().getCurrentState() == DESTROYED) {                              \n        // ignore                                                                           \n        return;                                                                             \n    }\n    // 使用 LifecycleBoundObserver 包装类\n    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n    // mObservers 为 Map<Observer,ObserverWrapper>\n    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);                   \n    if (existing != null && !existing.isAttachedTo(owner)) {\n        // 存在不同 LifecycleOwner 但相同 observer，抛异常\n        throw new IllegalArgumentException(\"Cannot add the same observer\"                   \n                + \" with different lifecycles\");                                            \n    }                                                                                       \n    if (existing != null) {                                                                 \n        return;                                                                             \n    }                                                                                       \n    owner.getLifecycle().addObserver(wrapper);                                              \n}\n\n// LifecycleBoundObserver\n@Override                                     \nboolean isAttachedTo(LifecycleOwner owner) {  \n    return mOwner == owner;                   \n}                                             \n```\n\n`LifecycleBoundObserver` 实现了 `GenericLifecycleObserver` 接口，用于响应 `Activity` 和 `Fragment` 的生命周期\n\n``` java\nclass LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver {   \n    @NonNull                                                                                 \n    final LifecycleOwner mOwner;                                                             \n                                                                                             \n    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<? super T> observer) {    \n        super(observer);                                                                     \n        mOwner = owner;                                                                      \n    }                                                                                        \n                                                                                             \n    @Override                                                                                \n    boolean shouldBeActive() { \n        // 检测是否为活动状态\n        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);                   \n    }                                                                                        \n                                                                                             \n    @Override                                                                                \n    public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {               \n        if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {\n            // DESTROYED 时移除 observer\n            removeObserver(mObserver);                                                       \n            return;                                                                          \n        }                                                                                    \n        activeStateChanged(shouldBeActive());                                                \n    }                                                                                        \n                                                                                             \n    @Override                                                                                \n    boolean isAttachedTo(LifecycleOwner owner) {\n        // 判断是否为同个 LifecycleOwner\n        return mOwner == owner;                                                              \n    }                                                                                        \n                                                                                             \n    @Override                                                                                \n    void detachObserver() {\n        // 1.removeObserver\n        // 2. lifecycle state 没有在 started 之后，或者已经是 destoryed\n        // 以上两种情况会调用 detachObserver\n        // 从 Lifecycle 中移除 observer\n        mOwner.getLifecycle().removeObserver(this);                                          \n    }                                                                                        \n} \n\nprivate abstract class ObserverWrapper {                                             \n    final Observer<? super T> mObserver;                                             \n    boolean mActive;                                                                 \n    int mLastVersion = START_VERSION;                                                \n                                                                                     \n    ObserverWrapper(Observer<? super T> observer) {                                  \n        mObserver = observer;                                                        \n    }                                                                                \n                                                                                     \n    abstract boolean shouldBeActive();                                               \n                                                                                     \n    boolean isAttachedTo(LifecycleOwner owner) {                                     \n        return false;                                                                \n    }                                                                                \n                                                                                     \n    void detachObserver() {                                                          \n    }                                                                                \n                                                                                     \n    void activeStateChanged(boolean newActive) {\n        // 当活动状态发生变化时\n        if (newActive == mActive) {                                                  \n            return;                                                                  \n        }                                                                            \n        // immediately set active state, so we'd never dispatch anything to inactive \n        // owner                                                                     \n        mActive = newActive;\n        // 是否为不活动状态\n        boolean wasInactive = LiveData.this.mActiveCount == 0; \n        // 当前活动个数统计\n        LiveData.this.mActiveCount += mActive ? 1 : -1;                              \n        if (wasInactive && mActive) {\n            // 不活动 -> 活动\n            onActive();                                                              \n        }                                                                            \n        if (LiveData.this.mActiveCount == 0 && !mActive) {\n            // 活动 -> 不活动\n            onInactive();                                                            \n        }                                                                            \n        if (mActive) { \n            // 当前为活动状态，分发当前 observer\n            dispatchingValue(this);                                                  \n        }                                                                            \n    }                                                                                \n}                                                                                    \n```\n\n当调用 `observe()` 会根据当前是否为活跃状态，分发当前值。\n\n#### postValue 和 setValue\n\n当在非主线程调用时，使用 `postValue()`，相关源码如下：\n\n``` java\nprotected void postValue(T value) {                                       \n    boolean postTask;                                                     \n    synchronized (mDataLock) {\n        // 当前是否存在需要分发的值\n        postTask = mPendingData == NOT_SET;  \n        // 多次调用，只会分发最后一次的值\n        mPendingData = value;                                             \n    }                                                                     \n    if (!postTask) {\n        // 已存在正在分发的任务\n        return;                                                           \n    }                                                                     \n    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);  \n}\n```\n\n这里需要注意的是，当分发数据的任务还没结束时，多次调用 `postValue` 只会分发最后一次的值，同一时间只会存在一个 `PostValueRunnable`\n\n``` java\nprivate final Runnable mPostValueRunnable = new Runnable() { \n    @Override                                                \n    public void run() {                                      \n        Object newValue;                                     \n        synchronized (mDataLock) {                           \n            newValue = mPendingData; \n            // 设置为 NOT_SET\n            mPendingData = NOT_SET;                          \n        }                                                    \n        //noinspection unchecked \n        // 再调用 setValue\n        setValue((T) newValue);                              \n    }                                                        \n}; \n\n@MainThread                                         \nprotected void setValue(T value) {\n    // 只能在主线程调用\n    assertMainThread(\"setValue\"); \n    // 使用 version 记录\n    mVersion++; \n    // 当前值\n    mData = value;  \n    // 分发\n    dispatchingValue(null);                         \n} \n\nvoid dispatchingValue(@Nullable ObserverWrapper initiator) {                           \n    if (mDispatchingValue) {\n        // 正在分发中\n        mDispatchInvalidated = true;                                                   \n        return;                                                                        \n    }                                                                                  \n    mDispatchingValue = true;                                                          \n    do {                                                                               \n        mDispatchInvalidated = false;                                                  \n        if (initiator != null) {\n            // 初始分发\n            considerNotify(initiator);                                                 \n            initiator = null;                                                          \n        } else {\n            // 升序迭代，调用 considerNotify\n            for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =  \n                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {        \n                considerNotify(iterator.next().getValue());                            \n                if (mDispatchInvalidated) {\n                    // 分发过程中，有新的数据需要分发\n                    break;                                                             \n                }                                                                      \n            }                                                                          \n        }                                                                              \n    } while (mDispatchInvalidated);                                                    \n    mDispatchingValue = false;                                                         \n}                                                                                      \n```\n\n如果有阅读过 [Jetpack中的Lifecycle](https://linxiaotao.github.io/2019/01/14/Jetpack%E4%B8%AD%E7%9A%84Lifecycle/) 这篇文章的话，可以很快看出，分发值的处理和 `Lifecycle` 有类似的地方，即在分发过程中，有新的值开始分发这种 case，都是采用中断当前的分发，推迟到下一次遍历时，分发新的值。\n\n``` java\nprivate void considerNotify(ObserverWrapper observer) {                                         \n    if (!observer.mActive) { \n        // 当前 observer 为非活动状态\n        return;                                                                                 \n    }                                                                                           \n    // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.  \n    //                                                                                          \n    // we still first check observer.active to keep it as the entrance for events. So even if   \n    // the observer moved to an active state, if we've not received that event, we better not   \n    // notify for a more predictable notification order.\n    // 可能存在已经是非活动状态，但没有接收到的 case\n    // 检测是否为活动状态\n    if (!observer.shouldBeActive()) {\n        // 非活动状态，mActive 和 shouldBeActive 不一致，通知 activeStateChanged\n        observer.activeStateChanged(false);                                                     \n        return;                                                                                 \n    }                                                                                           \n    if (observer.mLastVersion >= mVersion) { \n        // 当重新变为活动状态时，会分发当前值，避免重复值\n        return;                                                                                 \n    }                                                                                           \n    observer.mLastVersion = mVersion;                                                           \n    //noinspection unchecked                                                                    \n    observer.mObserver.onChanged((T) mData);                                                    \n}                                                                                               \n```\n\n需要注意的是，`setValue` 和 `postValue` 方法都是 `protected`，所以当我们想实现一个 LiveData 时，需要使用 MutableLiveData，源码很简单，就是将这两个方法修改为 `public`。\n\n> 这种实现思路有利于数据的不可变性。上游使用 MutableLiveData 分发数据，下游使用 LiveData 消费数据。\n\n如果使用过 RxJava 类似库的同学可能会觉得跟 LiveData 很像，同样是监听者模式。不一样的是，RxJava 提供了很多操作符，类似 `map`、`zip` 等，还有线程调度的 `observeOn` 和 `subscribeOn`。LiveData 没有线程调度的功能，它数据分发只在主线程上进行，没有线程锁等开销。除此之前，LiveData 只提供了 `map` 和 `switchMap` 的实现，但提供了 `MediatorLiveData` 去实现自己需要的操作符。\n\n#### Transformations\n\nTransformations 中有 `map` 和 `switchMap` 的实现。\n\n``` java\n@MainThread  \npublic static <X, Y> LiveData<Y> map(                              \n        @NonNull LiveData<X> source,                               \n        @NonNull final Function<X, Y> mapFunction) {\n    final MediatorLiveData<Y> result = new MediatorLiveData<>();   \n    result.addSource(source, new Observer<X>() {                   \n        @Override                                                  \n        public void onChanged(@Nullable X x) {\n            // 对源数据进行转化\n            result.setValue(mapFunction.apply(x));                 \n        }                                                          \n    });                                                            \n    return result;                                                 \n} \n\n@MainThread  \npublic static <X, Y> LiveData<Y> switchMap(                            \n        @NonNull LiveData<X> source,                                   \n        @NonNull final Function<X, LiveData<Y>> switchMapFunction) {   \n    final MediatorLiveData<Y> result = new MediatorLiveData<>();       \n    result.addSource(source, new Observer<X>() {                       \n        LiveData<Y> mSource;                                           \n                                                                       \n        @Override                                                      \n        public void onChanged(@Nullable X x) {\n            // 将发射出来的每个数据都转换成新的 LiveData，再接收\n            LiveData<Y> newLiveData = switchMapFunction.apply(x);      \n            if (mSource == newLiveData) {                              \n                return;                                                \n            }                                                          \n            if (mSource != null) {                                     \n                result.removeSource(mSource);                          \n            }                                                          \n            mSource = newLiveData;                                     \n            if (mSource != null) {                                     \n                result.addSource(mSource, new Observer<Y>() {          \n                    @Override                                          \n                    public void onChanged(@Nullable Y y) {             \n                        result.setValue(y);                            \n                    }                                                  \n                });                                                    \n            }                                                          \n        }                                                              \n    });                                                                \n    return result;                                                     \n}                                                                      \n```\n\nMediatorLiveData 可以监听多个 LiveData，这里我们简单看下它的源码：\n\n``` java\n@MainThread                                                                                       \npublic <S> void addSource(@NonNull LiveData<S> source, @NonNull Observer<? super S> onChanged) {  \n    Source<S> e = new Source<>(source, onChanged);                                                \n    Source<?> existing = mSources.putIfAbsent(source, e);                                         \n    if (existing != null && existing.mObserver != onChanged) {                                    \n        throw new IllegalArgumentException(                                                       \n                \"This source was already added with the different observer\");                     \n    }                                                                                             \n    if (existing != null) {                                                                       \n        return;                                                                                   \n    }                                                                                             \n    if (hasActiveObservers()) { \n        // 存在活动的 observer，开始监听 source livedata\n        e.plug();                                                                                 \n    }                                                                                             \n}                                                                                                 \n\n@MainThread                                                     \npublic <S> void removeSource(@NonNull LiveData<S> toRemote) {   \n    Source<?> source = mSources.remove(toRemote);               \n    if (source != null) { \n        // 删除监听\t\n        source.unplug();                                        \n    }                                                           \n}                                                               \n\n@CallSuper                                                         \n@Override                                                          \nprotected void onActive() {                                        \n    for (Map.Entry<LiveData<?>, Source<?>> source : mSources) { \n        // 重新监听\n        source.getValue().plug();                                  \n    }                                                              \n}                                                                  \n                                                                   \n@CallSuper                                                         \n@Override                                                          \nprotected void onInactive() {                                      \n    for (Map.Entry<LiveData<?>, Source<?>> source : mSources) {\n        // 暂时删除监听\n        source.getValue().unplug();                                \n    }                                                              \n}                                                                  \n\nprivate static class Source<V> implements Observer<V> {                    \n    final LiveData<V> mLiveData;                                           \n    final Observer<? super V> mObserver;                                   \n    int mVersion = START_VERSION;                                          \n                                                                           \n    Source(LiveData<V> liveData, final Observer<? super V> observer) {     \n        mLiveData = liveData;                                              \n        mObserver = observer;                                              \n    }                                                                      \n                                                                           \n    void plug() { \n        // 这里可以使用 observeForever，因为会在 onActive 和 onInactive 两个方法中处理，能响应页面的生命周期\n        mLiveData.observeForever(this);                                    \n    }                                                                      \n                                                                           \n    void unplug() {                                                        \n        mLiveData.removeObserver(this);                                    \n    }                                                                      \n                                                                           \n    @Override                                                              \n    public void onChanged(@Nullable V v) {                                 \n        if (mVersion != mLiveData.getVersion()) {                          \n            mVersion = mLiveData.getVersion();                             \n            mObserver.onChanged(v);                                        \n        }                                                                  \n    }                                                                      \n}                                                                          \n```\n\n### 总结\n\nLiveData 可以算是 RxJava 的简化版本，它最大的好处就是和 Lifecycle 结合起来使用，不需要手动处理监听。第二个是，将数据分发操作封闭在主线程，减少线程同步锁的损耗，更适合 Android 日常开发场景。","source":"_posts/Jetpack中的LiveData.md","raw":"---\ntitle: Jetpack中的LiveData\ndate: 2019-02-05 14:54:08\ncategories: Android Application\ntags:\n---\n\n### 关于LiveData\n\n`LiveData` 是一种可观察的数据持有类，下面是常用的写法：\n\n``` kotlin\nclass DataViewModel(application: Application) : AndroidViewModel(application) {\n\n    val dataSource: LiveData<String> = MutableLiveData()\n\n    fun postValue(text: String? = \"Hello World\") {\n        (dataSource as MutableLiveData).postValue(text)\n    }\n}\n\nviewModel.dataSource.observe(this, object : Observer<String> {\n\n            override fun onChanged(t: String?) {\n                println(\"onChange: ${t}\")\n            }\n\n})\n```\n\n一般情况下，`LiveData` 和 `ViewModel` 都是搭配使用的，可以在 `Activity` 和 `Fragment` 范围内提供复用，并处理因配置发生改变，而重建的情况。\n\n> 关于 `ViewModel` 更详细的理解，可以阅读之前的文章：[Jetpack中的ViewModel](https://linxiaotao.github.io/2019/01/05/Jetpack%E4%B8%AD%E7%9A%84ViewModel/)\n\n如果了解过 [RxJava](https://github.com/ReactiveX/RxJava) 的同学，对这种**观察者**的设计模式应该有点了解，`LiveData` 也是同样的思想，不过和 RxJava 不同的是：`LiveData` 使用 `Lifecycle` 将数据源和 `Activity` 和 `Fragment` 的生命周期结合起来，避免内存泄漏等情况。这个特性也是本文的重点。\n\n> 关于 Lifecycle 更详细的理解，可以阅读之前的文章：[Jetpack中的Lifecycle](https://linxiaotao.github.io/2019/01/14/Jetpack%E4%B8%AD%E7%9A%84Lifecycle/)\n\n建议在阅读以下内容时，先理解下 `Lifecycle`，因为 `LiveData` 能感应 `Activity` 和 `Fragment` 的生命周期就是基于 `Lifecycle` 实现的。\n\n### 源码解析\n\n#### 各个模块的作用\n\n在理解源码之前，我们先理清组成 `LiveData` 各个模块的作用。\n\n##### LiveData\n\n`LiveData` 表示一个可观察的数据源。在 `LiveData` 的设计中，它被设计为一个纯粹的数据源，对外只提供了：\n\n* observe(LifecycleOwner,Observer)\n\n  表示注册一个观察者（`Observer`），这里同时需要提供一个 `LifecycleOwner` 用于提供 `Lifecycle`\n\n* observeForever(Observer)\n\n  功能和 `observe(LifecycleOwner,Observer)` 类似，但缺少感应生命周期的功能\n\n* removeObserver(Observer) 和 removeObservers(LifecycleOwner)\n\n  表示删除观察者，后者则是删除同个 `LifecycleOwner` 范围的 `Observer`\n\n* getValue()\n\n  表示获取当前值\n\n* hasObservers()\n\n  表示是否存在 `Observer`\n\n* hasActiveObservers()\n\n  表示是否存在活动的 `Observer`，至于怎么去定义为活动的，后面会讲到\n\n`LiveData` 是一个纯粹的数据源，不包含添加数据的公开 API，只能通过使用 `MutableLiveData` 去添加数据\n\n> 这是一种不错的设计理念，单个组件功能越纯粹，代码的耦合度就越低。\n\n##### Observer\n\n`Observer` 表示观察者，响应数据发生变化。API 也非常简单：`onChange(T)`，这里需要注意的是：`onChange()` 中数据可以为 `NULL`，这和 `RxJava2` 的设计是不一样的，这个很难说，哪个设计更优。但根据 [JakeWharton](https://github.com/JakeWharton) 的回答是：It's not RxJava's choice, it's in the reactive streams spec.\n\n> 关于 `RxJava2` 不能传递 `NULL` 的讨论，可以参考这篇[文章](https://github.com/ReactiveX/RxJava/issues/4644)\n\n#### observe\n\n调用 `LiveData.observe(LifecycleOwner,Observer)` 去注册一个订阅者：\n\n``` java\n@MainThread                                                                                 \npublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {\n    // 注意，只能主线程调用\n    assertMainThread(\"observe\");                                                            \n    if (owner.getLifecycle().getCurrentState() == DESTROYED) {                              \n        // ignore                                                                           \n        return;                                                                             \n    }\n    // 使用 LifecycleBoundObserver 包装类\n    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n    // mObservers 为 Map<Observer,ObserverWrapper>\n    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);                   \n    if (existing != null && !existing.isAttachedTo(owner)) {\n        // 存在不同 LifecycleOwner 但相同 observer，抛异常\n        throw new IllegalArgumentException(\"Cannot add the same observer\"                   \n                + \" with different lifecycles\");                                            \n    }                                                                                       \n    if (existing != null) {                                                                 \n        return;                                                                             \n    }                                                                                       \n    owner.getLifecycle().addObserver(wrapper);                                              \n}\n\n// LifecycleBoundObserver\n@Override                                     \nboolean isAttachedTo(LifecycleOwner owner) {  \n    return mOwner == owner;                   \n}                                             \n```\n\n`LifecycleBoundObserver` 实现了 `GenericLifecycleObserver` 接口，用于响应 `Activity` 和 `Fragment` 的生命周期\n\n``` java\nclass LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver {   \n    @NonNull                                                                                 \n    final LifecycleOwner mOwner;                                                             \n                                                                                             \n    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<? super T> observer) {    \n        super(observer);                                                                     \n        mOwner = owner;                                                                      \n    }                                                                                        \n                                                                                             \n    @Override                                                                                \n    boolean shouldBeActive() { \n        // 检测是否为活动状态\n        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);                   \n    }                                                                                        \n                                                                                             \n    @Override                                                                                \n    public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {               \n        if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {\n            // DESTROYED 时移除 observer\n            removeObserver(mObserver);                                                       \n            return;                                                                          \n        }                                                                                    \n        activeStateChanged(shouldBeActive());                                                \n    }                                                                                        \n                                                                                             \n    @Override                                                                                \n    boolean isAttachedTo(LifecycleOwner owner) {\n        // 判断是否为同个 LifecycleOwner\n        return mOwner == owner;                                                              \n    }                                                                                        \n                                                                                             \n    @Override                                                                                \n    void detachObserver() {\n        // 1.removeObserver\n        // 2. lifecycle state 没有在 started 之后，或者已经是 destoryed\n        // 以上两种情况会调用 detachObserver\n        // 从 Lifecycle 中移除 observer\n        mOwner.getLifecycle().removeObserver(this);                                          \n    }                                                                                        \n} \n\nprivate abstract class ObserverWrapper {                                             \n    final Observer<? super T> mObserver;                                             \n    boolean mActive;                                                                 \n    int mLastVersion = START_VERSION;                                                \n                                                                                     \n    ObserverWrapper(Observer<? super T> observer) {                                  \n        mObserver = observer;                                                        \n    }                                                                                \n                                                                                     \n    abstract boolean shouldBeActive();                                               \n                                                                                     \n    boolean isAttachedTo(LifecycleOwner owner) {                                     \n        return false;                                                                \n    }                                                                                \n                                                                                     \n    void detachObserver() {                                                          \n    }                                                                                \n                                                                                     \n    void activeStateChanged(boolean newActive) {\n        // 当活动状态发生变化时\n        if (newActive == mActive) {                                                  \n            return;                                                                  \n        }                                                                            \n        // immediately set active state, so we'd never dispatch anything to inactive \n        // owner                                                                     \n        mActive = newActive;\n        // 是否为不活动状态\n        boolean wasInactive = LiveData.this.mActiveCount == 0; \n        // 当前活动个数统计\n        LiveData.this.mActiveCount += mActive ? 1 : -1;                              \n        if (wasInactive && mActive) {\n            // 不活动 -> 活动\n            onActive();                                                              \n        }                                                                            \n        if (LiveData.this.mActiveCount == 0 && !mActive) {\n            // 活动 -> 不活动\n            onInactive();                                                            \n        }                                                                            \n        if (mActive) { \n            // 当前为活动状态，分发当前 observer\n            dispatchingValue(this);                                                  \n        }                                                                            \n    }                                                                                \n}                                                                                    \n```\n\n当调用 `observe()` 会根据当前是否为活跃状态，分发当前值。\n\n#### postValue 和 setValue\n\n当在非主线程调用时，使用 `postValue()`，相关源码如下：\n\n``` java\nprotected void postValue(T value) {                                       \n    boolean postTask;                                                     \n    synchronized (mDataLock) {\n        // 当前是否存在需要分发的值\n        postTask = mPendingData == NOT_SET;  \n        // 多次调用，只会分发最后一次的值\n        mPendingData = value;                                             \n    }                                                                     \n    if (!postTask) {\n        // 已存在正在分发的任务\n        return;                                                           \n    }                                                                     \n    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);  \n}\n```\n\n这里需要注意的是，当分发数据的任务还没结束时，多次调用 `postValue` 只会分发最后一次的值，同一时间只会存在一个 `PostValueRunnable`\n\n``` java\nprivate final Runnable mPostValueRunnable = new Runnable() { \n    @Override                                                \n    public void run() {                                      \n        Object newValue;                                     \n        synchronized (mDataLock) {                           \n            newValue = mPendingData; \n            // 设置为 NOT_SET\n            mPendingData = NOT_SET;                          \n        }                                                    \n        //noinspection unchecked \n        // 再调用 setValue\n        setValue((T) newValue);                              \n    }                                                        \n}; \n\n@MainThread                                         \nprotected void setValue(T value) {\n    // 只能在主线程调用\n    assertMainThread(\"setValue\"); \n    // 使用 version 记录\n    mVersion++; \n    // 当前值\n    mData = value;  \n    // 分发\n    dispatchingValue(null);                         \n} \n\nvoid dispatchingValue(@Nullable ObserverWrapper initiator) {                           \n    if (mDispatchingValue) {\n        // 正在分发中\n        mDispatchInvalidated = true;                                                   \n        return;                                                                        \n    }                                                                                  \n    mDispatchingValue = true;                                                          \n    do {                                                                               \n        mDispatchInvalidated = false;                                                  \n        if (initiator != null) {\n            // 初始分发\n            considerNotify(initiator);                                                 \n            initiator = null;                                                          \n        } else {\n            // 升序迭代，调用 considerNotify\n            for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =  \n                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {        \n                considerNotify(iterator.next().getValue());                            \n                if (mDispatchInvalidated) {\n                    // 分发过程中，有新的数据需要分发\n                    break;                                                             \n                }                                                                      \n            }                                                                          \n        }                                                                              \n    } while (mDispatchInvalidated);                                                    \n    mDispatchingValue = false;                                                         \n}                                                                                      \n```\n\n如果有阅读过 [Jetpack中的Lifecycle](https://linxiaotao.github.io/2019/01/14/Jetpack%E4%B8%AD%E7%9A%84Lifecycle/) 这篇文章的话，可以很快看出，分发值的处理和 `Lifecycle` 有类似的地方，即在分发过程中，有新的值开始分发这种 case，都是采用中断当前的分发，推迟到下一次遍历时，分发新的值。\n\n``` java\nprivate void considerNotify(ObserverWrapper observer) {                                         \n    if (!observer.mActive) { \n        // 当前 observer 为非活动状态\n        return;                                                                                 \n    }                                                                                           \n    // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.  \n    //                                                                                          \n    // we still first check observer.active to keep it as the entrance for events. So even if   \n    // the observer moved to an active state, if we've not received that event, we better not   \n    // notify for a more predictable notification order.\n    // 可能存在已经是非活动状态，但没有接收到的 case\n    // 检测是否为活动状态\n    if (!observer.shouldBeActive()) {\n        // 非活动状态，mActive 和 shouldBeActive 不一致，通知 activeStateChanged\n        observer.activeStateChanged(false);                                                     \n        return;                                                                                 \n    }                                                                                           \n    if (observer.mLastVersion >= mVersion) { \n        // 当重新变为活动状态时，会分发当前值，避免重复值\n        return;                                                                                 \n    }                                                                                           \n    observer.mLastVersion = mVersion;                                                           \n    //noinspection unchecked                                                                    \n    observer.mObserver.onChanged((T) mData);                                                    \n}                                                                                               \n```\n\n需要注意的是，`setValue` 和 `postValue` 方法都是 `protected`，所以当我们想实现一个 LiveData 时，需要使用 MutableLiveData，源码很简单，就是将这两个方法修改为 `public`。\n\n> 这种实现思路有利于数据的不可变性。上游使用 MutableLiveData 分发数据，下游使用 LiveData 消费数据。\n\n如果使用过 RxJava 类似库的同学可能会觉得跟 LiveData 很像，同样是监听者模式。不一样的是，RxJava 提供了很多操作符，类似 `map`、`zip` 等，还有线程调度的 `observeOn` 和 `subscribeOn`。LiveData 没有线程调度的功能，它数据分发只在主线程上进行，没有线程锁等开销。除此之前，LiveData 只提供了 `map` 和 `switchMap` 的实现，但提供了 `MediatorLiveData` 去实现自己需要的操作符。\n\n#### Transformations\n\nTransformations 中有 `map` 和 `switchMap` 的实现。\n\n``` java\n@MainThread  \npublic static <X, Y> LiveData<Y> map(                              \n        @NonNull LiveData<X> source,                               \n        @NonNull final Function<X, Y> mapFunction) {\n    final MediatorLiveData<Y> result = new MediatorLiveData<>();   \n    result.addSource(source, new Observer<X>() {                   \n        @Override                                                  \n        public void onChanged(@Nullable X x) {\n            // 对源数据进行转化\n            result.setValue(mapFunction.apply(x));                 \n        }                                                          \n    });                                                            \n    return result;                                                 \n} \n\n@MainThread  \npublic static <X, Y> LiveData<Y> switchMap(                            \n        @NonNull LiveData<X> source,                                   \n        @NonNull final Function<X, LiveData<Y>> switchMapFunction) {   \n    final MediatorLiveData<Y> result = new MediatorLiveData<>();       \n    result.addSource(source, new Observer<X>() {                       \n        LiveData<Y> mSource;                                           \n                                                                       \n        @Override                                                      \n        public void onChanged(@Nullable X x) {\n            // 将发射出来的每个数据都转换成新的 LiveData，再接收\n            LiveData<Y> newLiveData = switchMapFunction.apply(x);      \n            if (mSource == newLiveData) {                              \n                return;                                                \n            }                                                          \n            if (mSource != null) {                                     \n                result.removeSource(mSource);                          \n            }                                                          \n            mSource = newLiveData;                                     \n            if (mSource != null) {                                     \n                result.addSource(mSource, new Observer<Y>() {          \n                    @Override                                          \n                    public void onChanged(@Nullable Y y) {             \n                        result.setValue(y);                            \n                    }                                                  \n                });                                                    \n            }                                                          \n        }                                                              \n    });                                                                \n    return result;                                                     \n}                                                                      \n```\n\nMediatorLiveData 可以监听多个 LiveData，这里我们简单看下它的源码：\n\n``` java\n@MainThread                                                                                       \npublic <S> void addSource(@NonNull LiveData<S> source, @NonNull Observer<? super S> onChanged) {  \n    Source<S> e = new Source<>(source, onChanged);                                                \n    Source<?> existing = mSources.putIfAbsent(source, e);                                         \n    if (existing != null && existing.mObserver != onChanged) {                                    \n        throw new IllegalArgumentException(                                                       \n                \"This source was already added with the different observer\");                     \n    }                                                                                             \n    if (existing != null) {                                                                       \n        return;                                                                                   \n    }                                                                                             \n    if (hasActiveObservers()) { \n        // 存在活动的 observer，开始监听 source livedata\n        e.plug();                                                                                 \n    }                                                                                             \n}                                                                                                 \n\n@MainThread                                                     \npublic <S> void removeSource(@NonNull LiveData<S> toRemote) {   \n    Source<?> source = mSources.remove(toRemote);               \n    if (source != null) { \n        // 删除监听\t\n        source.unplug();                                        \n    }                                                           \n}                                                               \n\n@CallSuper                                                         \n@Override                                                          \nprotected void onActive() {                                        \n    for (Map.Entry<LiveData<?>, Source<?>> source : mSources) { \n        // 重新监听\n        source.getValue().plug();                                  \n    }                                                              \n}                                                                  \n                                                                   \n@CallSuper                                                         \n@Override                                                          \nprotected void onInactive() {                                      \n    for (Map.Entry<LiveData<?>, Source<?>> source : mSources) {\n        // 暂时删除监听\n        source.getValue().unplug();                                \n    }                                                              \n}                                                                  \n\nprivate static class Source<V> implements Observer<V> {                    \n    final LiveData<V> mLiveData;                                           \n    final Observer<? super V> mObserver;                                   \n    int mVersion = START_VERSION;                                          \n                                                                           \n    Source(LiveData<V> liveData, final Observer<? super V> observer) {     \n        mLiveData = liveData;                                              \n        mObserver = observer;                                              \n    }                                                                      \n                                                                           \n    void plug() { \n        // 这里可以使用 observeForever，因为会在 onActive 和 onInactive 两个方法中处理，能响应页面的生命周期\n        mLiveData.observeForever(this);                                    \n    }                                                                      \n                                                                           \n    void unplug() {                                                        \n        mLiveData.removeObserver(this);                                    \n    }                                                                      \n                                                                           \n    @Override                                                              \n    public void onChanged(@Nullable V v) {                                 \n        if (mVersion != mLiveData.getVersion()) {                          \n            mVersion = mLiveData.getVersion();                             \n            mObserver.onChanged(v);                                        \n        }                                                                  \n    }                                                                      \n}                                                                          \n```\n\n### 总结\n\nLiveData 可以算是 RxJava 的简化版本，它最大的好处就是和 Lifecycle 结合起来使用，不需要手动处理监听。第二个是，将数据分发操作封闭在主线程，减少线程同步锁的损耗，更适合 Android 日常开发场景。","slug":"Jetpack中的LiveData","published":1,"updated":"2019-03-11T15:03:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs16000re39kqplih8hs","content":"<h3 id=\"关于LiveData\"><a href=\"#关于LiveData\" class=\"headerlink\" title=\"关于LiveData\"></a>关于LiveData</h3><p><code>LiveData</code> 是一种可观察的数据持有类，下面是常用的写法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataViewModel</span></span>(application: Application) : AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> dataSource: LiveData&lt;String&gt; = MutableLiveData()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">postValue</span><span class=\"params\">(text: <span class=\"type\">String</span>? = <span class=\"string\">\"Hello World\"</span>)</span></span> &#123;</span><br><span class=\"line\">        (dataSource <span class=\"keyword\">as</span> MutableLiveData).postValue(text)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">viewModel.dataSource.observe(<span class=\"keyword\">this</span>, <span class=\"keyword\">object</span> : Observer&lt;String&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onChanged</span><span class=\"params\">(t: <span class=\"type\">String</span>?)</span></span> &#123;</span><br><span class=\"line\">                println(<span class=\"string\">\"onChange: <span class=\"subst\">$&#123;t&#125;</span>\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>一般情况下，<code>LiveData</code> 和 <code>ViewModel</code> 都是搭配使用的，可以在 <code>Activity</code> 和 <code>Fragment</code> 范围内提供复用，并处理因配置发生改变，而重建的情况。</p>\n<blockquote>\n<p>关于 <code>ViewModel</code> 更详细的理解，可以阅读之前的文章：<a href=\"https://linxiaotao.github.io/2019/01/05/Jetpack%E4%B8%AD%E7%9A%84ViewModel/\">Jetpack中的ViewModel</a></p>\n</blockquote>\n<p>如果了解过 <a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"noopener\">RxJava</a> 的同学，对这种<strong>观察者</strong>的设计模式应该有点了解，<code>LiveData</code> 也是同样的思想，不过和 RxJava 不同的是：<code>LiveData</code> 使用 <code>Lifecycle</code> 将数据源和 <code>Activity</code> 和 <code>Fragment</code> 的生命周期结合起来，避免内存泄漏等情况。这个特性也是本文的重点。</p>\n<blockquote>\n<p>关于 Lifecycle 更详细的理解，可以阅读之前的文章：<a href=\"https://linxiaotao.github.io/2019/01/14/Jetpack%E4%B8%AD%E7%9A%84Lifecycle/\">Jetpack中的Lifecycle</a></p>\n</blockquote>\n<p>建议在阅读以下内容时，先理解下 <code>Lifecycle</code>，因为 <code>LiveData</code> 能感应 <code>Activity</code> 和 <code>Fragment</code> 的生命周期就是基于 <code>Lifecycle</code> 实现的。</p>\n<h3 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h3><h4 id=\"各个模块的作用\"><a href=\"#各个模块的作用\" class=\"headerlink\" title=\"各个模块的作用\"></a>各个模块的作用</h4><p>在理解源码之前，我们先理清组成 <code>LiveData</code> 各个模块的作用。</p>\n<h5 id=\"LiveData\"><a href=\"#LiveData\" class=\"headerlink\" title=\"LiveData\"></a>LiveData</h5><p><code>LiveData</code> 表示一个可观察的数据源。在 <code>LiveData</code> 的设计中，它被设计为一个纯粹的数据源，对外只提供了：</p>\n<ul>\n<li><p>observe(LifecycleOwner,Observer)</p>\n<p>表示注册一个观察者（<code>Observer</code>），这里同时需要提供一个 <code>LifecycleOwner</code> 用于提供 <code>Lifecycle</code></p>\n</li>\n<li><p>observeForever(Observer)</p>\n<p>功能和 <code>observe(LifecycleOwner,Observer)</code> 类似，但缺少感应生命周期的功能</p>\n</li>\n<li><p>removeObserver(Observer) 和 removeObservers(LifecycleOwner)</p>\n<p>表示删除观察者，后者则是删除同个 <code>LifecycleOwner</code> 范围的 <code>Observer</code></p>\n</li>\n<li><p>getValue()</p>\n<p>表示获取当前值</p>\n</li>\n<li><p>hasObservers()</p>\n<p>表示是否存在 <code>Observer</code></p>\n</li>\n<li><p>hasActiveObservers()</p>\n<p>表示是否存在活动的 <code>Observer</code>，至于怎么去定义为活动的，后面会讲到</p>\n</li>\n</ul>\n<p><code>LiveData</code> 是一个纯粹的数据源，不包含添加数据的公开 API，只能通过使用 <code>MutableLiveData</code> 去添加数据</p>\n<blockquote>\n<p>这是一种不错的设计理念，单个组件功能越纯粹，代码的耦合度就越低。</p>\n</blockquote>\n<h5 id=\"Observer\"><a href=\"#Observer\" class=\"headerlink\" title=\"Observer\"></a>Observer</h5><p><code>Observer</code> 表示观察者，响应数据发生变化。API 也非常简单：<code>onChange(T)</code>，这里需要注意的是：<code>onChange()</code> 中数据可以为 <code>NULL</code>，这和 <code>RxJava2</code> 的设计是不一样的，这个很难说，哪个设计更优。但根据 <a href=\"https://github.com/JakeWharton\" target=\"_blank\" rel=\"noopener\">JakeWharton</a> 的回答是：It’s not RxJava’s choice, it’s in the reactive streams spec.</p>\n<blockquote>\n<p>关于 <code>RxJava2</code> 不能传递 <code>NULL</code> 的讨论，可以参考这篇<a href=\"https://github.com/ReactiveX/RxJava/issues/4644\" target=\"_blank\" rel=\"noopener\">文章</a></p>\n</blockquote>\n<h4 id=\"observe\"><a href=\"#observe\" class=\"headerlink\" title=\"observe\"></a>observe</h4><p>调用 <code>LiveData.observe(LifecycleOwner,Observer)</code> 去注册一个订阅者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                                                 </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observe</span><span class=\"params\">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意，只能主线程调用</span></span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"observe\"</span>);                                                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;                              </span><br><span class=\"line\">        <span class=\"comment\">// ignore                                                                           </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 LifecycleBoundObserver 包装类</span></span><br><span class=\"line\">    LifecycleBoundObserver wrapper = <span class=\"keyword\">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class=\"line\">    <span class=\"comment\">// mObservers 为 Map&lt;Observer,ObserverWrapper&gt;</span></span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);                   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存在不同 LifecycleOwner 但相同 observer，抛异常</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Cannot add the same observer\"</span>                   </span><br><span class=\"line\">                + <span class=\"string\">\" with different lifecycles\"</span>);                                            </span><br><span class=\"line\">    &#125;                                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">    &#125;                                                                                       </span><br><span class=\"line\">    owner.getLifecycle().addObserver(wrapper);                                              </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// LifecycleBoundObserver</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                     </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mOwner == owner;                   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>LifecycleBoundObserver</code> 实现了 <code>GenericLifecycleObserver</code> 接口，用于响应 <code>Activity</code> 和 <code>Fragment</code> 的生命周期</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleBoundObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">GenericLifecycleObserver</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span>                                                                                 </span><br><span class=\"line\">    <span class=\"keyword\">final</span> LifecycleOwner mOwner;                                                             </span><br><span class=\"line\">                                                                                             </span><br><span class=\"line\">    LifecycleBoundObserver(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer) &#123;    </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);                                                                     </span><br><span class=\"line\">        mOwner = owner;                                                                      </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">                                                                                             </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 检测是否为活动状态</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);                   </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">                                                                                             </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// DESTROYED 时移除 observer</span></span><br><span class=\"line\">            removeObserver(mObserver);                                                       </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                          </span><br><span class=\"line\">        &#125;                                                                                    </span><br><span class=\"line\">        activeStateChanged(shouldBeActive());                                                </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">                                                                                             </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为同个 LifecycleOwner</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner == owner;                                                              </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">                                                                                             </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.removeObserver</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. lifecycle state 没有在 started 之后，或者已经是 destoryed</span></span><br><span class=\"line\">        <span class=\"comment\">// 以上两种情况会调用 detachObserver</span></span><br><span class=\"line\">        <span class=\"comment\">// 从 Lifecycle 中移除 observer</span></span><br><span class=\"line\">        mOwner.getLifecycle().removeObserver(<span class=\"keyword\">this</span>);                                          </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverWrapper</span> </span>&#123;                                             </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; mObserver;                                             </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> mActive;                                                                 </span><br><span class=\"line\">    <span class=\"keyword\">int</span> mLastVersion = START_VERSION;                                                </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">    ObserverWrapper(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer) &#123;                                  </span><br><span class=\"line\">        mObserver = observer;                                                        </span><br><span class=\"line\">    &#125;                                                                                </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span></span>;                                               </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;                                     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">    &#125;                                                                                </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;                                                          </span><br><span class=\"line\">    &#125;                                                                                </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activeStateChanged</span><span class=\"params\">(<span class=\"keyword\">boolean</span> newActive)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当活动状态发生变化时</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newActive == mActive) &#123;                                                  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                  </span><br><span class=\"line\">        &#125;                                                                            </span><br><span class=\"line\">        <span class=\"comment\">// immediately set active state, so we'd never dispatch anything to inactive </span></span><br><span class=\"line\">        <span class=\"comment\">// owner                                                                     </span></span><br><span class=\"line\">        mActive = newActive;</span><br><span class=\"line\">        <span class=\"comment\">// 是否为不活动状态</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> wasInactive = LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span>; </span><br><span class=\"line\">        <span class=\"comment\">// 当前活动个数统计</span></span><br><span class=\"line\">        LiveData.<span class=\"keyword\">this</span>.mActiveCount += mActive ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;                              </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不活动 -&gt; 活动</span></span><br><span class=\"line\">            onActive();                                                              </span><br><span class=\"line\">        &#125;                                                                            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span> &amp;&amp; !mActive) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 活动 -&gt; 不活动</span></span><br><span class=\"line\">            onInactive();                                                            </span><br><span class=\"line\">        &#125;                                                                            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActive) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 当前为活动状态，分发当前 observer</span></span><br><span class=\"line\">            dispatchingValue(<span class=\"keyword\">this</span>);                                                  </span><br><span class=\"line\">        &#125;                                                                            </span><br><span class=\"line\">    &#125;                                                                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当调用 <code>observe()</code> 会根据当前是否为活跃状态，分发当前值。</p>\n<h4 id=\"postValue-和-setValue\"><a href=\"#postValue-和-setValue\" class=\"headerlink\" title=\"postValue 和 setValue\"></a>postValue 和 setValue</h4><p>当在非主线程调用时，使用 <code>postValue()</code>，相关源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;                                       </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> postTask;                                                     </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mDataLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前是否存在需要分发的值</span></span><br><span class=\"line\">        postTask = mPendingData == NOT_SET;  </span><br><span class=\"line\">        <span class=\"comment\">// 多次调用，只会分发最后一次的值</span></span><br><span class=\"line\">        mPendingData = value;                                             </span><br><span class=\"line\">    &#125;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!postTask) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 已存在正在分发的任务</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                           </span><br><span class=\"line\">    &#125;                                                                     </span><br><span class=\"line\">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是，当分发数据的任务还没结束时，多次调用 <code>postValue</code> 只会分发最后一次的值，同一时间只会存在一个 <code>PostValueRunnable</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;                                      </span><br><span class=\"line\">        Object newValue;                                     </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mDataLock) &#123;                           </span><br><span class=\"line\">            newValue = mPendingData; </span><br><span class=\"line\">            <span class=\"comment\">// 设置为 NOT_SET</span></span><br><span class=\"line\">            mPendingData = NOT_SET;                          </span><br><span class=\"line\">        &#125;                                                    </span><br><span class=\"line\">        <span class=\"comment\">//noinspection unchecked </span></span><br><span class=\"line\">        <span class=\"comment\">// 再调用 setValue</span></span><br><span class=\"line\">        setValue((T) newValue);                              </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                         </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只能在主线程调用</span></span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"setValue\"</span>); </span><br><span class=\"line\">    <span class=\"comment\">// 使用 version 记录</span></span><br><span class=\"line\">    mVersion++; </span><br><span class=\"line\">    <span class=\"comment\">// 当前值</span></span><br><span class=\"line\">    mData = value;  </span><br><span class=\"line\">    <span class=\"comment\">// 分发</span></span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);                         </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(@Nullable ObserverWrapper initiator)</span> </span>&#123;                           </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDispatchingValue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 正在分发中</span></span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">true</span>;                                                   </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                        </span><br><span class=\"line\">    &#125;                                                                                  </span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">true</span>;                                                          </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;                                                                               </span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;                                                  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initiator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始分发</span></span><br><span class=\"line\">            considerNotify(initiator);                                                 </span><br><span class=\"line\">            initiator = <span class=\"keyword\">null</span>;                                                          </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 升序迭代，调用 considerNotify</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"keyword\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =  </span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;        </span><br><span class=\"line\">                considerNotify(iterator.next().getValue());                            </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 分发过程中，有新的数据需要分发</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                             </span><br><span class=\"line\">                &#125;                                                                      </span><br><span class=\"line\">            &#125;                                                                          </span><br><span class=\"line\">        &#125;                                                                              </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);                                                    </span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有阅读过 <a href=\"https://linxiaotao.github.io/2019/01/14/Jetpack%E4%B8%AD%E7%9A%84Lifecycle/\">Jetpack中的Lifecycle</a> 这篇文章的话，可以很快看出，分发值的处理和 <code>Lifecycle</code> 有类似的地方，即在分发过程中，有新的值开始分发这种 case，都是采用中断当前的分发，推迟到下一次遍历时，分发新的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 当前 observer 为非活动状态</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"comment\">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.  </span></span><br><span class=\"line\">    <span class=\"comment\">//                                                                                          </span></span><br><span class=\"line\">    <span class=\"comment\">// we still first check observer.active to keep it as the entrance for events. So even if   </span></span><br><span class=\"line\">    <span class=\"comment\">// the observer moved to an active state, if we've not received that event, we better not   </span></span><br><span class=\"line\">    <span class=\"comment\">// notify for a more predictable notification order.</span></span><br><span class=\"line\">    <span class=\"comment\">// 可能存在已经是非活动状态，但没有接收到的 case</span></span><br><span class=\"line\">    <span class=\"comment\">// 检测是否为活动状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 非活动状态，mActive 和 shouldBeActive 不一致，通知 activeStateChanged</span></span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);                                                     </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 当重新变为活动状态时，会分发当前值，避免重复值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    observer.mLastVersion = mVersion;                                                           </span><br><span class=\"line\">    <span class=\"comment\">//noinspection unchecked                                                                    </span></span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，<code>setValue</code> 和 <code>postValue</code> 方法都是 <code>protected</code>，所以当我们想实现一个 LiveData 时，需要使用 MutableLiveData，源码很简单，就是将这两个方法修改为 <code>public</code>。</p>\n<blockquote>\n<p>这种实现思路有利于数据的不可变性。上游使用 MutableLiveData 分发数据，下游使用 LiveData 消费数据。</p>\n</blockquote>\n<p>如果使用过 RxJava 类似库的同学可能会觉得跟 LiveData 很像，同样是监听者模式。不一样的是，RxJava 提供了很多操作符，类似 <code>map</code>、<code>zip</code> 等，还有线程调度的 <code>observeOn</code> 和 <code>subscribeOn</code>。LiveData 没有线程调度的功能，它数据分发只在主线程上进行，没有线程锁等开销。除此之前，LiveData 只提供了 <code>map</code> 和 <code>switchMap</code> 的实现，但提供了 <code>MediatorLiveData</code> 去实现自己需要的操作符。</p>\n<h4 id=\"Transformations\"><a href=\"#Transformations\" class=\"headerlink\" title=\"Transformations\"></a>Transformations</h4><p>Transformations 中有 <code>map</code> 和 <code>switchMap</code> 的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;X, Y&gt; <span class=\"function\">LiveData&lt;Y&gt; <span class=\"title\">map</span><span class=\"params\">(                              </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull LiveData&lt;X&gt; source,                               </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull <span class=\"keyword\">final</span> Function&lt;X, Y&gt; mapFunction)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> MediatorLiveData&lt;Y&gt; result = <span class=\"keyword\">new</span> MediatorLiveData&lt;&gt;();   </span><br><span class=\"line\">    result.addSource(source, <span class=\"keyword\">new</span> Observer&lt;X&gt;() &#123;                   </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>                                                  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable X x)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 对源数据进行转化</span></span><br><span class=\"line\">            result.setValue(mapFunction.apply(x));                 </span><br><span class=\"line\">        &#125;                                                          </span><br><span class=\"line\">    &#125;);                                                            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;                                                 </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;X, Y&gt; <span class=\"function\">LiveData&lt;Y&gt; <span class=\"title\">switchMap</span><span class=\"params\">(                            </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull LiveData&lt;X&gt; source,                                   </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull <span class=\"keyword\">final</span> Function&lt;X, LiveData&lt;Y&gt;&gt; switchMapFunction)</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">final</span> MediatorLiveData&lt;Y&gt; result = <span class=\"keyword\">new</span> MediatorLiveData&lt;&gt;();       </span><br><span class=\"line\">    result.addSource(source, <span class=\"keyword\">new</span> Observer&lt;X&gt;() &#123;                       </span><br><span class=\"line\">        LiveData&lt;Y&gt; mSource;                                           </span><br><span class=\"line\">                                                                       </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>                                                      </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable X x)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将发射出来的每个数据都转换成新的 LiveData，再接收</span></span><br><span class=\"line\">            LiveData&lt;Y&gt; newLiveData = switchMapFunction.apply(x);      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mSource == newLiveData) &#123;                              </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;                                                </span><br><span class=\"line\">            &#125;                                                          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mSource != <span class=\"keyword\">null</span>) &#123;                                     </span><br><span class=\"line\">                result.removeSource(mSource);                          </span><br><span class=\"line\">            &#125;                                                          </span><br><span class=\"line\">            mSource = newLiveData;                                     </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mSource != <span class=\"keyword\">null</span>) &#123;                                     </span><br><span class=\"line\">                result.addSource(mSource, <span class=\"keyword\">new</span> Observer&lt;Y&gt;() &#123;          </span><br><span class=\"line\">                    <span class=\"meta\">@Override</span>                                          </span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Y y)</span> </span>&#123;             </span><br><span class=\"line\">                        result.setValue(y);                            </span><br><span class=\"line\">                    &#125;                                                  </span><br><span class=\"line\">                &#125;);                                                    </span><br><span class=\"line\">            &#125;                                                          </span><br><span class=\"line\">        &#125;                                                              </span><br><span class=\"line\">    &#125;);                                                                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MediatorLiveData 可以监听多个 LiveData，这里我们简单看下它的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                                                       </span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;S&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addSource</span><span class=\"params\">(@NonNull LiveData&lt;S&gt; source, @NonNull Observer&lt;? <span class=\"keyword\">super</span> S&gt; onChanged)</span> </span>&#123;  </span><br><span class=\"line\">    Source&lt;S&gt; e = <span class=\"keyword\">new</span> Source&lt;&gt;(source, onChanged);                                                </span><br><span class=\"line\">    Source&lt;?&gt; existing = mSources.putIfAbsent(source, e);                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span> &amp;&amp; existing.mObserver != onChanged) &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(                                                       </span><br><span class=\"line\">                <span class=\"string\">\"This source was already added with the different observer\"</span>);                     </span><br><span class=\"line\">    &#125;                                                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                   </span><br><span class=\"line\">    &#125;                                                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasActiveObservers()) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 存在活动的 observer，开始监听 source livedata</span></span><br><span class=\"line\">        e.plug();                                                                                 </span><br><span class=\"line\">    &#125;                                                                                             </span><br><span class=\"line\">&#125;                                                                                                 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                     </span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;S&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeSource</span><span class=\"params\">(@NonNull LiveData&lt;S&gt; toRemote)</span> </span>&#123;   </span><br><span class=\"line\">    Source&lt;?&gt; source = mSources.remove(toRemote);               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (source != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 删除监听\t</span></span><br><span class=\"line\">        source.unplug();                                        </span><br><span class=\"line\">    &#125;                                                           </span><br><span class=\"line\">&#125;                                                               </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@CallSuper</span>                                                         </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;                                        </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 重新监听</span></span><br><span class=\"line\">        source.getValue().plug();                                  </span><br><span class=\"line\">    &#125;                                                              </span><br><span class=\"line\">&#125;                                                                  </span><br><span class=\"line\">                                                                   </span><br><span class=\"line\"><span class=\"meta\">@CallSuper</span>                                                         </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onInactive</span><span class=\"params\">()</span> </span>&#123;                                      </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 暂时删除监听</span></span><br><span class=\"line\">        source.getValue().unplug();                                </span><br><span class=\"line\">    &#125;                                                              </span><br><span class=\"line\">&#125;                                                                  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Source</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;                    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> LiveData&lt;V&gt; mLiveData;                                           </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> V&gt; mObserver;                                   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> mVersion = START_VERSION;                                          </span><br><span class=\"line\">                                                                           </span><br><span class=\"line\">    Source(LiveData&lt;V&gt; liveData, <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> V&gt; observer) &#123;     </span><br><span class=\"line\">        mLiveData = liveData;                                              </span><br><span class=\"line\">        mObserver = observer;                                              </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">                                                                           </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">plug</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 这里可以使用 observeForever，因为会在 onActive 和 onInactive 两个方法中处理，能响应页面的生命周期</span></span><br><span class=\"line\">        mLiveData.observeForever(<span class=\"keyword\">this</span>);                                    </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">                                                                           </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unplug</span><span class=\"params\">()</span> </span>&#123;                                                        </span><br><span class=\"line\">        mLiveData.removeObserver(<span class=\"keyword\">this</span>);                                    </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">                                                                           </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                              </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable V v)</span> </span>&#123;                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mVersion != mLiveData.getVersion()) &#123;                          </span><br><span class=\"line\">            mVersion = mLiveData.getVersion();                             </span><br><span class=\"line\">            mObserver.onChanged(v);                                        </span><br><span class=\"line\">        &#125;                                                                  </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>LiveData 可以算是 RxJava 的简化版本，它最大的好处就是和 Lifecycle 结合起来使用，不需要手动处理监听。第二个是，将数据分发操作封闭在主线程，减少线程同步锁的损耗，更适合 Android 日常开发场景。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"关于LiveData\"><a href=\"#关于LiveData\" class=\"headerlink\" title=\"关于LiveData\"></a>关于LiveData</h3><p><code>LiveData</code> 是一种可观察的数据持有类，下面是常用的写法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataViewModel</span></span>(application: Application) : AndroidViewModel(application) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> dataSource: LiveData&lt;String&gt; = MutableLiveData()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">postValue</span><span class=\"params\">(text: <span class=\"type\">String</span>? = <span class=\"string\">\"Hello World\"</span>)</span></span> &#123;</span><br><span class=\"line\">        (dataSource <span class=\"keyword\">as</span> MutableLiveData).postValue(text)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">viewModel.dataSource.observe(<span class=\"keyword\">this</span>, <span class=\"keyword\">object</span> : Observer&lt;String&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onChanged</span><span class=\"params\">(t: <span class=\"type\">String</span>?)</span></span> &#123;</span><br><span class=\"line\">                println(<span class=\"string\">\"onChange: <span class=\"subst\">$&#123;t&#125;</span>\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>一般情况下，<code>LiveData</code> 和 <code>ViewModel</code> 都是搭配使用的，可以在 <code>Activity</code> 和 <code>Fragment</code> 范围内提供复用，并处理因配置发生改变，而重建的情况。</p>\n<blockquote>\n<p>关于 <code>ViewModel</code> 更详细的理解，可以阅读之前的文章：<a href=\"https://linxiaotao.github.io/2019/01/05/Jetpack%E4%B8%AD%E7%9A%84ViewModel/\">Jetpack中的ViewModel</a></p>\n</blockquote>\n<p>如果了解过 <a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"noopener\">RxJava</a> 的同学，对这种<strong>观察者</strong>的设计模式应该有点了解，<code>LiveData</code> 也是同样的思想，不过和 RxJava 不同的是：<code>LiveData</code> 使用 <code>Lifecycle</code> 将数据源和 <code>Activity</code> 和 <code>Fragment</code> 的生命周期结合起来，避免内存泄漏等情况。这个特性也是本文的重点。</p>\n<blockquote>\n<p>关于 Lifecycle 更详细的理解，可以阅读之前的文章：<a href=\"https://linxiaotao.github.io/2019/01/14/Jetpack%E4%B8%AD%E7%9A%84Lifecycle/\">Jetpack中的Lifecycle</a></p>\n</blockquote>\n<p>建议在阅读以下内容时，先理解下 <code>Lifecycle</code>，因为 <code>LiveData</code> 能感应 <code>Activity</code> 和 <code>Fragment</code> 的生命周期就是基于 <code>Lifecycle</code> 实现的。</p>\n<h3 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h3><h4 id=\"各个模块的作用\"><a href=\"#各个模块的作用\" class=\"headerlink\" title=\"各个模块的作用\"></a>各个模块的作用</h4><p>在理解源码之前，我们先理清组成 <code>LiveData</code> 各个模块的作用。</p>\n<h5 id=\"LiveData\"><a href=\"#LiveData\" class=\"headerlink\" title=\"LiveData\"></a>LiveData</h5><p><code>LiveData</code> 表示一个可观察的数据源。在 <code>LiveData</code> 的设计中，它被设计为一个纯粹的数据源，对外只提供了：</p>\n<ul>\n<li><p>observe(LifecycleOwner,Observer)</p>\n<p>表示注册一个观察者（<code>Observer</code>），这里同时需要提供一个 <code>LifecycleOwner</code> 用于提供 <code>Lifecycle</code></p>\n</li>\n<li><p>observeForever(Observer)</p>\n<p>功能和 <code>observe(LifecycleOwner,Observer)</code> 类似，但缺少感应生命周期的功能</p>\n</li>\n<li><p>removeObserver(Observer) 和 removeObservers(LifecycleOwner)</p>\n<p>表示删除观察者，后者则是删除同个 <code>LifecycleOwner</code> 范围的 <code>Observer</code></p>\n</li>\n<li><p>getValue()</p>\n<p>表示获取当前值</p>\n</li>\n<li><p>hasObservers()</p>\n<p>表示是否存在 <code>Observer</code></p>\n</li>\n<li><p>hasActiveObservers()</p>\n<p>表示是否存在活动的 <code>Observer</code>，至于怎么去定义为活动的，后面会讲到</p>\n</li>\n</ul>\n<p><code>LiveData</code> 是一个纯粹的数据源，不包含添加数据的公开 API，只能通过使用 <code>MutableLiveData</code> 去添加数据</p>\n<blockquote>\n<p>这是一种不错的设计理念，单个组件功能越纯粹，代码的耦合度就越低。</p>\n</blockquote>\n<h5 id=\"Observer\"><a href=\"#Observer\" class=\"headerlink\" title=\"Observer\"></a>Observer</h5><p><code>Observer</code> 表示观察者，响应数据发生变化。API 也非常简单：<code>onChange(T)</code>，这里需要注意的是：<code>onChange()</code> 中数据可以为 <code>NULL</code>，这和 <code>RxJava2</code> 的设计是不一样的，这个很难说，哪个设计更优。但根据 <a href=\"https://github.com/JakeWharton\" target=\"_blank\" rel=\"noopener\">JakeWharton</a> 的回答是：It’s not RxJava’s choice, it’s in the reactive streams spec.</p>\n<blockquote>\n<p>关于 <code>RxJava2</code> 不能传递 <code>NULL</code> 的讨论，可以参考这篇<a href=\"https://github.com/ReactiveX/RxJava/issues/4644\" target=\"_blank\" rel=\"noopener\">文章</a></p>\n</blockquote>\n<h4 id=\"observe\"><a href=\"#observe\" class=\"headerlink\" title=\"observe\"></a>observe</h4><p>调用 <code>LiveData.observe(LifecycleOwner,Observer)</code> 去注册一个订阅者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                                                 </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observe</span><span class=\"params\">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意，只能主线程调用</span></span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"observe\"</span>);                                                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;                              </span><br><span class=\"line\">        <span class=\"comment\">// ignore                                                                           </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 LifecycleBoundObserver 包装类</span></span><br><span class=\"line\">    LifecycleBoundObserver wrapper = <span class=\"keyword\">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class=\"line\">    <span class=\"comment\">// mObservers 为 Map&lt;Observer,ObserverWrapper&gt;</span></span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);                   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存在不同 LifecycleOwner 但相同 observer，抛异常</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Cannot add the same observer\"</span>                   </span><br><span class=\"line\">                + <span class=\"string\">\" with different lifecycles\"</span>);                                            </span><br><span class=\"line\">    &#125;                                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;                                                                 </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                             </span><br><span class=\"line\">    &#125;                                                                                       </span><br><span class=\"line\">    owner.getLifecycle().addObserver(wrapper);                                              </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// LifecycleBoundObserver</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                     </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mOwner == owner;                   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>LifecycleBoundObserver</code> 实现了 <code>GenericLifecycleObserver</code> 接口，用于响应 <code>Activity</code> 和 <code>Fragment</code> 的生命周期</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleBoundObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">GenericLifecycleObserver</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span>                                                                                 </span><br><span class=\"line\">    <span class=\"keyword\">final</span> LifecycleOwner mOwner;                                                             </span><br><span class=\"line\">                                                                                             </span><br><span class=\"line\">    LifecycleBoundObserver(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer) &#123;    </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);                                                                     </span><br><span class=\"line\">        mOwner = owner;                                                                      </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">                                                                                             </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 检测是否为活动状态</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);                   </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">                                                                                             </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// DESTROYED 时移除 observer</span></span><br><span class=\"line\">            removeObserver(mObserver);                                                       </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                          </span><br><span class=\"line\">        &#125;                                                                                    </span><br><span class=\"line\">        activeStateChanged(shouldBeActive());                                                </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">                                                                                             </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为同个 LifecycleOwner</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner == owner;                                                              </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">                                                                                             </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.removeObserver</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. lifecycle state 没有在 started 之后，或者已经是 destoryed</span></span><br><span class=\"line\">        <span class=\"comment\">// 以上两种情况会调用 detachObserver</span></span><br><span class=\"line\">        <span class=\"comment\">// 从 Lifecycle 中移除 observer</span></span><br><span class=\"line\">        mOwner.getLifecycle().removeObserver(<span class=\"keyword\">this</span>);                                          </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverWrapper</span> </span>&#123;                                             </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; mObserver;                                             </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> mActive;                                                                 </span><br><span class=\"line\">    <span class=\"keyword\">int</span> mLastVersion = START_VERSION;                                                </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">    ObserverWrapper(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer) &#123;                                  </span><br><span class=\"line\">        mObserver = observer;                                                        </span><br><span class=\"line\">    &#125;                                                                                </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span></span>;                                               </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;                                     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">    &#125;                                                                                </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;                                                          </span><br><span class=\"line\">    &#125;                                                                                </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activeStateChanged</span><span class=\"params\">(<span class=\"keyword\">boolean</span> newActive)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当活动状态发生变化时</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newActive == mActive) &#123;                                                  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                                  </span><br><span class=\"line\">        &#125;                                                                            </span><br><span class=\"line\">        <span class=\"comment\">// immediately set active state, so we'd never dispatch anything to inactive </span></span><br><span class=\"line\">        <span class=\"comment\">// owner                                                                     </span></span><br><span class=\"line\">        mActive = newActive;</span><br><span class=\"line\">        <span class=\"comment\">// 是否为不活动状态</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> wasInactive = LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span>; </span><br><span class=\"line\">        <span class=\"comment\">// 当前活动个数统计</span></span><br><span class=\"line\">        LiveData.<span class=\"keyword\">this</span>.mActiveCount += mActive ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;                              </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不活动 -&gt; 活动</span></span><br><span class=\"line\">            onActive();                                                              </span><br><span class=\"line\">        &#125;                                                                            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span> &amp;&amp; !mActive) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 活动 -&gt; 不活动</span></span><br><span class=\"line\">            onInactive();                                                            </span><br><span class=\"line\">        &#125;                                                                            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActive) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 当前为活动状态，分发当前 observer</span></span><br><span class=\"line\">            dispatchingValue(<span class=\"keyword\">this</span>);                                                  </span><br><span class=\"line\">        &#125;                                                                            </span><br><span class=\"line\">    &#125;                                                                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当调用 <code>observe()</code> 会根据当前是否为活跃状态，分发当前值。</p>\n<h4 id=\"postValue-和-setValue\"><a href=\"#postValue-和-setValue\" class=\"headerlink\" title=\"postValue 和 setValue\"></a>postValue 和 setValue</h4><p>当在非主线程调用时，使用 <code>postValue()</code>，相关源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;                                       </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> postTask;                                                     </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mDataLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前是否存在需要分发的值</span></span><br><span class=\"line\">        postTask = mPendingData == NOT_SET;  </span><br><span class=\"line\">        <span class=\"comment\">// 多次调用，只会分发最后一次的值</span></span><br><span class=\"line\">        mPendingData = value;                                             </span><br><span class=\"line\">    &#125;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!postTask) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 已存在正在分发的任务</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                           </span><br><span class=\"line\">    &#125;                                                                     </span><br><span class=\"line\">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是，当分发数据的任务还没结束时，多次调用 <code>postValue</code> 只会分发最后一次的值，同一时间只会存在一个 <code>PostValueRunnable</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;                                      </span><br><span class=\"line\">        Object newValue;                                     </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mDataLock) &#123;                           </span><br><span class=\"line\">            newValue = mPendingData; </span><br><span class=\"line\">            <span class=\"comment\">// 设置为 NOT_SET</span></span><br><span class=\"line\">            mPendingData = NOT_SET;                          </span><br><span class=\"line\">        &#125;                                                    </span><br><span class=\"line\">        <span class=\"comment\">//noinspection unchecked </span></span><br><span class=\"line\">        <span class=\"comment\">// 再调用 setValue</span></span><br><span class=\"line\">        setValue((T) newValue);                              </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                         </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只能在主线程调用</span></span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"setValue\"</span>); </span><br><span class=\"line\">    <span class=\"comment\">// 使用 version 记录</span></span><br><span class=\"line\">    mVersion++; </span><br><span class=\"line\">    <span class=\"comment\">// 当前值</span></span><br><span class=\"line\">    mData = value;  </span><br><span class=\"line\">    <span class=\"comment\">// 分发</span></span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);                         </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(@Nullable ObserverWrapper initiator)</span> </span>&#123;                           </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDispatchingValue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 正在分发中</span></span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">true</span>;                                                   </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                        </span><br><span class=\"line\">    &#125;                                                                                  </span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">true</span>;                                                          </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;                                                                               </span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;                                                  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initiator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始分发</span></span><br><span class=\"line\">            considerNotify(initiator);                                                 </span><br><span class=\"line\">            initiator = <span class=\"keyword\">null</span>;                                                          </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 升序迭代，调用 considerNotify</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"keyword\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =  </span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;        </span><br><span class=\"line\">                considerNotify(iterator.next().getValue());                            </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 分发过程中，有新的数据需要分发</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                                                             </span><br><span class=\"line\">                &#125;                                                                      </span><br><span class=\"line\">            &#125;                                                                          </span><br><span class=\"line\">        &#125;                                                                              </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);                                                    </span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有阅读过 <a href=\"https://linxiaotao.github.io/2019/01/14/Jetpack%E4%B8%AD%E7%9A%84Lifecycle/\">Jetpack中的Lifecycle</a> 这篇文章的话，可以很快看出，分发值的处理和 <code>Lifecycle</code> 有类似的地方，即在分发过程中，有新的值开始分发这种 case，都是采用中断当前的分发，推迟到下一次遍历时，分发新的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 当前 observer 为非活动状态</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"comment\">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.  </span></span><br><span class=\"line\">    <span class=\"comment\">//                                                                                          </span></span><br><span class=\"line\">    <span class=\"comment\">// we still first check observer.active to keep it as the entrance for events. So even if   </span></span><br><span class=\"line\">    <span class=\"comment\">// the observer moved to an active state, if we've not received that event, we better not   </span></span><br><span class=\"line\">    <span class=\"comment\">// notify for a more predictable notification order.</span></span><br><span class=\"line\">    <span class=\"comment\">// 可能存在已经是非活动状态，但没有接收到的 case</span></span><br><span class=\"line\">    <span class=\"comment\">// 检测是否为活动状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 非活动状态，mActive 和 shouldBeActive 不一致，通知 activeStateChanged</span></span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);                                                     </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 当重新变为活动状态时，会分发当前值，避免重复值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                 </span><br><span class=\"line\">    &#125;                                                                                           </span><br><span class=\"line\">    observer.mLastVersion = mVersion;                                                           </span><br><span class=\"line\">    <span class=\"comment\">//noinspection unchecked                                                                    </span></span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);                                                    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，<code>setValue</code> 和 <code>postValue</code> 方法都是 <code>protected</code>，所以当我们想实现一个 LiveData 时，需要使用 MutableLiveData，源码很简单，就是将这两个方法修改为 <code>public</code>。</p>\n<blockquote>\n<p>这种实现思路有利于数据的不可变性。上游使用 MutableLiveData 分发数据，下游使用 LiveData 消费数据。</p>\n</blockquote>\n<p>如果使用过 RxJava 类似库的同学可能会觉得跟 LiveData 很像，同样是监听者模式。不一样的是，RxJava 提供了很多操作符，类似 <code>map</code>、<code>zip</code> 等，还有线程调度的 <code>observeOn</code> 和 <code>subscribeOn</code>。LiveData 没有线程调度的功能，它数据分发只在主线程上进行，没有线程锁等开销。除此之前，LiveData 只提供了 <code>map</code> 和 <code>switchMap</code> 的实现，但提供了 <code>MediatorLiveData</code> 去实现自己需要的操作符。</p>\n<h4 id=\"Transformations\"><a href=\"#Transformations\" class=\"headerlink\" title=\"Transformations\"></a>Transformations</h4><p>Transformations 中有 <code>map</code> 和 <code>switchMap</code> 的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;X, Y&gt; <span class=\"function\">LiveData&lt;Y&gt; <span class=\"title\">map</span><span class=\"params\">(                              </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull LiveData&lt;X&gt; source,                               </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull <span class=\"keyword\">final</span> Function&lt;X, Y&gt; mapFunction)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> MediatorLiveData&lt;Y&gt; result = <span class=\"keyword\">new</span> MediatorLiveData&lt;&gt;();   </span><br><span class=\"line\">    result.addSource(source, <span class=\"keyword\">new</span> Observer&lt;X&gt;() &#123;                   </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>                                                  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable X x)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 对源数据进行转化</span></span><br><span class=\"line\">            result.setValue(mapFunction.apply(x));                 </span><br><span class=\"line\">        &#125;                                                          </span><br><span class=\"line\">    &#125;);                                                            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;                                                 </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;X, Y&gt; <span class=\"function\">LiveData&lt;Y&gt; <span class=\"title\">switchMap</span><span class=\"params\">(                            </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull LiveData&lt;X&gt; source,                                   </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull <span class=\"keyword\">final</span> Function&lt;X, LiveData&lt;Y&gt;&gt; switchMapFunction)</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">final</span> MediatorLiveData&lt;Y&gt; result = <span class=\"keyword\">new</span> MediatorLiveData&lt;&gt;();       </span><br><span class=\"line\">    result.addSource(source, <span class=\"keyword\">new</span> Observer&lt;X&gt;() &#123;                       </span><br><span class=\"line\">        LiveData&lt;Y&gt; mSource;                                           </span><br><span class=\"line\">                                                                       </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>                                                      </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable X x)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将发射出来的每个数据都转换成新的 LiveData，再接收</span></span><br><span class=\"line\">            LiveData&lt;Y&gt; newLiveData = switchMapFunction.apply(x);      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mSource == newLiveData) &#123;                              </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;                                                </span><br><span class=\"line\">            &#125;                                                          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mSource != <span class=\"keyword\">null</span>) &#123;                                     </span><br><span class=\"line\">                result.removeSource(mSource);                          </span><br><span class=\"line\">            &#125;                                                          </span><br><span class=\"line\">            mSource = newLiveData;                                     </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mSource != <span class=\"keyword\">null</span>) &#123;                                     </span><br><span class=\"line\">                result.addSource(mSource, <span class=\"keyword\">new</span> Observer&lt;Y&gt;() &#123;          </span><br><span class=\"line\">                    <span class=\"meta\">@Override</span>                                          </span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Y y)</span> </span>&#123;             </span><br><span class=\"line\">                        result.setValue(y);                            </span><br><span class=\"line\">                    &#125;                                                  </span><br><span class=\"line\">                &#125;);                                                    </span><br><span class=\"line\">            &#125;                                                          </span><br><span class=\"line\">        &#125;                                                              </span><br><span class=\"line\">    &#125;);                                                                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MediatorLiveData 可以监听多个 LiveData，这里我们简单看下它的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                                                       </span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;S&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addSource</span><span class=\"params\">(@NonNull LiveData&lt;S&gt; source, @NonNull Observer&lt;? <span class=\"keyword\">super</span> S&gt; onChanged)</span> </span>&#123;  </span><br><span class=\"line\">    Source&lt;S&gt; e = <span class=\"keyword\">new</span> Source&lt;&gt;(source, onChanged);                                                </span><br><span class=\"line\">    Source&lt;?&gt; existing = mSources.putIfAbsent(source, e);                                         </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span> &amp;&amp; existing.mObserver != onChanged) &#123;                                    </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(                                                       </span><br><span class=\"line\">                <span class=\"string\">\"This source was already added with the different observer\"</span>);                     </span><br><span class=\"line\">    &#125;                                                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;                                                                       </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                   </span><br><span class=\"line\">    &#125;                                                                                             </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasActiveObservers()) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 存在活动的 observer，开始监听 source livedata</span></span><br><span class=\"line\">        e.plug();                                                                                 </span><br><span class=\"line\">    &#125;                                                                                             </span><br><span class=\"line\">&#125;                                                                                                 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span>                                                     </span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;S&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeSource</span><span class=\"params\">(@NonNull LiveData&lt;S&gt; toRemote)</span> </span>&#123;   </span><br><span class=\"line\">    Source&lt;?&gt; source = mSources.remove(toRemote);               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (source != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 删除监听\t</span></span><br><span class=\"line\">        source.unplug();                                        </span><br><span class=\"line\">    &#125;                                                           </span><br><span class=\"line\">&#125;                                                               </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@CallSuper</span>                                                         </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;                                        </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 重新监听</span></span><br><span class=\"line\">        source.getValue().plug();                                  </span><br><span class=\"line\">    &#125;                                                              </span><br><span class=\"line\">&#125;                                                                  </span><br><span class=\"line\">                                                                   </span><br><span class=\"line\"><span class=\"meta\">@CallSuper</span>                                                         </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onInactive</span><span class=\"params\">()</span> </span>&#123;                                      </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 暂时删除监听</span></span><br><span class=\"line\">        source.getValue().unplug();                                </span><br><span class=\"line\">    &#125;                                                              </span><br><span class=\"line\">&#125;                                                                  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Source</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;                    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> LiveData&lt;V&gt; mLiveData;                                           </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> V&gt; mObserver;                                   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> mVersion = START_VERSION;                                          </span><br><span class=\"line\">                                                                           </span><br><span class=\"line\">    Source(LiveData&lt;V&gt; liveData, <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> V&gt; observer) &#123;     </span><br><span class=\"line\">        mLiveData = liveData;                                              </span><br><span class=\"line\">        mObserver = observer;                                              </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">                                                                           </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">plug</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 这里可以使用 observeForever，因为会在 onActive 和 onInactive 两个方法中处理，能响应页面的生命周期</span></span><br><span class=\"line\">        mLiveData.observeForever(<span class=\"keyword\">this</span>);                                    </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">                                                                           </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unplug</span><span class=\"params\">()</span> </span>&#123;                                                        </span><br><span class=\"line\">        mLiveData.removeObserver(<span class=\"keyword\">this</span>);                                    </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">                                                                           </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                              </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable V v)</span> </span>&#123;                                 </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mVersion != mLiveData.getVersion()) &#123;                          </span><br><span class=\"line\">            mVersion = mLiveData.getVersion();                             </span><br><span class=\"line\">            mObserver.onChanged(v);                                        </span><br><span class=\"line\">        &#125;                                                                  </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>LiveData 可以算是 RxJava 的简化版本，它最大的好处就是和 Lifecycle 结合起来使用，不需要手动处理监听。第二个是，将数据分发操作封闭在主线程，减少线程同步锁的损耗，更适合 Android 日常开发场景。</p>\n"},{"title":"Jetpack中的Lifecycle","date":"2019-01-14T07:57:11.000Z","_content":"\n### 关于本文\n\n有很多项目都会使用 MVP 这种项目架构，使用 Presenter 来减轻 `Activity` 的负担，具体的 `MVP` 实现可以阅读 Google 推出的 [android-architecture](https://github.com/googlesamples/android-architecture)。\n\n一般使用 MVP，都会遇到一个问题，如何将 Presenter 和 View 的生命周期进行绑定，常见的做法是，在 `Activity` 的生命周期中手动调用 Presenter 的回调方法，更复杂的做法可能需要在 Presenter 或者 View 维护一个操作栈，在指定生命周期中去执行操作。\n\n### 关于Lifecycle\n\n[lifecycle](https://developer.android.com/topic/libraries/architecture/lifecycle) 是 Google 推出的用于响应 `Activity` 和 `Fragment` 生命周期改变的库。\n\n**These components help you produce better-organized, and often lighter-weight code, that is easier to maintain.**\n\n#### Lifecycle\n\n`Lifecycle` 是一个包含比如 `Activity` 或 `Fragment` 生命周期状态的类，同时允许其他对象去订阅这些状态\n\n`Lifecycle` 使用 Event 和 State 来管理生命周期状态的变化\n\n##### Event\n\n生命周期变化的事件\n\n##### State\n\n当前生命周期的状态\n\n使用 Google 文档中图片来表示这两者的关系：\n\n![lifecycle-states](https://developer.android.com/images/topic/libraries/architecture/lifecycle-states.png)\n\n我们可以调用 `addObserver` 去注册一个监听者\n\n``` kotlin\nlifecycle.addObserver(presenter)\n```\n\n而 `presenter` 则需要实现 `LifecycleObserver` 接口，具体的回调方法则通过注解的形式：\n\n``` kotlin\nclass Presenter : LifecycleObserver {\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_START)\n    fun onStart() {\n\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)\n    fun onDestroy() {\n\n    }\n\n}\n```\n\n当然我们也可以调用 `getCurrentState()` 来获取 `Lifecycle` 当前的状态\n\n#### LifecycleOwner\n\n上面我们简单介绍了 `Lifecyle` 和 `LifecycleObserver`  的作用和关系之后，再来看下 `getLifecycle` 这个方法：\n\n> 因为上面的例子是用 kotlin 写的，所以 `lifecycle.addObserver` 实际上应该为 `getLifecycle().addObserver()`\n\n``` java\npublic interface LifecycleOwner {\n    /**\n     * Returns the Lifecycle of the provider.\n     *\n     * @return The lifecycle of the provider.\n     */\n    @NonNull\n    Lifecycle getLifecycle();\n}\n```\n\n简单来说，`LifecycleOwner` 用于提供 `Lifecycle`，`LifecycleObserver` 监听 `Lifecycle` 的状态变化，`Lifecycle` 则是 `Activity` 或 `Fragment` 生命周期状态的抽象。\n\n可以看到 `Fragment` 和 `ComponentActivity` 等实现了 `LifecycleOwner` 接口，这里我们看下 `ComponentActivity` 的实现：\n\n``` java\nprivate LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);\n\n@CallSuper                                                   \n@Override                                                    \nprotected void onSaveInstanceState(Bundle outState) {\n    // 这里需要注意，onSaveInstanceState 状态设置为 CREATED\n    mLifecycleRegistry.markState(Lifecycle.State.CREATED);   \n    super.onSaveInstanceState(outState);                     \n}                                                            \n\n@Override                         \npublic Lifecycle getLifecycle() { \n    return mLifecycleRegistry;    \n}\n\n@Override                                                        \n@SuppressWarnings(\"RestrictedApi\")                               \nprotected void onCreate(@Nullable Bundle savedInstanceState) {   \n    super.onCreate(savedInstanceState);                          \n    ReportFragment.injectIfNeededIn(this);                       \n}                                                                \n```\n\n可以看到代码非常简洁，那它又是怎么去实现的呢？可以看到在 `onCreate` 中会调用 `ReportFragment.injectIfNeededIn`\n\n``` java\npublic static void injectIfNeededIn(Activity activity) {                                     \n    // ProcessLifecycleOwner should always correctly work and some activities may not extend \n    // FragmentActivity from support lib, so we use framework fragments for activities       \n    android.app.FragmentManager manager = activity.getFragmentManager();                     \n    if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {                            \n        manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();  \n        // Hopefully, we are the first to make a transaction.                                \n        manager.executePendingTransactions();                                                \n    }                                                                                        \n}   \n```\n\n这里会添加一个 `ReportFragment` 如果有阅读过 Glide 源码的同学，应该会看到类似的实现：通过添加一个透明的 `Fragment` 会监听 `Activity` 的生命周期。\n\n``` java\n@Override                                                               \npublic void onActivityCreated(Bundle savedInstanceState) {              \n    super.onActivityCreated(savedInstanceState);                        \n    dispatchCreate(mProcessListener);                                   \n    dispatch(Lifecycle.Event.ON_CREATE);                                \n}                                                                       \n                                                                        \n@Override                                                               \npublic void onStart() {                                                 \n    super.onStart();                                                    \n    dispatchStart(mProcessListener);                                    \n    dispatch(Lifecycle.Event.ON_START);                                 \n}                                                                       \n                                                                        \n@Override                                                               \npublic void onResume() {                                                \n    super.onResume();                                                   \n    dispatchResume(mProcessListener);                                   \n    dispatch(Lifecycle.Event.ON_RESUME);                                \n}                                                                       \n                                                                        \n@Override                                                               \npublic void onPause() {                                                 \n    super.onPause();                                                    \n    dispatch(Lifecycle.Event.ON_PAUSE);                                 \n}                                                                       \n                                                                        \n@Override                                                               \npublic void onStop() {                                                  \n    super.onStop();                                                     \n    dispatch(Lifecycle.Event.ON_STOP);                                  \n}                                                                       \n                                                                        \n@Override                                                               \npublic void onDestroy() {                                               \n    super.onDestroy();                                                  \n    dispatch(Lifecycle.Event.ON_DESTROY);                               \n    // just want to be sure that we won't leak reference to an activity \n    mProcessListener = null;                                            \n}\n\nprivate void dispatch(Lifecycle.Event event) {                                         \n    Activity activity = getActivity();                                                 \n    if (activity instanceof LifecycleRegistryOwner) {                                  \n        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);\n        return;                                                                        \n    }                                                                                  \n                                                                                       \n    if (activity instanceof LifecycleOwner) {                                          \n        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();              \n        if (lifecycle instanceof LifecycleRegistry) {                                  \n            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);               \n        }                                                                              \n    }                                                                                  \n}                                                                                      \n```\n\n在 `Activity` 的各种生命周期回调方法中，调用 `handleLifecycleEvent()` 分发 `Lifecycle.Event`\n\n##### handleLifecycleEvent\n\n`LifecycleRegistry` 是 `Lifecycle` 的实现类，看下 `handleLifecycleEvent` 的实现：\n\n``` java\npublic void handleLifecycleEvent(@NonNull Lifecycle.Event event) {    \n    State next = getStateAfter(event);                                \n    moveToState(next);                                                \n}                                                                     \n\n// event 和 Sate 的对应关系\nstatic State getStateAfter(Event event) {                                  \n    switch (event) {                                                       \n        case ON_CREATE:                                                    \n        case ON_STOP:                                                      \n            return CREATED;                                                \n        case ON_START:                                                     \n        case ON_PAUSE:                                                     \n            return STARTED;                                                \n        case ON_RESUME:                                                    \n            return RESUMED;                                                \n        case ON_DESTROY:                                                   \n            return DESTROYED;                                              \n        case ON_ANY:                                                       \n            break;                                                         \n    }                                                                      \n    throw new IllegalArgumentException(\"Unexpected event value \" + event); \n}                                                                          \n\nprivate void moveToState(State next) {                                \n    if (mState == next) {                                             \n        return;                                                       \n    }                                                                 \n    mState = next;                                                    \n    if (mHandlingEvent || mAddingObserverCounter != 0) {\n        // 正在处理事件中或者正在处理添加 Observer 中\n        mNewEventOccurred = true;                                     \n        // we will figure out what to do on upper level.              \n        return;                                                       \n    }\n    // 标记正在处理事件\n    mHandlingEvent = true;\n    // 同步状态\n    sync();                                                           \n    mHandlingEvent = false;                                           \n}\n\n// happens only on the top of stack (never in reentrance),                                    \n// so it doesn't have to take in account parents                                              \nprivate void sync() {\n    // 使用弱应用持有 LifecycleOwner，也是为了防止 Activity/Fragment 内存泄漏\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();                                    \n    if (lifecycleOwner == null) {\n        Log.w(LOG_TAG, \"LifecycleOwner is garbage collected, you shouldn't try dispatch \"     \n                + \"new events from it.\");                                                     \n        return;                                                                               \n    }                                                                                         \n    while (!isSynced()) {\n        // 如果还没完成同步\n        mNewEventOccurred = false;                                                            \n        // no need to check eldest for nullability, because isSynced does it for us.     \n        \n        // 使用 eldest(start) 判断是否需要回退 \n        // 使用 newest(end) 判断是否需要前进，刚添加的 observer 一般为初始化状态\n        if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {\n            // 最先添加的 observer 的状态大于当前状态，回退\n            backwardPass(lifecycleOwner);                                                     \n        }                                                                                     \n        Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();           \n        if (!mNewEventOccurred && newest != null                                              \n                && mState.compareTo(newest.getValue().mState) > 0) {\n            // 最新添加的 observer 如果状态一致，则可以乐观地表示在它之前添加的 observer 状态也是一致的\n            // mNewEventOccurred 表示有新的事件发生，则放弃这次同步，延迟到下一次\n            forwardPass(lifecycleOwner);                                                      \n        }                                                                                     \n    }                                                                                         \n    mNewEventOccurred = false;                                                                \n}\n\nprivate boolean isSynced() {                                                            \n    if (mObserverMap.size() == 0) {                                                     \n        return true;                                                                    \n    }\n    // eldest 最先添加的，newest 最新添加的\n    State eldestObserverState = mObserverMap.eldest().getValue().mState;                \n    State newestObserverState = mObserverMap.newest().getValue().mState;\n    // 判断状态是否一致\n    return eldestObserverState == newestObserverState && mState == newestObserverState; \n}                                                                                       \n```\n\n使用 `sync()` 同步状态，这里分为两种情况，一种是需要回退状态（backward），另外一种则是需要前进（forward），其中 `backward` 代码如下：\n\n``` java\nprivate void backwardPass(LifecycleOwner lifecycleOwner) {\n    // 使用 eldest(start) 判断是否需要回退 \n    // 降序迭代，end -> start\n    Iterator<Entry<LifecycleObserver, ObserverWithState>> descendingIterator =         \n            mObserverMap.descendingIterator();                                         \n    while (descendingIterator.hasNext() && !mNewEventOccurred) {\n        // mNewEventOccurred 判断是否有新事件分发\n        Entry<LifecycleObserver, ObserverWithState> entry = descendingIterator.next(); \n        ObserverWithState observer = entry.getValue();                                 \n        while ((observer.mState.compareTo(mState) > 0 && !mNewEventOccurred            \n                && mObserverMap.contains(entry.getKey()))) {\n            // 回退\n            // 举个例子：observer.state 为 RESUMED\n            // mState 为 CREATED\n            // downEvent(observer.state) 为 ON_PAUSE\n            Event event = downEvent(observer.mState);\n            // getStateAfter(event) 为 STARTED\n            // 最终：RESUMED -> STARTED，在下一次同步中再同步为 CREATED\n            // pushParentState 和 popParentState 则是将 state 暂存在 List 中，这个作用我们会在 addObserver 中讲\n            pushParentState(getStateAfter(event));\n            // 分发事件\n            observer.dispatchEvent(lifecycleOwner, event);                             \n            popParentState();                                                          \n        }                                                                              \n    }                                                                                  \n}\n\nprivate static Event downEvent(State state) {                             \n    switch (state) {                                                      \n        case INITIALIZED:                                                 \n            throw new IllegalArgumentException();                         \n        case CREATED:                                                     \n            return ON_DESTROY;                                            \n        case STARTED:                                                     \n            return ON_STOP;                                               \n        case RESUMED:                                                     \n            return ON_PAUSE;                                              \n        case DESTROYED:                                                   \n            throw new IllegalArgumentException();                         \n    }                                                                     \n    throw new IllegalArgumentException(\"Unexpected state value \" + state);\n} \n\nstatic State getStateAfter(Event event) {                                   \n    switch (event) {                                                        \n        case ON_CREATE:                                                     \n        case ON_STOP:                                                       \n            return CREATED;                                                 \n        case ON_START:                                                      \n        case ON_PAUSE:                                                      \n            return STARTED;                                                 \n        case ON_RESUME:                                                     \n            return RESUMED;                                                 \n        case ON_DESTROY:                                                    \n            return DESTROYED;                                               \n        case ON_ANY:                                                        \n            break;                                                          \n    }                                                                       \n    throw new IllegalArgumentException(\"Unexpected event value \" + event);  \n}\n\n// ObserverWithState.java\nvoid dispatchEvent(LifecycleOwner owner, Event event) { \n    State newState = getStateAfter(event);\n    // 使用较小的状态同步\n    mState = min(mState, newState);                     \n    mLifecycleObserver.onStateChanged(owner, event);    \n    mState = newState;                                  \n}                                                       \n```\n\n总结下 `backwardPass()` 的逻辑：将较大的状态逐步回退。为什么说是逐步呢？比如 `observer.state` 是 `RESUMED`，当前状态是 `CREATED`，那这里会分两次回退，分别为：`RESUMED -> STARTED` 和 `STARTED -> CREATED`\n\n`forwardPass()` 逻辑类似，则不分析了。\n\n##### addObserver\n\n`addObserver()` 是添加 `Observer` 的方法，源码如下：\n\n``` java\n@Override                                                                                 \npublic void addObserver(@NonNull LifecycleObserver observer) {\n    // 如果不是 DESTROYED，则从 INITIALIZED 开始分发\n    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n    // ObserverWithState 用于分发事件给 observer\n    ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);   \n    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);    \n                                                                                          \n    if (previous != null) { \n        // 唯一性\n        return;                                                                           \n    }                                                                                     \n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();                                \n    if (lifecycleOwner == null) {  \n        // mLifecycleOwner 为弱引用\n        // it is null we should be destroyed. Fallback quickly                            \n        return;                                                                           \n    }                                                                                     \n    \n    // isReentrance 表示是否在分发事件时新添加了 observer\n    // 举个例子：在 observer 在 onStart() 中又调用了 addObserver()\n    boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; \n    // 计算需要分发的状态\n    State targetState = calculateTargetState(observer);                                   \n    mAddingObserverCounter++; \n    // 将事件逐步分发到 targetState\n    while ((statefulObserver.mState.compareTo(targetState) < 0                            \n            && mObserverMap.contains(observer))) {\n        // 如果 statefulObserver.state 小于 targetState\n        pushParentState(statefulObserver.mState);\n        // 如果 state 为 STARTED，则 upEvent(state) 则为 ON_RESUME\n        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); \n        popParentState();                                                                 \n        // mState / subling may have been changed recalculate                             \n        targetState = calculateTargetState(observer);                                     \n    }                                                                                     \n                                                                                          \n    if (!isReentrance) {                                                                  \n        // we do sync only on the top level.\n        // 当前为重入，则不进行同步\n        sync();                                                                           \n    }                                                                                     \n    mAddingObserverCounter--;                                                             \n}\n\nprivate static Event upEvent(State state) {                                  \n    switch (state) {                                                         \n        case INITIALIZED:                                                    \n        case DESTROYED:                                                      \n            return ON_CREATE;                                                \n        case CREATED:                                                        \n            return ON_START;                                                 \n        case STARTED:                                                        \n            return ON_RESUME;                                                \n        case RESUMED:                                                        \n            throw new IllegalArgumentException();                            \n    }                                                                        \n    throw new IllegalArgumentException(\"Unexpected state value \" + state);   \n}                                                                            \n\nprivate State calculateTargetState(LifecycleObserver observer) {\n    // 获取上一个添加的 observer\n    Entry<LifecycleObserver, ObserverWithState> previous = mObserverMap.ceil(observer);       \n\t\n    State siblingState = previous != null ? previous.getValue().mState : null;\n    // mParentStates 是个 List，它的添加和删除分别由 pushParentState() 和 popParentState()，它们是成对出现的，在 dispatchEvent 的前后\n    // 在这种 case 下，会存在 parentState：在 dispatchEvent 时，又调用了 addObserver()，即上面说的 isReentrance\n    State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)\n            : null;\n    // 这里的计算是获取更合适的状态\n    // 考虑以下这种 case：某个 observer 在 onStart() 中再调用 addObserver，那这个 observer 理应使用 STARTED 状态分发，而当前状态即 mState 可能是 RESUMED，再在 sync() 中进行同步\n    return min(min(mState, siblingState), parentState);                                       \n}                                                                                             \n```\n\n`addObserver()` 主要考虑了 Reentrance 的情况，即在 `observer` 的事件分发中，又添加了新的 `observer` 的情况。\n\n#### ProcessLifecycleOwner\n\n`ProcessLifecycleOwner` 提供应用进程的生命周期。跟 `Activity` 和 `Fragment` 的生命周期不一样的是：\n\n* `ON_CREATE` 只会分发一次\n*  `ON_DESTROY` 则不会被分发\n* `ON_START` 和 `ON_RESUME` 在第一个 `Activity` 的时候分发\n* `ON_PAUSE` 和 `ON_STOP` 则在最后一个 `Activity` 的时候**延迟**分发，用于防止因为配置改变，而导致 `Activity` 重建\n\n下面我们来分析下 `ProcessLifecycleOwner` 的源码，首先看下 `init()`：\n\n``` java\n\n// 单例\nprivate static final ProcessLifecycleOwner sInstance = new ProcessLifecycleOwner();\n\nstatic void init(Context context) {\n    // 调用 attach\n    sInstance.attach(context);      \n}                                   \n\nvoid attach(Context context) {                                                          \n    mHandler = new Handler();\n    // 同样是使用 LifecycleRegistry 来处理\n    // 先分发 ON_CREATE，而且只会分发一次\n    mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);                          \n    Application app = (Application) context.getApplicationContext();\n    app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() {      \n        @Override                                                                       \n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {   \n            ReportFragment.get(activity).setProcessListener(mInitializationListener);   \n        }                                                                               \n                                                                                        \n        @Override                                                                       \n        public void onActivityPaused(Activity activity) {                               \n            activityPaused();                                                           \n        }                                                                               \n                                                                                        \n        @Override                                                                       \n        public void onActivityStopped(Activity activity) {                              \n            activityStopped();                                                          \n        }                                                                               \n    });                                                                                 \n}\n\nActivityInitializationListener mInitializationListener =      \n        new ActivityInitializationListener() {                \n            @Override                                         \n            public void onCreate() {                          \n            }                                                 \n                                                              \n            @Override                                         \n            public void onStart() {                           \n                activityStarted();                            \n            }                                                 \n                                                              \n            @Override                                         \n            public void onResume() {                          \n                activityResumed();                            \n            }                                                 \n        };\n\n      \n                                                 \n// ground truth counters                         \nprivate int mStartedCounter = 0;                 \nprivate int mResumedCounter = 0;                 \n                                                 \nprivate boolean mPauseSent = true;               \nprivate boolean mStopSent = true;                \n\nvoid activityStarted() {\n    // 计数\n    mStartedCounter++;                                            \n    if (mStartedCounter == 1 && mStopSent) {\n        // 第一次调用，分发 ON_START\n        // mStopSent 为 true 的情况：\n        // 1. 默认为 true\n        // 2. dispatchStopIfNeeded 中设置\n        // 防止因为配置改变，Activity 创建而导致重新分发\n        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); \n        mStopSent = false;                                        \n    }                                                             \n}\n\n void activityResumed() {                                               \n     mResumedCounter++;                                                 \n     if (mResumedCounter == 1) {                                        \n         if (mPauseSent) {\n             // 第一次调用分发 ON_RESUME\n             mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); \n             mPauseSent = false;                                        \n         } else { \n             // 配置改变，Activity 创建，删除延迟的 pause runnable\n             mHandler.removeCallbacks(mDelayedPauseRunnable);           \n         }                                                              \n     }                                                                  \n }                                                                      \n```\n\n上面是初始事件分发流程，下面我们来看下 `ON_PAUSE` 和 `ON_STOP` 的分发：\n\n``` java\n@VisibleForTesting                               \nstatic final long TIMEOUT_MS = 700; //mls \n\n// 在 onActivityPaused 中调用\nvoid activityPaused() {\n    // 计数\n    mResumedCounter--;                                              \n    if (mResumedCounter == 0) {\n        // 延迟分发\n        mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);    \n    }                                                               \n}\n \nprivate Runnable mDelayedPauseRunnable = new Runnable() { \n    @Override                                             \n    public void run() { \n        // 延迟分发\n        dispatchPauseIfNeeded();                          \n        dispatchStopIfNeeded();                           \n    }                                                     \n};                                                        \n\nvoid activityStopped() { \n    // 计数\n    mStartedCounter--;                                              \n    dispatchStopIfNeeded();                                         \n}                                                                   \n                                                                    \nvoid dispatchPauseIfNeeded() {\n    if (mResumedCounter == 0) {\n        // 计数\n        mPauseSent = true;\n        // 分发 ON_PAUSE\n        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);   \n    }                                                               \n}                                                                   \n                                                                    \nvoid dispatchStopIfNeeded() {                                       \n    if (mStartedCounter == 0 && mPauseSent) {\n        // 计数为 0，同时已经分发了 ON_PAUSE\n        // 分发 ON_STOP\n        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);    \n        mStopSent = true;                                           \n    }                                                               \n}                                                                   \n```\n\n到这里，我们已经将 `ProcessLifecycleOwner` 的流程分析完了，那 `ProcessLifecycleOwner.init()` 是在那里调用的呢？\n\n其实是用了一种比较巧妙的方法，在 `lifecycle-process` 这个包下的 `AndroidManifest.xml` 文件中，可以看到有如下配置：\n\n``` xml\n<application>\n        <provider\n            android:name=\"androidx.lifecycle.ProcessLifecycleOwnerInitializer\"\n            android:authorities=\"${applicationId}.lifecycle-process\"\n            android:exported=\"false\"\n            android:multiprocess=\"true\" />\n</application>\n```\n\n其中 `ProcessLifecycleOwnerInitializer` 是一个 `ContentProvider` 即利用 `ContentProvider` 来实现自动初始化\n\n> ContentProvider 的 `onCreate` 方法会在应用启动时候调用\n>\n> Implement this to initialize your content provider on startup. This method is called for all registered content providers on the application main thread at application launch time. It must not perform lengthy operations, or application startup will be delayed.\n\n``` java\n@Override                                     \npublic boolean onCreate() {                   \n    LifecycleDispatcher.init(getContext());   \n    ProcessLifecycleOwner.init(getContext()); \n    return true;                              \n}                                             \n```\n\n可以看到这里调用了两个初始化方法，其中 `ProcessLifecycleOwner.init()` 我们已经分析了，再看看 `LifecycleDispatcher.init()`\n\n``` java\nstatic void init(Context context) {                                                 \n    if (sInitialized.getAndSet(true)) {                                             \n        return;                                                                     \n    }                                                                               \n    ((Application) context.getApplicationContext())                                 \n            .registerActivityLifecycleCallbacks(new DispatcherActivityCallback());  \n}                                                                                   \n                                                                                    \n@SuppressWarnings(\"WeakerAccess\")                                                   \n@VisibleForTesting                                                                  \nstatic class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks {   \n                                                                                    \n    @Override                                                                       \n    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {   \n        ReportFragment.injectIfNeededIn(activity);                                  \n    }                                                                               \n                                                                                    \n    @Override                                                                       \n    public void onActivityStopped(Activity activity) {                              \n    }                                                                               \n                                                                                    \n    @Override                                                                       \n    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {   \n    }                                                                               \n}                                                                                   \n```\n\n初始化的逻辑比较简单，即在 `Activity` 创建时，调用 `ReportFragment.injectIfneededIn()` ，其实我们在 `Activity` 的 `Lifecycle` 处理中，也见到这个方法： \n\n``` java                                                       \n// ComponentActivity.java\n@Override                                                        \n@SuppressWarnings(\"RestrictedApi\")                               \nprotected void onCreate(@Nullable Bundle savedInstanceState) {   \n    super.onCreate(savedInstanceState);                          \n    ReportFragment.injectIfNeededIn(this);                       \n}\n\n// ReportFragment.java\npublic static void injectIfNeededIn(Activity activity) {                                      \n    // ProcessLifecycleOwner should always correctly work and some activities may not extend  \n    // FragmentActivity from support lib, so we use framework fragments for activities        \n    android.app.FragmentManager manager = activity.getFragmentManager();                      \n    if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {\n        // 重复添加判断\n        manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();   \n        // Hopefully, we are the first to make a transaction.                                 \n        manager.executePendingTransactions();                                                 \n    }                                                                                         \n}                                                                                             \n```\n\n这里可以理解为双重保障吧，可能存在不继承 `ComponentActivity` 的 `Activity`。\n\n### 总结\n\n分析了 `Lifecycle`  的整个流程，可以发现其实逻辑还是比较简单的，实现上也是参考了其他开源库的做法，比如 `ReportFragment` 通过添加一个透明的 `Fragment` 去感知 `Activity` 的生命周期，`Glide` 也是这么做的。还有使用 `ContentProvider` 去实现在 `Application` 创建时自动初始化，也是一个不错的想法。\n\n`Lifecycle` 的源码比我一开始想象的复杂，不是在于它的逻辑，而是在 `sync()` 这一块，通过 `Listener` 执行状态回调是一个非常常见的做法，但是有很多需要考虑的 case，举个例子，在分发回调时，有新的状态发生，那么应该怎么去处理。或者，在回调方法中，又添加了新的 `Listener`，那应该怎么处理。\n\n学习源码，不仅仅是学习实现原理，还可以学习一个健壮的库是如何处理各种场景下的 case 的。","source":"_posts/Jetpack中的Lifecycle.md","raw":"---\ntitle: Jetpack中的Lifecycle\ndate: 2019-01-14 15:57:11\ncategories: Android Application\ntags:\n---\n\n### 关于本文\n\n有很多项目都会使用 MVP 这种项目架构，使用 Presenter 来减轻 `Activity` 的负担，具体的 `MVP` 实现可以阅读 Google 推出的 [android-architecture](https://github.com/googlesamples/android-architecture)。\n\n一般使用 MVP，都会遇到一个问题，如何将 Presenter 和 View 的生命周期进行绑定，常见的做法是，在 `Activity` 的生命周期中手动调用 Presenter 的回调方法，更复杂的做法可能需要在 Presenter 或者 View 维护一个操作栈，在指定生命周期中去执行操作。\n\n### 关于Lifecycle\n\n[lifecycle](https://developer.android.com/topic/libraries/architecture/lifecycle) 是 Google 推出的用于响应 `Activity` 和 `Fragment` 生命周期改变的库。\n\n**These components help you produce better-organized, and often lighter-weight code, that is easier to maintain.**\n\n#### Lifecycle\n\n`Lifecycle` 是一个包含比如 `Activity` 或 `Fragment` 生命周期状态的类，同时允许其他对象去订阅这些状态\n\n`Lifecycle` 使用 Event 和 State 来管理生命周期状态的变化\n\n##### Event\n\n生命周期变化的事件\n\n##### State\n\n当前生命周期的状态\n\n使用 Google 文档中图片来表示这两者的关系：\n\n![lifecycle-states](https://developer.android.com/images/topic/libraries/architecture/lifecycle-states.png)\n\n我们可以调用 `addObserver` 去注册一个监听者\n\n``` kotlin\nlifecycle.addObserver(presenter)\n```\n\n而 `presenter` 则需要实现 `LifecycleObserver` 接口，具体的回调方法则通过注解的形式：\n\n``` kotlin\nclass Presenter : LifecycleObserver {\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_START)\n    fun onStart() {\n\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)\n    fun onDestroy() {\n\n    }\n\n}\n```\n\n当然我们也可以调用 `getCurrentState()` 来获取 `Lifecycle` 当前的状态\n\n#### LifecycleOwner\n\n上面我们简单介绍了 `Lifecyle` 和 `LifecycleObserver`  的作用和关系之后，再来看下 `getLifecycle` 这个方法：\n\n> 因为上面的例子是用 kotlin 写的，所以 `lifecycle.addObserver` 实际上应该为 `getLifecycle().addObserver()`\n\n``` java\npublic interface LifecycleOwner {\n    /**\n     * Returns the Lifecycle of the provider.\n     *\n     * @return The lifecycle of the provider.\n     */\n    @NonNull\n    Lifecycle getLifecycle();\n}\n```\n\n简单来说，`LifecycleOwner` 用于提供 `Lifecycle`，`LifecycleObserver` 监听 `Lifecycle` 的状态变化，`Lifecycle` 则是 `Activity` 或 `Fragment` 生命周期状态的抽象。\n\n可以看到 `Fragment` 和 `ComponentActivity` 等实现了 `LifecycleOwner` 接口，这里我们看下 `ComponentActivity` 的实现：\n\n``` java\nprivate LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);\n\n@CallSuper                                                   \n@Override                                                    \nprotected void onSaveInstanceState(Bundle outState) {\n    // 这里需要注意，onSaveInstanceState 状态设置为 CREATED\n    mLifecycleRegistry.markState(Lifecycle.State.CREATED);   \n    super.onSaveInstanceState(outState);                     \n}                                                            \n\n@Override                         \npublic Lifecycle getLifecycle() { \n    return mLifecycleRegistry;    \n}\n\n@Override                                                        \n@SuppressWarnings(\"RestrictedApi\")                               \nprotected void onCreate(@Nullable Bundle savedInstanceState) {   \n    super.onCreate(savedInstanceState);                          \n    ReportFragment.injectIfNeededIn(this);                       \n}                                                                \n```\n\n可以看到代码非常简洁，那它又是怎么去实现的呢？可以看到在 `onCreate` 中会调用 `ReportFragment.injectIfNeededIn`\n\n``` java\npublic static void injectIfNeededIn(Activity activity) {                                     \n    // ProcessLifecycleOwner should always correctly work and some activities may not extend \n    // FragmentActivity from support lib, so we use framework fragments for activities       \n    android.app.FragmentManager manager = activity.getFragmentManager();                     \n    if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {                            \n        manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();  \n        // Hopefully, we are the first to make a transaction.                                \n        manager.executePendingTransactions();                                                \n    }                                                                                        \n}   \n```\n\n这里会添加一个 `ReportFragment` 如果有阅读过 Glide 源码的同学，应该会看到类似的实现：通过添加一个透明的 `Fragment` 会监听 `Activity` 的生命周期。\n\n``` java\n@Override                                                               \npublic void onActivityCreated(Bundle savedInstanceState) {              \n    super.onActivityCreated(savedInstanceState);                        \n    dispatchCreate(mProcessListener);                                   \n    dispatch(Lifecycle.Event.ON_CREATE);                                \n}                                                                       \n                                                                        \n@Override                                                               \npublic void onStart() {                                                 \n    super.onStart();                                                    \n    dispatchStart(mProcessListener);                                    \n    dispatch(Lifecycle.Event.ON_START);                                 \n}                                                                       \n                                                                        \n@Override                                                               \npublic void onResume() {                                                \n    super.onResume();                                                   \n    dispatchResume(mProcessListener);                                   \n    dispatch(Lifecycle.Event.ON_RESUME);                                \n}                                                                       \n                                                                        \n@Override                                                               \npublic void onPause() {                                                 \n    super.onPause();                                                    \n    dispatch(Lifecycle.Event.ON_PAUSE);                                 \n}                                                                       \n                                                                        \n@Override                                                               \npublic void onStop() {                                                  \n    super.onStop();                                                     \n    dispatch(Lifecycle.Event.ON_STOP);                                  \n}                                                                       \n                                                                        \n@Override                                                               \npublic void onDestroy() {                                               \n    super.onDestroy();                                                  \n    dispatch(Lifecycle.Event.ON_DESTROY);                               \n    // just want to be sure that we won't leak reference to an activity \n    mProcessListener = null;                                            \n}\n\nprivate void dispatch(Lifecycle.Event event) {                                         \n    Activity activity = getActivity();                                                 \n    if (activity instanceof LifecycleRegistryOwner) {                                  \n        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);\n        return;                                                                        \n    }                                                                                  \n                                                                                       \n    if (activity instanceof LifecycleOwner) {                                          \n        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();              \n        if (lifecycle instanceof LifecycleRegistry) {                                  \n            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);               \n        }                                                                              \n    }                                                                                  \n}                                                                                      \n```\n\n在 `Activity` 的各种生命周期回调方法中，调用 `handleLifecycleEvent()` 分发 `Lifecycle.Event`\n\n##### handleLifecycleEvent\n\n`LifecycleRegistry` 是 `Lifecycle` 的实现类，看下 `handleLifecycleEvent` 的实现：\n\n``` java\npublic void handleLifecycleEvent(@NonNull Lifecycle.Event event) {    \n    State next = getStateAfter(event);                                \n    moveToState(next);                                                \n}                                                                     \n\n// event 和 Sate 的对应关系\nstatic State getStateAfter(Event event) {                                  \n    switch (event) {                                                       \n        case ON_CREATE:                                                    \n        case ON_STOP:                                                      \n            return CREATED;                                                \n        case ON_START:                                                     \n        case ON_PAUSE:                                                     \n            return STARTED;                                                \n        case ON_RESUME:                                                    \n            return RESUMED;                                                \n        case ON_DESTROY:                                                   \n            return DESTROYED;                                              \n        case ON_ANY:                                                       \n            break;                                                         \n    }                                                                      \n    throw new IllegalArgumentException(\"Unexpected event value \" + event); \n}                                                                          \n\nprivate void moveToState(State next) {                                \n    if (mState == next) {                                             \n        return;                                                       \n    }                                                                 \n    mState = next;                                                    \n    if (mHandlingEvent || mAddingObserverCounter != 0) {\n        // 正在处理事件中或者正在处理添加 Observer 中\n        mNewEventOccurred = true;                                     \n        // we will figure out what to do on upper level.              \n        return;                                                       \n    }\n    // 标记正在处理事件\n    mHandlingEvent = true;\n    // 同步状态\n    sync();                                                           \n    mHandlingEvent = false;                                           \n}\n\n// happens only on the top of stack (never in reentrance),                                    \n// so it doesn't have to take in account parents                                              \nprivate void sync() {\n    // 使用弱应用持有 LifecycleOwner，也是为了防止 Activity/Fragment 内存泄漏\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();                                    \n    if (lifecycleOwner == null) {\n        Log.w(LOG_TAG, \"LifecycleOwner is garbage collected, you shouldn't try dispatch \"     \n                + \"new events from it.\");                                                     \n        return;                                                                               \n    }                                                                                         \n    while (!isSynced()) {\n        // 如果还没完成同步\n        mNewEventOccurred = false;                                                            \n        // no need to check eldest for nullability, because isSynced does it for us.     \n        \n        // 使用 eldest(start) 判断是否需要回退 \n        // 使用 newest(end) 判断是否需要前进，刚添加的 observer 一般为初始化状态\n        if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {\n            // 最先添加的 observer 的状态大于当前状态，回退\n            backwardPass(lifecycleOwner);                                                     \n        }                                                                                     \n        Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();           \n        if (!mNewEventOccurred && newest != null                                              \n                && mState.compareTo(newest.getValue().mState) > 0) {\n            // 最新添加的 observer 如果状态一致，则可以乐观地表示在它之前添加的 observer 状态也是一致的\n            // mNewEventOccurred 表示有新的事件发生，则放弃这次同步，延迟到下一次\n            forwardPass(lifecycleOwner);                                                      \n        }                                                                                     \n    }                                                                                         \n    mNewEventOccurred = false;                                                                \n}\n\nprivate boolean isSynced() {                                                            \n    if (mObserverMap.size() == 0) {                                                     \n        return true;                                                                    \n    }\n    // eldest 最先添加的，newest 最新添加的\n    State eldestObserverState = mObserverMap.eldest().getValue().mState;                \n    State newestObserverState = mObserverMap.newest().getValue().mState;\n    // 判断状态是否一致\n    return eldestObserverState == newestObserverState && mState == newestObserverState; \n}                                                                                       \n```\n\n使用 `sync()` 同步状态，这里分为两种情况，一种是需要回退状态（backward），另外一种则是需要前进（forward），其中 `backward` 代码如下：\n\n``` java\nprivate void backwardPass(LifecycleOwner lifecycleOwner) {\n    // 使用 eldest(start) 判断是否需要回退 \n    // 降序迭代，end -> start\n    Iterator<Entry<LifecycleObserver, ObserverWithState>> descendingIterator =         \n            mObserverMap.descendingIterator();                                         \n    while (descendingIterator.hasNext() && !mNewEventOccurred) {\n        // mNewEventOccurred 判断是否有新事件分发\n        Entry<LifecycleObserver, ObserverWithState> entry = descendingIterator.next(); \n        ObserverWithState observer = entry.getValue();                                 \n        while ((observer.mState.compareTo(mState) > 0 && !mNewEventOccurred            \n                && mObserverMap.contains(entry.getKey()))) {\n            // 回退\n            // 举个例子：observer.state 为 RESUMED\n            // mState 为 CREATED\n            // downEvent(observer.state) 为 ON_PAUSE\n            Event event = downEvent(observer.mState);\n            // getStateAfter(event) 为 STARTED\n            // 最终：RESUMED -> STARTED，在下一次同步中再同步为 CREATED\n            // pushParentState 和 popParentState 则是将 state 暂存在 List 中，这个作用我们会在 addObserver 中讲\n            pushParentState(getStateAfter(event));\n            // 分发事件\n            observer.dispatchEvent(lifecycleOwner, event);                             \n            popParentState();                                                          \n        }                                                                              \n    }                                                                                  \n}\n\nprivate static Event downEvent(State state) {                             \n    switch (state) {                                                      \n        case INITIALIZED:                                                 \n            throw new IllegalArgumentException();                         \n        case CREATED:                                                     \n            return ON_DESTROY;                                            \n        case STARTED:                                                     \n            return ON_STOP;                                               \n        case RESUMED:                                                     \n            return ON_PAUSE;                                              \n        case DESTROYED:                                                   \n            throw new IllegalArgumentException();                         \n    }                                                                     \n    throw new IllegalArgumentException(\"Unexpected state value \" + state);\n} \n\nstatic State getStateAfter(Event event) {                                   \n    switch (event) {                                                        \n        case ON_CREATE:                                                     \n        case ON_STOP:                                                       \n            return CREATED;                                                 \n        case ON_START:                                                      \n        case ON_PAUSE:                                                      \n            return STARTED;                                                 \n        case ON_RESUME:                                                     \n            return RESUMED;                                                 \n        case ON_DESTROY:                                                    \n            return DESTROYED;                                               \n        case ON_ANY:                                                        \n            break;                                                          \n    }                                                                       \n    throw new IllegalArgumentException(\"Unexpected event value \" + event);  \n}\n\n// ObserverWithState.java\nvoid dispatchEvent(LifecycleOwner owner, Event event) { \n    State newState = getStateAfter(event);\n    // 使用较小的状态同步\n    mState = min(mState, newState);                     \n    mLifecycleObserver.onStateChanged(owner, event);    \n    mState = newState;                                  \n}                                                       \n```\n\n总结下 `backwardPass()` 的逻辑：将较大的状态逐步回退。为什么说是逐步呢？比如 `observer.state` 是 `RESUMED`，当前状态是 `CREATED`，那这里会分两次回退，分别为：`RESUMED -> STARTED` 和 `STARTED -> CREATED`\n\n`forwardPass()` 逻辑类似，则不分析了。\n\n##### addObserver\n\n`addObserver()` 是添加 `Observer` 的方法，源码如下：\n\n``` java\n@Override                                                                                 \npublic void addObserver(@NonNull LifecycleObserver observer) {\n    // 如果不是 DESTROYED，则从 INITIALIZED 开始分发\n    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n    // ObserverWithState 用于分发事件给 observer\n    ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);   \n    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);    \n                                                                                          \n    if (previous != null) { \n        // 唯一性\n        return;                                                                           \n    }                                                                                     \n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();                                \n    if (lifecycleOwner == null) {  \n        // mLifecycleOwner 为弱引用\n        // it is null we should be destroyed. Fallback quickly                            \n        return;                                                                           \n    }                                                                                     \n    \n    // isReentrance 表示是否在分发事件时新添加了 observer\n    // 举个例子：在 observer 在 onStart() 中又调用了 addObserver()\n    boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; \n    // 计算需要分发的状态\n    State targetState = calculateTargetState(observer);                                   \n    mAddingObserverCounter++; \n    // 将事件逐步分发到 targetState\n    while ((statefulObserver.mState.compareTo(targetState) < 0                            \n            && mObserverMap.contains(observer))) {\n        // 如果 statefulObserver.state 小于 targetState\n        pushParentState(statefulObserver.mState);\n        // 如果 state 为 STARTED，则 upEvent(state) 则为 ON_RESUME\n        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); \n        popParentState();                                                                 \n        // mState / subling may have been changed recalculate                             \n        targetState = calculateTargetState(observer);                                     \n    }                                                                                     \n                                                                                          \n    if (!isReentrance) {                                                                  \n        // we do sync only on the top level.\n        // 当前为重入，则不进行同步\n        sync();                                                                           \n    }                                                                                     \n    mAddingObserverCounter--;                                                             \n}\n\nprivate static Event upEvent(State state) {                                  \n    switch (state) {                                                         \n        case INITIALIZED:                                                    \n        case DESTROYED:                                                      \n            return ON_CREATE;                                                \n        case CREATED:                                                        \n            return ON_START;                                                 \n        case STARTED:                                                        \n            return ON_RESUME;                                                \n        case RESUMED:                                                        \n            throw new IllegalArgumentException();                            \n    }                                                                        \n    throw new IllegalArgumentException(\"Unexpected state value \" + state);   \n}                                                                            \n\nprivate State calculateTargetState(LifecycleObserver observer) {\n    // 获取上一个添加的 observer\n    Entry<LifecycleObserver, ObserverWithState> previous = mObserverMap.ceil(observer);       \n\t\n    State siblingState = previous != null ? previous.getValue().mState : null;\n    // mParentStates 是个 List，它的添加和删除分别由 pushParentState() 和 popParentState()，它们是成对出现的，在 dispatchEvent 的前后\n    // 在这种 case 下，会存在 parentState：在 dispatchEvent 时，又调用了 addObserver()，即上面说的 isReentrance\n    State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)\n            : null;\n    // 这里的计算是获取更合适的状态\n    // 考虑以下这种 case：某个 observer 在 onStart() 中再调用 addObserver，那这个 observer 理应使用 STARTED 状态分发，而当前状态即 mState 可能是 RESUMED，再在 sync() 中进行同步\n    return min(min(mState, siblingState), parentState);                                       \n}                                                                                             \n```\n\n`addObserver()` 主要考虑了 Reentrance 的情况，即在 `observer` 的事件分发中，又添加了新的 `observer` 的情况。\n\n#### ProcessLifecycleOwner\n\n`ProcessLifecycleOwner` 提供应用进程的生命周期。跟 `Activity` 和 `Fragment` 的生命周期不一样的是：\n\n* `ON_CREATE` 只会分发一次\n*  `ON_DESTROY` 则不会被分发\n* `ON_START` 和 `ON_RESUME` 在第一个 `Activity` 的时候分发\n* `ON_PAUSE` 和 `ON_STOP` 则在最后一个 `Activity` 的时候**延迟**分发，用于防止因为配置改变，而导致 `Activity` 重建\n\n下面我们来分析下 `ProcessLifecycleOwner` 的源码，首先看下 `init()`：\n\n``` java\n\n// 单例\nprivate static final ProcessLifecycleOwner sInstance = new ProcessLifecycleOwner();\n\nstatic void init(Context context) {\n    // 调用 attach\n    sInstance.attach(context);      \n}                                   \n\nvoid attach(Context context) {                                                          \n    mHandler = new Handler();\n    // 同样是使用 LifecycleRegistry 来处理\n    // 先分发 ON_CREATE，而且只会分发一次\n    mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);                          \n    Application app = (Application) context.getApplicationContext();\n    app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() {      \n        @Override                                                                       \n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {   \n            ReportFragment.get(activity).setProcessListener(mInitializationListener);   \n        }                                                                               \n                                                                                        \n        @Override                                                                       \n        public void onActivityPaused(Activity activity) {                               \n            activityPaused();                                                           \n        }                                                                               \n                                                                                        \n        @Override                                                                       \n        public void onActivityStopped(Activity activity) {                              \n            activityStopped();                                                          \n        }                                                                               \n    });                                                                                 \n}\n\nActivityInitializationListener mInitializationListener =      \n        new ActivityInitializationListener() {                \n            @Override                                         \n            public void onCreate() {                          \n            }                                                 \n                                                              \n            @Override                                         \n            public void onStart() {                           \n                activityStarted();                            \n            }                                                 \n                                                              \n            @Override                                         \n            public void onResume() {                          \n                activityResumed();                            \n            }                                                 \n        };\n\n      \n                                                 \n// ground truth counters                         \nprivate int mStartedCounter = 0;                 \nprivate int mResumedCounter = 0;                 \n                                                 \nprivate boolean mPauseSent = true;               \nprivate boolean mStopSent = true;                \n\nvoid activityStarted() {\n    // 计数\n    mStartedCounter++;                                            \n    if (mStartedCounter == 1 && mStopSent) {\n        // 第一次调用，分发 ON_START\n        // mStopSent 为 true 的情况：\n        // 1. 默认为 true\n        // 2. dispatchStopIfNeeded 中设置\n        // 防止因为配置改变，Activity 创建而导致重新分发\n        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); \n        mStopSent = false;                                        \n    }                                                             \n}\n\n void activityResumed() {                                               \n     mResumedCounter++;                                                 \n     if (mResumedCounter == 1) {                                        \n         if (mPauseSent) {\n             // 第一次调用分发 ON_RESUME\n             mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); \n             mPauseSent = false;                                        \n         } else { \n             // 配置改变，Activity 创建，删除延迟的 pause runnable\n             mHandler.removeCallbacks(mDelayedPauseRunnable);           \n         }                                                              \n     }                                                                  \n }                                                                      \n```\n\n上面是初始事件分发流程，下面我们来看下 `ON_PAUSE` 和 `ON_STOP` 的分发：\n\n``` java\n@VisibleForTesting                               \nstatic final long TIMEOUT_MS = 700; //mls \n\n// 在 onActivityPaused 中调用\nvoid activityPaused() {\n    // 计数\n    mResumedCounter--;                                              \n    if (mResumedCounter == 0) {\n        // 延迟分发\n        mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);    \n    }                                                               \n}\n \nprivate Runnable mDelayedPauseRunnable = new Runnable() { \n    @Override                                             \n    public void run() { \n        // 延迟分发\n        dispatchPauseIfNeeded();                          \n        dispatchStopIfNeeded();                           \n    }                                                     \n};                                                        \n\nvoid activityStopped() { \n    // 计数\n    mStartedCounter--;                                              \n    dispatchStopIfNeeded();                                         \n}                                                                   \n                                                                    \nvoid dispatchPauseIfNeeded() {\n    if (mResumedCounter == 0) {\n        // 计数\n        mPauseSent = true;\n        // 分发 ON_PAUSE\n        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);   \n    }                                                               \n}                                                                   \n                                                                    \nvoid dispatchStopIfNeeded() {                                       \n    if (mStartedCounter == 0 && mPauseSent) {\n        // 计数为 0，同时已经分发了 ON_PAUSE\n        // 分发 ON_STOP\n        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);    \n        mStopSent = true;                                           \n    }                                                               \n}                                                                   \n```\n\n到这里，我们已经将 `ProcessLifecycleOwner` 的流程分析完了，那 `ProcessLifecycleOwner.init()` 是在那里调用的呢？\n\n其实是用了一种比较巧妙的方法，在 `lifecycle-process` 这个包下的 `AndroidManifest.xml` 文件中，可以看到有如下配置：\n\n``` xml\n<application>\n        <provider\n            android:name=\"androidx.lifecycle.ProcessLifecycleOwnerInitializer\"\n            android:authorities=\"${applicationId}.lifecycle-process\"\n            android:exported=\"false\"\n            android:multiprocess=\"true\" />\n</application>\n```\n\n其中 `ProcessLifecycleOwnerInitializer` 是一个 `ContentProvider` 即利用 `ContentProvider` 来实现自动初始化\n\n> ContentProvider 的 `onCreate` 方法会在应用启动时候调用\n>\n> Implement this to initialize your content provider on startup. This method is called for all registered content providers on the application main thread at application launch time. It must not perform lengthy operations, or application startup will be delayed.\n\n``` java\n@Override                                     \npublic boolean onCreate() {                   \n    LifecycleDispatcher.init(getContext());   \n    ProcessLifecycleOwner.init(getContext()); \n    return true;                              \n}                                             \n```\n\n可以看到这里调用了两个初始化方法，其中 `ProcessLifecycleOwner.init()` 我们已经分析了，再看看 `LifecycleDispatcher.init()`\n\n``` java\nstatic void init(Context context) {                                                 \n    if (sInitialized.getAndSet(true)) {                                             \n        return;                                                                     \n    }                                                                               \n    ((Application) context.getApplicationContext())                                 \n            .registerActivityLifecycleCallbacks(new DispatcherActivityCallback());  \n}                                                                                   \n                                                                                    \n@SuppressWarnings(\"WeakerAccess\")                                                   \n@VisibleForTesting                                                                  \nstatic class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks {   \n                                                                                    \n    @Override                                                                       \n    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {   \n        ReportFragment.injectIfNeededIn(activity);                                  \n    }                                                                               \n                                                                                    \n    @Override                                                                       \n    public void onActivityStopped(Activity activity) {                              \n    }                                                                               \n                                                                                    \n    @Override                                                                       \n    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {   \n    }                                                                               \n}                                                                                   \n```\n\n初始化的逻辑比较简单，即在 `Activity` 创建时，调用 `ReportFragment.injectIfneededIn()` ，其实我们在 `Activity` 的 `Lifecycle` 处理中，也见到这个方法： \n\n``` java                                                       \n// ComponentActivity.java\n@Override                                                        \n@SuppressWarnings(\"RestrictedApi\")                               \nprotected void onCreate(@Nullable Bundle savedInstanceState) {   \n    super.onCreate(savedInstanceState);                          \n    ReportFragment.injectIfNeededIn(this);                       \n}\n\n// ReportFragment.java\npublic static void injectIfNeededIn(Activity activity) {                                      \n    // ProcessLifecycleOwner should always correctly work and some activities may not extend  \n    // FragmentActivity from support lib, so we use framework fragments for activities        \n    android.app.FragmentManager manager = activity.getFragmentManager();                      \n    if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {\n        // 重复添加判断\n        manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();   \n        // Hopefully, we are the first to make a transaction.                                 \n        manager.executePendingTransactions();                                                 \n    }                                                                                         \n}                                                                                             \n```\n\n这里可以理解为双重保障吧，可能存在不继承 `ComponentActivity` 的 `Activity`。\n\n### 总结\n\n分析了 `Lifecycle`  的整个流程，可以发现其实逻辑还是比较简单的，实现上也是参考了其他开源库的做法，比如 `ReportFragment` 通过添加一个透明的 `Fragment` 去感知 `Activity` 的生命周期，`Glide` 也是这么做的。还有使用 `ContentProvider` 去实现在 `Application` 创建时自动初始化，也是一个不错的想法。\n\n`Lifecycle` 的源码比我一开始想象的复杂，不是在于它的逻辑，而是在 `sync()` 这一块，通过 `Listener` 执行状态回调是一个非常常见的做法，但是有很多需要考虑的 case，举个例子，在分发回调时，有新的状态发生，那么应该怎么去处理。或者，在回调方法中，又添加了新的 `Listener`，那应该怎么处理。\n\n学习源码，不仅仅是学习实现原理，还可以学习一个健壮的库是如何处理各种场景下的 case 的。","slug":"Jetpack中的Lifecycle","published":1,"updated":"2019-01-27T07:44:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs17000ve39k1y9fineq","content":"<h3 id=\"关于本文\"><a href=\"#关于本文\" class=\"headerlink\" title=\"关于本文\"></a>关于本文</h3><p>有很多项目都会使用 MVP 这种项目架构，使用 Presenter 来减轻 <code>Activity</code> 的负担，具体的 <code>MVP</code> 实现可以阅读 Google 推出的 <a href=\"https://github.com/googlesamples/android-architecture\" target=\"_blank\" rel=\"noopener\">android-architecture</a>。</p>\n<p>一般使用 MVP，都会遇到一个问题，如何将 Presenter 和 View 的生命周期进行绑定，常见的做法是，在 <code>Activity</code> 的生命周期中手动调用 Presenter 的回调方法，更复杂的做法可能需要在 Presenter 或者 View 维护一个操作栈，在指定生命周期中去执行操作。</p>\n<h3 id=\"关于Lifecycle\"><a href=\"#关于Lifecycle\" class=\"headerlink\" title=\"关于Lifecycle\"></a>关于Lifecycle</h3><p><a href=\"https://developer.android.com/topic/libraries/architecture/lifecycle\" target=\"_blank\" rel=\"noopener\">lifecycle</a> 是 Google 推出的用于响应 <code>Activity</code> 和 <code>Fragment</code> 生命周期改变的库。</p>\n<p><strong>These components help you produce better-organized, and often lighter-weight code, that is easier to maintain.</strong></p>\n<h4 id=\"Lifecycle\"><a href=\"#Lifecycle\" class=\"headerlink\" title=\"Lifecycle\"></a>Lifecycle</h4><p><code>Lifecycle</code> 是一个包含比如 <code>Activity</code> 或 <code>Fragment</code> 生命周期状态的类，同时允许其他对象去订阅这些状态</p>\n<p><code>Lifecycle</code> 使用 Event 和 State 来管理生命周期状态的变化</p>\n<h5 id=\"Event\"><a href=\"#Event\" class=\"headerlink\" title=\"Event\"></a>Event</h5><p>生命周期变化的事件</p>\n<h5 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h5><p>当前生命周期的状态</p>\n<p>使用 Google 文档中图片来表示这两者的关系：</p>\n<p><img src=\"https://developer.android.com/images/topic/libraries/architecture/lifecycle-states.png\" alt=\"lifecycle-states\"></p>\n<p>我们可以调用 <code>addObserver</code> 去注册一个监听者</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lifecycle.addObserver(presenter)</span><br></pre></td></tr></table></figure>\n<p>而 <code>presenter</code> 则需要实现 <code>LifecycleObserver</code> 接口，具体的回调方法则通过注解的形式：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Presenter</span> : <span class=\"type\">LifecycleObserver &#123;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然我们也可以调用 <code>getCurrentState()</code> 来获取 <code>Lifecycle</code> 当前的状态</p>\n<h4 id=\"LifecycleOwner\"><a href=\"#LifecycleOwner\" class=\"headerlink\" title=\"LifecycleOwner\"></a>LifecycleOwner</h4><p>上面我们简单介绍了 <code>Lifecyle</code> 和 <code>LifecycleObserver</code>  的作用和关系之后，再来看下 <code>getLifecycle</code> 这个方法：</p>\n<blockquote>\n<p>因为上面的例子是用 kotlin 写的，所以 <code>lifecycle.addObserver</code> 实际上应该为 <code>getLifecycle().addObserver()</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the Lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> The lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"function\">Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说，<code>LifecycleOwner</code> 用于提供 <code>Lifecycle</code>，<code>LifecycleObserver</code> 监听 <code>Lifecycle</code> 的状态变化，<code>Lifecycle</code> 则是 <code>Activity</code> 或 <code>Fragment</code> 生命周期状态的抽象。</p>\n<p>可以看到 <code>Fragment</code> 和 <code>ComponentActivity</code> 等实现了 <code>LifecycleOwner</code> 接口，这里我们看下 <code>ComponentActivity</code> 的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> LifecycleRegistry mLifecycleRegistry = <span class=\"keyword\">new</span> LifecycleRegistry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@CallSuper</span>                                                   </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(Bundle outState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里需要注意，onSaveInstanceState 状态设置为 CREATED</span></span><br><span class=\"line\">    mLifecycleRegistry.markState(Lifecycle.State.CREATED);   </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onSaveInstanceState(outState);                     </span><br><span class=\"line\">&#125;                                                            </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                         </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mLifecycleRegistry;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                        </span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"RestrictedApi\"</span>)                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);                          </span><br><span class=\"line\">    ReportFragment.injectIfNeededIn(<span class=\"keyword\">this</span>);                       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到代码非常简洁，那它又是怎么去实现的呢？可以看到在 <code>onCreate</code> 中会调用 <code>ReportFragment.injectIfNeededIn</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">injectIfNeededIn</span><span class=\"params\">(Activity activity)</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"comment\">// ProcessLifecycleOwner should always correctly work and some activities may not extend </span></span><br><span class=\"line\">    <span class=\"comment\">// FragmentActivity from support lib, so we use framework fragments for activities       </span></span><br><span class=\"line\">    android.app.FragmentManager manager = activity.getFragmentManager();                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class=\"keyword\">null</span>) &#123;                            </span><br><span class=\"line\">        manager.beginTransaction().add(<span class=\"keyword\">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();  </span><br><span class=\"line\">        <span class=\"comment\">// Hopefully, we are the first to make a transaction.                                </span></span><br><span class=\"line\">        manager.executePendingTransactions();                                                </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里会添加一个 <code>ReportFragment</code> 如果有阅读过 Glide 源码的同学，应该会看到类似的实现：通过添加一个透明的 <code>Fragment</code> 会监听 <code>Activity</code> 的生命周期。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;              </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onActivityCreated(savedInstanceState);                        </span><br><span class=\"line\">    dispatchCreate(mProcessListener);                                   </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_CREATE);                                </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                        </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;                                                 </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onStart();                                                    </span><br><span class=\"line\">    dispatchStart(mProcessListener);                                    </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_START);                                 </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                        </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;                                                </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume();                                                   </span><br><span class=\"line\">    dispatchResume(mProcessListener);                                   </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_RESUME);                                </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                        </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;                                                 </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onPause();                                                    </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_PAUSE);                                 </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                        </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onStop();                                                     </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_STOP);                                  </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                        </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;                                               </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();                                                  </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_DESTROY);                               </span><br><span class=\"line\">    <span class=\"comment\">// just want to be sure that we won't leak reference to an activity </span></span><br><span class=\"line\">    mProcessListener = <span class=\"keyword\">null</span>;                                            </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(Lifecycle.Event event)</span> </span>&#123;                                         </span><br><span class=\"line\">    Activity activity = getActivity();                                                 </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleRegistryOwner) &#123;                                  </span><br><span class=\"line\">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                        </span><br><span class=\"line\">    &#125;                                                                                  </span><br><span class=\"line\">                                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleOwner) &#123;                                          </span><br><span class=\"line\">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();              </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lifecycle <span class=\"keyword\">instanceof</span> LifecycleRegistry) &#123;                                  </span><br><span class=\"line\">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);               </span><br><span class=\"line\">        &#125;                                                                              </span><br><span class=\"line\">    &#125;                                                                                  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>Activity</code> 的各种生命周期回调方法中，调用 <code>handleLifecycleEvent()</code> 分发 <code>Lifecycle.Event</code></p>\n<h5 id=\"handleLifecycleEvent\"><a href=\"#handleLifecycleEvent\" class=\"headerlink\" title=\"handleLifecycleEvent\"></a>handleLifecycleEvent</h5><p><code>LifecycleRegistry</code> 是 <code>Lifecycle</code> 的实现类，看下 <code>handleLifecycleEvent</code> 的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLifecycleEvent</span><span class=\"params\">(@NonNull Lifecycle.Event event)</span> </span>&#123;    </span><br><span class=\"line\">    State next = getStateAfter(event);                                </span><br><span class=\"line\">    moveToState(next);                                                </span><br><span class=\"line\">&#125;                                                                     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// event 和 Sate 的对应关系</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> State <span class=\"title\">getStateAfter</span><span class=\"params\">(Event event)</span> </span>&#123;                                  </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (event) &#123;                                                       </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_CREATE:                                                    </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_STOP:                                                      </span><br><span class=\"line\">            <span class=\"keyword\">return</span> CREATED;                                                </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_START:                                                     </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_PAUSE:                                                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> STARTED;                                                </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_RESUME:                                                    </span><br><span class=\"line\">            <span class=\"keyword\">return</span> RESUMED;                                                </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_DESTROY:                                                   </span><br><span class=\"line\">            <span class=\"keyword\">return</span> DESTROYED;                                              </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_ANY:                                                       </span><br><span class=\"line\">            <span class=\"keyword\">break</span>;                                                         </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unexpected event value \"</span> + event); </span><br><span class=\"line\">&#125;                                                                          </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(State next)</span> </span>&#123;                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mState == next) &#123;                                             </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                       </span><br><span class=\"line\">    &#125;                                                                 </span><br><span class=\"line\">    mState = next;                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHandlingEvent || mAddingObserverCounter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 正在处理事件中或者正在处理添加 Observer 中</span></span><br><span class=\"line\">        mNewEventOccurred = <span class=\"keyword\">true</span>;                                     </span><br><span class=\"line\">        <span class=\"comment\">// we will figure out what to do on upper level.              </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 标记正在处理事件</span></span><br><span class=\"line\">    mHandlingEvent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 同步状态</span></span><br><span class=\"line\">    sync();                                                           </span><br><span class=\"line\">    mHandlingEvent = <span class=\"keyword\">false</span>;                                           </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// happens only on the top of stack (never in reentrance),                                    </span></span><br><span class=\"line\"><span class=\"comment\">// so it doesn't have to take in account parents                                              </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sync</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用弱应用持有 LifecycleOwner，也是为了防止 Activity/Fragment 内存泄漏</span></span><br><span class=\"line\">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Log.w(LOG_TAG, <span class=\"string\">\"LifecycleOwner is garbage collected, you shouldn't try dispatch \"</span>     </span><br><span class=\"line\">                + <span class=\"string\">\"new events from it.\"</span>);                                                     </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                               </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isSynced()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果还没完成同步</span></span><br><span class=\"line\">        mNewEventOccurred = <span class=\"keyword\">false</span>;                                                            </span><br><span class=\"line\">        <span class=\"comment\">// no need to check eldest for nullability, because isSynced does it for us.     </span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 使用 eldest(start) 判断是否需要回退 </span></span><br><span class=\"line\">        <span class=\"comment\">// 使用 newest(end) 判断是否需要前进，刚添加的 observer 一般为初始化状态</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 最先添加的 observer 的状态大于当前状态，回退</span></span><br><span class=\"line\">            backwardPass(lifecycleOwner);                                                     </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();           </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class=\"keyword\">null</span>                                              </span><br><span class=\"line\">                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 最新添加的 observer 如果状态一致，则可以乐观地表示在它之前添加的 observer 状态也是一致的</span></span><br><span class=\"line\">            <span class=\"comment\">// mNewEventOccurred 表示有新的事件发生，则放弃这次同步，延迟到下一次</span></span><br><span class=\"line\">            forwardPass(lifecycleOwner);                                                      </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">    mNewEventOccurred = <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSynced</span><span class=\"params\">()</span> </span>&#123;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mObserverMap.size() == <span class=\"number\">0</span>) &#123;                                                     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// eldest 最先添加的，newest 最新添加的</span></span><br><span class=\"line\">    State eldestObserverState = mObserverMap.eldest().getValue().mState;                </span><br><span class=\"line\">    State newestObserverState = mObserverMap.newest().getValue().mState;</span><br><span class=\"line\">    <span class=\"comment\">// 判断状态是否一致</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>sync()</code> 同步状态，这里分为两种情况，一种是需要回退状态（backward），另外一种则是需要前进（forward），其中 <code>backward</code> 代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">backwardPass</span><span class=\"params\">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 eldest(start) 判断是否需要回退 </span></span><br><span class=\"line\">    <span class=\"comment\">// 降序迭代，end -&gt; start</span></span><br><span class=\"line\">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =         </span><br><span class=\"line\">            mObserverMap.descendingIterator();                                         </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mNewEventOccurred 判断是否有新事件分发</span></span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next(); </span><br><span class=\"line\">        ObserverWithState observer = entry.getValue();                                 </span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((observer.mState.compareTo(mState) &gt; <span class=\"number\">0</span> &amp;&amp; !mNewEventOccurred            </span><br><span class=\"line\">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回退</span></span><br><span class=\"line\">            <span class=\"comment\">// 举个例子：observer.state 为 RESUMED</span></span><br><span class=\"line\">            <span class=\"comment\">// mState 为 CREATED</span></span><br><span class=\"line\">            <span class=\"comment\">// downEvent(observer.state) 为 ON_PAUSE</span></span><br><span class=\"line\">            Event event = downEvent(observer.mState);</span><br><span class=\"line\">            <span class=\"comment\">// getStateAfter(event) 为 STARTED</span></span><br><span class=\"line\">            <span class=\"comment\">// 最终：RESUMED -&gt; STARTED，在下一次同步中再同步为 CREATED</span></span><br><span class=\"line\">            <span class=\"comment\">// pushParentState 和 popParentState 则是将 state 暂存在 List 中，这个作用我们会在 addObserver 中讲</span></span><br><span class=\"line\">            pushParentState(getStateAfter(event));</span><br><span class=\"line\">            <span class=\"comment\">// 分发事件</span></span><br><span class=\"line\">            observer.dispatchEvent(lifecycleOwner, event);                             </span><br><span class=\"line\">            popParentState();                                                          </span><br><span class=\"line\">        &#125;                                                                              </span><br><span class=\"line\">    &#125;                                                                                  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Event <span class=\"title\">downEvent</span><span class=\"params\">(State state)</span> </span>&#123;                             </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (state) &#123;                                                      </span><br><span class=\"line\">        <span class=\"keyword\">case</span> INITIALIZED:                                                 </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();                         </span><br><span class=\"line\">        <span class=\"keyword\">case</span> CREATED:                                                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_DESTROY;                                            </span><br><span class=\"line\">        <span class=\"keyword\">case</span> STARTED:                                                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_STOP;                                               </span><br><span class=\"line\">        <span class=\"keyword\">case</span> RESUMED:                                                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_PAUSE;                                              </span><br><span class=\"line\">        <span class=\"keyword\">case</span> DESTROYED:                                                   </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();                         </span><br><span class=\"line\">    &#125;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unexpected state value \"</span> + state);</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> State <span class=\"title\">getStateAfter</span><span class=\"params\">(Event event)</span> </span>&#123;                                   </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (event) &#123;                                                        </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_CREATE:                                                     </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_STOP:                                                       </span><br><span class=\"line\">            <span class=\"keyword\">return</span> CREATED;                                                 </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_START:                                                      </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_PAUSE:                                                      </span><br><span class=\"line\">            <span class=\"keyword\">return</span> STARTED;                                                 </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_RESUME:                                                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> RESUMED;                                                 </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_DESTROY:                                                    </span><br><span class=\"line\">            <span class=\"keyword\">return</span> DESTROYED;                                               </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_ANY:                                                        </span><br><span class=\"line\">            <span class=\"keyword\">break</span>;                                                          </span><br><span class=\"line\">    &#125;                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unexpected event value \"</span> + event);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ObserverWithState.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchEvent</span><span class=\"params\">(LifecycleOwner owner, Event event)</span> </span>&#123; </span><br><span class=\"line\">    State newState = getStateAfter(event);</span><br><span class=\"line\">    <span class=\"comment\">// 使用较小的状态同步</span></span><br><span class=\"line\">    mState = min(mState, newState);                     </span><br><span class=\"line\">    mLifecycleObserver.onStateChanged(owner, event);    </span><br><span class=\"line\">    mState = newState;                                  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结下 <code>backwardPass()</code> 的逻辑：将较大的状态逐步回退。为什么说是逐步呢？比如 <code>observer.state</code> 是 <code>RESUMED</code>，当前状态是 <code>CREATED</code>，那这里会分两次回退，分别为：<code>RESUMED -&gt; STARTED</code> 和 <code>STARTED -&gt; CREATED</code></p>\n<p><code>forwardPass()</code> 逻辑类似，则不分析了。</p>\n<h5 id=\"addObserver\"><a href=\"#addObserver\" class=\"headerlink\" title=\"addObserver\"></a>addObserver</h5><p><code>addObserver()</code> 是添加 <code>Observer</code> 的方法，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                 </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不是 DESTROYED，则从 INITIALIZED 开始分发</span></span><br><span class=\"line\">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class=\"line\">    <span class=\"comment\">// ObserverWithState 用于分发事件给 observer</span></span><br><span class=\"line\">    ObserverWithState statefulObserver = <span class=\"keyword\">new</span> ObserverWithState(observer, initialState);   </span><br><span class=\"line\">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);    </span><br><span class=\"line\">                                                                                          </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 唯一性</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                           </span><br><span class=\"line\">    &#125;                                                                                     </span><br><span class=\"line\">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// mLifecycleOwner 为弱引用</span></span><br><span class=\"line\">        <span class=\"comment\">// it is null we should be destroyed. Fallback quickly                            </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                           </span><br><span class=\"line\">    &#125;                                                                                     </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// isReentrance 表示是否在分发事件时新添加了 observer</span></span><br><span class=\"line\">    <span class=\"comment\">// 举个例子：在 observer 在 onStart() 中又调用了 addObserver()</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isReentrance = mAddingObserverCounter != <span class=\"number\">0</span> || mHandlingEvent; </span><br><span class=\"line\">    <span class=\"comment\">// 计算需要分发的状态</span></span><br><span class=\"line\">    State targetState = calculateTargetState(observer);                                   </span><br><span class=\"line\">    mAddingObserverCounter++; </span><br><span class=\"line\">    <span class=\"comment\">// 将事件逐步分发到 targetState</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class=\"number\">0</span>                            </span><br><span class=\"line\">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 statefulObserver.state 小于 targetState</span></span><br><span class=\"line\">        pushParentState(statefulObserver.mState);</span><br><span class=\"line\">        <span class=\"comment\">// 如果 state 为 STARTED，则 upEvent(state) 则为 ON_RESUME</span></span><br><span class=\"line\">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); </span><br><span class=\"line\">        popParentState();                                                                 </span><br><span class=\"line\">        <span class=\"comment\">// mState / subling may have been changed recalculate                             </span></span><br><span class=\"line\">        targetState = calculateTargetState(observer);                                     </span><br><span class=\"line\">    &#125;                                                                                     </span><br><span class=\"line\">                                                                                          </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isReentrance) &#123;                                                                  </span><br><span class=\"line\">        <span class=\"comment\">// we do sync only on the top level.</span></span><br><span class=\"line\">        <span class=\"comment\">// 当前为重入，则不进行同步</span></span><br><span class=\"line\">        sync();                                                                           </span><br><span class=\"line\">    &#125;                                                                                     </span><br><span class=\"line\">    mAddingObserverCounter--;                                                             </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Event <span class=\"title\">upEvent</span><span class=\"params\">(State state)</span> </span>&#123;                                  </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (state) &#123;                                                         </span><br><span class=\"line\">        <span class=\"keyword\">case</span> INITIALIZED:                                                    </span><br><span class=\"line\">        <span class=\"keyword\">case</span> DESTROYED:                                                      </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_CREATE;                                                </span><br><span class=\"line\">        <span class=\"keyword\">case</span> CREATED:                                                        </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_START;                                                 </span><br><span class=\"line\">        <span class=\"keyword\">case</span> STARTED:                                                        </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_RESUME;                                                </span><br><span class=\"line\">        <span class=\"keyword\">case</span> RESUMED:                                                        </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();                            </span><br><span class=\"line\">    &#125;                                                                        </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unexpected state value \"</span> + state);   </span><br><span class=\"line\">&#125;                                                                            </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> State <span class=\"title\">calculateTargetState</span><span class=\"params\">(LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取上一个添加的 observer</span></span><br><span class=\"line\">    Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);       </span><br><span class=\"line\">\t</span><br><span class=\"line\">    State siblingState = previous != <span class=\"keyword\">null</span> ? previous.getValue().mState : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// mParentStates 是个 List，它的添加和删除分别由 pushParentState() 和 popParentState()，它们是成对出现的，在 dispatchEvent 的前后</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这种 case 下，会存在 parentState：在 dispatchEvent 时，又调用了 addObserver()，即上面说的 isReentrance</span></span><br><span class=\"line\">    State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class=\"number\">1</span>)</span><br><span class=\"line\">            : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的计算是获取更合适的状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 考虑以下这种 case：某个 observer 在 onStart() 中再调用 addObserver，那这个 observer 理应使用 STARTED 状态分发，而当前状态即 mState 可能是 RESUMED，再在 sync() 中进行同步</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(min(mState, siblingState), parentState);                                       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>addObserver()</code> 主要考虑了 Reentrance 的情况，即在 <code>observer</code> 的事件分发中，又添加了新的 <code>observer</code> 的情况。</p>\n<h4 id=\"ProcessLifecycleOwner\"><a href=\"#ProcessLifecycleOwner\" class=\"headerlink\" title=\"ProcessLifecycleOwner\"></a>ProcessLifecycleOwner</h4><p><code>ProcessLifecycleOwner</code> 提供应用进程的生命周期。跟 <code>Activity</code> 和 <code>Fragment</code> 的生命周期不一样的是：</p>\n<ul>\n<li><code>ON_CREATE</code> 只会分发一次</li>\n<li><code>ON_DESTROY</code> 则不会被分发</li>\n<li><code>ON_START</code> 和 <code>ON_RESUME</code> 在第一个 <code>Activity</code> 的时候分发</li>\n<li><code>ON_PAUSE</code> 和 <code>ON_STOP</code> 则在最后一个 <code>Activity</code> 的时候<strong>延迟</strong>分发，用于防止因为配置改变，而导致 <code>Activity</code> 重建</li>\n</ul>\n<p>下面我们来分析下 <code>ProcessLifecycleOwner</code> 的源码，首先看下 <code>init()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单例</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProcessLifecycleOwner sInstance = <span class=\"keyword\">new</span> ProcessLifecycleOwner();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 attach</span></span><br><span class=\"line\">    sInstance.attach(context);      </span><br><span class=\"line\">&#125;                                   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context)</span> </span>&#123;                                                          </span><br><span class=\"line\">    mHandler = <span class=\"keyword\">new</span> Handler();</span><br><span class=\"line\">    <span class=\"comment\">// 同样是使用 LifecycleRegistry 来处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 先分发 ON_CREATE，而且只会分发一次</span></span><br><span class=\"line\">    mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);                          </span><br><span class=\"line\">    Application app = (Application) context.getApplicationContext();</span><br><span class=\"line\">    app.registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> EmptyActivityLifecycleCallbacks() &#123;      </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;   </span><br><span class=\"line\">            ReportFragment.get(activity).setProcessListener(mInitializationListener);   </span><br><span class=\"line\">        &#125;                                                                               </span><br><span class=\"line\">                                                                                        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>&#123;                               </span><br><span class=\"line\">            activityPaused();                                                           </span><br><span class=\"line\">        &#125;                                                                               </span><br><span class=\"line\">                                                                                        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123;                              </span><br><span class=\"line\">            activityStopped();                                                          </span><br><span class=\"line\">        &#125;                                                                               </span><br><span class=\"line\">    &#125;);                                                                                 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ActivityInitializationListener mInitializationListener =      </span><br><span class=\"line\">        <span class=\"keyword\">new</span> ActivityInitializationListener() &#123;                </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                         </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;                          </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                         </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;                           </span><br><span class=\"line\">                activityStarted();                            </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                         </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;                          </span><br><span class=\"line\">                activityResumed();                            </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">      </span><br><span class=\"line\">                                                 </span><br><span class=\"line\"><span class=\"comment\">// ground truth counters                         </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mStartedCounter = <span class=\"number\">0</span>;                 </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mResumedCounter = <span class=\"number\">0</span>;                 </span><br><span class=\"line\">                                                 </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mPauseSent = <span class=\"keyword\">true</span>;               </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mStopSent = <span class=\"keyword\">true</span>;                </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityStarted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    mStartedCounter++;                                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartedCounter == <span class=\"number\">1</span> &amp;&amp; mStopSent) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一次调用，分发 ON_START</span></span><br><span class=\"line\">        <span class=\"comment\">// mStopSent 为 true 的情况：</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 默认为 true</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. dispatchStopIfNeeded 中设置</span></span><br><span class=\"line\">        <span class=\"comment\">// 防止因为配置改变，Activity 创建而导致重新分发</span></span><br><span class=\"line\">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); </span><br><span class=\"line\">        mStopSent = <span class=\"keyword\">false</span>;                                        </span><br><span class=\"line\">    &#125;                                                             </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityResumed</span><span class=\"params\">()</span> </span>&#123;                                               </span><br><span class=\"line\">     mResumedCounter++;                                                 </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">1</span>) &#123;                                        </span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mPauseSent) &#123;</span><br><span class=\"line\">             <span class=\"comment\">// 第一次调用分发 ON_RESUME</span></span><br><span class=\"line\">             mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); </span><br><span class=\"line\">             mPauseSent = <span class=\"keyword\">false</span>;                                        </span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">             <span class=\"comment\">// 配置改变，Activity 创建，删除延迟的 pause runnable</span></span><br><span class=\"line\">             mHandler.removeCallbacks(mDelayedPauseRunnable);           </span><br><span class=\"line\">         &#125;                                                              </span><br><span class=\"line\">     &#125;                                                                  </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>上面是初始事件分发流程，下面我们来看下 <code>ON_PAUSE</code> 和 <code>ON_STOP</code> 的分发：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@VisibleForTesting</span>                               </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> TIMEOUT_MS = <span class=\"number\">700</span>; <span class=\"comment\">//mls </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 onActivityPaused 中调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityPaused</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    mResumedCounter--;                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 延迟分发</span></span><br><span class=\"line\">        mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);    </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">private</span> Runnable mDelayedPauseRunnable = <span class=\"keyword\">new</span> Runnable() &#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                             </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 延迟分发</span></span><br><span class=\"line\">        dispatchPauseIfNeeded();                          </span><br><span class=\"line\">        dispatchStopIfNeeded();                           </span><br><span class=\"line\">    &#125;                                                     </span><br><span class=\"line\">&#125;;                                                        </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityStopped</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    mStartedCounter--;                                              </span><br><span class=\"line\">    dispatchStopIfNeeded();                                         </span><br><span class=\"line\">&#125;                                                                   </span><br><span class=\"line\">                                                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchPauseIfNeeded</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计数</span></span><br><span class=\"line\">        mPauseSent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 分发 ON_PAUSE</span></span><br><span class=\"line\">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);   </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;                                                                   </span><br><span class=\"line\">                                                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchStopIfNeeded</span><span class=\"params\">()</span> </span>&#123;                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartedCounter == <span class=\"number\">0</span> &amp;&amp; mPauseSent) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计数为 0，同时已经分发了 ON_PAUSE</span></span><br><span class=\"line\">        <span class=\"comment\">// 分发 ON_STOP</span></span><br><span class=\"line\">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);    </span><br><span class=\"line\">        mStopSent = <span class=\"keyword\">true</span>;                                           </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经将 <code>ProcessLifecycleOwner</code> 的流程分析完了，那 <code>ProcessLifecycleOwner.init()</code> 是在那里调用的呢？</p>\n<p>其实是用了一种比较巧妙的方法，在 <code>lifecycle-process</code> 这个包下的 <code>AndroidManifest.xml</code> 文件中，可以看到有如下配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">application</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">provider</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">\"androidx.lifecycle.ProcessLifecycleOwnerInitializer\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:authorities</span>=<span class=\"string\">\"$&#123;applicationId&#125;.lifecycle-process\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:exported</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:multiprocess</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其中 <code>ProcessLifecycleOwnerInitializer</code> 是一个 <code>ContentProvider</code> 即利用 <code>ContentProvider</code> 来实现自动初始化</p>\n<blockquote>\n<p>ContentProvider 的 <code>onCreate</code> 方法会在应用启动时候调用</p>\n<p>Implement this to initialize your content provider on startup. This method is called for all registered content providers on the application main thread at application launch time. It must not perform lengthy operations, or application startup will be delayed.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                     </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;                   </span><br><span class=\"line\">    LifecycleDispatcher.init(getContext());   </span><br><span class=\"line\">    ProcessLifecycleOwner.init(getContext()); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                              </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里调用了两个初始化方法，其中 <code>ProcessLifecycleOwner.init()</code> 我们已经分析了，再看看 <code>LifecycleDispatcher.init()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;                                                 </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sInitialized.getAndSet(<span class=\"keyword\">true</span>)) &#123;                                             </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                     </span><br><span class=\"line\">    &#125;                                                                               </span><br><span class=\"line\">    ((Application) context.getApplicationContext())                                 </span><br><span class=\"line\">            .registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> DispatcherActivityCallback());  </span><br><span class=\"line\">&#125;                                                                                   </span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"WeakerAccess\"</span>)                                                   </span><br><span class=\"line\"><span class=\"meta\">@VisibleForTesting</span>                                                                  </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherActivityCallback</span> <span class=\"keyword\">extends</span> <span class=\"title\">EmptyActivityLifecycleCallbacks</span> </span>&#123;   </span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;   </span><br><span class=\"line\">        ReportFragment.injectIfNeededIn(activity);                                  </span><br><span class=\"line\">    &#125;                                                                               </span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123;                              </span><br><span class=\"line\">    &#125;                                                                               </span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span> </span>&#123;   </span><br><span class=\"line\">    &#125;                                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化的逻辑比较简单，即在 <code>Activity</code> 创建时，调用 <code>ReportFragment.injectIfneededIn()</code> ，其实我们在 <code>Activity</code> 的 <code>Lifecycle</code> 处理中，也见到这个方法： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ComponentActivity.java</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                        </span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"RestrictedApi\"</span>)                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);                          </span><br><span class=\"line\">    ReportFragment.injectIfNeededIn(<span class=\"keyword\">this</span>);                       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReportFragment.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">injectIfNeededIn</span><span class=\"params\">(Activity activity)</span> </span>&#123;                                      </span><br><span class=\"line\">    <span class=\"comment\">// ProcessLifecycleOwner should always correctly work and some activities may not extend  </span></span><br><span class=\"line\">    <span class=\"comment\">// FragmentActivity from support lib, so we use framework fragments for activities        </span></span><br><span class=\"line\">    android.app.FragmentManager manager = activity.getFragmentManager();                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 重复添加判断</span></span><br><span class=\"line\">        manager.beginTransaction().add(<span class=\"keyword\">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();   </span><br><span class=\"line\">        <span class=\"comment\">// Hopefully, we are the first to make a transaction.                                 </span></span><br><span class=\"line\">        manager.executePendingTransactions();                                                 </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里可以理解为双重保障吧，可能存在不继承 <code>ComponentActivity</code> 的 <code>Activity</code>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>分析了 <code>Lifecycle</code>  的整个流程，可以发现其实逻辑还是比较简单的，实现上也是参考了其他开源库的做法，比如 <code>ReportFragment</code> 通过添加一个透明的 <code>Fragment</code> 去感知 <code>Activity</code> 的生命周期，<code>Glide</code> 也是这么做的。还有使用 <code>ContentProvider</code> 去实现在 <code>Application</code> 创建时自动初始化，也是一个不错的想法。</p>\n<p><code>Lifecycle</code> 的源码比我一开始想象的复杂，不是在于它的逻辑，而是在 <code>sync()</code> 这一块，通过 <code>Listener</code> 执行状态回调是一个非常常见的做法，但是有很多需要考虑的 case，举个例子，在分发回调时，有新的状态发生，那么应该怎么去处理。或者，在回调方法中，又添加了新的 <code>Listener</code>，那应该怎么处理。</p>\n<p>学习源码，不仅仅是学习实现原理，还可以学习一个健壮的库是如何处理各种场景下的 case 的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"关于本文\"><a href=\"#关于本文\" class=\"headerlink\" title=\"关于本文\"></a>关于本文</h3><p>有很多项目都会使用 MVP 这种项目架构，使用 Presenter 来减轻 <code>Activity</code> 的负担，具体的 <code>MVP</code> 实现可以阅读 Google 推出的 <a href=\"https://github.com/googlesamples/android-architecture\" target=\"_blank\" rel=\"noopener\">android-architecture</a>。</p>\n<p>一般使用 MVP，都会遇到一个问题，如何将 Presenter 和 View 的生命周期进行绑定，常见的做法是，在 <code>Activity</code> 的生命周期中手动调用 Presenter 的回调方法，更复杂的做法可能需要在 Presenter 或者 View 维护一个操作栈，在指定生命周期中去执行操作。</p>\n<h3 id=\"关于Lifecycle\"><a href=\"#关于Lifecycle\" class=\"headerlink\" title=\"关于Lifecycle\"></a>关于Lifecycle</h3><p><a href=\"https://developer.android.com/topic/libraries/architecture/lifecycle\" target=\"_blank\" rel=\"noopener\">lifecycle</a> 是 Google 推出的用于响应 <code>Activity</code> 和 <code>Fragment</code> 生命周期改变的库。</p>\n<p><strong>These components help you produce better-organized, and often lighter-weight code, that is easier to maintain.</strong></p>\n<h4 id=\"Lifecycle\"><a href=\"#Lifecycle\" class=\"headerlink\" title=\"Lifecycle\"></a>Lifecycle</h4><p><code>Lifecycle</code> 是一个包含比如 <code>Activity</code> 或 <code>Fragment</code> 生命周期状态的类，同时允许其他对象去订阅这些状态</p>\n<p><code>Lifecycle</code> 使用 Event 和 State 来管理生命周期状态的变化</p>\n<h5 id=\"Event\"><a href=\"#Event\" class=\"headerlink\" title=\"Event\"></a>Event</h5><p>生命周期变化的事件</p>\n<h5 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h5><p>当前生命周期的状态</p>\n<p>使用 Google 文档中图片来表示这两者的关系：</p>\n<p><img src=\"https://developer.android.com/images/topic/libraries/architecture/lifecycle-states.png\" alt=\"lifecycle-states\"></p>\n<p>我们可以调用 <code>addObserver</code> 去注册一个监听者</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lifecycle.addObserver(presenter)</span><br></pre></td></tr></table></figure>\n<p>而 <code>presenter</code> 则需要实现 <code>LifecycleObserver</code> 接口，具体的回调方法则通过注解的形式：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Presenter</span> : <span class=\"type\">LifecycleObserver &#123;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然我们也可以调用 <code>getCurrentState()</code> 来获取 <code>Lifecycle</code> 当前的状态</p>\n<h4 id=\"LifecycleOwner\"><a href=\"#LifecycleOwner\" class=\"headerlink\" title=\"LifecycleOwner\"></a>LifecycleOwner</h4><p>上面我们简单介绍了 <code>Lifecyle</code> 和 <code>LifecycleObserver</code>  的作用和关系之后，再来看下 <code>getLifecycle</code> 这个方法：</p>\n<blockquote>\n<p>因为上面的例子是用 kotlin 写的，所以 <code>lifecycle.addObserver</code> 实际上应该为 <code>getLifecycle().addObserver()</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the Lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> The lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"function\">Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说，<code>LifecycleOwner</code> 用于提供 <code>Lifecycle</code>，<code>LifecycleObserver</code> 监听 <code>Lifecycle</code> 的状态变化，<code>Lifecycle</code> 则是 <code>Activity</code> 或 <code>Fragment</code> 生命周期状态的抽象。</p>\n<p>可以看到 <code>Fragment</code> 和 <code>ComponentActivity</code> 等实现了 <code>LifecycleOwner</code> 接口，这里我们看下 <code>ComponentActivity</code> 的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> LifecycleRegistry mLifecycleRegistry = <span class=\"keyword\">new</span> LifecycleRegistry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@CallSuper</span>                                                   </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(Bundle outState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里需要注意，onSaveInstanceState 状态设置为 CREATED</span></span><br><span class=\"line\">    mLifecycleRegistry.markState(Lifecycle.State.CREATED);   </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onSaveInstanceState(outState);                     </span><br><span class=\"line\">&#125;                                                            </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                         </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mLifecycleRegistry;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                        </span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"RestrictedApi\"</span>)                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);                          </span><br><span class=\"line\">    ReportFragment.injectIfNeededIn(<span class=\"keyword\">this</span>);                       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到代码非常简洁，那它又是怎么去实现的呢？可以看到在 <code>onCreate</code> 中会调用 <code>ReportFragment.injectIfNeededIn</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">injectIfNeededIn</span><span class=\"params\">(Activity activity)</span> </span>&#123;                                     </span><br><span class=\"line\">    <span class=\"comment\">// ProcessLifecycleOwner should always correctly work and some activities may not extend </span></span><br><span class=\"line\">    <span class=\"comment\">// FragmentActivity from support lib, so we use framework fragments for activities       </span></span><br><span class=\"line\">    android.app.FragmentManager manager = activity.getFragmentManager();                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class=\"keyword\">null</span>) &#123;                            </span><br><span class=\"line\">        manager.beginTransaction().add(<span class=\"keyword\">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();  </span><br><span class=\"line\">        <span class=\"comment\">// Hopefully, we are the first to make a transaction.                                </span></span><br><span class=\"line\">        manager.executePendingTransactions();                                                </span><br><span class=\"line\">    &#125;                                                                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里会添加一个 <code>ReportFragment</code> 如果有阅读过 Glide 源码的同学，应该会看到类似的实现：通过添加一个透明的 <code>Fragment</code> 会监听 <code>Activity</code> 的生命周期。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;              </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onActivityCreated(savedInstanceState);                        </span><br><span class=\"line\">    dispatchCreate(mProcessListener);                                   </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_CREATE);                                </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                        </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;                                                 </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onStart();                                                    </span><br><span class=\"line\">    dispatchStart(mProcessListener);                                    </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_START);                                 </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                        </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;                                                </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume();                                                   </span><br><span class=\"line\">    dispatchResume(mProcessListener);                                   </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_RESUME);                                </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                        </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;                                                 </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onPause();                                                    </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_PAUSE);                                 </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                        </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onStop();                                                     </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_STOP);                                  </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                        </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;                                               </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();                                                  </span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_DESTROY);                               </span><br><span class=\"line\">    <span class=\"comment\">// just want to be sure that we won't leak reference to an activity </span></span><br><span class=\"line\">    mProcessListener = <span class=\"keyword\">null</span>;                                            </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(Lifecycle.Event event)</span> </span>&#123;                                         </span><br><span class=\"line\">    Activity activity = getActivity();                                                 </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleRegistryOwner) &#123;                                  </span><br><span class=\"line\">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                        </span><br><span class=\"line\">    &#125;                                                                                  </span><br><span class=\"line\">                                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleOwner) &#123;                                          </span><br><span class=\"line\">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();              </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lifecycle <span class=\"keyword\">instanceof</span> LifecycleRegistry) &#123;                                  </span><br><span class=\"line\">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);               </span><br><span class=\"line\">        &#125;                                                                              </span><br><span class=\"line\">    &#125;                                                                                  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>Activity</code> 的各种生命周期回调方法中，调用 <code>handleLifecycleEvent()</code> 分发 <code>Lifecycle.Event</code></p>\n<h5 id=\"handleLifecycleEvent\"><a href=\"#handleLifecycleEvent\" class=\"headerlink\" title=\"handleLifecycleEvent\"></a>handleLifecycleEvent</h5><p><code>LifecycleRegistry</code> 是 <code>Lifecycle</code> 的实现类，看下 <code>handleLifecycleEvent</code> 的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLifecycleEvent</span><span class=\"params\">(@NonNull Lifecycle.Event event)</span> </span>&#123;    </span><br><span class=\"line\">    State next = getStateAfter(event);                                </span><br><span class=\"line\">    moveToState(next);                                                </span><br><span class=\"line\">&#125;                                                                     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// event 和 Sate 的对应关系</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> State <span class=\"title\">getStateAfter</span><span class=\"params\">(Event event)</span> </span>&#123;                                  </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (event) &#123;                                                       </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_CREATE:                                                    </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_STOP:                                                      </span><br><span class=\"line\">            <span class=\"keyword\">return</span> CREATED;                                                </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_START:                                                     </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_PAUSE:                                                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> STARTED;                                                </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_RESUME:                                                    </span><br><span class=\"line\">            <span class=\"keyword\">return</span> RESUMED;                                                </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_DESTROY:                                                   </span><br><span class=\"line\">            <span class=\"keyword\">return</span> DESTROYED;                                              </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_ANY:                                                       </span><br><span class=\"line\">            <span class=\"keyword\">break</span>;                                                         </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unexpected event value \"</span> + event); </span><br><span class=\"line\">&#125;                                                                          </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(State next)</span> </span>&#123;                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mState == next) &#123;                                             </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                       </span><br><span class=\"line\">    &#125;                                                                 </span><br><span class=\"line\">    mState = next;                                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHandlingEvent || mAddingObserverCounter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 正在处理事件中或者正在处理添加 Observer 中</span></span><br><span class=\"line\">        mNewEventOccurred = <span class=\"keyword\">true</span>;                                     </span><br><span class=\"line\">        <span class=\"comment\">// we will figure out what to do on upper level.              </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 标记正在处理事件</span></span><br><span class=\"line\">    mHandlingEvent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 同步状态</span></span><br><span class=\"line\">    sync();                                                           </span><br><span class=\"line\">    mHandlingEvent = <span class=\"keyword\">false</span>;                                           </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// happens only on the top of stack (never in reentrance),                                    </span></span><br><span class=\"line\"><span class=\"comment\">// so it doesn't have to take in account parents                                              </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sync</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用弱应用持有 LifecycleOwner，也是为了防止 Activity/Fragment 内存泄漏</span></span><br><span class=\"line\">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();                                    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Log.w(LOG_TAG, <span class=\"string\">\"LifecycleOwner is garbage collected, you shouldn't try dispatch \"</span>     </span><br><span class=\"line\">                + <span class=\"string\">\"new events from it.\"</span>);                                                     </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                               </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isSynced()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果还没完成同步</span></span><br><span class=\"line\">        mNewEventOccurred = <span class=\"keyword\">false</span>;                                                            </span><br><span class=\"line\">        <span class=\"comment\">// no need to check eldest for nullability, because isSynced does it for us.     </span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 使用 eldest(start) 判断是否需要回退 </span></span><br><span class=\"line\">        <span class=\"comment\">// 使用 newest(end) 判断是否需要前进，刚添加的 observer 一般为初始化状态</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 最先添加的 observer 的状态大于当前状态，回退</span></span><br><span class=\"line\">            backwardPass(lifecycleOwner);                                                     </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();           </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class=\"keyword\">null</span>                                              </span><br><span class=\"line\">                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 最新添加的 observer 如果状态一致，则可以乐观地表示在它之前添加的 observer 状态也是一致的</span></span><br><span class=\"line\">            <span class=\"comment\">// mNewEventOccurred 表示有新的事件发生，则放弃这次同步，延迟到下一次</span></span><br><span class=\"line\">            forwardPass(lifecycleOwner);                                                      </span><br><span class=\"line\">        &#125;                                                                                     </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">    mNewEventOccurred = <span class=\"keyword\">false</span>;                                                                </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSynced</span><span class=\"params\">()</span> </span>&#123;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mObserverMap.size() == <span class=\"number\">0</span>) &#123;                                                     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// eldest 最先添加的，newest 最新添加的</span></span><br><span class=\"line\">    State eldestObserverState = mObserverMap.eldest().getValue().mState;                </span><br><span class=\"line\">    State newestObserverState = mObserverMap.newest().getValue().mState;</span><br><span class=\"line\">    <span class=\"comment\">// 判断状态是否一致</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>sync()</code> 同步状态，这里分为两种情况，一种是需要回退状态（backward），另外一种则是需要前进（forward），其中 <code>backward</code> 代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">backwardPass</span><span class=\"params\">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 eldest(start) 判断是否需要回退 </span></span><br><span class=\"line\">    <span class=\"comment\">// 降序迭代，end -&gt; start</span></span><br><span class=\"line\">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =         </span><br><span class=\"line\">            mObserverMap.descendingIterator();                                         </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mNewEventOccurred 判断是否有新事件分发</span></span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next(); </span><br><span class=\"line\">        ObserverWithState observer = entry.getValue();                                 </span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((observer.mState.compareTo(mState) &gt; <span class=\"number\">0</span> &amp;&amp; !mNewEventOccurred            </span><br><span class=\"line\">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回退</span></span><br><span class=\"line\">            <span class=\"comment\">// 举个例子：observer.state 为 RESUMED</span></span><br><span class=\"line\">            <span class=\"comment\">// mState 为 CREATED</span></span><br><span class=\"line\">            <span class=\"comment\">// downEvent(observer.state) 为 ON_PAUSE</span></span><br><span class=\"line\">            Event event = downEvent(observer.mState);</span><br><span class=\"line\">            <span class=\"comment\">// getStateAfter(event) 为 STARTED</span></span><br><span class=\"line\">            <span class=\"comment\">// 最终：RESUMED -&gt; STARTED，在下一次同步中再同步为 CREATED</span></span><br><span class=\"line\">            <span class=\"comment\">// pushParentState 和 popParentState 则是将 state 暂存在 List 中，这个作用我们会在 addObserver 中讲</span></span><br><span class=\"line\">            pushParentState(getStateAfter(event));</span><br><span class=\"line\">            <span class=\"comment\">// 分发事件</span></span><br><span class=\"line\">            observer.dispatchEvent(lifecycleOwner, event);                             </span><br><span class=\"line\">            popParentState();                                                          </span><br><span class=\"line\">        &#125;                                                                              </span><br><span class=\"line\">    &#125;                                                                                  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Event <span class=\"title\">downEvent</span><span class=\"params\">(State state)</span> </span>&#123;                             </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (state) &#123;                                                      </span><br><span class=\"line\">        <span class=\"keyword\">case</span> INITIALIZED:                                                 </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();                         </span><br><span class=\"line\">        <span class=\"keyword\">case</span> CREATED:                                                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_DESTROY;                                            </span><br><span class=\"line\">        <span class=\"keyword\">case</span> STARTED:                                                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_STOP;                                               </span><br><span class=\"line\">        <span class=\"keyword\">case</span> RESUMED:                                                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_PAUSE;                                              </span><br><span class=\"line\">        <span class=\"keyword\">case</span> DESTROYED:                                                   </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();                         </span><br><span class=\"line\">    &#125;                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unexpected state value \"</span> + state);</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> State <span class=\"title\">getStateAfter</span><span class=\"params\">(Event event)</span> </span>&#123;                                   </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (event) &#123;                                                        </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_CREATE:                                                     </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_STOP:                                                       </span><br><span class=\"line\">            <span class=\"keyword\">return</span> CREATED;                                                 </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_START:                                                      </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_PAUSE:                                                      </span><br><span class=\"line\">            <span class=\"keyword\">return</span> STARTED;                                                 </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_RESUME:                                                     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> RESUMED;                                                 </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_DESTROY:                                                    </span><br><span class=\"line\">            <span class=\"keyword\">return</span> DESTROYED;                                               </span><br><span class=\"line\">        <span class=\"keyword\">case</span> ON_ANY:                                                        </span><br><span class=\"line\">            <span class=\"keyword\">break</span>;                                                          </span><br><span class=\"line\">    &#125;                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unexpected event value \"</span> + event);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ObserverWithState.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchEvent</span><span class=\"params\">(LifecycleOwner owner, Event event)</span> </span>&#123; </span><br><span class=\"line\">    State newState = getStateAfter(event);</span><br><span class=\"line\">    <span class=\"comment\">// 使用较小的状态同步</span></span><br><span class=\"line\">    mState = min(mState, newState);                     </span><br><span class=\"line\">    mLifecycleObserver.onStateChanged(owner, event);    </span><br><span class=\"line\">    mState = newState;                                  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结下 <code>backwardPass()</code> 的逻辑：将较大的状态逐步回退。为什么说是逐步呢？比如 <code>observer.state</code> 是 <code>RESUMED</code>，当前状态是 <code>CREATED</code>，那这里会分两次回退，分别为：<code>RESUMED -&gt; STARTED</code> 和 <code>STARTED -&gt; CREATED</code></p>\n<p><code>forwardPass()</code> 逻辑类似，则不分析了。</p>\n<h5 id=\"addObserver\"><a href=\"#addObserver\" class=\"headerlink\" title=\"addObserver\"></a>addObserver</h5><p><code>addObserver()</code> 是添加 <code>Observer</code> 的方法，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                 </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不是 DESTROYED，则从 INITIALIZED 开始分发</span></span><br><span class=\"line\">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class=\"line\">    <span class=\"comment\">// ObserverWithState 用于分发事件给 observer</span></span><br><span class=\"line\">    ObserverWithState statefulObserver = <span class=\"keyword\">new</span> ObserverWithState(observer, initialState);   </span><br><span class=\"line\">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);    </span><br><span class=\"line\">                                                                                          </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 唯一性</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                           </span><br><span class=\"line\">    &#125;                                                                                     </span><br><span class=\"line\">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// mLifecycleOwner 为弱引用</span></span><br><span class=\"line\">        <span class=\"comment\">// it is null we should be destroyed. Fallback quickly                            </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                           </span><br><span class=\"line\">    &#125;                                                                                     </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// isReentrance 表示是否在分发事件时新添加了 observer</span></span><br><span class=\"line\">    <span class=\"comment\">// 举个例子：在 observer 在 onStart() 中又调用了 addObserver()</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isReentrance = mAddingObserverCounter != <span class=\"number\">0</span> || mHandlingEvent; </span><br><span class=\"line\">    <span class=\"comment\">// 计算需要分发的状态</span></span><br><span class=\"line\">    State targetState = calculateTargetState(observer);                                   </span><br><span class=\"line\">    mAddingObserverCounter++; </span><br><span class=\"line\">    <span class=\"comment\">// 将事件逐步分发到 targetState</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class=\"number\">0</span>                            </span><br><span class=\"line\">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 statefulObserver.state 小于 targetState</span></span><br><span class=\"line\">        pushParentState(statefulObserver.mState);</span><br><span class=\"line\">        <span class=\"comment\">// 如果 state 为 STARTED，则 upEvent(state) 则为 ON_RESUME</span></span><br><span class=\"line\">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); </span><br><span class=\"line\">        popParentState();                                                                 </span><br><span class=\"line\">        <span class=\"comment\">// mState / subling may have been changed recalculate                             </span></span><br><span class=\"line\">        targetState = calculateTargetState(observer);                                     </span><br><span class=\"line\">    &#125;                                                                                     </span><br><span class=\"line\">                                                                                          </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isReentrance) &#123;                                                                  </span><br><span class=\"line\">        <span class=\"comment\">// we do sync only on the top level.</span></span><br><span class=\"line\">        <span class=\"comment\">// 当前为重入，则不进行同步</span></span><br><span class=\"line\">        sync();                                                                           </span><br><span class=\"line\">    &#125;                                                                                     </span><br><span class=\"line\">    mAddingObserverCounter--;                                                             </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Event <span class=\"title\">upEvent</span><span class=\"params\">(State state)</span> </span>&#123;                                  </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (state) &#123;                                                         </span><br><span class=\"line\">        <span class=\"keyword\">case</span> INITIALIZED:                                                    </span><br><span class=\"line\">        <span class=\"keyword\">case</span> DESTROYED:                                                      </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_CREATE;                                                </span><br><span class=\"line\">        <span class=\"keyword\">case</span> CREATED:                                                        </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_START;                                                 </span><br><span class=\"line\">        <span class=\"keyword\">case</span> STARTED:                                                        </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ON_RESUME;                                                </span><br><span class=\"line\">        <span class=\"keyword\">case</span> RESUMED:                                                        </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();                            </span><br><span class=\"line\">    &#125;                                                                        </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unexpected state value \"</span> + state);   </span><br><span class=\"line\">&#125;                                                                            </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> State <span class=\"title\">calculateTargetState</span><span class=\"params\">(LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取上一个添加的 observer</span></span><br><span class=\"line\">    Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);       </span><br><span class=\"line\">\t</span><br><span class=\"line\">    State siblingState = previous != <span class=\"keyword\">null</span> ? previous.getValue().mState : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// mParentStates 是个 List，它的添加和删除分别由 pushParentState() 和 popParentState()，它们是成对出现的，在 dispatchEvent 的前后</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这种 case 下，会存在 parentState：在 dispatchEvent 时，又调用了 addObserver()，即上面说的 isReentrance</span></span><br><span class=\"line\">    State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class=\"number\">1</span>)</span><br><span class=\"line\">            : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的计算是获取更合适的状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 考虑以下这种 case：某个 observer 在 onStart() 中再调用 addObserver，那这个 observer 理应使用 STARTED 状态分发，而当前状态即 mState 可能是 RESUMED，再在 sync() 中进行同步</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(min(mState, siblingState), parentState);                                       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>addObserver()</code> 主要考虑了 Reentrance 的情况，即在 <code>observer</code> 的事件分发中，又添加了新的 <code>observer</code> 的情况。</p>\n<h4 id=\"ProcessLifecycleOwner\"><a href=\"#ProcessLifecycleOwner\" class=\"headerlink\" title=\"ProcessLifecycleOwner\"></a>ProcessLifecycleOwner</h4><p><code>ProcessLifecycleOwner</code> 提供应用进程的生命周期。跟 <code>Activity</code> 和 <code>Fragment</code> 的生命周期不一样的是：</p>\n<ul>\n<li><code>ON_CREATE</code> 只会分发一次</li>\n<li><code>ON_DESTROY</code> 则不会被分发</li>\n<li><code>ON_START</code> 和 <code>ON_RESUME</code> 在第一个 <code>Activity</code> 的时候分发</li>\n<li><code>ON_PAUSE</code> 和 <code>ON_STOP</code> 则在最后一个 <code>Activity</code> 的时候<strong>延迟</strong>分发，用于防止因为配置改变，而导致 <code>Activity</code> 重建</li>\n</ul>\n<p>下面我们来分析下 <code>ProcessLifecycleOwner</code> 的源码，首先看下 <code>init()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单例</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProcessLifecycleOwner sInstance = <span class=\"keyword\">new</span> ProcessLifecycleOwner();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 attach</span></span><br><span class=\"line\">    sInstance.attach(context);      </span><br><span class=\"line\">&#125;                                   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context)</span> </span>&#123;                                                          </span><br><span class=\"line\">    mHandler = <span class=\"keyword\">new</span> Handler();</span><br><span class=\"line\">    <span class=\"comment\">// 同样是使用 LifecycleRegistry 来处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 先分发 ON_CREATE，而且只会分发一次</span></span><br><span class=\"line\">    mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);                          </span><br><span class=\"line\">    Application app = (Application) context.getApplicationContext();</span><br><span class=\"line\">    app.registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> EmptyActivityLifecycleCallbacks() &#123;      </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;   </span><br><span class=\"line\">            ReportFragment.get(activity).setProcessListener(mInitializationListener);   </span><br><span class=\"line\">        &#125;                                                                               </span><br><span class=\"line\">                                                                                        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>&#123;                               </span><br><span class=\"line\">            activityPaused();                                                           </span><br><span class=\"line\">        &#125;                                                                               </span><br><span class=\"line\">                                                                                        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123;                              </span><br><span class=\"line\">            activityStopped();                                                          </span><br><span class=\"line\">        &#125;                                                                               </span><br><span class=\"line\">    &#125;);                                                                                 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ActivityInitializationListener mInitializationListener =      </span><br><span class=\"line\">        <span class=\"keyword\">new</span> ActivityInitializationListener() &#123;                </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                         </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;                          </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                         </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;                           </span><br><span class=\"line\">                activityStarted();                            </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">            <span class=\"meta\">@Override</span>                                         </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;                          </span><br><span class=\"line\">                activityResumed();                            </span><br><span class=\"line\">            &#125;                                                 </span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">      </span><br><span class=\"line\">                                                 </span><br><span class=\"line\"><span class=\"comment\">// ground truth counters                         </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mStartedCounter = <span class=\"number\">0</span>;                 </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mResumedCounter = <span class=\"number\">0</span>;                 </span><br><span class=\"line\">                                                 </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mPauseSent = <span class=\"keyword\">true</span>;               </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mStopSent = <span class=\"keyword\">true</span>;                </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityStarted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    mStartedCounter++;                                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartedCounter == <span class=\"number\">1</span> &amp;&amp; mStopSent) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一次调用，分发 ON_START</span></span><br><span class=\"line\">        <span class=\"comment\">// mStopSent 为 true 的情况：</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 默认为 true</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. dispatchStopIfNeeded 中设置</span></span><br><span class=\"line\">        <span class=\"comment\">// 防止因为配置改变，Activity 创建而导致重新分发</span></span><br><span class=\"line\">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); </span><br><span class=\"line\">        mStopSent = <span class=\"keyword\">false</span>;                                        </span><br><span class=\"line\">    &#125;                                                             </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityResumed</span><span class=\"params\">()</span> </span>&#123;                                               </span><br><span class=\"line\">     mResumedCounter++;                                                 </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">1</span>) &#123;                                        </span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mPauseSent) &#123;</span><br><span class=\"line\">             <span class=\"comment\">// 第一次调用分发 ON_RESUME</span></span><br><span class=\"line\">             mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); </span><br><span class=\"line\">             mPauseSent = <span class=\"keyword\">false</span>;                                        </span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">             <span class=\"comment\">// 配置改变，Activity 创建，删除延迟的 pause runnable</span></span><br><span class=\"line\">             mHandler.removeCallbacks(mDelayedPauseRunnable);           </span><br><span class=\"line\">         &#125;                                                              </span><br><span class=\"line\">     &#125;                                                                  </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>上面是初始事件分发流程，下面我们来看下 <code>ON_PAUSE</code> 和 <code>ON_STOP</code> 的分发：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@VisibleForTesting</span>                               </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> TIMEOUT_MS = <span class=\"number\">700</span>; <span class=\"comment\">//mls </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 onActivityPaused 中调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityPaused</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    mResumedCounter--;                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 延迟分发</span></span><br><span class=\"line\">        mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);    </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">private</span> Runnable mDelayedPauseRunnable = <span class=\"keyword\">new</span> Runnable() &#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                             </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">// 延迟分发</span></span><br><span class=\"line\">        dispatchPauseIfNeeded();                          </span><br><span class=\"line\">        dispatchStopIfNeeded();                           </span><br><span class=\"line\">    &#125;                                                     </span><br><span class=\"line\">&#125;;                                                        </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityStopped</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    mStartedCounter--;                                              </span><br><span class=\"line\">    dispatchStopIfNeeded();                                         </span><br><span class=\"line\">&#125;                                                                   </span><br><span class=\"line\">                                                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchPauseIfNeeded</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计数</span></span><br><span class=\"line\">        mPauseSent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 分发 ON_PAUSE</span></span><br><span class=\"line\">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);   </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;                                                                   </span><br><span class=\"line\">                                                                    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchStopIfNeeded</span><span class=\"params\">()</span> </span>&#123;                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStartedCounter == <span class=\"number\">0</span> &amp;&amp; mPauseSent) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计数为 0，同时已经分发了 ON_PAUSE</span></span><br><span class=\"line\">        <span class=\"comment\">// 分发 ON_STOP</span></span><br><span class=\"line\">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);    </span><br><span class=\"line\">        mStopSent = <span class=\"keyword\">true</span>;                                           </span><br><span class=\"line\">    &#125;                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经将 <code>ProcessLifecycleOwner</code> 的流程分析完了，那 <code>ProcessLifecycleOwner.init()</code> 是在那里调用的呢？</p>\n<p>其实是用了一种比较巧妙的方法，在 <code>lifecycle-process</code> 这个包下的 <code>AndroidManifest.xml</code> 文件中，可以看到有如下配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">application</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">provider</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">\"androidx.lifecycle.ProcessLifecycleOwnerInitializer\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:authorities</span>=<span class=\"string\">\"$&#123;applicationId&#125;.lifecycle-process\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:exported</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:multiprocess</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其中 <code>ProcessLifecycleOwnerInitializer</code> 是一个 <code>ContentProvider</code> 即利用 <code>ContentProvider</code> 来实现自动初始化</p>\n<blockquote>\n<p>ContentProvider 的 <code>onCreate</code> 方法会在应用启动时候调用</p>\n<p>Implement this to initialize your content provider on startup. This method is called for all registered content providers on the application main thread at application launch time. It must not perform lengthy operations, or application startup will be delayed.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                     </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;                   </span><br><span class=\"line\">    LifecycleDispatcher.init(getContext());   </span><br><span class=\"line\">    ProcessLifecycleOwner.init(getContext()); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                              </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里调用了两个初始化方法，其中 <code>ProcessLifecycleOwner.init()</code> 我们已经分析了，再看看 <code>LifecycleDispatcher.init()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;                                                 </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sInitialized.getAndSet(<span class=\"keyword\">true</span>)) &#123;                                             </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                     </span><br><span class=\"line\">    &#125;                                                                               </span><br><span class=\"line\">    ((Application) context.getApplicationContext())                                 </span><br><span class=\"line\">            .registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> DispatcherActivityCallback());  </span><br><span class=\"line\">&#125;                                                                                   </span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"WeakerAccess\"</span>)                                                   </span><br><span class=\"line\"><span class=\"meta\">@VisibleForTesting</span>                                                                  </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherActivityCallback</span> <span class=\"keyword\">extends</span> <span class=\"title\">EmptyActivityLifecycleCallbacks</span> </span>&#123;   </span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;   </span><br><span class=\"line\">        ReportFragment.injectIfNeededIn(activity);                                  </span><br><span class=\"line\">    &#125;                                                                               </span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123;                              </span><br><span class=\"line\">    &#125;                                                                               </span><br><span class=\"line\">                                                                                    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                                       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span> </span>&#123;   </span><br><span class=\"line\">    &#125;                                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化的逻辑比较简单，即在 <code>Activity</code> 创建时，调用 <code>ReportFragment.injectIfneededIn()</code> ，其实我们在 <code>Activity</code> 的 <code>Lifecycle</code> 处理中，也见到这个方法： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ComponentActivity.java</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                        </span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"RestrictedApi\"</span>)                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);                          </span><br><span class=\"line\">    ReportFragment.injectIfNeededIn(<span class=\"keyword\">this</span>);                       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReportFragment.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">injectIfNeededIn</span><span class=\"params\">(Activity activity)</span> </span>&#123;                                      </span><br><span class=\"line\">    <span class=\"comment\">// ProcessLifecycleOwner should always correctly work and some activities may not extend  </span></span><br><span class=\"line\">    <span class=\"comment\">// FragmentActivity from support lib, so we use framework fragments for activities        </span></span><br><span class=\"line\">    android.app.FragmentManager manager = activity.getFragmentManager();                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 重复添加判断</span></span><br><span class=\"line\">        manager.beginTransaction().add(<span class=\"keyword\">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();   </span><br><span class=\"line\">        <span class=\"comment\">// Hopefully, we are the first to make a transaction.                                 </span></span><br><span class=\"line\">        manager.executePendingTransactions();                                                 </span><br><span class=\"line\">    &#125;                                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里可以理解为双重保障吧，可能存在不继承 <code>ComponentActivity</code> 的 <code>Activity</code>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>分析了 <code>Lifecycle</code>  的整个流程，可以发现其实逻辑还是比较简单的，实现上也是参考了其他开源库的做法，比如 <code>ReportFragment</code> 通过添加一个透明的 <code>Fragment</code> 去感知 <code>Activity</code> 的生命周期，<code>Glide</code> 也是这么做的。还有使用 <code>ContentProvider</code> 去实现在 <code>Application</code> 创建时自动初始化，也是一个不错的想法。</p>\n<p><code>Lifecycle</code> 的源码比我一开始想象的复杂，不是在于它的逻辑，而是在 <code>sync()</code> 这一块，通过 <code>Listener</code> 执行状态回调是一个非常常见的做法，但是有很多需要考虑的 case，举个例子，在分发回调时，有新的状态发生，那么应该怎么去处理。或者，在回调方法中，又添加了新的 <code>Listener</code>，那应该怎么处理。</p>\n<p>学习源码，不仅仅是学习实现原理，还可以学习一个健壮的库是如何处理各种场景下的 case 的。</p>\n"},{"title":"SparseArray源码解析","date":"2019-01-08T13:58:23.000Z","_content":"\n### 关于SparseArray\n\n`SparseArray` 是 Android SDK 提供的将 integers 映射到对象的容器。相对于 `HashMap` 更节省内存，因为它避免了 key 发生自动装箱，同时不用额外的对象来表示映射关系。\n\n`SparseArray` 使用二分查找来查询 key，这意味着，key 是有序存储的，而且不适用于大量数据的情况。通常情况下，它的查找比 `HashMap` 慢。\n\n为了提高性能，`SparseArray` 在删除 key 时，不会立即调整数据结构，而是将该条目标记为删除，在之后使用相同 key 时可以复用或者垃圾回收操作中进行调整。\n\n> 垃圾回收操作会发生在需要扩容、获取size 或者检索条目值时\n\n### 源码分析\n\n#### 构造函数\n\n`SparseArray` 有两个构造函数\n\n``` java\nprivate int[] mKeys;\nprivate Object[] mValues;\npublic SparseArray() {                                                  \n    this(10);                                                           \n}                                                                       \n                                                                                                                                            \npublic SparseArray(int initialCapacity) {                               \n    if (initialCapacity == 0) {                                         \n        mKeys = EmptyArray.INT;                                         \n        mValues = EmptyArray.OBJECT;                                    \n    } else {                                                            \n        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);   \n        mKeys = new int[mValues.length];                                \n    }                                                                   \n    mSize = 0;                                                          \n}                                                                       \n```\n\n如果使用不指定初始化容量，将使用默认 10，可以看到，`SparseArray` 内部使用两个数组来分别存储 key 和 value\n\n#### put\n\n如果 key 没有存在，则添加，否则进行替换操作\n\n``` java\npublic void put(int key, E value) {                                           \n    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);                 \n                                                                              \n    if (i >= 0) { \n        // key 已经存在，替换\n        mValues[i] = value;                                                   \n    } else {\n        // key 不存在，取反获取 key 应该插入的下标\n        i = ~i;                                                               \n                                                                              \n        if (i < mSize && mValues[i] == DELETED) {\n            // 复用被标记为 DELETED 的条目\n            mKeys[i] = key;                                                   \n            mValues[i] = value;                                               \n            return;                                                           \n        }                                                                     \n                                                                              \n        if (mGarbage && mSize >= mKeys.length) { \n            // 需要扩容\n            gc();                                                             \n                                                                              \n            // Search again because indices may have changed.                 \n            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);            \n        }                                                                     \n        \n        // 插入新的条目\n        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);               \n        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);         \n        mSize++;                                                              \n    }                                                                         \n}\n\nstatic int binarySearch(int[] array, int size, int value) {       \n    int lo = 0;                                                   \n    int hi = size - 1;                                            \n                                                                  \n    while (lo <= hi) {                                            \n        final int mid = (lo + hi) >>> 1;                          \n        final int midVal = array[mid];                            \n                                                                  \n        if (midVal < value) {                                     \n            lo = mid + 1;                                         \n        } else if (midVal > value) {                              \n            hi = mid - 1;                                         \n        } else {                                                  \n            return mid;  // value found                           \n        }                                                         \n    }                                                             \n    return ~lo;  // value not present                             \n}                                                                 \n```\n\n`binarySearch` 就是二分查找算法的实现 ，需要注意的是，如果没有查找到，则返回 `~lo`\n\n> 这里的 `lo` 可以认为是，虽然没有查找到指定的值，但这是最接近的，换句话说，这个是指定值应该插入的位置\n>\n> 比如：在 1,2,3,4,6,7 查找 5，那么 `binarySearch` 将返回 `~4`\n\n#### get\n\nget 操作比较简单，同样的先二分查找 key，存在则返回，否则返回默认值\n\n``` java\npublic E get(int key, E valueIfKeyNotFound) {                 \n    int i = ContainerHelpers.binarySearch(mKeys, mSize, key); \n                                                              \n    if (i < 0 || mValues[i] == DELETED) {                     \n        return valueIfKeyNotFound;                            \n    } else {                                                  \n        return (E) mValues[i];                                \n    }                                                         \n}                                                             \n```\n\n#### remove\n\nremove 操作实际调用 `delete` 方法\n\n``` java\npublic void delete(int key) {                                   \n    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);   \n                                                                \n    if (i >= 0) {                                               \n        if (mValues[i] != DELETED) {\n            // 只是标记为 DELETED\n            mValues[i] = DELETED;\n            // 需要回收\n            mGarbage = true;                                    \n        }                                                       \n    }                                                           \n}                                                               \n```\n\n#### size\n\n调用 `size` 之后，会先检查是否需要 `gc` 即回收操作\n\n``` java\npublic int size() {   \n    if (mGarbage) {   \n        gc();         \n    }                 \n                      \n    return mSize;     \n}                     \n```\n\n#### gc\n\n在调用 `size` 和涉及 index 相关的方法时，都会检查是否需要 `gc`，比如 `keyAt` 等\n\n``` java\nprivate void gc() {                                          \n    // Log.e(\"SparseArray\", \"gc start with \" + mSize);       \n                                                             \n    int n = mSize;                                           \n    int o = 0;                                               \n    int[] keys = mKeys;                                      \n    Object[] values = mValues;                               \n                                                             \n    for (int i = 0; i < n; i++) {\n        // 将没有标记为 DELETED 的条目移到新位置，清除 DELETED\n        Object val = values[i];                              \n                                                             \n        if (val != DELETED) {                                \n            if (i != o) {\n                keys[o] = keys[i];                           \n                values[o] = val;                             \n                values[i] = null;                            \n            }                                                \n                                                             \n            o++;                                             \n        }                                                    \n    }                                                        \n                                                             \n    mGarbage = false;                                        \n    mSize = o;                                               \n                                                             \n    // Log.e(\"SparseArray\", \"gc end with \" + mSize);         \n}                                                            \n```\n\n### 总结\n\n`SparseArray` 是用两个数组来分别存储 key 和 value，其中 key 是 `int[]` 避免了自动装箱，同时是升序的，所以查找 key 可以使用二分查找，相对于 `HashMap` 更省内存，但检索速度更慢。在数据量较少的情况下，可以使用 `SparseArray` 代替 `HashMap`\n\n","source":"_posts/SparseArray源码解析.md","raw":"---\ntitle: SparseArray源码解析\ndate: 2019-01-08 21:58:23\ncategories: Android Application\ntags:\n---\n\n### 关于SparseArray\n\n`SparseArray` 是 Android SDK 提供的将 integers 映射到对象的容器。相对于 `HashMap` 更节省内存，因为它避免了 key 发生自动装箱，同时不用额外的对象来表示映射关系。\n\n`SparseArray` 使用二分查找来查询 key，这意味着，key 是有序存储的，而且不适用于大量数据的情况。通常情况下，它的查找比 `HashMap` 慢。\n\n为了提高性能，`SparseArray` 在删除 key 时，不会立即调整数据结构，而是将该条目标记为删除，在之后使用相同 key 时可以复用或者垃圾回收操作中进行调整。\n\n> 垃圾回收操作会发生在需要扩容、获取size 或者检索条目值时\n\n### 源码分析\n\n#### 构造函数\n\n`SparseArray` 有两个构造函数\n\n``` java\nprivate int[] mKeys;\nprivate Object[] mValues;\npublic SparseArray() {                                                  \n    this(10);                                                           \n}                                                                       \n                                                                                                                                            \npublic SparseArray(int initialCapacity) {                               \n    if (initialCapacity == 0) {                                         \n        mKeys = EmptyArray.INT;                                         \n        mValues = EmptyArray.OBJECT;                                    \n    } else {                                                            \n        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);   \n        mKeys = new int[mValues.length];                                \n    }                                                                   \n    mSize = 0;                                                          \n}                                                                       \n```\n\n如果使用不指定初始化容量，将使用默认 10，可以看到，`SparseArray` 内部使用两个数组来分别存储 key 和 value\n\n#### put\n\n如果 key 没有存在，则添加，否则进行替换操作\n\n``` java\npublic void put(int key, E value) {                                           \n    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);                 \n                                                                              \n    if (i >= 0) { \n        // key 已经存在，替换\n        mValues[i] = value;                                                   \n    } else {\n        // key 不存在，取反获取 key 应该插入的下标\n        i = ~i;                                                               \n                                                                              \n        if (i < mSize && mValues[i] == DELETED) {\n            // 复用被标记为 DELETED 的条目\n            mKeys[i] = key;                                                   \n            mValues[i] = value;                                               \n            return;                                                           \n        }                                                                     \n                                                                              \n        if (mGarbage && mSize >= mKeys.length) { \n            // 需要扩容\n            gc();                                                             \n                                                                              \n            // Search again because indices may have changed.                 \n            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);            \n        }                                                                     \n        \n        // 插入新的条目\n        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);               \n        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);         \n        mSize++;                                                              \n    }                                                                         \n}\n\nstatic int binarySearch(int[] array, int size, int value) {       \n    int lo = 0;                                                   \n    int hi = size - 1;                                            \n                                                                  \n    while (lo <= hi) {                                            \n        final int mid = (lo + hi) >>> 1;                          \n        final int midVal = array[mid];                            \n                                                                  \n        if (midVal < value) {                                     \n            lo = mid + 1;                                         \n        } else if (midVal > value) {                              \n            hi = mid - 1;                                         \n        } else {                                                  \n            return mid;  // value found                           \n        }                                                         \n    }                                                             \n    return ~lo;  // value not present                             \n}                                                                 \n```\n\n`binarySearch` 就是二分查找算法的实现 ，需要注意的是，如果没有查找到，则返回 `~lo`\n\n> 这里的 `lo` 可以认为是，虽然没有查找到指定的值，但这是最接近的，换句话说，这个是指定值应该插入的位置\n>\n> 比如：在 1,2,3,4,6,7 查找 5，那么 `binarySearch` 将返回 `~4`\n\n#### get\n\nget 操作比较简单，同样的先二分查找 key，存在则返回，否则返回默认值\n\n``` java\npublic E get(int key, E valueIfKeyNotFound) {                 \n    int i = ContainerHelpers.binarySearch(mKeys, mSize, key); \n                                                              \n    if (i < 0 || mValues[i] == DELETED) {                     \n        return valueIfKeyNotFound;                            \n    } else {                                                  \n        return (E) mValues[i];                                \n    }                                                         \n}                                                             \n```\n\n#### remove\n\nremove 操作实际调用 `delete` 方法\n\n``` java\npublic void delete(int key) {                                   \n    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);   \n                                                                \n    if (i >= 0) {                                               \n        if (mValues[i] != DELETED) {\n            // 只是标记为 DELETED\n            mValues[i] = DELETED;\n            // 需要回收\n            mGarbage = true;                                    \n        }                                                       \n    }                                                           \n}                                                               \n```\n\n#### size\n\n调用 `size` 之后，会先检查是否需要 `gc` 即回收操作\n\n``` java\npublic int size() {   \n    if (mGarbage) {   \n        gc();         \n    }                 \n                      \n    return mSize;     \n}                     \n```\n\n#### gc\n\n在调用 `size` 和涉及 index 相关的方法时，都会检查是否需要 `gc`，比如 `keyAt` 等\n\n``` java\nprivate void gc() {                                          \n    // Log.e(\"SparseArray\", \"gc start with \" + mSize);       \n                                                             \n    int n = mSize;                                           \n    int o = 0;                                               \n    int[] keys = mKeys;                                      \n    Object[] values = mValues;                               \n                                                             \n    for (int i = 0; i < n; i++) {\n        // 将没有标记为 DELETED 的条目移到新位置，清除 DELETED\n        Object val = values[i];                              \n                                                             \n        if (val != DELETED) {                                \n            if (i != o) {\n                keys[o] = keys[i];                           \n                values[o] = val;                             \n                values[i] = null;                            \n            }                                                \n                                                             \n            o++;                                             \n        }                                                    \n    }                                                        \n                                                             \n    mGarbage = false;                                        \n    mSize = o;                                               \n                                                             \n    // Log.e(\"SparseArray\", \"gc end with \" + mSize);         \n}                                                            \n```\n\n### 总结\n\n`SparseArray` 是用两个数组来分别存储 key 和 value，其中 key 是 `int[]` 避免了自动装箱，同时是升序的，所以查找 key 可以使用二分查找，相对于 `HashMap` 更省内存，但检索速度更慢。在数据量较少的情况下，可以使用 `SparseArray` 代替 `HashMap`\n\n","slug":"SparseArray源码解析","published":1,"updated":"2019-01-08T15:03:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs18000we39k0nf0myaa","content":"<h3 id=\"关于SparseArray\"><a href=\"#关于SparseArray\" class=\"headerlink\" title=\"关于SparseArray\"></a>关于SparseArray</h3><p><code>SparseArray</code> 是 Android SDK 提供的将 integers 映射到对象的容器。相对于 <code>HashMap</code> 更节省内存，因为它避免了 key 发生自动装箱，同时不用额外的对象来表示映射关系。</p>\n<p><code>SparseArray</code> 使用二分查找来查询 key，这意味着，key 是有序存储的，而且不适用于大量数据的情况。通常情况下，它的查找比 <code>HashMap</code> 慢。</p>\n<p>为了提高性能，<code>SparseArray</code> 在删除 key 时，不会立即调整数据结构，而是将该条目标记为删除，在之后使用相同 key 时可以复用或者垃圾回收操作中进行调整。</p>\n<blockquote>\n<p>垃圾回收操作会发生在需要扩容、获取size 或者检索条目值时</p>\n</blockquote>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p><code>SparseArray</code> 有两个构造函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] mKeys;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Object[] mValues;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SparseArray</span><span class=\"params\">()</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);                                                           </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                                                                                            </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SparseArray</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;                                         </span><br><span class=\"line\">        mKeys = EmptyArray.INT;                                         </span><br><span class=\"line\">        mValues = EmptyArray.OBJECT;                                    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                            </span><br><span class=\"line\">        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);   </span><br><span class=\"line\">        mKeys = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[mValues.length];                                </span><br><span class=\"line\">    &#125;                                                                   </span><br><span class=\"line\">    mSize = <span class=\"number\">0</span>;                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果使用不指定初始化容量，将使用默认 10，可以看到，<code>SparseArray</code> 内部使用两个数组来分别存储 key 和 value</p>\n<h4 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h4><p>如果 key 没有存在，则添加，否则进行替换操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, E value)</span> </span>&#123;                                           </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);                 </span><br><span class=\"line\">                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// key 已经存在，替换</span></span><br><span class=\"line\">        mValues[i] = value;                                                   </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// key 不存在，取反获取 key 应该插入的下标</span></span><br><span class=\"line\">        i = ~i;                                                               </span><br><span class=\"line\">                                                                              </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 复用被标记为 DELETED 的条目</span></span><br><span class=\"line\">            mKeys[i] = key;                                                   </span><br><span class=\"line\">            mValues[i] = value;                                               </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                           </span><br><span class=\"line\">        &#125;                                                                     </span><br><span class=\"line\">                                                                              </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 需要扩容</span></span><br><span class=\"line\">            gc();                                                             </span><br><span class=\"line\">                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// Search again because indices may have changed.                 </span></span><br><span class=\"line\">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);            </span><br><span class=\"line\">        &#125;                                                                     </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 插入新的条目</span></span><br><span class=\"line\">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);               </span><br><span class=\"line\">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);         </span><br><span class=\"line\">        mSize++;                                                              </span><br><span class=\"line\">    &#125;                                                                         </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> value)</span> </span>&#123;       </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>;                                                   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> hi = size - <span class=\"number\">1</span>;                                            </span><br><span class=\"line\">                                                                  </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (lo &lt;= hi) &#123;                                            </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class=\"number\">1</span>;                          </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> midVal = array[mid];                            </span><br><span class=\"line\">                                                                  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (midVal &lt; value) &#123;                                     </span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span>;                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (midVal &gt; value) &#123;                              </span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span>;                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;  <span class=\"comment\">// value found                           </span></span><br><span class=\"line\">        &#125;                                                         </span><br><span class=\"line\">    &#125;                                                             </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ~lo;  <span class=\"comment\">// value not present                             </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>binarySearch</code> 就是二分查找算法的实现 ，需要注意的是，如果没有查找到，则返回 <code>~lo</code></p>\n<blockquote>\n<p>这里的 <code>lo</code> 可以认为是，虽然没有查找到指定的值，但这是最接近的，换句话说，这个是指定值应该插入的位置</p>\n<p>比如：在 1,2,3,4,6,7 查找 5，那么 <code>binarySearch</code> 将返回 <code>~4</code></p>\n</blockquote>\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h4><p>get 操作比较简单，同样的先二分查找 key，存在则返回，否则返回默认值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key, E valueIfKeyNotFound)</span> </span>&#123;                 </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key); </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || mValues[i] == DELETED) &#123;                     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> valueIfKeyNotFound;                            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) mValues[i];                                </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h4><p>remove 操作实际调用 <code>delete</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;                                   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);   </span><br><span class=\"line\">                                                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mValues[i] != DELETED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 只是标记为 DELETED</span></span><br><span class=\"line\">            mValues[i] = DELETED;</span><br><span class=\"line\">            <span class=\"comment\">// 需要回收</span></span><br><span class=\"line\">            mGarbage = <span class=\"keyword\">true</span>;                                    </span><br><span class=\"line\">        &#125;                                                       </span><br><span class=\"line\">    &#125;                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size\"></a>size</h4><p>调用 <code>size</code> 之后，会先检查是否需要 <code>gc</code> 即回收操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mGarbage) &#123;   </span><br><span class=\"line\">        gc();         </span><br><span class=\"line\">    &#125;                 </span><br><span class=\"line\">                      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mSize;     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"gc\"><a href=\"#gc\" class=\"headerlink\" title=\"gc\"></a>gc</h4><p>在调用 <code>size</code> 和涉及 index 相关的方法时，都会检查是否需要 <code>gc</code>，比如 <code>keyAt</code> 等</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">gc</span><span class=\"params\">()</span> </span>&#123;                                          </span><br><span class=\"line\">    <span class=\"comment\">// Log.e(\"SparseArray\", \"gc start with \" + mSize);       </span></span><br><span class=\"line\">                                                             </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = mSize;                                           </span><br><span class=\"line\">    <span class=\"keyword\">int</span> o = <span class=\"number\">0</span>;                                               </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] keys = mKeys;                                      </span><br><span class=\"line\">    Object[] values = mValues;                               </span><br><span class=\"line\">                                                             </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将没有标记为 DELETED 的条目移到新位置，清除 DELETED</span></span><br><span class=\"line\">        Object val = values[i];                              </span><br><span class=\"line\">                                                             </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val != DELETED) &#123;                                </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != o) &#123;</span><br><span class=\"line\">                keys[o] = keys[i];                           </span><br><span class=\"line\">                values[o] = val;                             </span><br><span class=\"line\">                values[i] = <span class=\"keyword\">null</span>;                            </span><br><span class=\"line\">            &#125;                                                </span><br><span class=\"line\">                                                             </span><br><span class=\"line\">            o++;                                             </span><br><span class=\"line\">        &#125;                                                    </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">                                                             </span><br><span class=\"line\">    mGarbage = <span class=\"keyword\">false</span>;                                        </span><br><span class=\"line\">    mSize = o;                                               </span><br><span class=\"line\">                                                             </span><br><span class=\"line\">    <span class=\"comment\">// Log.e(\"SparseArray\", \"gc end with \" + mSize);         </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>SparseArray</code> 是用两个数组来分别存储 key 和 value，其中 key 是 <code>int[]</code> 避免了自动装箱，同时是升序的，所以查找 key 可以使用二分查找，相对于 <code>HashMap</code> 更省内存，但检索速度更慢。在数据量较少的情况下，可以使用 <code>SparseArray</code> 代替 <code>HashMap</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"关于SparseArray\"><a href=\"#关于SparseArray\" class=\"headerlink\" title=\"关于SparseArray\"></a>关于SparseArray</h3><p><code>SparseArray</code> 是 Android SDK 提供的将 integers 映射到对象的容器。相对于 <code>HashMap</code> 更节省内存，因为它避免了 key 发生自动装箱，同时不用额外的对象来表示映射关系。</p>\n<p><code>SparseArray</code> 使用二分查找来查询 key，这意味着，key 是有序存储的，而且不适用于大量数据的情况。通常情况下，它的查找比 <code>HashMap</code> 慢。</p>\n<p>为了提高性能，<code>SparseArray</code> 在删除 key 时，不会立即调整数据结构，而是将该条目标记为删除，在之后使用相同 key 时可以复用或者垃圾回收操作中进行调整。</p>\n<blockquote>\n<p>垃圾回收操作会发生在需要扩容、获取size 或者检索条目值时</p>\n</blockquote>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p><code>SparseArray</code> 有两个构造函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] mKeys;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Object[] mValues;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SparseArray</span><span class=\"params\">()</span> </span>&#123;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);                                                           </span><br><span class=\"line\">&#125;                                                                       </span><br><span class=\"line\">                                                                                                                                            </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SparseArray</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;                                         </span><br><span class=\"line\">        mKeys = EmptyArray.INT;                                         </span><br><span class=\"line\">        mValues = EmptyArray.OBJECT;                                    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                            </span><br><span class=\"line\">        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);   </span><br><span class=\"line\">        mKeys = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[mValues.length];                                </span><br><span class=\"line\">    &#125;                                                                   </span><br><span class=\"line\">    mSize = <span class=\"number\">0</span>;                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果使用不指定初始化容量，将使用默认 10，可以看到，<code>SparseArray</code> 内部使用两个数组来分别存储 key 和 value</p>\n<h4 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h4><p>如果 key 没有存在，则添加，否则进行替换操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, E value)</span> </span>&#123;                                           </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);                 </span><br><span class=\"line\">                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// key 已经存在，替换</span></span><br><span class=\"line\">        mValues[i] = value;                                                   </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// key 不存在，取反获取 key 应该插入的下标</span></span><br><span class=\"line\">        i = ~i;                                                               </span><br><span class=\"line\">                                                                              </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 复用被标记为 DELETED 的条目</span></span><br><span class=\"line\">            mKeys[i] = key;                                                   </span><br><span class=\"line\">            mValues[i] = value;                                               </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;                                                           </span><br><span class=\"line\">        &#125;                                                                     </span><br><span class=\"line\">                                                                              </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 需要扩容</span></span><br><span class=\"line\">            gc();                                                             </span><br><span class=\"line\">                                                                              </span><br><span class=\"line\">            <span class=\"comment\">// Search again because indices may have changed.                 </span></span><br><span class=\"line\">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);            </span><br><span class=\"line\">        &#125;                                                                     </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 插入新的条目</span></span><br><span class=\"line\">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);               </span><br><span class=\"line\">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);         </span><br><span class=\"line\">        mSize++;                                                              </span><br><span class=\"line\">    &#125;                                                                         </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> value)</span> </span>&#123;       </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>;                                                   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> hi = size - <span class=\"number\">1</span>;                                            </span><br><span class=\"line\">                                                                  </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (lo &lt;= hi) &#123;                                            </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class=\"number\">1</span>;                          </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> midVal = array[mid];                            </span><br><span class=\"line\">                                                                  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (midVal &lt; value) &#123;                                     </span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span>;                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (midVal &gt; value) &#123;                              </span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span>;                                         </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;  <span class=\"comment\">// value found                           </span></span><br><span class=\"line\">        &#125;                                                         </span><br><span class=\"line\">    &#125;                                                             </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ~lo;  <span class=\"comment\">// value not present                             </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>binarySearch</code> 就是二分查找算法的实现 ，需要注意的是，如果没有查找到，则返回 <code>~lo</code></p>\n<blockquote>\n<p>这里的 <code>lo</code> 可以认为是，虽然没有查找到指定的值，但这是最接近的，换句话说，这个是指定值应该插入的位置</p>\n<p>比如：在 1,2,3,4,6,7 查找 5，那么 <code>binarySearch</code> 将返回 <code>~4</code></p>\n</blockquote>\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h4><p>get 操作比较简单，同样的先二分查找 key，存在则返回，否则返回默认值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key, E valueIfKeyNotFound)</span> </span>&#123;                 </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key); </span><br><span class=\"line\">                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || mValues[i] == DELETED) &#123;                     </span><br><span class=\"line\">        <span class=\"keyword\">return</span> valueIfKeyNotFound;                            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) mValues[i];                                </span><br><span class=\"line\">    &#125;                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h4><p>remove 操作实际调用 <code>delete</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;                                   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);   </span><br><span class=\"line\">                                                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mValues[i] != DELETED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 只是标记为 DELETED</span></span><br><span class=\"line\">            mValues[i] = DELETED;</span><br><span class=\"line\">            <span class=\"comment\">// 需要回收</span></span><br><span class=\"line\">            mGarbage = <span class=\"keyword\">true</span>;                                    </span><br><span class=\"line\">        &#125;                                                       </span><br><span class=\"line\">    &#125;                                                           </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size\"></a>size</h4><p>调用 <code>size</code> 之后，会先检查是否需要 <code>gc</code> 即回收操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mGarbage) &#123;   </span><br><span class=\"line\">        gc();         </span><br><span class=\"line\">    &#125;                 </span><br><span class=\"line\">                      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mSize;     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"gc\"><a href=\"#gc\" class=\"headerlink\" title=\"gc\"></a>gc</h4><p>在调用 <code>size</code> 和涉及 index 相关的方法时，都会检查是否需要 <code>gc</code>，比如 <code>keyAt</code> 等</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">gc</span><span class=\"params\">()</span> </span>&#123;                                          </span><br><span class=\"line\">    <span class=\"comment\">// Log.e(\"SparseArray\", \"gc start with \" + mSize);       </span></span><br><span class=\"line\">                                                             </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = mSize;                                           </span><br><span class=\"line\">    <span class=\"keyword\">int</span> o = <span class=\"number\">0</span>;                                               </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] keys = mKeys;                                      </span><br><span class=\"line\">    Object[] values = mValues;                               </span><br><span class=\"line\">                                                             </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将没有标记为 DELETED 的条目移到新位置，清除 DELETED</span></span><br><span class=\"line\">        Object val = values[i];                              </span><br><span class=\"line\">                                                             </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val != DELETED) &#123;                                </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != o) &#123;</span><br><span class=\"line\">                keys[o] = keys[i];                           </span><br><span class=\"line\">                values[o] = val;                             </span><br><span class=\"line\">                values[i] = <span class=\"keyword\">null</span>;                            </span><br><span class=\"line\">            &#125;                                                </span><br><span class=\"line\">                                                             </span><br><span class=\"line\">            o++;                                             </span><br><span class=\"line\">        &#125;                                                    </span><br><span class=\"line\">    &#125;                                                        </span><br><span class=\"line\">                                                             </span><br><span class=\"line\">    mGarbage = <span class=\"keyword\">false</span>;                                        </span><br><span class=\"line\">    mSize = o;                                               </span><br><span class=\"line\">                                                             </span><br><span class=\"line\">    <span class=\"comment\">// Log.e(\"SparseArray\", \"gc end with \" + mSize);         </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>SparseArray</code> 是用两个数组来分别存储 key 和 value，其中 key 是 <code>int[]</code> 避免了自动装箱，同时是升序的，所以查找 key 可以使用二分查找，相对于 <code>HashMap</code> 更省内存，但检索速度更慢。在数据量较少的情况下，可以使用 <code>SparseArray</code> 代替 <code>HashMap</code></p>\n"},{"title":"灵活使用位运算符","date":"2018-09-08T07:26:00.000Z","_content":"\n### 复习\n\n#### 移位运算\n\n* \"<<\" 左移：右边空出的位上补 0，相当于乘以 2\n* \">>\" 右移：左边空出的位上，如果正数，则补 0，否则，可能补 0 或者 1，取决于计算机系统。正数情况下，相当于除以 2\n* \">>>\" 无符号右移：左边空出的位上一律补上 0，相当于除以 2\n\n#### 位运算符\n\n* & 与运算符：两个操作数相同位上同时为 1，结果数相同位上才为 1\n* | 或运算符：两个操作数相同位上只要有一个为 1，结果数相同位上就为 1\n* ^ 异或运算符：两个操作数相同位上不相同，结果数相同位上才为 1\n\n### 灵活使用\n\n#### 状态管理\n\n1. 清除特定位（即设置为 0）\n\n   mask 特定位为 0，其他位为 1：s = s & mask\n\n2. 获取指定位\n\n   mask 特定位为 1，其他位为 0：r = s & mask\n\n3. 设置特定位（即设置为 1）\n\n   mask 特定位为 1，其他位为 0：s = s | mask\n\n4. 特定位取反\n\n   mask 特定位置为 1,其他位为 0：s = s ^ mask\n\n#### 交换变量\n\na ^= b;\n\nb ^= a;\n\na ^= b;\n\n#### 判断奇偶\n\na & 1 = 0 偶数\n\na & 1 = 1 奇数\n\n#### 取模\n\na % (2^n) = a & (2^n -1);\n\n2^n - 1 刚好是最高位 1 变成 0，剩下的低位 0 变成 1","source":"_posts/灵活使用位运算符.md","raw":"---\ntitle: 灵活使用位运算符\ndate: 2018-09-08 15:26:00\ncategories: Java\ntags:\n---\n\n### 复习\n\n#### 移位运算\n\n* \"<<\" 左移：右边空出的位上补 0，相当于乘以 2\n* \">>\" 右移：左边空出的位上，如果正数，则补 0，否则，可能补 0 或者 1，取决于计算机系统。正数情况下，相当于除以 2\n* \">>>\" 无符号右移：左边空出的位上一律补上 0，相当于除以 2\n\n#### 位运算符\n\n* & 与运算符：两个操作数相同位上同时为 1，结果数相同位上才为 1\n* | 或运算符：两个操作数相同位上只要有一个为 1，结果数相同位上就为 1\n* ^ 异或运算符：两个操作数相同位上不相同，结果数相同位上才为 1\n\n### 灵活使用\n\n#### 状态管理\n\n1. 清除特定位（即设置为 0）\n\n   mask 特定位为 0，其他位为 1：s = s & mask\n\n2. 获取指定位\n\n   mask 特定位为 1，其他位为 0：r = s & mask\n\n3. 设置特定位（即设置为 1）\n\n   mask 特定位为 1，其他位为 0：s = s | mask\n\n4. 特定位取反\n\n   mask 特定位置为 1,其他位为 0：s = s ^ mask\n\n#### 交换变量\n\na ^= b;\n\nb ^= a;\n\na ^= b;\n\n#### 判断奇偶\n\na & 1 = 0 偶数\n\na & 1 = 1 奇数\n\n#### 取模\n\na % (2^n) = a & (2^n -1);\n\n2^n - 1 刚好是最高位 1 变成 0，剩下的低位 0 变成 1","slug":"灵活使用位运算符","published":1,"updated":"2018-09-08T07:27:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs19000ze39kssxyvq0x","content":"<h3 id=\"复习\"><a href=\"#复习\" class=\"headerlink\" title=\"复习\"></a>复习</h3><h4 id=\"移位运算\"><a href=\"#移位运算\" class=\"headerlink\" title=\"移位运算\"></a>移位运算</h4><ul>\n<li>“&lt;&lt;” 左移：右边空出的位上补 0，相当于乘以 2</li>\n<li>“&gt;&gt;” 右移：左边空出的位上，如果正数，则补 0，否则，可能补 0 或者 1，取决于计算机系统。正数情况下，相当于除以 2</li>\n<li>“&gt;&gt;&gt;” 无符号右移：左边空出的位上一律补上 0，相当于除以 2</li>\n</ul>\n<h4 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h4><ul>\n<li>&amp; 与运算符：两个操作数相同位上同时为 1，结果数相同位上才为 1</li>\n<li>| 或运算符：两个操作数相同位上只要有一个为 1，结果数相同位上就为 1</li>\n<li>^ 异或运算符：两个操作数相同位上不相同，结果数相同位上才为 1</li>\n</ul>\n<h3 id=\"灵活使用\"><a href=\"#灵活使用\" class=\"headerlink\" title=\"灵活使用\"></a>灵活使用</h3><h4 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h4><ol>\n<li><p>清除特定位（即设置为 0）</p>\n<p>mask 特定位为 0，其他位为 1：s = s &amp; mask</p>\n</li>\n<li><p>获取指定位</p>\n<p>mask 特定位为 1，其他位为 0：r = s &amp; mask</p>\n</li>\n<li><p>设置特定位（即设置为 1）</p>\n<p>mask 特定位为 1，其他位为 0：s = s | mask</p>\n</li>\n<li><p>特定位取反</p>\n<p>mask 特定位置为 1,其他位为 0：s = s ^ mask</p>\n</li>\n</ol>\n<h4 id=\"交换变量\"><a href=\"#交换变量\" class=\"headerlink\" title=\"交换变量\"></a>交换变量</h4><p>a ^= b;</p>\n<p>b ^= a;</p>\n<p>a ^= b;</p>\n<h4 id=\"判断奇偶\"><a href=\"#判断奇偶\" class=\"headerlink\" title=\"判断奇偶\"></a>判断奇偶</h4><p>a &amp; 1 = 0 偶数</p>\n<p>a &amp; 1 = 1 奇数</p>\n<h4 id=\"取模\"><a href=\"#取模\" class=\"headerlink\" title=\"取模\"></a>取模</h4><p>a % (2^n) = a &amp; (2^n -1);</p>\n<p>2^n - 1 刚好是最高位 1 变成 0，剩下的低位 0 变成 1</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"复习\"><a href=\"#复习\" class=\"headerlink\" title=\"复习\"></a>复习</h3><h4 id=\"移位运算\"><a href=\"#移位运算\" class=\"headerlink\" title=\"移位运算\"></a>移位运算</h4><ul>\n<li>“&lt;&lt;” 左移：右边空出的位上补 0，相当于乘以 2</li>\n<li>“&gt;&gt;” 右移：左边空出的位上，如果正数，则补 0，否则，可能补 0 或者 1，取决于计算机系统。正数情况下，相当于除以 2</li>\n<li>“&gt;&gt;&gt;” 无符号右移：左边空出的位上一律补上 0，相当于除以 2</li>\n</ul>\n<h4 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h4><ul>\n<li>&amp; 与运算符：两个操作数相同位上同时为 1，结果数相同位上才为 1</li>\n<li>| 或运算符：两个操作数相同位上只要有一个为 1，结果数相同位上就为 1</li>\n<li>^ 异或运算符：两个操作数相同位上不相同，结果数相同位上才为 1</li>\n</ul>\n<h3 id=\"灵活使用\"><a href=\"#灵活使用\" class=\"headerlink\" title=\"灵活使用\"></a>灵活使用</h3><h4 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h4><ol>\n<li><p>清除特定位（即设置为 0）</p>\n<p>mask 特定位为 0，其他位为 1：s = s &amp; mask</p>\n</li>\n<li><p>获取指定位</p>\n<p>mask 特定位为 1，其他位为 0：r = s &amp; mask</p>\n</li>\n<li><p>设置特定位（即设置为 1）</p>\n<p>mask 特定位为 1，其他位为 0：s = s | mask</p>\n</li>\n<li><p>特定位取反</p>\n<p>mask 特定位置为 1,其他位为 0：s = s ^ mask</p>\n</li>\n</ol>\n<h4 id=\"交换变量\"><a href=\"#交换变量\" class=\"headerlink\" title=\"交换变量\"></a>交换变量</h4><p>a ^= b;</p>\n<p>b ^= a;</p>\n<p>a ^= b;</p>\n<h4 id=\"判断奇偶\"><a href=\"#判断奇偶\" class=\"headerlink\" title=\"判断奇偶\"></a>判断奇偶</h4><p>a &amp; 1 = 0 偶数</p>\n<p>a &amp; 1 = 1 奇数</p>\n<h4 id=\"取模\"><a href=\"#取模\" class=\"headerlink\" title=\"取模\"></a>取模</h4><p>a % (2^n) = a &amp; (2^n -1);</p>\n<p>2^n - 1 刚好是最高位 1 变成 0，剩下的低位 0 变成 1</p>\n"},{"title":"可拖拽的网格布局","date":"2018-07-19T03:42:26.000Z","_content":"### 效果\n\n![效果图](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/DragGridLayout.gif?x-oss-process=style/doc-img)\n\n### 背景\n\n在之前的项目中为了实现类似微信朋友圈的图片九宫格效果，手写了一个简单的网格控件，继承于 ViewGroup，后面因为准备做小组的技术分享，关于自定义控件的，所以就想把这个控件优化下，来作为这次分享的例子。自定义控件一般涉及测量、布局、绘制三大流程，再加上触摸事件的处理。之前的已完成的部分，已经包括了测量和布局，绘制暂时没有好想法，所以这次就想再加上触摸事件的处理。在使用微信发布朋友圈的时候，看到可以通过拖拽来重新排序图片，所以这次就加上可拖拽的功能。\n\n### 思路\n\n因为网格控件是位置是比较固定的，所以可以通过实时计算每个 Item 的位置，这里我们为了方便，所以缓存了每个 Item 的位置。当我们拖拽某个 Item 靠近新的位置时，如果新位置大于原来的位置，我们将原来位置到新位置的 Item 向后移动一位，反之，则向前移动一位。不知道这样解释是否清晰。\n\n### 实现\n\n**[源码](https://github.com/LinXiaoTao/DragGridLayout)**\n\n首先我们要保存初始布局时的位置信息，这里我们使用 `SparseArray<Point>` 去缓存，相关代码如下：\n\n``` java\nint childTop = getPaddingTop();                                                                \nint childLeft = getPaddingLeft();                                                              \n                                                                                               \nfor (int i = 0; i < getChildCount(); i++) {                                                    \n    final View childView = getChildAt(i);                                                      \n    Point point = mLayoutPositionArray.get(i);                                                 \n                                                                                               \n    if(point == null){                                                                         \n        point = acquireTempPoint();                                                            \n    }                                                                                          \n                                                                                               \n    point.x = childLeft;                                                                       \n    point.y = childTop;                                                                        \n    mLayoutPositionArray.put(i, point);                                                        \n                                                                                               \n    childView.layout(childLeft, childTop, childLeft + itemWidth, childTop + itemHeight);       \n                                                                                               \n    if (mGridAdapter != null) {                                                                \n        mGridAdapter.handleItemView(childView, i);                                             \n    }                                                                                          \n    childLeft += itemWidth + mHGap;                                                            \n    if ((i + 1) % mColumnCount == 0) {                                                         \n        childTop += itemHeight + mVGap;                                                        \n        childLeft = getPaddingLeft();                                                          \n    }                                                                                          \n}                                                                                                                               \n```\n\n接下来是 Item 的拖拽移动处理，同样的我们可以通过手动处理 `onTouchEvent()` 和 `onInterceptTouchEvent()` 去实现，为了节约时间，我们使用 `ViewDragHelper` 去实现，关于 `ViewDragHelper` 的使用，这里我们就不去细讲，可以参考这篇[博客](https://blog.csdn.net/lmj623565791/article/details/46858663)，关于触发拖动操作，这里我们使用长按开始拖动，同样的，长按等手势判定，我们交给  `GestureDetector` 去处理，下面是两个类的集成代码：\n\n``` java\n@Override                                                                   \npublic boolean onInterceptTouchEvent(MotionEvent ev) {                      \n    boolean intercept = mDragHelper.shouldInterceptTouchEvent(ev);          \n    if (mDragHelper.getViewDragState() == ViewDragHelper.STATE_DRAGGING) {  \n        if (getParent() != null) {\n            // 这里需要禁止父视图拦截事件，防止父视图为滚动控件，发生滑动冲突\n            getParent().requestDisallowInterceptTouchEvent(true);           \n        }                                                                   \n    }                                                                       \n    return intercept;                                                       \n}                                                                           \n                                                                            \n@SuppressLint(\"ClickableViewAccessibility\")                                 \n@Override                                                                   \npublic boolean onTouchEvent(MotionEvent event) {                            \n    mDragHelper.processTouchEvent(event);                                   \n    if (mDragHelper.getViewDragState() == ViewDragHelper.STATE_DRAGGING) {  \n        if (getParent() != null) {\n            // 这里需要禁止父视图拦截事件，防止父视图为滚动控件，发生滑动冲突\n            getParent().requestDisallowInterceptTouchEvent(true);           \n        }                                                                   \n    }                                                                       \n    // 手势判断                                                                 \n    mGestureDetector.onTouchEvent(event);                                   \n    return true;                                                            \n}                                                                           \n```\n\n这时候，我们的长按开始拖拽已经实现了，接下来，当我们拖拽时，如何让目标位置的子视图移动出位置呢？在上面，我们已经提到了思路，即将部分视图进行整体移动去实现。我们通过代码来看下实现思路：\n\n``` java\n@Override                                                                                                                                          \npublic void onViewPositionChanged(@NonNull View changedView, int left, int top, int dx, int dy) {\n    // 当子视图拖拽移动时，ViewDragHelper 会回调这个方法返回新的位置\n    super.onViewPositionChanged(changedView, left, top, dx, dy);                                                                                   \n    Log.d(TAG,\"dx: \" + dx + \"，dy: \" + dy);\n    // findFirstContactView 拖拽到新的目标位置\n    int targetPosition = findFirstContactView(left, top, left + changedView.getWidth(), top + changedView.getHeight(), changedView);               \n    int sourcePosition = indexOfChild(changedView);                                                                                                \n    if (targetPosition == -1 || sourcePosition == targetPosition) {                                                                                \n        if (targetPosition == -1) {                                                                                                                \n            Log.d(TAG, \"targetPosition == -1\");                                                                                                    \n        }                                                                                                                                          \n        if (sourcePosition == targetPosition) {                                                                                                    \n            Log.w(TAG, \"sourcePosition == targetPosition\");                                                                                        \n        }                                                                                                                                          \n        return;                                                                                                                                    \n    }                                                                                                                                              \n    if (mAnimatorCountDown.get() > 0) {\n        // 上一次整体移动的动画还没结束\n        return;                                                                                                                                    \n    }                                                                                                                                              \n    Log.d(TAG, \"sourcePositon: \" + sourcePosition + \" ,targetPosition: \" + targetPosition);                                                        \n    // 移动位置                                                                                                                                        \n    if (targetPosition < sourcePosition && (dx < 0 || dy < 0)) {\n        // 当前目标位置小于拖拽视图的原位置，同时手势为向左或者向上\n        mTargetPosition = targetPosition;                                                                                                          \n        for (int i = targetPosition; i < sourcePosition; i++) {                                                                                    \n            moveAnimation(getChildAt(i), mLayoutPositionArray.get(i + 1), i + 1, null);                                                            \n        }                                                                                                                                          \n    } else if (targetPosition > sourcePosition && (dx > 0 || dy > 0)) {\n        // 当前目标位置大于拖拽视图的原位置，同时手势为向右或者向下\n        mTargetPosition = targetPosition;                                                                                                          \n        for (int i = sourcePosition + 1; i < (targetPosition + 1); i++) {                                                                          \n            moveAnimation(getChildAt(i), mLayoutPositionArray.get(i - 1), i - 1, null);                                                            \n        }                                                                                                                                          \n    }                                                                                                                                              \n}                                                                                                                                                  \n```\n\n通过上面的代码和注释，实现的思路应该很清晰了。接下来，我们再看下 `findFirstContactView` 这个方法，这是获取拖拽视图移动目标位置，代码如下：\n\n``` java\nprivate int findFirstContactView(int left, int top, int right, int bottom, View excludeView) {                          \n    final int childCount = getChildCount();                                                                             \n    for (int i = childCount - 1; i >= 0; i--) {\n        // 这里我们遍历子视图\n        final View child = getChildAt(i);                                                                               \n        if (child == excludeView) {                                                                                     \n            continue;                                                                                                   \n        }                                                                                                               \n        if (left < child.getRight() && child.getLeft() < right && top < child.getBottom() && child.getTop() < bottom) { \n            // 是否存在相交的子视图                                                                                                       \n            int calculateLeft = left;                                                                                   \n            int calculateRight = right;                                                                                 \n            int caluculateTop = top;                                                                                    \n            int caluculateBottom = bottom;                                                                              \n            if (child.getLeft() > calculateLeft){                                                                       \n                calculateLeft = child.getLeft();                                                                        \n            }                                                                                                           \n            if (child.getRight() < calculateRight){                                                                     \n                calculateRight = child.getRight();                                                                      \n            }                                                                                                           \n            if (child.getTop() > caluculateTop){                                                                        \n                caluculateTop = child.getTop();                                                                         \n            }                                                                                                           \n            if (child.getBottom() < caluculateBottom){                                                                  \n                caluculateBottom = child.getBottom();                                                                   \n            }                                                                                                           \n            int unionArea = (calculateRight - calculateLeft) * (caluculateBottom - caluculateTop);                      \n            if (unionArea > (child.getWidth() * child.getHeight() * 0.5f)){\n                // 这里我们再通过 相交面积是否大于视图面积的一半 去判定\n                // 这是为了不那么敏感\n                return i;                                                                                               \n            }                                                                                                           \n        }                                                                                                               \n    }                                                                                                                   \n    return -1;                                                                                                          \n}                                                                                                                       \n```\n\n经过上面的步骤，我们已经实现了百分之八十的代码，这时，我们还需要考虑几个问题。\n\n* 位置交换后，我们通过 `indexOfChild` 或 `getChildAt` 得到的数据还是原来的，即我们通过调用 `addView` 添加的顺序。这里我们自己去缓存一个子视图列表，重写上面两个方法：\n\n  ``` java\n  @Override                             \n  public int indexOfChild(View child) { \n      return mChildViews.indexOf(child);\n  }                                     \n                                        \n  @Override                             \n  public View getChildAt(int index) {   \n      return mChildViews.get(index);    \n  }                                     \n  ```\n\n  同时在视图移动时，去修改这个列表：\n\n  ``` java\n  mChildViews.set(targetPosition, targetView); \n  ```\n\n* 绘制顺序问题，ViewGroup 的默认绘制顺序是根据 `addView`  的调用顺序，这样会带来一个问题，当你拖拽到比当前拖拽视图更晚添加的子视图时，会显示在这个视图下面，同样我们可以通过 `setChildrenDrawingOrderEnabled` 和 \n\n  `getChildDrawingOrder` 去自定义绘制顺序，这里为了方便，我们通过设置拖拽视图的 Z 值来实现同样的效果：\n\n  ``` java\n  ViewCompat.setZ(capturedChild, 100f);     \n  postInvalidate();                         \n  ```\n\n最后我们顺便把 Item 的点击事件实现下。。。\n\n``` java\n @Override                                                                                 \n public boolean onSingleTapConfirmed(MotionEvent e) {                                      \n     final View targetView = mDragHelper.findTopChildUnder((int) e.getX(), (int) e.getY());\n     if (targetView == null) {                                                             \n         return performClick();                                                            \n     } else if (mGridItemClickListener != null) {                                          \n         mGridItemClickListener.onClickItem(indexOfChild(targetView), targetView);         \n         return true;                                                                      \n     }                                                                                     \n     return false;                                                                         \n }                                                                                         \n```\n","source":"_posts/可拖拽的网格布局.md","raw":"---\ntitle: 可拖拽的网格布局\ndate: 2018-07-19 11:42:26\ncategories: Android Application\n---\n### 效果\n\n![效果图](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/DragGridLayout.gif?x-oss-process=style/doc-img)\n\n### 背景\n\n在之前的项目中为了实现类似微信朋友圈的图片九宫格效果，手写了一个简单的网格控件，继承于 ViewGroup，后面因为准备做小组的技术分享，关于自定义控件的，所以就想把这个控件优化下，来作为这次分享的例子。自定义控件一般涉及测量、布局、绘制三大流程，再加上触摸事件的处理。之前的已完成的部分，已经包括了测量和布局，绘制暂时没有好想法，所以这次就想再加上触摸事件的处理。在使用微信发布朋友圈的时候，看到可以通过拖拽来重新排序图片，所以这次就加上可拖拽的功能。\n\n### 思路\n\n因为网格控件是位置是比较固定的，所以可以通过实时计算每个 Item 的位置，这里我们为了方便，所以缓存了每个 Item 的位置。当我们拖拽某个 Item 靠近新的位置时，如果新位置大于原来的位置，我们将原来位置到新位置的 Item 向后移动一位，反之，则向前移动一位。不知道这样解释是否清晰。\n\n### 实现\n\n**[源码](https://github.com/LinXiaoTao/DragGridLayout)**\n\n首先我们要保存初始布局时的位置信息，这里我们使用 `SparseArray<Point>` 去缓存，相关代码如下：\n\n``` java\nint childTop = getPaddingTop();                                                                \nint childLeft = getPaddingLeft();                                                              \n                                                                                               \nfor (int i = 0; i < getChildCount(); i++) {                                                    \n    final View childView = getChildAt(i);                                                      \n    Point point = mLayoutPositionArray.get(i);                                                 \n                                                                                               \n    if(point == null){                                                                         \n        point = acquireTempPoint();                                                            \n    }                                                                                          \n                                                                                               \n    point.x = childLeft;                                                                       \n    point.y = childTop;                                                                        \n    mLayoutPositionArray.put(i, point);                                                        \n                                                                                               \n    childView.layout(childLeft, childTop, childLeft + itemWidth, childTop + itemHeight);       \n                                                                                               \n    if (mGridAdapter != null) {                                                                \n        mGridAdapter.handleItemView(childView, i);                                             \n    }                                                                                          \n    childLeft += itemWidth + mHGap;                                                            \n    if ((i + 1) % mColumnCount == 0) {                                                         \n        childTop += itemHeight + mVGap;                                                        \n        childLeft = getPaddingLeft();                                                          \n    }                                                                                          \n}                                                                                                                               \n```\n\n接下来是 Item 的拖拽移动处理，同样的我们可以通过手动处理 `onTouchEvent()` 和 `onInterceptTouchEvent()` 去实现，为了节约时间，我们使用 `ViewDragHelper` 去实现，关于 `ViewDragHelper` 的使用，这里我们就不去细讲，可以参考这篇[博客](https://blog.csdn.net/lmj623565791/article/details/46858663)，关于触发拖动操作，这里我们使用长按开始拖动，同样的，长按等手势判定，我们交给  `GestureDetector` 去处理，下面是两个类的集成代码：\n\n``` java\n@Override                                                                   \npublic boolean onInterceptTouchEvent(MotionEvent ev) {                      \n    boolean intercept = mDragHelper.shouldInterceptTouchEvent(ev);          \n    if (mDragHelper.getViewDragState() == ViewDragHelper.STATE_DRAGGING) {  \n        if (getParent() != null) {\n            // 这里需要禁止父视图拦截事件，防止父视图为滚动控件，发生滑动冲突\n            getParent().requestDisallowInterceptTouchEvent(true);           \n        }                                                                   \n    }                                                                       \n    return intercept;                                                       \n}                                                                           \n                                                                            \n@SuppressLint(\"ClickableViewAccessibility\")                                 \n@Override                                                                   \npublic boolean onTouchEvent(MotionEvent event) {                            \n    mDragHelper.processTouchEvent(event);                                   \n    if (mDragHelper.getViewDragState() == ViewDragHelper.STATE_DRAGGING) {  \n        if (getParent() != null) {\n            // 这里需要禁止父视图拦截事件，防止父视图为滚动控件，发生滑动冲突\n            getParent().requestDisallowInterceptTouchEvent(true);           \n        }                                                                   \n    }                                                                       \n    // 手势判断                                                                 \n    mGestureDetector.onTouchEvent(event);                                   \n    return true;                                                            \n}                                                                           \n```\n\n这时候，我们的长按开始拖拽已经实现了，接下来，当我们拖拽时，如何让目标位置的子视图移动出位置呢？在上面，我们已经提到了思路，即将部分视图进行整体移动去实现。我们通过代码来看下实现思路：\n\n``` java\n@Override                                                                                                                                          \npublic void onViewPositionChanged(@NonNull View changedView, int left, int top, int dx, int dy) {\n    // 当子视图拖拽移动时，ViewDragHelper 会回调这个方法返回新的位置\n    super.onViewPositionChanged(changedView, left, top, dx, dy);                                                                                   \n    Log.d(TAG,\"dx: \" + dx + \"，dy: \" + dy);\n    // findFirstContactView 拖拽到新的目标位置\n    int targetPosition = findFirstContactView(left, top, left + changedView.getWidth(), top + changedView.getHeight(), changedView);               \n    int sourcePosition = indexOfChild(changedView);                                                                                                \n    if (targetPosition == -1 || sourcePosition == targetPosition) {                                                                                \n        if (targetPosition == -1) {                                                                                                                \n            Log.d(TAG, \"targetPosition == -1\");                                                                                                    \n        }                                                                                                                                          \n        if (sourcePosition == targetPosition) {                                                                                                    \n            Log.w(TAG, \"sourcePosition == targetPosition\");                                                                                        \n        }                                                                                                                                          \n        return;                                                                                                                                    \n    }                                                                                                                                              \n    if (mAnimatorCountDown.get() > 0) {\n        // 上一次整体移动的动画还没结束\n        return;                                                                                                                                    \n    }                                                                                                                                              \n    Log.d(TAG, \"sourcePositon: \" + sourcePosition + \" ,targetPosition: \" + targetPosition);                                                        \n    // 移动位置                                                                                                                                        \n    if (targetPosition < sourcePosition && (dx < 0 || dy < 0)) {\n        // 当前目标位置小于拖拽视图的原位置，同时手势为向左或者向上\n        mTargetPosition = targetPosition;                                                                                                          \n        for (int i = targetPosition; i < sourcePosition; i++) {                                                                                    \n            moveAnimation(getChildAt(i), mLayoutPositionArray.get(i + 1), i + 1, null);                                                            \n        }                                                                                                                                          \n    } else if (targetPosition > sourcePosition && (dx > 0 || dy > 0)) {\n        // 当前目标位置大于拖拽视图的原位置，同时手势为向右或者向下\n        mTargetPosition = targetPosition;                                                                                                          \n        for (int i = sourcePosition + 1; i < (targetPosition + 1); i++) {                                                                          \n            moveAnimation(getChildAt(i), mLayoutPositionArray.get(i - 1), i - 1, null);                                                            \n        }                                                                                                                                          \n    }                                                                                                                                              \n}                                                                                                                                                  \n```\n\n通过上面的代码和注释，实现的思路应该很清晰了。接下来，我们再看下 `findFirstContactView` 这个方法，这是获取拖拽视图移动目标位置，代码如下：\n\n``` java\nprivate int findFirstContactView(int left, int top, int right, int bottom, View excludeView) {                          \n    final int childCount = getChildCount();                                                                             \n    for (int i = childCount - 1; i >= 0; i--) {\n        // 这里我们遍历子视图\n        final View child = getChildAt(i);                                                                               \n        if (child == excludeView) {                                                                                     \n            continue;                                                                                                   \n        }                                                                                                               \n        if (left < child.getRight() && child.getLeft() < right && top < child.getBottom() && child.getTop() < bottom) { \n            // 是否存在相交的子视图                                                                                                       \n            int calculateLeft = left;                                                                                   \n            int calculateRight = right;                                                                                 \n            int caluculateTop = top;                                                                                    \n            int caluculateBottom = bottom;                                                                              \n            if (child.getLeft() > calculateLeft){                                                                       \n                calculateLeft = child.getLeft();                                                                        \n            }                                                                                                           \n            if (child.getRight() < calculateRight){                                                                     \n                calculateRight = child.getRight();                                                                      \n            }                                                                                                           \n            if (child.getTop() > caluculateTop){                                                                        \n                caluculateTop = child.getTop();                                                                         \n            }                                                                                                           \n            if (child.getBottom() < caluculateBottom){                                                                  \n                caluculateBottom = child.getBottom();                                                                   \n            }                                                                                                           \n            int unionArea = (calculateRight - calculateLeft) * (caluculateBottom - caluculateTop);                      \n            if (unionArea > (child.getWidth() * child.getHeight() * 0.5f)){\n                // 这里我们再通过 相交面积是否大于视图面积的一半 去判定\n                // 这是为了不那么敏感\n                return i;                                                                                               \n            }                                                                                                           \n        }                                                                                                               \n    }                                                                                                                   \n    return -1;                                                                                                          \n}                                                                                                                       \n```\n\n经过上面的步骤，我们已经实现了百分之八十的代码，这时，我们还需要考虑几个问题。\n\n* 位置交换后，我们通过 `indexOfChild` 或 `getChildAt` 得到的数据还是原来的，即我们通过调用 `addView` 添加的顺序。这里我们自己去缓存一个子视图列表，重写上面两个方法：\n\n  ``` java\n  @Override                             \n  public int indexOfChild(View child) { \n      return mChildViews.indexOf(child);\n  }                                     \n                                        \n  @Override                             \n  public View getChildAt(int index) {   \n      return mChildViews.get(index);    \n  }                                     \n  ```\n\n  同时在视图移动时，去修改这个列表：\n\n  ``` java\n  mChildViews.set(targetPosition, targetView); \n  ```\n\n* 绘制顺序问题，ViewGroup 的默认绘制顺序是根据 `addView`  的调用顺序，这样会带来一个问题，当你拖拽到比当前拖拽视图更晚添加的子视图时，会显示在这个视图下面，同样我们可以通过 `setChildrenDrawingOrderEnabled` 和 \n\n  `getChildDrawingOrder` 去自定义绘制顺序，这里为了方便，我们通过设置拖拽视图的 Z 值来实现同样的效果：\n\n  ``` java\n  ViewCompat.setZ(capturedChild, 100f);     \n  postInvalidate();                         \n  ```\n\n最后我们顺便把 Item 的点击事件实现下。。。\n\n``` java\n @Override                                                                                 \n public boolean onSingleTapConfirmed(MotionEvent e) {                                      \n     final View targetView = mDragHelper.findTopChildUnder((int) e.getX(), (int) e.getY());\n     if (targetView == null) {                                                             \n         return performClick();                                                            \n     } else if (mGridItemClickListener != null) {                                          \n         mGridItemClickListener.onClickItem(indexOfChild(targetView), targetView);         \n         return true;                                                                      \n     }                                                                                     \n     return false;                                                                         \n }                                                                                         \n```\n","slug":"可拖拽的网格布局","published":1,"updated":"2018-11-16T10:14:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs1a0011e39kxudjjvtd","content":"<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/DragGridLayout.gif?x-oss-process=style/doc-img\" alt=\"效果图\"></p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在之前的项目中为了实现类似微信朋友圈的图片九宫格效果，手写了一个简单的网格控件，继承于 ViewGroup，后面因为准备做小组的技术分享，关于自定义控件的，所以就想把这个控件优化下，来作为这次分享的例子。自定义控件一般涉及测量、布局、绘制三大流程，再加上触摸事件的处理。之前的已完成的部分，已经包括了测量和布局，绘制暂时没有好想法，所以这次就想再加上触摸事件的处理。在使用微信发布朋友圈的时候，看到可以通过拖拽来重新排序图片，所以这次就加上可拖拽的功能。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>因为网格控件是位置是比较固定的，所以可以通过实时计算每个 Item 的位置，这里我们为了方便，所以缓存了每个 Item 的位置。当我们拖拽某个 Item 靠近新的位置时，如果新位置大于原来的位置，我们将原来位置到新位置的 Item 向后移动一位，反之，则向前移动一位。不知道这样解释是否清晰。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p><strong><a href=\"https://github.com/LinXiaoTao/DragGridLayout\" target=\"_blank\" rel=\"noopener\">源码</a></strong></p>\n<p>首先我们要保存初始布局时的位置信息，这里我们使用 <code>SparseArray&lt;Point&gt;</code> 去缓存，相关代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> childTop = getPaddingTop();                                                                </span><br><span class=\"line\"><span class=\"keyword\">int</span> childLeft = getPaddingLeft();                                                              </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; getChildCount(); i++) &#123;                                                    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> View childView = getChildAt(i);                                                      </span><br><span class=\"line\">    Point point = mLayoutPositionArray.get(i);                                                 </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(point == <span class=\"keyword\">null</span>)&#123;                                                                         </span><br><span class=\"line\">        point = acquireTempPoint();                                                            </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    point.x = childLeft;                                                                       </span><br><span class=\"line\">    point.y = childTop;                                                                        </span><br><span class=\"line\">    mLayoutPositionArray.put(i, point);                                                        </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    childView.layout(childLeft, childTop, childLeft + itemWidth, childTop + itemHeight);       </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mGridAdapter != <span class=\"keyword\">null</span>) &#123;                                                                </span><br><span class=\"line\">        mGridAdapter.handleItemView(childView, i);                                             </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">    childLeft += itemWidth + mHGap;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((i + <span class=\"number\">1</span>) % mColumnCount == <span class=\"number\">0</span>) &#123;                                                         </span><br><span class=\"line\">        childTop += itemHeight + mVGap;                                                        </span><br><span class=\"line\">        childLeft = getPaddingLeft();                                                          </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来是 Item 的拖拽移动处理，同样的我们可以通过手动处理 <code>onTouchEvent()</code> 和 <code>onInterceptTouchEvent()</code> 去实现，为了节约时间，我们使用 <code>ViewDragHelper</code> 去实现，关于 <code>ViewDragHelper</code> 的使用，这里我们就不去细讲，可以参考这篇<a href=\"https://blog.csdn.net/lmj623565791/article/details/46858663\" target=\"_blank\" rel=\"noopener\">博客</a>，关于触发拖动操作，这里我们使用长按开始拖动，同样的，长按等手势判定，我们交给  <code>GestureDetector</code> 去处理，下面是两个类的集成代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;                      </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> intercept = mDragHelper.shouldInterceptTouchEvent(ev);          </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDragHelper.getViewDragState() == ViewDragHelper.STATE_DRAGGING) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getParent() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要禁止父视图拦截事件，防止父视图为滚动控件，发生滑动冲突</span></span><br><span class=\"line\">            getParent().requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);           </span><br><span class=\"line\">        &#125;                                                                   </span><br><span class=\"line\">    &#125;                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">return</span> intercept;                                                       </span><br><span class=\"line\">&#125;                                                                           </span><br><span class=\"line\">                                                                            </span><br><span class=\"line\"><span class=\"meta\">@SuppressLint</span>(<span class=\"string\">\"ClickableViewAccessibility\"</span>)                                 </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;                            </span><br><span class=\"line\">    mDragHelper.processTouchEvent(event);                                   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDragHelper.getViewDragState() == ViewDragHelper.STATE_DRAGGING) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getParent() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要禁止父视图拦截事件，防止父视图为滚动控件，发生滑动冲突</span></span><br><span class=\"line\">            getParent().requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);           </span><br><span class=\"line\">        &#125;                                                                   </span><br><span class=\"line\">    &#125;                                                                       </span><br><span class=\"line\">    <span class=\"comment\">// 手势判断                                                                 </span></span><br><span class=\"line\">    mGestureDetector.onTouchEvent(event);                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候，我们的长按开始拖拽已经实现了，接下来，当我们拖拽时，如何让目标位置的子视图移动出位置呢？在上面，我们已经提到了思路，即将部分视图进行整体移动去实现。我们通过代码来看下实现思路：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewPositionChanged</span><span class=\"params\">(@NonNull View changedView, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当子视图拖拽移动时，ViewDragHelper 会回调这个方法返回新的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onViewPositionChanged(changedView, left, top, dx, dy);                                                                                   </span><br><span class=\"line\">    Log.d(TAG,<span class=\"string\">\"dx: \"</span> + dx + <span class=\"string\">\"，dy: \"</span> + dy);</span><br><span class=\"line\">    <span class=\"comment\">// findFirstContactView 拖拽到新的目标位置</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> targetPosition = findFirstContactView(left, top, left + changedView.getWidth(), top + changedView.getHeight(), changedView);               </span><br><span class=\"line\">    <span class=\"keyword\">int</span> sourcePosition = indexOfChild(changedView);                                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetPosition == -<span class=\"number\">1</span> || sourcePosition == targetPosition) &#123;                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (targetPosition == -<span class=\"number\">1</span>) &#123;                                                                                                                </span><br><span class=\"line\">            Log.d(TAG, <span class=\"string\">\"targetPosition == -1\"</span>);                                                                                                    </span><br><span class=\"line\">        &#125;                                                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourcePosition == targetPosition) &#123;                                                                                                    </span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"sourcePosition == targetPosition\"</span>);                                                                                        </span><br><span class=\"line\">        &#125;                                                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                                                                    </span><br><span class=\"line\">    &#125;                                                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAnimatorCountDown.get() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 上一次整体移动的动画还没结束</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                                                                    </span><br><span class=\"line\">    &#125;                                                                                                                                              </span><br><span class=\"line\">    Log.d(TAG, <span class=\"string\">\"sourcePositon: \"</span> + sourcePosition + <span class=\"string\">\" ,targetPosition: \"</span> + targetPosition);                                                        </span><br><span class=\"line\">    <span class=\"comment\">// 移动位置                                                                                                                                        </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetPosition &lt; sourcePosition &amp;&amp; (dx &lt; <span class=\"number\">0</span> || dy &lt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前目标位置小于拖拽视图的原位置，同时手势为向左或者向上</span></span><br><span class=\"line\">        mTargetPosition = targetPosition;                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = targetPosition; i &lt; sourcePosition; i++) &#123;                                                                                    </span><br><span class=\"line\">            moveAnimation(getChildAt(i), mLayoutPositionArray.get(i + <span class=\"number\">1</span>), i + <span class=\"number\">1</span>, <span class=\"keyword\">null</span>);                                                            </span><br><span class=\"line\">        &#125;                                                                                                                                          </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (targetPosition &gt; sourcePosition &amp;&amp; (dx &gt; <span class=\"number\">0</span> || dy &gt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前目标位置大于拖拽视图的原位置，同时手势为向右或者向下</span></span><br><span class=\"line\">        mTargetPosition = targetPosition;                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = sourcePosition + <span class=\"number\">1</span>; i &lt; (targetPosition + <span class=\"number\">1</span>); i++) &#123;                                                                          </span><br><span class=\"line\">            moveAnimation(getChildAt(i), mLayoutPositionArray.get(i - <span class=\"number\">1</span>), i - <span class=\"number\">1</span>, <span class=\"keyword\">null</span>);                                                            </span><br><span class=\"line\">        &#125;                                                                                                                                          </span><br><span class=\"line\">    &#125;                                                                                                                                              </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面的代码和注释，实现的思路应该很清晰了。接下来，我们再看下 <code>findFirstContactView</code> 这个方法，这是获取拖拽视图移动目标位置，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">findFirstContactView</span><span class=\"params\">(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom, View excludeView)</span> </span>&#123;                          </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childCount = getChildCount();                                                                             </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里我们遍历子视图</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View child = getChildAt(i);                                                                               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child == excludeView) &#123;                                                                                     </span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;                                                                                                   </span><br><span class=\"line\">        &#125;                                                                                                               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; child.getRight() &amp;&amp; child.getLeft() &lt; right &amp;&amp; top &lt; child.getBottom() &amp;&amp; child.getTop() &lt; bottom) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 是否存在相交的子视图                                                                                                       </span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> calculateLeft = left;                                                                                   </span><br><span class=\"line\">            <span class=\"keyword\">int</span> calculateRight = right;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">int</span> caluculateTop = top;                                                                                    </span><br><span class=\"line\">            <span class=\"keyword\">int</span> caluculateBottom = bottom;                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (child.getLeft() &gt; calculateLeft)&#123;                                                                       </span><br><span class=\"line\">                calculateLeft = child.getLeft();                                                                        </span><br><span class=\"line\">            &#125;                                                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (child.getRight() &lt; calculateRight)&#123;                                                                     </span><br><span class=\"line\">                calculateRight = child.getRight();                                                                      </span><br><span class=\"line\">            &#125;                                                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (child.getTop() &gt; caluculateTop)&#123;                                                                        </span><br><span class=\"line\">                caluculateTop = child.getTop();                                                                         </span><br><span class=\"line\">            &#125;                                                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (child.getBottom() &lt; caluculateBottom)&#123;                                                                  </span><br><span class=\"line\">                caluculateBottom = child.getBottom();                                                                   </span><br><span class=\"line\">            &#125;                                                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">int</span> unionArea = (calculateRight - calculateLeft) * (caluculateBottom - caluculateTop);                      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (unionArea &gt; (child.getWidth() * child.getHeight() * <span class=\"number\">0.5f</span>))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 这里我们再通过 相交面积是否大于视图面积的一半 去判定</span></span><br><span class=\"line\">                <span class=\"comment\">// 这是为了不那么敏感</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;                                                                                               </span><br><span class=\"line\">            &#125;                                                                                                           </span><br><span class=\"line\">        &#125;                                                                                                               </span><br><span class=\"line\">    &#125;                                                                                                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;                                                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过上面的步骤，我们已经实现了百分之八十的代码，这时，我们还需要考虑几个问题。</p>\n<ul>\n<li><p>位置交换后，我们通过 <code>indexOfChild</code> 或 <code>getChildAt</code> 得到的数据还是原来的，即我们通过调用 <code>addView</code> 添加的顺序。这里我们自己去缓存一个子视图列表，重写上面两个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                             </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOfChild</span><span class=\"params\">(View child)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mChildViews.indexOf(child);</span><br><span class=\"line\">&#125;                                     </span><br><span class=\"line\">                                      </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                             </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">getChildAt</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mChildViews.get(index);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时在视图移动时，去修改这个列表：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mChildViews.set(targetPosition, targetView);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绘制顺序问题，ViewGroup 的默认绘制顺序是根据 <code>addView</code>  的调用顺序，这样会带来一个问题，当你拖拽到比当前拖拽视图更晚添加的子视图时，会显示在这个视图下面，同样我们可以通过 <code>setChildrenDrawingOrderEnabled</code> 和 </p>\n<p><code>getChildDrawingOrder</code> 去自定义绘制顺序，这里为了方便，我们通过设置拖拽视图的 Z 值来实现同样的效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ViewCompat.setZ(capturedChild, <span class=\"number\">100f</span>);     </span><br><span class=\"line\">postInvalidate();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>最后我们顺便把 Item 的点击事件实现下。。。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                 </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onSingleTapConfirmed</span><span class=\"params\">(MotionEvent e)</span> </span>&#123;                                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> View targetView = mDragHelper.findTopChildUnder((<span class=\"keyword\">int</span>) e.getX(), (<span class=\"keyword\">int</span>) e.getY());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetView == <span class=\"keyword\">null</span>) &#123;                                                             </span><br><span class=\"line\">        <span class=\"keyword\">return</span> performClick();                                                            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mGridItemClickListener != <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        mGridItemClickListener.onClickItem(indexOfChild(targetView), targetView);         </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                      </span><br><span class=\"line\">    &#125;                                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/DragGridLayout.gif?x-oss-process=style/doc-img\" alt=\"效果图\"></p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在之前的项目中为了实现类似微信朋友圈的图片九宫格效果，手写了一个简单的网格控件，继承于 ViewGroup，后面因为准备做小组的技术分享，关于自定义控件的，所以就想把这个控件优化下，来作为这次分享的例子。自定义控件一般涉及测量、布局、绘制三大流程，再加上触摸事件的处理。之前的已完成的部分，已经包括了测量和布局，绘制暂时没有好想法，所以这次就想再加上触摸事件的处理。在使用微信发布朋友圈的时候，看到可以通过拖拽来重新排序图片，所以这次就加上可拖拽的功能。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>因为网格控件是位置是比较固定的，所以可以通过实时计算每个 Item 的位置，这里我们为了方便，所以缓存了每个 Item 的位置。当我们拖拽某个 Item 靠近新的位置时，如果新位置大于原来的位置，我们将原来位置到新位置的 Item 向后移动一位，反之，则向前移动一位。不知道这样解释是否清晰。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p><strong><a href=\"https://github.com/LinXiaoTao/DragGridLayout\" target=\"_blank\" rel=\"noopener\">源码</a></strong></p>\n<p>首先我们要保存初始布局时的位置信息，这里我们使用 <code>SparseArray&lt;Point&gt;</code> 去缓存，相关代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> childTop = getPaddingTop();                                                                </span><br><span class=\"line\"><span class=\"keyword\">int</span> childLeft = getPaddingLeft();                                                              </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; getChildCount(); i++) &#123;                                                    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> View childView = getChildAt(i);                                                      </span><br><span class=\"line\">    Point point = mLayoutPositionArray.get(i);                                                 </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(point == <span class=\"keyword\">null</span>)&#123;                                                                         </span><br><span class=\"line\">        point = acquireTempPoint();                                                            </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    point.x = childLeft;                                                                       </span><br><span class=\"line\">    point.y = childTop;                                                                        </span><br><span class=\"line\">    mLayoutPositionArray.put(i, point);                                                        </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    childView.layout(childLeft, childTop, childLeft + itemWidth, childTop + itemHeight);       </span><br><span class=\"line\">                                                                                               </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mGridAdapter != <span class=\"keyword\">null</span>) &#123;                                                                </span><br><span class=\"line\">        mGridAdapter.handleItemView(childView, i);                                             </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">    childLeft += itemWidth + mHGap;                                                            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((i + <span class=\"number\">1</span>) % mColumnCount == <span class=\"number\">0</span>) &#123;                                                         </span><br><span class=\"line\">        childTop += itemHeight + mVGap;                                                        </span><br><span class=\"line\">        childLeft = getPaddingLeft();                                                          </span><br><span class=\"line\">    &#125;                                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来是 Item 的拖拽移动处理，同样的我们可以通过手动处理 <code>onTouchEvent()</code> 和 <code>onInterceptTouchEvent()</code> 去实现，为了节约时间，我们使用 <code>ViewDragHelper</code> 去实现，关于 <code>ViewDragHelper</code> 的使用，这里我们就不去细讲，可以参考这篇<a href=\"https://blog.csdn.net/lmj623565791/article/details/46858663\" target=\"_blank\" rel=\"noopener\">博客</a>，关于触发拖动操作，这里我们使用长按开始拖动，同样的，长按等手势判定，我们交给  <code>GestureDetector</code> 去处理，下面是两个类的集成代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;                      </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> intercept = mDragHelper.shouldInterceptTouchEvent(ev);          </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDragHelper.getViewDragState() == ViewDragHelper.STATE_DRAGGING) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getParent() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要禁止父视图拦截事件，防止父视图为滚动控件，发生滑动冲突</span></span><br><span class=\"line\">            getParent().requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);           </span><br><span class=\"line\">        &#125;                                                                   </span><br><span class=\"line\">    &#125;                                                                       </span><br><span class=\"line\">    <span class=\"keyword\">return</span> intercept;                                                       </span><br><span class=\"line\">&#125;                                                                           </span><br><span class=\"line\">                                                                            </span><br><span class=\"line\"><span class=\"meta\">@SuppressLint</span>(<span class=\"string\">\"ClickableViewAccessibility\"</span>)                                 </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;                            </span><br><span class=\"line\">    mDragHelper.processTouchEvent(event);                                   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDragHelper.getViewDragState() == ViewDragHelper.STATE_DRAGGING) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getParent() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要禁止父视图拦截事件，防止父视图为滚动控件，发生滑动冲突</span></span><br><span class=\"line\">            getParent().requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);           </span><br><span class=\"line\">        &#125;                                                                   </span><br><span class=\"line\">    &#125;                                                                       </span><br><span class=\"line\">    <span class=\"comment\">// 手势判断                                                                 </span></span><br><span class=\"line\">    mGestureDetector.onTouchEvent(event);                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候，我们的长按开始拖拽已经实现了，接下来，当我们拖拽时，如何让目标位置的子视图移动出位置呢？在上面，我们已经提到了思路，即将部分视图进行整体移动去实现。我们通过代码来看下实现思路：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                                                          </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewPositionChanged</span><span class=\"params\">(@NonNull View changedView, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当子视图拖拽移动时，ViewDragHelper 会回调这个方法返回新的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onViewPositionChanged(changedView, left, top, dx, dy);                                                                                   </span><br><span class=\"line\">    Log.d(TAG,<span class=\"string\">\"dx: \"</span> + dx + <span class=\"string\">\"，dy: \"</span> + dy);</span><br><span class=\"line\">    <span class=\"comment\">// findFirstContactView 拖拽到新的目标位置</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> targetPosition = findFirstContactView(left, top, left + changedView.getWidth(), top + changedView.getHeight(), changedView);               </span><br><span class=\"line\">    <span class=\"keyword\">int</span> sourcePosition = indexOfChild(changedView);                                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetPosition == -<span class=\"number\">1</span> || sourcePosition == targetPosition) &#123;                                                                                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (targetPosition == -<span class=\"number\">1</span>) &#123;                                                                                                                </span><br><span class=\"line\">            Log.d(TAG, <span class=\"string\">\"targetPosition == -1\"</span>);                                                                                                    </span><br><span class=\"line\">        &#125;                                                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourcePosition == targetPosition) &#123;                                                                                                    </span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"sourcePosition == targetPosition\"</span>);                                                                                        </span><br><span class=\"line\">        &#125;                                                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                                                                    </span><br><span class=\"line\">    &#125;                                                                                                                                              </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAnimatorCountDown.get() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 上一次整体移动的动画还没结束</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                                                                                                                    </span><br><span class=\"line\">    &#125;                                                                                                                                              </span><br><span class=\"line\">    Log.d(TAG, <span class=\"string\">\"sourcePositon: \"</span> + sourcePosition + <span class=\"string\">\" ,targetPosition: \"</span> + targetPosition);                                                        </span><br><span class=\"line\">    <span class=\"comment\">// 移动位置                                                                                                                                        </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetPosition &lt; sourcePosition &amp;&amp; (dx &lt; <span class=\"number\">0</span> || dy &lt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前目标位置小于拖拽视图的原位置，同时手势为向左或者向上</span></span><br><span class=\"line\">        mTargetPosition = targetPosition;                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = targetPosition; i &lt; sourcePosition; i++) &#123;                                                                                    </span><br><span class=\"line\">            moveAnimation(getChildAt(i), mLayoutPositionArray.get(i + <span class=\"number\">1</span>), i + <span class=\"number\">1</span>, <span class=\"keyword\">null</span>);                                                            </span><br><span class=\"line\">        &#125;                                                                                                                                          </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (targetPosition &gt; sourcePosition &amp;&amp; (dx &gt; <span class=\"number\">0</span> || dy &gt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前目标位置大于拖拽视图的原位置，同时手势为向右或者向下</span></span><br><span class=\"line\">        mTargetPosition = targetPosition;                                                                                                          </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = sourcePosition + <span class=\"number\">1</span>; i &lt; (targetPosition + <span class=\"number\">1</span>); i++) &#123;                                                                          </span><br><span class=\"line\">            moveAnimation(getChildAt(i), mLayoutPositionArray.get(i - <span class=\"number\">1</span>), i - <span class=\"number\">1</span>, <span class=\"keyword\">null</span>);                                                            </span><br><span class=\"line\">        &#125;                                                                                                                                          </span><br><span class=\"line\">    &#125;                                                                                                                                              </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面的代码和注释，实现的思路应该很清晰了。接下来，我们再看下 <code>findFirstContactView</code> 这个方法，这是获取拖拽视图移动目标位置，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">findFirstContactView</span><span class=\"params\">(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom, View excludeView)</span> </span>&#123;                          </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childCount = getChildCount();                                                                             </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里我们遍历子视图</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View child = getChildAt(i);                                                                               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child == excludeView) &#123;                                                                                     </span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;                                                                                                   </span><br><span class=\"line\">        &#125;                                                                                                               </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; child.getRight() &amp;&amp; child.getLeft() &lt; right &amp;&amp; top &lt; child.getBottom() &amp;&amp; child.getTop() &lt; bottom) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 是否存在相交的子视图                                                                                                       </span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> calculateLeft = left;                                                                                   </span><br><span class=\"line\">            <span class=\"keyword\">int</span> calculateRight = right;                                                                                 </span><br><span class=\"line\">            <span class=\"keyword\">int</span> caluculateTop = top;                                                                                    </span><br><span class=\"line\">            <span class=\"keyword\">int</span> caluculateBottom = bottom;                                                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (child.getLeft() &gt; calculateLeft)&#123;                                                                       </span><br><span class=\"line\">                calculateLeft = child.getLeft();                                                                        </span><br><span class=\"line\">            &#125;                                                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (child.getRight() &lt; calculateRight)&#123;                                                                     </span><br><span class=\"line\">                calculateRight = child.getRight();                                                                      </span><br><span class=\"line\">            &#125;                                                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (child.getTop() &gt; caluculateTop)&#123;                                                                        </span><br><span class=\"line\">                caluculateTop = child.getTop();                                                                         </span><br><span class=\"line\">            &#125;                                                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (child.getBottom() &lt; caluculateBottom)&#123;                                                                  </span><br><span class=\"line\">                caluculateBottom = child.getBottom();                                                                   </span><br><span class=\"line\">            &#125;                                                                                                           </span><br><span class=\"line\">            <span class=\"keyword\">int</span> unionArea = (calculateRight - calculateLeft) * (caluculateBottom - caluculateTop);                      </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (unionArea &gt; (child.getWidth() * child.getHeight() * <span class=\"number\">0.5f</span>))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 这里我们再通过 相交面积是否大于视图面积的一半 去判定</span></span><br><span class=\"line\">                <span class=\"comment\">// 这是为了不那么敏感</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;                                                                                               </span><br><span class=\"line\">            &#125;                                                                                                           </span><br><span class=\"line\">        &#125;                                                                                                               </span><br><span class=\"line\">    &#125;                                                                                                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;                                                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过上面的步骤，我们已经实现了百分之八十的代码，这时，我们还需要考虑几个问题。</p>\n<ul>\n<li><p>位置交换后，我们通过 <code>indexOfChild</code> 或 <code>getChildAt</code> 得到的数据还是原来的，即我们通过调用 <code>addView</code> 添加的顺序。这里我们自己去缓存一个子视图列表，重写上面两个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                             </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOfChild</span><span class=\"params\">(View child)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mChildViews.indexOf(child);</span><br><span class=\"line\">&#125;                                     </span><br><span class=\"line\">                                      </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                             </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">getChildAt</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mChildViews.get(index);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时在视图移动时，去修改这个列表：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mChildViews.set(targetPosition, targetView);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绘制顺序问题，ViewGroup 的默认绘制顺序是根据 <code>addView</code>  的调用顺序，这样会带来一个问题，当你拖拽到比当前拖拽视图更晚添加的子视图时，会显示在这个视图下面，同样我们可以通过 <code>setChildrenDrawingOrderEnabled</code> 和 </p>\n<p><code>getChildDrawingOrder</code> 去自定义绘制顺序，这里为了方便，我们通过设置拖拽视图的 Z 值来实现同样的效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ViewCompat.setZ(capturedChild, <span class=\"number\">100f</span>);     </span><br><span class=\"line\">postInvalidate();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>最后我们顺便把 Item 的点击事件实现下。。。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                 </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onSingleTapConfirmed</span><span class=\"params\">(MotionEvent e)</span> </span>&#123;                                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> View targetView = mDragHelper.findTopChildUnder((<span class=\"keyword\">int</span>) e.getX(), (<span class=\"keyword\">int</span>) e.getY());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetView == <span class=\"keyword\">null</span>) &#123;                                                             </span><br><span class=\"line\">        <span class=\"keyword\">return</span> performClick();                                                            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mGridItemClickListener != <span class=\"keyword\">null</span>) &#123;                                          </span><br><span class=\"line\">        mGridItemClickListener.onClickItem(indexOfChild(targetView), targetView);         </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;                                                                      </span><br><span class=\"line\">    &#125;                                                                                     </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"性能优化第一步","date":"2018-04-19T03:37:45.000Z","_content":"\n## 感谢\n\n[cpu-profiler](https://developer.android.com/studio/profile/cpu-profiler.html)\n\n## 前言\n\n对于有一定 Android 应用开发经验的同学来说，性能优化是避不开的话题，一般来说，Android 上我们常说的性能优化包括，内存优化和界面优化，当然还有电量优化、网络优化等等。性能优化知识的学习是一个长期的过程，也不可能通过一两篇文章就能说的清楚，需要在具有相关的理论知识的前提下，同时在日常开发中加以实践，才能在这方面的工作中得心应手。\n\n同时作者也并不是这方面的大牛，还处于入门学习的阶段，所以也会遇到初学者经常碰到的问题，其中，我个人认为阻碍初学者在这方面深入学习的一个原因是，大部分的文章都偏向于理论知识和工具使用说明，很多同学包括作者在看完这些文章，都有着似懂非懂的感觉，只记住了工具的名称，但等到自己去实际使用时，却不知道如何下手。这也是这个系列文章存在的意义，希望能通过实际例子去使用工具，从而能掌握工具基本的使用，之后在实际开发中，通过经常使用来达到得心应手的地步。\n\n## 例子\n\n作者最近刚接手一个新项目，在首页列表滑动时就感到有点不顺畅，特别是在滑动到有 ViewPager 部分的时候，如果是熟悉的项目，可能会第一时间会去检查代码，但前面说到这个是刚接手的项目，同时首页的代码逻辑比较复杂，不花点时间熟悉下代码可能很难找出问题来，那在这种情况下，我们就只能通过外部工具来检查，快速定位问题。\n\nAndroid Studio 提供了一个非常好用的工具：Android Profiler，基本可以满足大部分的场景了。所以下面的分析我们都基于 Android Profiler。\n\n为了更直观的观察问题，我创建了个 Demo，里面包含了问题代码，首先我们先通过两个 gif 图来看下，没有问题代码之前和加了问题代码之后的运行情况：\n\n![正常](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/source.gif?x-oss-process=style/doc-img)\n\n![问题代码](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/low.gif?x-oss-process=style/doc-img)\n\n上面的 gif 图中，我们先开启了 [GPU 呈现模式分析](https://github.com/LinXiaoTao/notes/blob/master/android/topic/performance/rendering/profile-gpu.md) 后面的文章中我们会说到这个，现在只需要了解横坐标表示应用绘制渲染的每一帧，纵坐标表示每一帧绘制渲染的时间，绿线表示 16.6 ms，也就是要想保持应用能够流畅使用，我们应该让页面绘制渲染时间尽量位于绿线之下。\n\n从第一张动图中可以看到页面每一帧的绘制渲染时间都基本处于绿线之下，而第二章动图加了问题代码之后，出现了不少帧出现了绘制渲染时间过长的情况。\n\n接下来，我们可以使用 Android Profiler 来对应用进行分析，在这个例子中，我们只使用 [cpu-profiler](https://developer.android.com/studio/profile/cpu-profiler.html) 功能。具体介绍可以看官方文档，下面就官方提供的图片简单说下：\n\n![cpu-profiler](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/cpu_profiler_L2-2X.png?x-oss-process=style/doc-img)\n\n这是 cpu-profiler 的主界面，具体各个部分的说明可以阅读官方文档，我们只需要知道这里记录了各个线程的活动状态：\n\n* 绿色：表示线程处于活动状态或准备使用 CPU。 即，它正在“运行中”或处于“可运行”状态。\n* 黄色：表示线程处于活动状态，但它正在等待一个 I/O 操作（如磁盘或网络 I/O），然后才能完成它的工作。\n* 灰色：表示线程正在休眠且没有消耗任何 CPU 时间。 当线程需要访问尚不可用的资源时偶尔会发生这种情况。 线程进入自主休眠或内核将此线程置于休眠状态，直到所需的资源可用。\n\n可以看到标记 5 为一个记录按钮，用于开始和停止记录[函数跟踪](https://developer.android.com/studio/profile/cpu-profiler.html#method_traces)。这个是我们这篇文章所要着重讲的功能，接下来我们看下函数跟踪的功能面板，图片同样来源于官方文档：\n\n![method-traces](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/cpu_profiler_L3-2X.png?x-oss-process=style/doc-img)\n\n使用方式很简单，先点击记录按钮，接着在应用上操作一小会，接着再次按下按钮，结束记录。上图则是记录后的面版：\n\n* 标记 1和标记 2 表示这次函数跟踪的时间段\n* 标记 3 表示函数跟踪的结果，具体展示跟标记 4 所选的展示标签有关\n* 标记 4 则是不同的展示标签\n* 标记 5 则是函数调用的时间信息：\n  * Wall clock time: 壁钟时间信息表示实际经过的时间\n  * Thread time: 线程时间信息表示实际经过的时间减去线程没有消耗 CPU 资源的任意时间部分。 对于任何给定函数，其线程时间始终少于或等于其壁钟时间。 使用线程时间可以让您更好地了解线程的实际 CPU 使用率中有多少是给定函数消耗的\n\n标记 4 中包含的标签包括：Call Chart、Flame Chart、Top Down 和 Bottom Up，具体的含义可以阅读[官方文档](https://developer.android.com/studio/profile/cpu-profiler.html#method_traces)，这里我们同样只是简单解释下：\n\n* Call Chart：函数调用情况的图形化界面。从上至下表示父函数和子函数的调用情况。\n\n  > 这里我们的父函数指的是，调用其他函数的函数，而被调用的函数称为该父函数的子函数。\n\n  ![call-chart](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/call-chart.png?x-oss-process=style/doc-img)\n\n  可以看到，应用的执行开始于 `ZygoteInit.main()` 其中系统 API 的调用表示为橙色，第三方 API 包括 Java 的调用表示为蓝色，应用自有函数的调用表示为绿色。\n\n* Flame Chart：提供一个倒置的调用图表，其汇总相同的调用堆栈，简单来说就是将 Call Chart 倒置过来\n\n  ![flame-chart](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/flame-chart.png?x-oss-process=style/doc-img)\n\n* Top Down：显示一个函数调用列表，在该列表中展开函数节点会被调用的子函数\n\n  ![top-down](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/top-down.png?x-oss-process=style/doc-img)\n\n* Bottom Up：显示一个函数调用列表，在该列表中展开函数节点将显示函数的父函数\n\n  ![bottom-up](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/bottom-up.png?x-oss-process=style/doc-img)\n\n简单了解每个选项的功能后，我们针对上面的 demo 来实践下，这里我们选择 bottom up 选项，从上面图看出，每个函数所展示的信息有：Total（函数总共花费的时间）、%（所占的百分比）、Self（函数自身花费的时间）、%（所占的百分比）、Children（函数所调用的子函数花费的时间），%（所占百分比）。可以看到 `main()` `run()` 这些方法的时间主要都是花费在调用子函数上。那么我们先找出本身最耗时的方法，使用 Self 进行排序：\n\n![max-self-method](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/max-self-method.png?x-oss-process=style/doc-img)\n\n很清楚的看出， `setConfiguration()` 函数是除了 `nativePollOnce()` 之外最耗时的函数，而 `nativePollOnce()` 是系统函数，是 Handle 用于阻塞获取栈中下一个执行的消息，具体可以看另外一篇文章，[Android消息机制-Handler](https://linxiaotao.github.io/2018/03/23/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler/) 所以这个函数我们这里不需要关心它，所以我们打开 `setConfiguration()` 的父函数调用链，可以发现最终指到我们应用自身的函数，即 `MainActivity.getResources()` 这时候，我们就可以找到对应的类和函数，也可以使用快捷跳转方式：\t**Jump To Source**，我们看下具体的函数实现：\n\n``` java\n@Override                                                     \npublic Resources getResources() {                             \n    Resources res = super.getResources();                     \n    Configuration config = new Configuration();               \n    config.setToDefaults();                                   \n    res.updateConfiguration(config, res.getDisplayMetrics()); \n    return res;                                               \n}                                                             \n```\n\n从代码中可以看出，耗时函数就出在 `res.updateConfiguration()`，而 `getResources()` 会在比如 View 的构造函数中或者 inflate 布局时候被调用，我们上面的例子实现的是，使用 ViewPager 去实现图片滑动浏览的效果，ViewPager 在滑动的时候会调用 `instantiateItem()` 函数去生成新的 item：\n\n``` java\n@NonNull                                                                                                         \n@Override                                                                                                        \npublic Object instantiateItem(@NonNull ViewGroup container, int position) {                                      \n    final TextView childView = (TextView) View.inflate(container.getContext(), R.layout.item_image, null);       \n    childView.setText(String.valueOf(position));                                                                 \n    container.addView(childView);                                                                                \n    return childView;                                                                                            \n}                                                                                                                \n```\n\n这里会调用 `inflate()` 从 xml 布局文件中构建 View，而这个函数又会调用 `getResources()` 函数，最终调用到 `setConfiguration()` 上，这也是我们之所以在滑动的时候，会出现卡顿的原因。\n\n## 小结\n\n在上面的例子上，我们不需要去纠结为什么要重载 `getResources()` 而是通过这个例子达到能简单使用 cpu-profiler 的目的。\n\n当然你也可以使用其他工具来检查，比如 [method-trace](https://developer.android.com/studio/profile/am-methodtrace.html) 等等，但最终目的是一样的，找到耗时函数，从而去优化它。\n\n","source":"_posts/性能优化第一步.md","raw":"---\ntitle: 性能优化第一步\ndate: 2018-04-19 11:37:45\ncategories: Android Application\n---\n\n## 感谢\n\n[cpu-profiler](https://developer.android.com/studio/profile/cpu-profiler.html)\n\n## 前言\n\n对于有一定 Android 应用开发经验的同学来说，性能优化是避不开的话题，一般来说，Android 上我们常说的性能优化包括，内存优化和界面优化，当然还有电量优化、网络优化等等。性能优化知识的学习是一个长期的过程，也不可能通过一两篇文章就能说的清楚，需要在具有相关的理论知识的前提下，同时在日常开发中加以实践，才能在这方面的工作中得心应手。\n\n同时作者也并不是这方面的大牛，还处于入门学习的阶段，所以也会遇到初学者经常碰到的问题，其中，我个人认为阻碍初学者在这方面深入学习的一个原因是，大部分的文章都偏向于理论知识和工具使用说明，很多同学包括作者在看完这些文章，都有着似懂非懂的感觉，只记住了工具的名称，但等到自己去实际使用时，却不知道如何下手。这也是这个系列文章存在的意义，希望能通过实际例子去使用工具，从而能掌握工具基本的使用，之后在实际开发中，通过经常使用来达到得心应手的地步。\n\n## 例子\n\n作者最近刚接手一个新项目，在首页列表滑动时就感到有点不顺畅，特别是在滑动到有 ViewPager 部分的时候，如果是熟悉的项目，可能会第一时间会去检查代码，但前面说到这个是刚接手的项目，同时首页的代码逻辑比较复杂，不花点时间熟悉下代码可能很难找出问题来，那在这种情况下，我们就只能通过外部工具来检查，快速定位问题。\n\nAndroid Studio 提供了一个非常好用的工具：Android Profiler，基本可以满足大部分的场景了。所以下面的分析我们都基于 Android Profiler。\n\n为了更直观的观察问题，我创建了个 Demo，里面包含了问题代码，首先我们先通过两个 gif 图来看下，没有问题代码之前和加了问题代码之后的运行情况：\n\n![正常](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/source.gif?x-oss-process=style/doc-img)\n\n![问题代码](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/low.gif?x-oss-process=style/doc-img)\n\n上面的 gif 图中，我们先开启了 [GPU 呈现模式分析](https://github.com/LinXiaoTao/notes/blob/master/android/topic/performance/rendering/profile-gpu.md) 后面的文章中我们会说到这个，现在只需要了解横坐标表示应用绘制渲染的每一帧，纵坐标表示每一帧绘制渲染的时间，绿线表示 16.6 ms，也就是要想保持应用能够流畅使用，我们应该让页面绘制渲染时间尽量位于绿线之下。\n\n从第一张动图中可以看到页面每一帧的绘制渲染时间都基本处于绿线之下，而第二章动图加了问题代码之后，出现了不少帧出现了绘制渲染时间过长的情况。\n\n接下来，我们可以使用 Android Profiler 来对应用进行分析，在这个例子中，我们只使用 [cpu-profiler](https://developer.android.com/studio/profile/cpu-profiler.html) 功能。具体介绍可以看官方文档，下面就官方提供的图片简单说下：\n\n![cpu-profiler](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/cpu_profiler_L2-2X.png?x-oss-process=style/doc-img)\n\n这是 cpu-profiler 的主界面，具体各个部分的说明可以阅读官方文档，我们只需要知道这里记录了各个线程的活动状态：\n\n* 绿色：表示线程处于活动状态或准备使用 CPU。 即，它正在“运行中”或处于“可运行”状态。\n* 黄色：表示线程处于活动状态，但它正在等待一个 I/O 操作（如磁盘或网络 I/O），然后才能完成它的工作。\n* 灰色：表示线程正在休眠且没有消耗任何 CPU 时间。 当线程需要访问尚不可用的资源时偶尔会发生这种情况。 线程进入自主休眠或内核将此线程置于休眠状态，直到所需的资源可用。\n\n可以看到标记 5 为一个记录按钮，用于开始和停止记录[函数跟踪](https://developer.android.com/studio/profile/cpu-profiler.html#method_traces)。这个是我们这篇文章所要着重讲的功能，接下来我们看下函数跟踪的功能面板，图片同样来源于官方文档：\n\n![method-traces](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/cpu_profiler_L3-2X.png?x-oss-process=style/doc-img)\n\n使用方式很简单，先点击记录按钮，接着在应用上操作一小会，接着再次按下按钮，结束记录。上图则是记录后的面版：\n\n* 标记 1和标记 2 表示这次函数跟踪的时间段\n* 标记 3 表示函数跟踪的结果，具体展示跟标记 4 所选的展示标签有关\n* 标记 4 则是不同的展示标签\n* 标记 5 则是函数调用的时间信息：\n  * Wall clock time: 壁钟时间信息表示实际经过的时间\n  * Thread time: 线程时间信息表示实际经过的时间减去线程没有消耗 CPU 资源的任意时间部分。 对于任何给定函数，其线程时间始终少于或等于其壁钟时间。 使用线程时间可以让您更好地了解线程的实际 CPU 使用率中有多少是给定函数消耗的\n\n标记 4 中包含的标签包括：Call Chart、Flame Chart、Top Down 和 Bottom Up，具体的含义可以阅读[官方文档](https://developer.android.com/studio/profile/cpu-profiler.html#method_traces)，这里我们同样只是简单解释下：\n\n* Call Chart：函数调用情况的图形化界面。从上至下表示父函数和子函数的调用情况。\n\n  > 这里我们的父函数指的是，调用其他函数的函数，而被调用的函数称为该父函数的子函数。\n\n  ![call-chart](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/call-chart.png?x-oss-process=style/doc-img)\n\n  可以看到，应用的执行开始于 `ZygoteInit.main()` 其中系统 API 的调用表示为橙色，第三方 API 包括 Java 的调用表示为蓝色，应用自有函数的调用表示为绿色。\n\n* Flame Chart：提供一个倒置的调用图表，其汇总相同的调用堆栈，简单来说就是将 Call Chart 倒置过来\n\n  ![flame-chart](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/flame-chart.png?x-oss-process=style/doc-img)\n\n* Top Down：显示一个函数调用列表，在该列表中展开函数节点会被调用的子函数\n\n  ![top-down](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/top-down.png?x-oss-process=style/doc-img)\n\n* Bottom Up：显示一个函数调用列表，在该列表中展开函数节点将显示函数的父函数\n\n  ![bottom-up](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/bottom-up.png?x-oss-process=style/doc-img)\n\n简单了解每个选项的功能后，我们针对上面的 demo 来实践下，这里我们选择 bottom up 选项，从上面图看出，每个函数所展示的信息有：Total（函数总共花费的时间）、%（所占的百分比）、Self（函数自身花费的时间）、%（所占的百分比）、Children（函数所调用的子函数花费的时间），%（所占百分比）。可以看到 `main()` `run()` 这些方法的时间主要都是花费在调用子函数上。那么我们先找出本身最耗时的方法，使用 Self 进行排序：\n\n![max-self-method](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/max-self-method.png?x-oss-process=style/doc-img)\n\n很清楚的看出， `setConfiguration()` 函数是除了 `nativePollOnce()` 之外最耗时的函数，而 `nativePollOnce()` 是系统函数，是 Handle 用于阻塞获取栈中下一个执行的消息，具体可以看另外一篇文章，[Android消息机制-Handler](https://linxiaotao.github.io/2018/03/23/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler/) 所以这个函数我们这里不需要关心它，所以我们打开 `setConfiguration()` 的父函数调用链，可以发现最终指到我们应用自身的函数，即 `MainActivity.getResources()` 这时候，我们就可以找到对应的类和函数，也可以使用快捷跳转方式：\t**Jump To Source**，我们看下具体的函数实现：\n\n``` java\n@Override                                                     \npublic Resources getResources() {                             \n    Resources res = super.getResources();                     \n    Configuration config = new Configuration();               \n    config.setToDefaults();                                   \n    res.updateConfiguration(config, res.getDisplayMetrics()); \n    return res;                                               \n}                                                             \n```\n\n从代码中可以看出，耗时函数就出在 `res.updateConfiguration()`，而 `getResources()` 会在比如 View 的构造函数中或者 inflate 布局时候被调用，我们上面的例子实现的是，使用 ViewPager 去实现图片滑动浏览的效果，ViewPager 在滑动的时候会调用 `instantiateItem()` 函数去生成新的 item：\n\n``` java\n@NonNull                                                                                                         \n@Override                                                                                                        \npublic Object instantiateItem(@NonNull ViewGroup container, int position) {                                      \n    final TextView childView = (TextView) View.inflate(container.getContext(), R.layout.item_image, null);       \n    childView.setText(String.valueOf(position));                                                                 \n    container.addView(childView);                                                                                \n    return childView;                                                                                            \n}                                                                                                                \n```\n\n这里会调用 `inflate()` 从 xml 布局文件中构建 View，而这个函数又会调用 `getResources()` 函数，最终调用到 `setConfiguration()` 上，这也是我们之所以在滑动的时候，会出现卡顿的原因。\n\n## 小结\n\n在上面的例子上，我们不需要去纠结为什么要重载 `getResources()` 而是通过这个例子达到能简单使用 cpu-profiler 的目的。\n\n当然你也可以使用其他工具来检查，比如 [method-trace](https://developer.android.com/studio/profile/am-methodtrace.html) 等等，但最终目的是一样的，找到耗时函数，从而去优化它。\n\n","slug":"性能优化第一步","published":1,"updated":"2018-11-16T10:20:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs1b0014e39kk7884ref","content":"<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"https://developer.android.com/studio/profile/cpu-profiler.html\" target=\"_blank\" rel=\"noopener\">cpu-profiler</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于有一定 Android 应用开发经验的同学来说，性能优化是避不开的话题，一般来说，Android 上我们常说的性能优化包括，内存优化和界面优化，当然还有电量优化、网络优化等等。性能优化知识的学习是一个长期的过程，也不可能通过一两篇文章就能说的清楚，需要在具有相关的理论知识的前提下，同时在日常开发中加以实践，才能在这方面的工作中得心应手。</p>\n<p>同时作者也并不是这方面的大牛，还处于入门学习的阶段，所以也会遇到初学者经常碰到的问题，其中，我个人认为阻碍初学者在这方面深入学习的一个原因是，大部分的文章都偏向于理论知识和工具使用说明，很多同学包括作者在看完这些文章，都有着似懂非懂的感觉，只记住了工具的名称，但等到自己去实际使用时，却不知道如何下手。这也是这个系列文章存在的意义，希望能通过实际例子去使用工具，从而能掌握工具基本的使用，之后在实际开发中，通过经常使用来达到得心应手的地步。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>作者最近刚接手一个新项目，在首页列表滑动时就感到有点不顺畅，特别是在滑动到有 ViewPager 部分的时候，如果是熟悉的项目，可能会第一时间会去检查代码，但前面说到这个是刚接手的项目，同时首页的代码逻辑比较复杂，不花点时间熟悉下代码可能很难找出问题来，那在这种情况下，我们就只能通过外部工具来检查，快速定位问题。</p>\n<p>Android Studio 提供了一个非常好用的工具：Android Profiler，基本可以满足大部分的场景了。所以下面的分析我们都基于 Android Profiler。</p>\n<p>为了更直观的观察问题，我创建了个 Demo，里面包含了问题代码，首先我们先通过两个 gif 图来看下，没有问题代码之前和加了问题代码之后的运行情况：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/source.gif?x-oss-process=style/doc-img\" alt=\"正常\"></p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/low.gif?x-oss-process=style/doc-img\" alt=\"问题代码\"></p>\n<p>上面的 gif 图中，我们先开启了 <a href=\"https://github.com/LinXiaoTao/notes/blob/master/android/topic/performance/rendering/profile-gpu.md\" target=\"_blank\" rel=\"noopener\">GPU 呈现模式分析</a> 后面的文章中我们会说到这个，现在只需要了解横坐标表示应用绘制渲染的每一帧，纵坐标表示每一帧绘制渲染的时间，绿线表示 16.6 ms，也就是要想保持应用能够流畅使用，我们应该让页面绘制渲染时间尽量位于绿线之下。</p>\n<p>从第一张动图中可以看到页面每一帧的绘制渲染时间都基本处于绿线之下，而第二章动图加了问题代码之后，出现了不少帧出现了绘制渲染时间过长的情况。</p>\n<p>接下来，我们可以使用 Android Profiler 来对应用进行分析，在这个例子中，我们只使用 <a href=\"https://developer.android.com/studio/profile/cpu-profiler.html\" target=\"_blank\" rel=\"noopener\">cpu-profiler</a> 功能。具体介绍可以看官方文档，下面就官方提供的图片简单说下：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/cpu_profiler_L2-2X.png?x-oss-process=style/doc-img\" alt=\"cpu-profiler\"></p>\n<p>这是 cpu-profiler 的主界面，具体各个部分的说明可以阅读官方文档，我们只需要知道这里记录了各个线程的活动状态：</p>\n<ul>\n<li>绿色：表示线程处于活动状态或准备使用 CPU。 即，它正在“运行中”或处于“可运行”状态。</li>\n<li>黄色：表示线程处于活动状态，但它正在等待一个 I/O 操作（如磁盘或网络 I/O），然后才能完成它的工作。</li>\n<li>灰色：表示线程正在休眠且没有消耗任何 CPU 时间。 当线程需要访问尚不可用的资源时偶尔会发生这种情况。 线程进入自主休眠或内核将此线程置于休眠状态，直到所需的资源可用。</li>\n</ul>\n<p>可以看到标记 5 为一个记录按钮，用于开始和停止记录<a href=\"https://developer.android.com/studio/profile/cpu-profiler.html#method_traces\" target=\"_blank\" rel=\"noopener\">函数跟踪</a>。这个是我们这篇文章所要着重讲的功能，接下来我们看下函数跟踪的功能面板，图片同样来源于官方文档：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/cpu_profiler_L3-2X.png?x-oss-process=style/doc-img\" alt=\"method-traces\"></p>\n<p>使用方式很简单，先点击记录按钮，接着在应用上操作一小会，接着再次按下按钮，结束记录。上图则是记录后的面版：</p>\n<ul>\n<li>标记 1和标记 2 表示这次函数跟踪的时间段</li>\n<li>标记 3 表示函数跟踪的结果，具体展示跟标记 4 所选的展示标签有关</li>\n<li>标记 4 则是不同的展示标签</li>\n<li>标记 5 则是函数调用的时间信息：<ul>\n<li>Wall clock time: 壁钟时间信息表示实际经过的时间</li>\n<li>Thread time: 线程时间信息表示实际经过的时间减去线程没有消耗 CPU 资源的任意时间部分。 对于任何给定函数，其线程时间始终少于或等于其壁钟时间。 使用线程时间可以让您更好地了解线程的实际 CPU 使用率中有多少是给定函数消耗的</li>\n</ul>\n</li>\n</ul>\n<p>标记 4 中包含的标签包括：Call Chart、Flame Chart、Top Down 和 Bottom Up，具体的含义可以阅读<a href=\"https://developer.android.com/studio/profile/cpu-profiler.html#method_traces\" target=\"_blank\" rel=\"noopener\">官方文档</a>，这里我们同样只是简单解释下：</p>\n<ul>\n<li><p>Call Chart：函数调用情况的图形化界面。从上至下表示父函数和子函数的调用情况。</p>\n<blockquote>\n<p>这里我们的父函数指的是，调用其他函数的函数，而被调用的函数称为该父函数的子函数。</p>\n</blockquote>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/call-chart.png?x-oss-process=style/doc-img\" alt=\"call-chart\"></p>\n<p>可以看到，应用的执行开始于 <code>ZygoteInit.main()</code> 其中系统 API 的调用表示为橙色，第三方 API 包括 Java 的调用表示为蓝色，应用自有函数的调用表示为绿色。</p>\n</li>\n<li><p>Flame Chart：提供一个倒置的调用图表，其汇总相同的调用堆栈，简单来说就是将 Call Chart 倒置过来</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/flame-chart.png?x-oss-process=style/doc-img\" alt=\"flame-chart\"></p>\n</li>\n<li><p>Top Down：显示一个函数调用列表，在该列表中展开函数节点会被调用的子函数</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/top-down.png?x-oss-process=style/doc-img\" alt=\"top-down\"></p>\n</li>\n<li><p>Bottom Up：显示一个函数调用列表，在该列表中展开函数节点将显示函数的父函数</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/bottom-up.png?x-oss-process=style/doc-img\" alt=\"bottom-up\"></p>\n</li>\n</ul>\n<p>简单了解每个选项的功能后，我们针对上面的 demo 来实践下，这里我们选择 bottom up 选项，从上面图看出，每个函数所展示的信息有：Total（函数总共花费的时间）、%（所占的百分比）、Self（函数自身花费的时间）、%（所占的百分比）、Children（函数所调用的子函数花费的时间），%（所占百分比）。可以看到 <code>main()</code> <code>run()</code> 这些方法的时间主要都是花费在调用子函数上。那么我们先找出本身最耗时的方法，使用 Self 进行排序：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/max-self-method.png?x-oss-process=style/doc-img\" alt=\"max-self-method\"></p>\n<p>很清楚的看出， <code>setConfiguration()</code> 函数是除了 <code>nativePollOnce()</code> 之外最耗时的函数，而 <code>nativePollOnce()</code> 是系统函数，是 Handle 用于阻塞获取栈中下一个执行的消息，具体可以看另外一篇文章，<a href=\"https://linxiaotao.github.io/2018/03/23/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler/\">Android消息机制-Handler</a> 所以这个函数我们这里不需要关心它，所以我们打开 <code>setConfiguration()</code> 的父函数调用链，可以发现最终指到我们应用自身的函数，即 <code>MainActivity.getResources()</code> 这时候，我们就可以找到对应的类和函数，也可以使用快捷跳转方式：    <strong>Jump To Source</strong>，我们看下具体的函数实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                     </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resources <span class=\"title\">getResources</span><span class=\"params\">()</span> </span>&#123;                             </span><br><span class=\"line\">    Resources res = <span class=\"keyword\">super</span>.getResources();                     </span><br><span class=\"line\">    Configuration config = <span class=\"keyword\">new</span> Configuration();               </span><br><span class=\"line\">    config.setToDefaults();                                   </span><br><span class=\"line\">    res.updateConfiguration(config, res.getDisplayMetrics()); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码中可以看出，耗时函数就出在 <code>res.updateConfiguration()</code>，而 <code>getResources()</code> 会在比如 View 的构造函数中或者 inflate 布局时候被调用，我们上面的例子实现的是，使用 ViewPager 去实现图片滑动浏览的效果，ViewPager 在滑动的时候会调用 <code>instantiateItem()</code> 函数去生成新的 item：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                                                         </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">instantiateItem</span><span class=\"params\">(@NonNull ViewGroup container, <span class=\"keyword\">int</span> position)</span> </span>&#123;                                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> TextView childView = (TextView) View.inflate(container.getContext(), R.layout.item_image, <span class=\"keyword\">null</span>);       </span><br><span class=\"line\">    childView.setText(String.valueOf(position));                                                                 </span><br><span class=\"line\">    container.addView(childView);                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> childView;                                                                                            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里会调用 <code>inflate()</code> 从 xml 布局文件中构建 View，而这个函数又会调用 <code>getResources()</code> 函数，最终调用到 <code>setConfiguration()</code> 上，这也是我们之所以在滑动的时候，会出现卡顿的原因。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在上面的例子上，我们不需要去纠结为什么要重载 <code>getResources()</code> 而是通过这个例子达到能简单使用 cpu-profiler 的目的。</p>\n<p>当然你也可以使用其他工具来检查，比如 <a href=\"https://developer.android.com/studio/profile/am-methodtrace.html\" target=\"_blank\" rel=\"noopener\">method-trace</a> 等等，但最终目的是一样的，找到耗时函数，从而去优化它。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"https://developer.android.com/studio/profile/cpu-profiler.html\" target=\"_blank\" rel=\"noopener\">cpu-profiler</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于有一定 Android 应用开发经验的同学来说，性能优化是避不开的话题，一般来说，Android 上我们常说的性能优化包括，内存优化和界面优化，当然还有电量优化、网络优化等等。性能优化知识的学习是一个长期的过程，也不可能通过一两篇文章就能说的清楚，需要在具有相关的理论知识的前提下，同时在日常开发中加以实践，才能在这方面的工作中得心应手。</p>\n<p>同时作者也并不是这方面的大牛，还处于入门学习的阶段，所以也会遇到初学者经常碰到的问题，其中，我个人认为阻碍初学者在这方面深入学习的一个原因是，大部分的文章都偏向于理论知识和工具使用说明，很多同学包括作者在看完这些文章，都有着似懂非懂的感觉，只记住了工具的名称，但等到自己去实际使用时，却不知道如何下手。这也是这个系列文章存在的意义，希望能通过实际例子去使用工具，从而能掌握工具基本的使用，之后在实际开发中，通过经常使用来达到得心应手的地步。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>作者最近刚接手一个新项目，在首页列表滑动时就感到有点不顺畅，特别是在滑动到有 ViewPager 部分的时候，如果是熟悉的项目，可能会第一时间会去检查代码，但前面说到这个是刚接手的项目，同时首页的代码逻辑比较复杂，不花点时间熟悉下代码可能很难找出问题来，那在这种情况下，我们就只能通过外部工具来检查，快速定位问题。</p>\n<p>Android Studio 提供了一个非常好用的工具：Android Profiler，基本可以满足大部分的场景了。所以下面的分析我们都基于 Android Profiler。</p>\n<p>为了更直观的观察问题，我创建了个 Demo，里面包含了问题代码，首先我们先通过两个 gif 图来看下，没有问题代码之前和加了问题代码之后的运行情况：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/source.gif?x-oss-process=style/doc-img\" alt=\"正常\"></p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/low.gif?x-oss-process=style/doc-img\" alt=\"问题代码\"></p>\n<p>上面的 gif 图中，我们先开启了 <a href=\"https://github.com/LinXiaoTao/notes/blob/master/android/topic/performance/rendering/profile-gpu.md\" target=\"_blank\" rel=\"noopener\">GPU 呈现模式分析</a> 后面的文章中我们会说到这个，现在只需要了解横坐标表示应用绘制渲染的每一帧，纵坐标表示每一帧绘制渲染的时间，绿线表示 16.6 ms，也就是要想保持应用能够流畅使用，我们应该让页面绘制渲染时间尽量位于绿线之下。</p>\n<p>从第一张动图中可以看到页面每一帧的绘制渲染时间都基本处于绿线之下，而第二章动图加了问题代码之后，出现了不少帧出现了绘制渲染时间过长的情况。</p>\n<p>接下来，我们可以使用 Android Profiler 来对应用进行分析，在这个例子中，我们只使用 <a href=\"https://developer.android.com/studio/profile/cpu-profiler.html\" target=\"_blank\" rel=\"noopener\">cpu-profiler</a> 功能。具体介绍可以看官方文档，下面就官方提供的图片简单说下：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/cpu_profiler_L2-2X.png?x-oss-process=style/doc-img\" alt=\"cpu-profiler\"></p>\n<p>这是 cpu-profiler 的主界面，具体各个部分的说明可以阅读官方文档，我们只需要知道这里记录了各个线程的活动状态：</p>\n<ul>\n<li>绿色：表示线程处于活动状态或准备使用 CPU。 即，它正在“运行中”或处于“可运行”状态。</li>\n<li>黄色：表示线程处于活动状态，但它正在等待一个 I/O 操作（如磁盘或网络 I/O），然后才能完成它的工作。</li>\n<li>灰色：表示线程正在休眠且没有消耗任何 CPU 时间。 当线程需要访问尚不可用的资源时偶尔会发生这种情况。 线程进入自主休眠或内核将此线程置于休眠状态，直到所需的资源可用。</li>\n</ul>\n<p>可以看到标记 5 为一个记录按钮，用于开始和停止记录<a href=\"https://developer.android.com/studio/profile/cpu-profiler.html#method_traces\" target=\"_blank\" rel=\"noopener\">函数跟踪</a>。这个是我们这篇文章所要着重讲的功能，接下来我们看下函数跟踪的功能面板，图片同样来源于官方文档：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/cpu_profiler_L3-2X.png?x-oss-process=style/doc-img\" alt=\"method-traces\"></p>\n<p>使用方式很简单，先点击记录按钮，接着在应用上操作一小会，接着再次按下按钮，结束记录。上图则是记录后的面版：</p>\n<ul>\n<li>标记 1和标记 2 表示这次函数跟踪的时间段</li>\n<li>标记 3 表示函数跟踪的结果，具体展示跟标记 4 所选的展示标签有关</li>\n<li>标记 4 则是不同的展示标签</li>\n<li>标记 5 则是函数调用的时间信息：<ul>\n<li>Wall clock time: 壁钟时间信息表示实际经过的时间</li>\n<li>Thread time: 线程时间信息表示实际经过的时间减去线程没有消耗 CPU 资源的任意时间部分。 对于任何给定函数，其线程时间始终少于或等于其壁钟时间。 使用线程时间可以让您更好地了解线程的实际 CPU 使用率中有多少是给定函数消耗的</li>\n</ul>\n</li>\n</ul>\n<p>标记 4 中包含的标签包括：Call Chart、Flame Chart、Top Down 和 Bottom Up，具体的含义可以阅读<a href=\"https://developer.android.com/studio/profile/cpu-profiler.html#method_traces\" target=\"_blank\" rel=\"noopener\">官方文档</a>，这里我们同样只是简单解释下：</p>\n<ul>\n<li><p>Call Chart：函数调用情况的图形化界面。从上至下表示父函数和子函数的调用情况。</p>\n<blockquote>\n<p>这里我们的父函数指的是，调用其他函数的函数，而被调用的函数称为该父函数的子函数。</p>\n</blockquote>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/call-chart.png?x-oss-process=style/doc-img\" alt=\"call-chart\"></p>\n<p>可以看到，应用的执行开始于 <code>ZygoteInit.main()</code> 其中系统 API 的调用表示为橙色，第三方 API 包括 Java 的调用表示为蓝色，应用自有函数的调用表示为绿色。</p>\n</li>\n<li><p>Flame Chart：提供一个倒置的调用图表，其汇总相同的调用堆栈，简单来说就是将 Call Chart 倒置过来</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/flame-chart.png?x-oss-process=style/doc-img\" alt=\"flame-chart\"></p>\n</li>\n<li><p>Top Down：显示一个函数调用列表，在该列表中展开函数节点会被调用的子函数</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/top-down.png?x-oss-process=style/doc-img\" alt=\"top-down\"></p>\n</li>\n<li><p>Bottom Up：显示一个函数调用列表，在该列表中展开函数节点将显示函数的父函数</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/bottom-up.png?x-oss-process=style/doc-img\" alt=\"bottom-up\"></p>\n</li>\n</ul>\n<p>简单了解每个选项的功能后，我们针对上面的 demo 来实践下，这里我们选择 bottom up 选项，从上面图看出，每个函数所展示的信息有：Total（函数总共花费的时间）、%（所占的百分比）、Self（函数自身花费的时间）、%（所占的百分比）、Children（函数所调用的子函数花费的时间），%（所占百分比）。可以看到 <code>main()</code> <code>run()</code> 这些方法的时间主要都是花费在调用子函数上。那么我们先找出本身最耗时的方法，使用 Self 进行排序：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/max-self-method.png?x-oss-process=style/doc-img\" alt=\"max-self-method\"></p>\n<p>很清楚的看出， <code>setConfiguration()</code> 函数是除了 <code>nativePollOnce()</code> 之外最耗时的函数，而 <code>nativePollOnce()</code> 是系统函数，是 Handle 用于阻塞获取栈中下一个执行的消息，具体可以看另外一篇文章，<a href=\"https://linxiaotao.github.io/2018/03/23/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler/\">Android消息机制-Handler</a> 所以这个函数我们这里不需要关心它，所以我们打开 <code>setConfiguration()</code> 的父函数调用链，可以发现最终指到我们应用自身的函数，即 <code>MainActivity.getResources()</code> 这时候，我们就可以找到对应的类和函数，也可以使用快捷跳转方式：    <strong>Jump To Source</strong>，我们看下具体的函数实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>                                                     </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resources <span class=\"title\">getResources</span><span class=\"params\">()</span> </span>&#123;                             </span><br><span class=\"line\">    Resources res = <span class=\"keyword\">super</span>.getResources();                     </span><br><span class=\"line\">    Configuration config = <span class=\"keyword\">new</span> Configuration();               </span><br><span class=\"line\">    config.setToDefaults();                                   </span><br><span class=\"line\">    res.updateConfiguration(config, res.getDisplayMetrics()); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码中可以看出，耗时函数就出在 <code>res.updateConfiguration()</code>，而 <code>getResources()</code> 会在比如 View 的构造函数中或者 inflate 布局时候被调用，我们上面的例子实现的是，使用 ViewPager 去实现图片滑动浏览的效果，ViewPager 在滑动的时候会调用 <code>instantiateItem()</code> 函数去生成新的 item：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span>                                                                                                         </span><br><span class=\"line\"><span class=\"meta\">@Override</span>                                                                                                        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">instantiateItem</span><span class=\"params\">(@NonNull ViewGroup container, <span class=\"keyword\">int</span> position)</span> </span>&#123;                                      </span><br><span class=\"line\">    <span class=\"keyword\">final</span> TextView childView = (TextView) View.inflate(container.getContext(), R.layout.item_image, <span class=\"keyword\">null</span>);       </span><br><span class=\"line\">    childView.setText(String.valueOf(position));                                                                 </span><br><span class=\"line\">    container.addView(childView);                                                                                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> childView;                                                                                            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里会调用 <code>inflate()</code> 从 xml 布局文件中构建 View，而这个函数又会调用 <code>getResources()</code> 函数，最终调用到 <code>setConfiguration()</code> 上，这也是我们之所以在滑动的时候，会出现卡顿的原因。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在上面的例子上，我们不需要去纠结为什么要重载 <code>getResources()</code> 而是通过这个例子达到能简单使用 cpu-profiler 的目的。</p>\n<p>当然你也可以使用其他工具来检查，比如 <a href=\"https://developer.android.com/studio/profile/am-methodtrace.html\" target=\"_blank\" rel=\"noopener\">method-trace</a> 等等，但最终目的是一样的，找到耗时函数，从而去优化它。</p>\n"},{"title":"熟悉又陌生的Context","date":"2018-04-12T02:45:36.000Z","_content":"\n## 感谢\n\n[android-context](http://gityuan.com/2017/04/09/android_context/)\n\n## 概述\n\n> 本文中涉及的源码分析都是基于 Android 27\n\nContext 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 `getResources()` 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：\n\n![Context](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/Context.png?x-oss-process=style/doc-img)\n\n其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：\n\n``` java\npublic ContextWrapper(Context base) {\n\tmBase = base;\n}\n\n@Override\npublic void startActivity(Intent intent) {\n    mBase.startActivity(intent);\n}\n```\n\n通过在构造函数中将 ContextImpl 实例赋值给 `mBase`，然后在比如 `startActivity` 等方法实现中，将调用转发给 `mBase`，至于 `mBase` 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。\n\n通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。\n\n## Context初始化\n\n### Activity\n\n在前面的 [Activity 启动分析](https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/)中，我们知道 Activity 启动方法是 `ActivityThread.performLaunchActivity()`\n\n``` java\nprivate void performLaunchActivity() {\n    // 初始化 LoadedApk\n    if (r.packageInfo == null) {\n    \tr.packageInfo = getPackageInfo();\n    }\n    \n    // 创建 ContextImpl 实例\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n    } catch (Exception e) {\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        appContext.setOuterContext(activity);\n        activity.attach();\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n首先获取 LoadedApk 实例，接着调用 `createBaseContextForActivity()` 创建 ContextImpl 实例，之前我们提到 ContextWrapper 是将 Context 核心功能转发给 ContextImpl 实现的，而 `ContextWrapper.mBase` 的赋值，在 Activity 启动流程中，是通过调用 `Activity.attach()` 实现，这个我们在后面的分析中可以知道。\n\n#### create \n\n``` java\nprivate ComtextImpl createBaseContextForActivity() {\n    final int displayId;\n    try {\n        displayId = ActivityManager.getService().getActivityDisplayId(r.token);\n    } catch (RemoteException e) {\n        \n    }\n    \n    ContextImpl appContext = ContextImpl.createActivityContext();\n}\n```\n\n``` java\nstatic ContextImpl createActivityContext() {\n    ContextImpl context = new ContextImpl();\n    \n    // Activity Resource\n    final ResourcesManager resourcesManager = ResourcesManager.getInstance();\n    context.setResources(resourcesManager.createBaseActivityResources(activityToken,\n                packageInfo.getResDir(),\n                splitDirs,\n                packageInfo.getOverlayDirs(),\n                packageInfo.getApplicationInfo().sharedLibraryFiles,\n                displayId,\n                overrideConfiguration,\n                compatInfo,\n                classLoader));\n    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,\n                context.getResources());\n}\n```\n\n#### attach\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n}\n```\n\n``` java\nprotected void attachBaseContext() {\n    super.attachBaseContext(newBase);\n}\n```\n\n这个步骤比较简单，最终也是调用 `ContextWrapper.attachBaseContext()`\n\n### Service\n\nService 的创建是在 `ActivityThread.handleCreateService()`\n\n``` java\n// 初始化 LoadedApk\nLoadedApk packageInfo = getPackageInfoNoCheck();\n\nService service = null;\ntry {\n    java.lang.ClassLoader cl = packageInfo.getClassLoader();\n    // 通过反射实例化 Service\n    service = (Service) cl.loadClass(data.info.name).newInstance();\n} catch (Exception e) {\n    \n}\n\ntry {\n    ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n    context.setOuterContext(service);\n    \n    Application app = packageInfo.makeApplication(false, mInstrumentation);\n    service.attach();\n} catch (Exception e) {\n    \n}\n```\n\nService 的 Context 初始化流程和 Activity 是差不多，相同的 LoadedApk -> ContextImpl -> attach\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    // Service 的 Resources 相对于 Activity 是比较简单的\n    context.setResources(packageInfo.getResources());\n    return context;\n}\n```\n\n#### attach\n\n``` java\npublic final void attach() {\n    attachBaseContext(context);\n}\n```\n\nService 的 attach 和 Activity 相同，都是调用 `ContextWrapper.attachBaseContext()`\n\n### Application\n\nApplication 的创建是在 `LoadedApk.makeApplication()` \n\n``` java\npublic Application makeApplication() {\n    // 保持单例\n    if (mApplication != null) {\n    \treturn mApplication;\n    }\n    Application app = null;\n    String appClass = mApplicationInfo.className;\n    if (forceDefaultAppClass || (appClass == null)) {\n        // 如果强制使用默认 Application，或者没有实现自定义 Application\n    \tappClass = \"android.app.Application\";\n    }\n    try {\n        java.lang.ClassLoader cl = getClassLoader();\n        if (!mPackageName.equals(\"android\")) {\n            // 包名不是 \"android\"，即非系统进程\n        \tinitializeJavaContextClassLoader();\n        }\n        // 创建 ContextImpl 实例\n        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n        // 创建 Application 实例\n    \tapp = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n    \tappContext.setOuterContext(app);\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n咋一看好像 Application 的流程和其他两个不太相同，其实 Application 的 attach 是在 `Instrumentation.newApplication()`\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    context.setResources(packageInfo.getResources());\n}\n```\n\n#### attach\n\n``` java\npublic static Application newApplication() {\n    // 反射获取实例\n    Application app = (Application)clazz.newInstance();\n    app.attach(context);\n    return app;\n}\n```\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;\n}\n```\n\n### 小结\n\n Activity、Service、Application 的 Context 初始化流程大致是这样，首先创建 ContextImpl 实例，接着调用 `ContextWrapper.attachBaseContext()` 赋值给 `mBase`，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。\n\n## 实践\n\n通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过对实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。\n\n### View Context\n\n#### 问题\n\n我们知道可以通过调用 `View.getContext()` 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。\n\n#### 分析\n\n首先我们对 View 的 `mContext` 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。\n\n如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：\n\n``` java\nLayoutInflater layoutInflater = LayoutInflater.from(context);\nView view = layoutInflater.inflate(R.layout.xxx,null);\n```\n\n首先我们看下 `LayoutInflater.from()`：\n\n``` java\npublic static LayoutInflater from(Context context) {\nLayoutInflater LayoutInflater =\t\t  (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    if (LayoutInflater == null) {\n        throw new AssertionError(\"LayoutInflater not found.\");\n    }\n    return LayoutInflater;\n}\n```\n\n在前面，我们提到 Context 的核心方法都转发给 `mBase` 即 ContextImpl 实例，所以看下 ContextImpl 类的实现：\n\n``` java\npublic Object getSystemService(String name) {\n    return SystemServiceRegistry.getSystemService(this, name);\n}\n\npublic static Object getSystemService(ContextImpl ctx, String name) {\n    ServiceFetcher<?> fetcher = SYSTEM_SERVICE_FETCHERS.get(name);\n    return fetcher != null ? fetcher.getService(ctx) : null;\n}\n```\n\n可以看到最终的调用都转发给了 ServiceFetcher，而 `SYSTEM_SERVICE_FETCHERS` 则是存储着各个类型的 Fetcher 的实例\n\n``` java\n// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name->Fetcher\nprivate static final HashMap<String, ServiceFetcher<?>> SYSTEM_SERVICE_FETCHERS =\n            new HashMap<String, ServiceFetcher<?>>();\n// 存储 Class->Name\nprivate static final HashMap<Class<?>, String> SYSTEM_SERVICE_NAMES =\n            new HashMap<Class<?>, String>();\n\nprivate static <T> void registerService(String serviceName, Class<T> serviceClass,\n            ServiceFetcher<T> serviceFetcher) {\n    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);\n    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);\n}\n```\n\n`SYSTEM_SERVICE_FETCHERS` 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 `registerService()`，这里我们只关心 LayoutInflater 的注册：\n\n``` java\nregisterService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,\n        new CachedServiceFetcher<LayoutInflater>() {                  \n    @Override                                                         \n    public LayoutInflater createService(ContextImpl ctx) {            \n        return new PhoneLayoutInflater(ctx.getOuterContext());        \n    }});                                                              \n```\n\nLayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 只是简单的继承 LayoutInflater，核心代码都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 `CachedServiceFetcher.getService()`\n\n``` java\npublic final T getService(ContextImpl ctx) {\n    final Object[] cache = ctx.mServiceCache;\n    synchronized (cache) {\n        Object service = cache[mCacheIndex];\n        if (service == null) {\n            try {\n                service = createService(ctx);\n                cache[mCacheIndex] = service;\n            } catch (ServiceNotFoundException e) {\n                \n            }\n        }\n        return (T)service;\n    }\n}\n```\n\n注意到，Service 的缓存是存储在 `ContextImpl.mServiceCache` 并且该字段不是静态的，即**Service 的缓存是针对于相同的 Context 实例的**，如果不存在缓存，那么调用 `createService()`，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：\n\n```java\n// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application\nreturn new PhoneLayoutInflater(ctx.getOuterContext()); \n```\n\n而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：\n\n``` java\nprotected LayoutInflater(Context context) {\n    // 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到\n    mContext = context;\n}\n```\n\n接下来我们看下 `inflate()` 源码：\n\n``` java\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n```\n\n``` java\npublic View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n    synchronized (mConstructorArgs) {\n        // mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了\n        final Context inflaterContext = mContext;\n        final AttributeSet attrs = Xml.asAttributeSet(parser);\n    \tContext lastContext = (Context) mConstructorArgs[0];\n        mConstructorArgs[0] = inflaterContext;\n        View result = root;\n        \n        try {\n            // 解析 xml 中的节点\n            \n            final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n        } catch () {\n            \n        } finally {\n            mConstructorArgs[0] = lastContext;\n            mConstructorArgs[1] = null;\n        }\n        \n        return result;\n    }\n}\n    \n```\n\n`inflater()` 就是对 xml 布局进行解析，接着实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 `createViewFromTag()` 它是根据标签名称去实例化具体的 View 实例\n\n``` java\nView createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n            boolean ignoreThemeAttr) {\n    if (name.equals(\"view\")) {\n        // 如果我们使用 view 标签则从 class 属性中获取具体类名称\n        name = attrs.getAttributeValue(null, \"class\");\n    }\n    \n    if (!ignoreThemeAttr) {\n        // 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性\n        // 获取设置的 theme 属性值\n        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);\n    \tfinal int themeResId = ta.getResourceId(0, 0);\n        if (themeResId != 0) {\n            // 如果设置了，则将 context 包装成 ContextThemeWrapper\n            // 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性\n            context = new ContextThemeWrapper(context, themeResId);\n        }\n        ta.recycle();\n    }\n    \n    try {\n        View view;\n        \n        // Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView\n        if (mFactory2 != null) {\n        \tview = mFactory2.onCreateView(parent, name, context, attrs);\n        } else if (mFactory != null) {\n            view = mFactory.onCreateView(name, context, attrs);\n        } else {\n            view = null;\n        }\n        \n        if (view == null && mPrivateFactory != null) {\n        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);\n        }\n        \n        if (view == null) {\n            final Object lastContext = mConstructorArgs[0];\n            mConstructorArgs[0] = context;\n            try {\n                if (-1 == name.indexOf('.')) {\n                    // 系统控件\n                    view = onCreateView(parent, name, attrs);\n                } else {\n                    // 自定义控件\n                    view = createView(name, null, attrs);\n                }\n            } finally {\n                mConstructorArgs[0] = lastContext;\n            }\n        }\n        \n        return view;\n    } catch () {\n        \n    }\n}\n```\n\n不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 `createView()`\n\n``` java\npublic final View createView(String name, String prefix, AttributeSet attrs){\n\t// 缓存构造函数\n    Constructor<? extends View> constructor = sConstructorMap.get(name);\n    // 检查构造函数类加载器\n    if (constructor != null && !verifyClassLoader(constructor)){\n        constructor = null;\n        sConstructorMap.remove(name);\n    }\n    Class<? extends View> clazz = null;\n    try {\n        \n        // 获取 View 构造函数实例，并处理过滤情况\n        if (constructor == null) {\n        \tclazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n        \n            if (mFilter != null && clazz != null) {\n            // 检查是否过滤\n        \tboolean allowed = mFilter.onLoadClass(clazz);\n            if (!allowed) {\n                failNotAllowed(name, prefix, attrs);\n            }\n            }\n            constructor = clazz.getConstructor(mConstructorSignature);\n            constructor.setAccessible(true);\n            sConstructorMap.put(name, constructor);\n        } else {\n            if (mFilter != null) {\n                // 存在过滤器\n                Boolean allowedState = mFilterMap.get(name);\n                if (allowedState == null) {\n                    // 没有缓存过滤结果，新的类\n                    clazz = mContext.getClassLoader().loadClass(                            \n                    prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \tboolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                \tmFilterMap.put(name, allowed);\n                    if (!allowed) {\n                    \tfailNotAllowed(name, prefix, attrs);\n                    }\n                } else if (allowedState.equals(Boolean.FALSE)) {\n                    failNotAllowed(name, prefix, attrs);\n                } \n            }\n        }\n        \n        Object lastContext = mConstructorArgs[0];\n        if (mConstructorArgs[0] == null) {\n            // 如果还没设置 context 参数\n            mConstructorArgs[0] = mContext;\n        }\n        Object[] args = mConstructorArgs;\n        args[1] = attrs;\n        // 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知\n        final View view = constructor.newInstance(args); \n        if (view instanceof ViewStub) {\n            // 使用相同的 Context 处理 ViewStub\n            final ViewStub viewStub = (ViewStub) view;\n            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n        }\n        mConstructorArgs[0] = lastContext;\n        return view;\n    } catech () {\n        \n    }\n}\n```\n\n最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同的地方，我们先通过一个例子来看下效果：\n\n``` java\nprotected void onCreate(Bundle savedInstanceState) {\n    // 使用两种 Context 创建两个 EditText\n    addEditText(this);                   \n\taddEditText(getApplicationContext());\n}\nprivate void addEditText(@Nullable Context context) { \n                                                      \n    if (mRootLayout == null) {                        \n        return;                                       \n    }                                                 \n                                                      \n    if (context == null) {                            \n        return;                                       \n    }                                                 \n                                                                                                       \n    EditText editText = new EditText(context);        \n    mRootLayout.addView(editText);                    \n    editText.setText(context.toString());                                                               \n}                                                     \n```\n\n代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题\n\n``` xml\n<Applicatin \n  android:theme=\"@style/AppTheme\">\n</Applicatin>\n\n<item name=\"colorAccent\">@color/colorAccent</item>\n<color name=\"colorAccent\">#FF4081</color>\n```\n\n![ActivityContextEditText](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/ActivityContextEditText.png?x-oss-process=style/doc-img)\n\n![ApplicationContextEditText](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/ApplicationContextEditText.png?x-oss-process=style/doc-img)\n\n我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：\n\n``` java\npublic Resources.Theme getTheme() {\n    if (mTheme != null) {\n        return mTheme;\n    }\n    if (mThemeResource == 0) {\n        mThemeResource = R.style.Theme_AppCompat_Light;\n    }\n    initializeTheme();\n    return mTheme;\n}\n\nprivate void initializeTheme() {\n    final boolean first = mTheme == null;\n    if (first) {\n        mTheme = getResources().newTheme();\n        Resources.Theme theme = getBaseContext().getTheme();\n        if (theme != null) {\n            mTheme.setTo(theme);\n        }\n    }\n    onApplyThemeResource(mTheme, mThemeResource, first);\n}\n\nprotected void onApplyThemeResource(Resources.Theme theme, int resid, boolean first) {\n    theme.applyStyle(resid, true);\n}\n```\n\n`mTheme` 和 `mThemeResource` 都可以通过构造方法和 set 方法进行赋值，假设没有给 `mTheme` 赋值，只给 `mThemeResource` 赋值，那么上面的代码将 `mThemeSource` 应用到 `ContextWrapper.getTheme()` 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 `ActivityThread.performLaunchActivity()` 中，其中涉及 Theme 的赋值是：\n\n``` java\nint theme = r.activityInfo.getThemeResource();\nif (theme != 0) {\n    activity.setTheme(theme);\n}\n```\n\n现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。\n\n#### 小结\n\n通过上面的源码分析，我们可以知道：\n\n1. 当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 `View(Context,AttributeSet)` 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。\n2. Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。\n\n### getApplication()和getApplicatinContext()\n\n**接下来的分析参考于 [android-context](http://gityuan.com/2017/04/09/android_context/)**\n\n绝大数情况下，这两个方法的返回值是一样。\n\n`getApplicationContext()` 的存在是 Android 历史原因，`getApplication()` 这个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 `getApplicationContext()`。\n\n两者对比：\n\n1. 对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过\n2. BroadcastReceiver 只能通过 `getApplicationContext()` 获取 Application 实例\n3. ContentProvider 也只能通过 `getApplicationContext()` 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 `getApplicationContext()` 则会返回空。\n\n#### 小结\n\n绝大数情况下，`getApplication()` 和 `getApplicationContext()` 返回是一样的，但如果不是特别熟悉，最好对 `getApplicationContext()` 进行空值判断。\n\n### Dialog Context\n\n我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：\n\n```\nCaused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?\n```\n\n### start Activity\n\n通过调用 `startActivity()` 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 `startActivity()` 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：\n\n在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记的话，则会抛出以下异常：\n\n```\nCaused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?\n```\n\nAndroid 26 上 ContextImpl 的相关代码如下：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n\n    }\n}\n```\n\n只要没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记就会抛异常。\n\n而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0\n        && options != null && ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n    }\n}\n```\n\n只有在指定了 `options` 同时其中没有指定 LaunchTaskId 才会抛异常。\n\n## 总结\n\n上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。\n\n不管如何谨慎小心，怀着诚惶诚恐的心态写作，但是毕竟作者的水平有限，如果有写的不对的地方，敬请指教，先行感谢。","source":"_posts/熟悉又陌生的Context.md","raw":"---\ntitle: 熟悉又陌生的Context\ndate: 2018-04-12 10:45:36\ncategories: Android Framework\n---\n\n## 感谢\n\n[android-context](http://gityuan.com/2017/04/09/android_context/)\n\n## 概述\n\n> 本文中涉及的源码分析都是基于 Android 27\n\nContext 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 `getResources()` 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：\n\n![Context](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/Context.png?x-oss-process=style/doc-img)\n\n其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：\n\n``` java\npublic ContextWrapper(Context base) {\n\tmBase = base;\n}\n\n@Override\npublic void startActivity(Intent intent) {\n    mBase.startActivity(intent);\n}\n```\n\n通过在构造函数中将 ContextImpl 实例赋值给 `mBase`，然后在比如 `startActivity` 等方法实现中，将调用转发给 `mBase`，至于 `mBase` 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。\n\n通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。\n\n## Context初始化\n\n### Activity\n\n在前面的 [Activity 启动分析](https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/)中，我们知道 Activity 启动方法是 `ActivityThread.performLaunchActivity()`\n\n``` java\nprivate void performLaunchActivity() {\n    // 初始化 LoadedApk\n    if (r.packageInfo == null) {\n    \tr.packageInfo = getPackageInfo();\n    }\n    \n    // 创建 ContextImpl 实例\n    ContextImpl appContext = createBaseContextForActivity(r);\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = appContext.getClassLoader();\n        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n    } catch (Exception e) {\n        \n    }\n    \n    try {\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n        appContext.setOuterContext(activity);\n        activity.attach();\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n首先获取 LoadedApk 实例，接着调用 `createBaseContextForActivity()` 创建 ContextImpl 实例，之前我们提到 ContextWrapper 是将 Context 核心功能转发给 ContextImpl 实现的，而 `ContextWrapper.mBase` 的赋值，在 Activity 启动流程中，是通过调用 `Activity.attach()` 实现，这个我们在后面的分析中可以知道。\n\n#### create \n\n``` java\nprivate ComtextImpl createBaseContextForActivity() {\n    final int displayId;\n    try {\n        displayId = ActivityManager.getService().getActivityDisplayId(r.token);\n    } catch (RemoteException e) {\n        \n    }\n    \n    ContextImpl appContext = ContextImpl.createActivityContext();\n}\n```\n\n``` java\nstatic ContextImpl createActivityContext() {\n    ContextImpl context = new ContextImpl();\n    \n    // Activity Resource\n    final ResourcesManager resourcesManager = ResourcesManager.getInstance();\n    context.setResources(resourcesManager.createBaseActivityResources(activityToken,\n                packageInfo.getResDir(),\n                splitDirs,\n                packageInfo.getOverlayDirs(),\n                packageInfo.getApplicationInfo().sharedLibraryFiles,\n                displayId,\n                overrideConfiguration,\n                compatInfo,\n                classLoader));\n    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,\n                context.getResources());\n}\n```\n\n#### attach\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n}\n```\n\n``` java\nprotected void attachBaseContext() {\n    super.attachBaseContext(newBase);\n}\n```\n\n这个步骤比较简单，最终也是调用 `ContextWrapper.attachBaseContext()`\n\n### Service\n\nService 的创建是在 `ActivityThread.handleCreateService()`\n\n``` java\n// 初始化 LoadedApk\nLoadedApk packageInfo = getPackageInfoNoCheck();\n\nService service = null;\ntry {\n    java.lang.ClassLoader cl = packageInfo.getClassLoader();\n    // 通过反射实例化 Service\n    service = (Service) cl.loadClass(data.info.name).newInstance();\n} catch (Exception e) {\n    \n}\n\ntry {\n    ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n    context.setOuterContext(service);\n    \n    Application app = packageInfo.makeApplication(false, mInstrumentation);\n    service.attach();\n} catch (Exception e) {\n    \n}\n```\n\nService 的 Context 初始化流程和 Activity 是差不多，相同的 LoadedApk -> ContextImpl -> attach\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    // Service 的 Resources 相对于 Activity 是比较简单的\n    context.setResources(packageInfo.getResources());\n    return context;\n}\n```\n\n#### attach\n\n``` java\npublic final void attach() {\n    attachBaseContext(context);\n}\n```\n\nService 的 attach 和 Activity 相同，都是调用 `ContextWrapper.attachBaseContext()`\n\n### Application\n\nApplication 的创建是在 `LoadedApk.makeApplication()` \n\n``` java\npublic Application makeApplication() {\n    // 保持单例\n    if (mApplication != null) {\n    \treturn mApplication;\n    }\n    Application app = null;\n    String appClass = mApplicationInfo.className;\n    if (forceDefaultAppClass || (appClass == null)) {\n        // 如果强制使用默认 Application，或者没有实现自定义 Application\n    \tappClass = \"android.app.Application\";\n    }\n    try {\n        java.lang.ClassLoader cl = getClassLoader();\n        if (!mPackageName.equals(\"android\")) {\n            // 包名不是 \"android\"，即非系统进程\n        \tinitializeJavaContextClassLoader();\n        }\n        // 创建 ContextImpl 实例\n        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n        // 创建 Application 实例\n    \tapp = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n    \tappContext.setOuterContext(app);\n    } catch (Exception e) {\n        \n    }\n}\n```\n\n咋一看好像 Application 的流程和其他两个不太相同，其实 Application 的 attach 是在 `Instrumentation.newApplication()`\n\n#### create\n\n``` java\nstatic ContextImpl createAppContext() {\n    ContextImpl context = new ContextImpl();\n    context.setResources(packageInfo.getResources());\n}\n```\n\n#### attach\n\n``` java\npublic static Application newApplication() {\n    // 反射获取实例\n    Application app = (Application)clazz.newInstance();\n    app.attach(context);\n    return app;\n}\n```\n\n``` java\nfinal void attach() {\n    attachBaseContext(context);\n    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;\n}\n```\n\n### 小结\n\n Activity、Service、Application 的 Context 初始化流程大致是这样，首先创建 ContextImpl 实例，接着调用 `ContextWrapper.attachBaseContext()` 赋值给 `mBase`，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。\n\n## 实践\n\n通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过对实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。\n\n### View Context\n\n#### 问题\n\n我们知道可以通过调用 `View.getContext()` 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。\n\n#### 分析\n\n首先我们对 View 的 `mContext` 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。\n\n如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：\n\n``` java\nLayoutInflater layoutInflater = LayoutInflater.from(context);\nView view = layoutInflater.inflate(R.layout.xxx,null);\n```\n\n首先我们看下 `LayoutInflater.from()`：\n\n``` java\npublic static LayoutInflater from(Context context) {\nLayoutInflater LayoutInflater =\t\t  (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    if (LayoutInflater == null) {\n        throw new AssertionError(\"LayoutInflater not found.\");\n    }\n    return LayoutInflater;\n}\n```\n\n在前面，我们提到 Context 的核心方法都转发给 `mBase` 即 ContextImpl 实例，所以看下 ContextImpl 类的实现：\n\n``` java\npublic Object getSystemService(String name) {\n    return SystemServiceRegistry.getSystemService(this, name);\n}\n\npublic static Object getSystemService(ContextImpl ctx, String name) {\n    ServiceFetcher<?> fetcher = SYSTEM_SERVICE_FETCHERS.get(name);\n    return fetcher != null ? fetcher.getService(ctx) : null;\n}\n```\n\n可以看到最终的调用都转发给了 ServiceFetcher，而 `SYSTEM_SERVICE_FETCHERS` 则是存储着各个类型的 Fetcher 的实例\n\n``` java\n// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name->Fetcher\nprivate static final HashMap<String, ServiceFetcher<?>> SYSTEM_SERVICE_FETCHERS =\n            new HashMap<String, ServiceFetcher<?>>();\n// 存储 Class->Name\nprivate static final HashMap<Class<?>, String> SYSTEM_SERVICE_NAMES =\n            new HashMap<Class<?>, String>();\n\nprivate static <T> void registerService(String serviceName, Class<T> serviceClass,\n            ServiceFetcher<T> serviceFetcher) {\n    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);\n    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);\n}\n```\n\n`SYSTEM_SERVICE_FETCHERS` 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 `registerService()`，这里我们只关心 LayoutInflater 的注册：\n\n``` java\nregisterService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,\n        new CachedServiceFetcher<LayoutInflater>() {                  \n    @Override                                                         \n    public LayoutInflater createService(ContextImpl ctx) {            \n        return new PhoneLayoutInflater(ctx.getOuterContext());        \n    }});                                                              \n```\n\nLayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 只是简单的继承 LayoutInflater，核心代码都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 `CachedServiceFetcher.getService()`\n\n``` java\npublic final T getService(ContextImpl ctx) {\n    final Object[] cache = ctx.mServiceCache;\n    synchronized (cache) {\n        Object service = cache[mCacheIndex];\n        if (service == null) {\n            try {\n                service = createService(ctx);\n                cache[mCacheIndex] = service;\n            } catch (ServiceNotFoundException e) {\n                \n            }\n        }\n        return (T)service;\n    }\n}\n```\n\n注意到，Service 的缓存是存储在 `ContextImpl.mServiceCache` 并且该字段不是静态的，即**Service 的缓存是针对于相同的 Context 实例的**，如果不存在缓存，那么调用 `createService()`，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：\n\n```java\n// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application\nreturn new PhoneLayoutInflater(ctx.getOuterContext()); \n```\n\n而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：\n\n``` java\nprotected LayoutInflater(Context context) {\n    // 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到\n    mContext = context;\n}\n```\n\n接下来我们看下 `inflate()` 源码：\n\n``` java\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n```\n\n``` java\npublic View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n    synchronized (mConstructorArgs) {\n        // mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了\n        final Context inflaterContext = mContext;\n        final AttributeSet attrs = Xml.asAttributeSet(parser);\n    \tContext lastContext = (Context) mConstructorArgs[0];\n        mConstructorArgs[0] = inflaterContext;\n        View result = root;\n        \n        try {\n            // 解析 xml 中的节点\n            \n            final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n        } catch () {\n            \n        } finally {\n            mConstructorArgs[0] = lastContext;\n            mConstructorArgs[1] = null;\n        }\n        \n        return result;\n    }\n}\n    \n```\n\n`inflater()` 就是对 xml 布局进行解析，接着实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 `createViewFromTag()` 它是根据标签名称去实例化具体的 View 实例\n\n``` java\nView createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n            boolean ignoreThemeAttr) {\n    if (name.equals(\"view\")) {\n        // 如果我们使用 view 标签则从 class 属性中获取具体类名称\n        name = attrs.getAttributeValue(null, \"class\");\n    }\n    \n    if (!ignoreThemeAttr) {\n        // 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性\n        // 获取设置的 theme 属性值\n        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);\n    \tfinal int themeResId = ta.getResourceId(0, 0);\n        if (themeResId != 0) {\n            // 如果设置了，则将 context 包装成 ContextThemeWrapper\n            // 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性\n            context = new ContextThemeWrapper(context, themeResId);\n        }\n        ta.recycle();\n    }\n    \n    try {\n        View view;\n        \n        // Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView\n        if (mFactory2 != null) {\n        \tview = mFactory2.onCreateView(parent, name, context, attrs);\n        } else if (mFactory != null) {\n            view = mFactory.onCreateView(name, context, attrs);\n        } else {\n            view = null;\n        }\n        \n        if (view == null && mPrivateFactory != null) {\n        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);\n        }\n        \n        if (view == null) {\n            final Object lastContext = mConstructorArgs[0];\n            mConstructorArgs[0] = context;\n            try {\n                if (-1 == name.indexOf('.')) {\n                    // 系统控件\n                    view = onCreateView(parent, name, attrs);\n                } else {\n                    // 自定义控件\n                    view = createView(name, null, attrs);\n                }\n            } finally {\n                mConstructorArgs[0] = lastContext;\n            }\n        }\n        \n        return view;\n    } catch () {\n        \n    }\n}\n```\n\n不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 `createView()`\n\n``` java\npublic final View createView(String name, String prefix, AttributeSet attrs){\n\t// 缓存构造函数\n    Constructor<? extends View> constructor = sConstructorMap.get(name);\n    // 检查构造函数类加载器\n    if (constructor != null && !verifyClassLoader(constructor)){\n        constructor = null;\n        sConstructorMap.remove(name);\n    }\n    Class<? extends View> clazz = null;\n    try {\n        \n        // 获取 View 构造函数实例，并处理过滤情况\n        if (constructor == null) {\n        \tclazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n        \n            if (mFilter != null && clazz != null) {\n            // 检查是否过滤\n        \tboolean allowed = mFilter.onLoadClass(clazz);\n            if (!allowed) {\n                failNotAllowed(name, prefix, attrs);\n            }\n            }\n            constructor = clazz.getConstructor(mConstructorSignature);\n            constructor.setAccessible(true);\n            sConstructorMap.put(name, constructor);\n        } else {\n            if (mFilter != null) {\n                // 存在过滤器\n                Boolean allowedState = mFilterMap.get(name);\n                if (allowedState == null) {\n                    // 没有缓存过滤结果，新的类\n                    clazz = mContext.getClassLoader().loadClass(                            \n                    prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \tboolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                \tmFilterMap.put(name, allowed);\n                    if (!allowed) {\n                    \tfailNotAllowed(name, prefix, attrs);\n                    }\n                } else if (allowedState.equals(Boolean.FALSE)) {\n                    failNotAllowed(name, prefix, attrs);\n                } \n            }\n        }\n        \n        Object lastContext = mConstructorArgs[0];\n        if (mConstructorArgs[0] == null) {\n            // 如果还没设置 context 参数\n            mConstructorArgs[0] = mContext;\n        }\n        Object[] args = mConstructorArgs;\n        args[1] = attrs;\n        // 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知\n        final View view = constructor.newInstance(args); \n        if (view instanceof ViewStub) {\n            // 使用相同的 Context 处理 ViewStub\n            final ViewStub viewStub = (ViewStub) view;\n            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n        }\n        mConstructorArgs[0] = lastContext;\n        return view;\n    } catech () {\n        \n    }\n}\n```\n\n最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同的地方，我们先通过一个例子来看下效果：\n\n``` java\nprotected void onCreate(Bundle savedInstanceState) {\n    // 使用两种 Context 创建两个 EditText\n    addEditText(this);                   \n\taddEditText(getApplicationContext());\n}\nprivate void addEditText(@Nullable Context context) { \n                                                      \n    if (mRootLayout == null) {                        \n        return;                                       \n    }                                                 \n                                                      \n    if (context == null) {                            \n        return;                                       \n    }                                                 \n                                                                                                       \n    EditText editText = new EditText(context);        \n    mRootLayout.addView(editText);                    \n    editText.setText(context.toString());                                                               \n}                                                     \n```\n\n代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题\n\n``` xml\n<Applicatin \n  android:theme=\"@style/AppTheme\">\n</Applicatin>\n\n<item name=\"colorAccent\">@color/colorAccent</item>\n<color name=\"colorAccent\">#FF4081</color>\n```\n\n![ActivityContextEditText](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/ActivityContextEditText.png?x-oss-process=style/doc-img)\n\n![ApplicationContextEditText](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/ApplicationContextEditText.png?x-oss-process=style/doc-img)\n\n我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：\n\n``` java\npublic Resources.Theme getTheme() {\n    if (mTheme != null) {\n        return mTheme;\n    }\n    if (mThemeResource == 0) {\n        mThemeResource = R.style.Theme_AppCompat_Light;\n    }\n    initializeTheme();\n    return mTheme;\n}\n\nprivate void initializeTheme() {\n    final boolean first = mTheme == null;\n    if (first) {\n        mTheme = getResources().newTheme();\n        Resources.Theme theme = getBaseContext().getTheme();\n        if (theme != null) {\n            mTheme.setTo(theme);\n        }\n    }\n    onApplyThemeResource(mTheme, mThemeResource, first);\n}\n\nprotected void onApplyThemeResource(Resources.Theme theme, int resid, boolean first) {\n    theme.applyStyle(resid, true);\n}\n```\n\n`mTheme` 和 `mThemeResource` 都可以通过构造方法和 set 方法进行赋值，假设没有给 `mTheme` 赋值，只给 `mThemeResource` 赋值，那么上面的代码将 `mThemeSource` 应用到 `ContextWrapper.getTheme()` 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 `ActivityThread.performLaunchActivity()` 中，其中涉及 Theme 的赋值是：\n\n``` java\nint theme = r.activityInfo.getThemeResource();\nif (theme != 0) {\n    activity.setTheme(theme);\n}\n```\n\n现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。\n\n#### 小结\n\n通过上面的源码分析，我们可以知道：\n\n1. 当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 `View(Context,AttributeSet)` 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。\n2. Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。\n\n### getApplication()和getApplicatinContext()\n\n**接下来的分析参考于 [android-context](http://gityuan.com/2017/04/09/android_context/)**\n\n绝大数情况下，这两个方法的返回值是一样。\n\n`getApplicationContext()` 的存在是 Android 历史原因，`getApplication()` 这个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 `getApplicationContext()`。\n\n两者对比：\n\n1. 对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过\n2. BroadcastReceiver 只能通过 `getApplicationContext()` 获取 Application 实例\n3. ContentProvider 也只能通过 `getApplicationContext()` 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 `getApplicationContext()` 则会返回空。\n\n#### 小结\n\n绝大数情况下，`getApplication()` 和 `getApplicationContext()` 返回是一样的，但如果不是特别熟悉，最好对 `getApplicationContext()` 进行空值判断。\n\n### Dialog Context\n\n我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：\n\n```\nCaused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?\n```\n\n### start Activity\n\n通过调用 `startActivity()` 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 `startActivity()` 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：\n\n在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记的话，则会抛出以下异常：\n\n```\nCaused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?\n```\n\nAndroid 26 上 ContextImpl 的相关代码如下：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n\n    }\n}\n```\n\n只要没有添加 `Intent.FLAG_ACTIVITY_NEW_TASK` 标记就会抛异常。\n\n而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：\n\n``` java\npublic void startActivity(Intent intent, Bundle options) {\n    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0\n        && options != null && ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) {\n        throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                    + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                    + \" Is this really what you want?\");\n    }\n}\n```\n\n只有在指定了 `options` 同时其中没有指定 LaunchTaskId 才会抛异常。\n\n## 总结\n\n上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。\n\n不管如何谨慎小心，怀着诚惶诚恐的心态写作，但是毕竟作者的水平有限，如果有写的不对的地方，敬请指教，先行感谢。","slug":"熟悉又陌生的Context","published":1,"updated":"2018-11-16T10:11:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs1c0015e39khoam1zgt","content":"<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><blockquote>\n<p>本文中涉及的源码分析都是基于 Android 27</p>\n</blockquote>\n<p>Context 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 <code>getResources()</code> 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/Context.png?x-oss-process=style/doc-img\" alt=\"Context\"></p>\n<p>其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ContextWrapper</span><span class=\"params\">(Context base)</span> </span>&#123;</span><br><span class=\"line\">\tmBase = base;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    mBase.startActivity(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过在构造函数中将 ContextImpl 实例赋值给 <code>mBase</code>，然后在比如 <code>startActivity</code> 等方法实现中，将调用转发给 <code>mBase</code>，至于 <code>mBase</code> 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。</p>\n<p>通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。</p>\n<h2 id=\"Context初始化\"><a href=\"#Context初始化\" class=\"headerlink\" title=\"Context初始化\"></a>Context初始化</h2><h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>在前面的 <a href=\"https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/\">Activity 启动分析</a>中，我们知道 Activity 启动方法是 <code>ActivityThread.performLaunchActivity()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.packageInfo == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tr.packageInfo = getPackageInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        appContext.setOuterContext(activity);</span><br><span class=\"line\">        activity.attach();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先获取 LoadedApk 实例，接着调用 <code>createBaseContextForActivity()</code> 创建 ContextImpl 实例，之前我们提到 ContextWrapper 是将 Context 核心功能转发给 ContextImpl 实现的，而 <code>ContextWrapper.mBase</code> 的赋值，在 Activity 启动流程中，是通过调用 <code>Activity.attach()</code> 实现，这个我们在后面的分析中可以知道。</p>\n<h4 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ComtextImpl <span class=\"title\">createBaseContextForActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> displayId;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        displayId = ActivityManager.getService().getActivityDisplayId(r.token);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ContextImpl appContext = ContextImpl.createActivityContext();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createActivityContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ResourcesManager resourcesManager = ResourcesManager.getInstance();</span><br><span class=\"line\">    context.setResources(resourcesManager.createBaseActivityResources(activityToken,</span><br><span class=\"line\">                packageInfo.getResDir(),</span><br><span class=\"line\">                splitDirs,</span><br><span class=\"line\">                packageInfo.getOverlayDirs(),</span><br><span class=\"line\">                packageInfo.getApplicationInfo().sharedLibraryFiles,</span><br><span class=\"line\">                displayId,</span><br><span class=\"line\">                overrideConfiguration,</span><br><span class=\"line\">                compatInfo,</span><br><span class=\"line\">                classLoader));</span><br><span class=\"line\">    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,</span><br><span class=\"line\">                context.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach\"><a href=\"#attach\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">attachBaseContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.attachBaseContext(newBase);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个步骤比较简单，最终也是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h3><p>Service 的创建是在 <code>ActivityThread.handleCreateService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">LoadedApk packageInfo = getPackageInfoNoCheck();</span><br><span class=\"line\"></span><br><span class=\"line\">Service service = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class=\"line\">    <span class=\"comment\">// 通过反射实例化 Service</span></span><br><span class=\"line\">    service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ContextImpl context = ContextImpl.createAppContext(<span class=\"keyword\">this</span>, packageInfo);</span><br><span class=\"line\">    context.setOuterContext(service);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Application app = packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">    service.attach();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 Context 初始化流程和 Activity 是差不多，相同的 LoadedApk -&gt; ContextImpl -&gt; attach</p>\n<h4 id=\"create-1\"><a href=\"#create-1\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    <span class=\"comment\">// Service 的 Resources 相对于 Activity 是比较简单的</span></span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-1\"><a href=\"#attach-1\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 attach 和 Activity 相同，都是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h3><p>Application 的创建是在 <code>LoadedApk.makeApplication()</code> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Application <span class=\"title\">makeApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保持单例</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> mApplication;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Application app = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    String appClass = mApplicationInfo.className;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forceDefaultAppClass || (appClass == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果强制使用默认 Application，或者没有实现自定义 Application</span></span><br><span class=\"line\">    \tappClass = <span class=\"string\">\"android.app.Application\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mPackageName.equals(<span class=\"string\">\"android\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 包名不是 \"android\"，即非系统进程</span></span><br><span class=\"line\">        \tinitializeJavaContextClassLoader();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建 Application 实例</span></span><br><span class=\"line\">    \tapp = mActivityThread.mInstrumentation.newApplication(</span><br><span class=\"line\">                    cl, appClass, appContext);</span><br><span class=\"line\">    \tappContext.setOuterContext(app);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>咋一看好像 Application 的流程和其他两个不太相同，其实 Application 的 attach 是在 <code>Instrumentation.newApplication()</code></p>\n<h4 id=\"create-2\"><a href=\"#create-2\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-2\"><a href=\"#attach-2\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Application <span class=\"title\">newApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 反射获取实例</span></span><br><span class=\"line\">    Application app = (Application)clazz.newInstance();</span><br><span class=\"line\">    app.attach(context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p> Activity、Service、Application 的 Context 初始化流程大致是这样，首先创建 ContextImpl 实例，接着调用 <code>ContextWrapper.attachBaseContext()</code> 赋值给 <code>mBase</code>，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过对实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。</p>\n<h3 id=\"View-Context\"><a href=\"#View-Context\" class=\"headerlink\" title=\"View Context\"></a>View Context</h3><h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>我们知道可以通过调用 <code>View.getContext()</code> 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>首先我们对 View 的 <code>mContext</code> 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。</p>\n<p>如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater layoutInflater = LayoutInflater.from(context);</span><br><span class=\"line\">View view = layoutInflater.inflate(R.layout.xxx,<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>首先我们看下 <code>LayoutInflater.from()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LayoutInflater <span class=\"title\">from</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">LayoutInflater LayoutInflater =\t\t  (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LayoutInflater == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"LayoutInflater not found.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> LayoutInflater;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在前面，我们提到 Context 的核心方法都转发给 <code>mBase</code> 即 ContextImpl 实例，所以看下 ContextImpl 类的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SystemServiceRegistry.getSystemService(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class=\"line\">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetcher != <span class=\"keyword\">null</span> ? fetcher.getService(ctx) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到最终的调用都转发给了 ServiceFetcher，而 <code>SYSTEM_SERVICE_FETCHERS</code> 则是存储着各个类型的 Fetcher 的实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name-&gt;Fetcher</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 存储 Class-&gt;Name</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">registerService</span><span class=\"params\">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class=\"line\">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class=\"line\">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SYSTEM_SERVICE_FETCHERS</code> 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 <code>registerService()</code>，这里我们只关心 LayoutInflater 的注册：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;                  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutInflater <span class=\"title\">createService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());        </span><br><span class=\"line\">    &#125;&#125;);</span><br></pre></td></tr></table></figure>\n<p>LayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 只是简单的继承 LayoutInflater，核心代码都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 <code>CachedServiceFetcher.getService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> T <span class=\"title\">getService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] cache = ctx.mServiceCache;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (cache) &#123;</span><br><span class=\"line\">        Object service = cache[mCacheIndex];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                service = createService(ctx);</span><br><span class=\"line\">                cache[mCacheIndex] = service;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ServiceNotFoundException e) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意到，Service 的缓存是存储在 <code>ContextImpl.mServiceCache</code> 并且该字段不是静态的，即<strong>Service 的缓存是针对于相同的 Context 实例的</strong>，如果不存在缓存，那么调用 <code>createService()</code>，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br></pre></td></tr></table></figure>\n<p>而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">LayoutInflater</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到</span></span><br><span class=\"line\">    mContext = context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们看下 <code>inflate()</code> 源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> resource, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Resources res = getContext().getResources();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inflate(parser, root, attachToRoot);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        parser.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(XmlPullParser parser, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mConstructorArgs) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Context inflaterContext = mContext;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class=\"line\">    \tContext lastContext = (Context) mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = inflaterContext;</span><br><span class=\"line\">        View result = root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 解析 xml 中的节点</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>inflater()</code> 就是对 xml 布局进行解析，接着实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 <code>createViewFromTag()</code> 它是根据标签名称去实例化具体的 View 实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">View <span class=\"title\">createViewFromTag</span><span class=\"params\">(View parent, String name, Context context, AttributeSet attrs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name.equals(<span class=\"string\">\"view\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果我们使用 view 标签则从 class 属性中获取具体类名称</span></span><br><span class=\"line\">        name = attrs.getAttributeValue(<span class=\"keyword\">null</span>, <span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ignoreThemeAttr) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取设置的 theme 属性值</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> themeResId = ta.getResourceId(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (themeResId != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了，则将 context 包装成 ContextThemeWrapper</span></span><br><span class=\"line\">            <span class=\"comment\">// 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性</span></span><br><span class=\"line\">            context = <span class=\"keyword\">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ta.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        View view;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFactory2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            view = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span> &amp;&amp; mPrivateFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = context;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == name.indexOf(<span class=\"string\">'.'</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 系统控件</span></span><br><span class=\"line\">                    view = onCreateView(parent, name, attrs);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 自定义控件</span></span><br><span class=\"line\">                    view = createView(name, <span class=\"keyword\">null</span>, attrs);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 <code>createView()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> View <span class=\"title\">createView</span><span class=\"params\">(String name, String prefix, AttributeSet attrs)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存构造函数</span></span><br><span class=\"line\">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class=\"line\">    <span class=\"comment\">// 检查构造函数类加载器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (constructor != <span class=\"keyword\">null</span> &amp;&amp; !verifyClassLoader(constructor))&#123;</span><br><span class=\"line\">        constructor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        sConstructorMap.remove(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Class&lt;? extends View&gt; clazz = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取 View 构造函数实例，并处理过滤情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (constructor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tclazz = mContext.getClassLoader().loadClass(</span><br><span class=\"line\">                        prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span> &amp;&amp; clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 检查是否过滤</span></span><br><span class=\"line\">        \t<span class=\"keyword\">boolean</span> allowed = mFilter.onLoadClass(clazz);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class=\"line\">            constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            sConstructorMap.put(name, constructor);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 存在过滤器</span></span><br><span class=\"line\">                Boolean allowedState = mFilterMap.get(name);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (allowedState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 没有缓存过滤结果，新的类</span></span><br><span class=\"line\">                    clazz = mContext.getClassLoader().loadClass(                            </span><br><span class=\"line\">                    prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">                \t<span class=\"keyword\">boolean</span> allowed = clazz != <span class=\"keyword\">null</span> &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class=\"line\">                \tmFilterMap.put(name, allowed);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                    \tfailNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (allowedState.equals(Boolean.FALSE)) &#123;</span><br><span class=\"line\">                    failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mConstructorArgs[<span class=\"number\">0</span>] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果还没设置 context 参数</span></span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = mContext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object[] args = mConstructorArgs;</span><br><span class=\"line\">        args[<span class=\"number\">1</span>] = attrs;</span><br><span class=\"line\">        <span class=\"comment\">// 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View view = constructor.newInstance(args); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view <span class=\"keyword\">instanceof</span> ViewStub) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用相同的 Context 处理 ViewStub</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> ViewStub viewStub = (ViewStub) view;</span><br><span class=\"line\">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; catech () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同的地方，我们先通过一个例子来看下效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用两种 Context 创建两个 EditText</span></span><br><span class=\"line\">    addEditText(<span class=\"keyword\">this</span>);                   </span><br><span class=\"line\">\taddEditText(getApplicationContext());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addEditText</span><span class=\"params\">(@Nullable Context context)</span> </span>&#123; </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mRootLayout == <span class=\"keyword\">null</span>) &#123;                        </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;                            </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                                                                       </span><br><span class=\"line\">    EditText editText = <span class=\"keyword\">new</span> EditText(context);        </span><br><span class=\"line\">    mRootLayout.addView(editText);                    </span><br><span class=\"line\">    editText.setText(context.toString());                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Applicatin</span> </span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/AppTheme\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Applicatin</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>@color/colorAccent<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">color</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>#FF4081<span class=\"tag\">&lt;/<span class=\"name\">color</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/ActivityContextEditText.png?x-oss-process=style/doc-img\" alt=\"ActivityContextEditText\"></p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/ApplicationContextEditText.png?x-oss-process=style/doc-img\" alt=\"ApplicationContextEditText\"></p>\n<p>我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Resources.<span class=\"function\">Theme <span class=\"title\">getTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTheme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThemeResource == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mThemeResource = R.style.Theme_AppCompat_Light;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    initializeTheme();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initializeTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> first = mTheme == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first) &#123;</span><br><span class=\"line\">        mTheme = getResources().newTheme();</span><br><span class=\"line\">        Resources.Theme theme = getBaseContext().getTheme();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (theme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mTheme.setTo(theme);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    onApplyThemeResource(mTheme, mThemeResource, first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplyThemeResource</span><span class=\"params\">(Resources.Theme theme, <span class=\"keyword\">int</span> resid, <span class=\"keyword\">boolean</span> first)</span> </span>&#123;</span><br><span class=\"line\">    theme.applyStyle(resid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mTheme</code> 和 <code>mThemeResource</code> 都可以通过构造方法和 set 方法进行赋值，假设没有给 <code>mTheme</code> 赋值，只给 <code>mThemeResource</code> 赋值，那么上面的代码将 <code>mThemeSource</code> 应用到 <code>ContextWrapper.getTheme()</code> 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 <code>ActivityThread.performLaunchActivity()</code> 中，其中涉及 Theme 的赋值是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (theme != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    activity.setTheme(theme);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过上面的源码分析，我们可以知道：</p>\n<ol>\n<li>当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 <code>View(Context,AttributeSet)</code> 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。</li>\n<li>Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。</li>\n</ol>\n<h3 id=\"getApplication-和getApplicatinContext\"><a href=\"#getApplication-和getApplicatinContext\" class=\"headerlink\" title=\"getApplication()和getApplicatinContext()\"></a>getApplication()和getApplicatinContext()</h3><p><strong>接下来的分析参考于 <a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></strong></p>\n<p>绝大数情况下，这两个方法的返回值是一样。</p>\n<p><code>getApplicationContext()</code> 的存在是 Android 历史原因，<code>getApplication()</code> 这个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 <code>getApplicationContext()</code>。</p>\n<p>两者对比：</p>\n<ol>\n<li>对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过</li>\n<li>BroadcastReceiver 只能通过 <code>getApplicationContext()</code> 获取 Application 实例</li>\n<li>ContentProvider 也只能通过 <code>getApplicationContext()</code> 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 <code>getApplicationContext()</code> 则会返回空。</li>\n</ol>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>绝大数情况下，<code>getApplication()</code> 和 <code>getApplicationContext()</code> 返回是一样的，但如果不是特别熟悉，最好对 <code>getApplicationContext()</code> 进行空值判断。</p>\n<h3 id=\"Dialog-Context\"><a href=\"#Dialog-Context\" class=\"headerlink\" title=\"Dialog Context\"></a>Dialog Context</h3><p>我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?</span><br></pre></td></tr></table></figure>\n<h3 id=\"start-Activity\"><a href=\"#start-Activity\" class=\"headerlink\" title=\"start Activity\"></a>start Activity</h3><p>通过调用 <code>startActivity()</code> 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 <code>startActivity()</code> 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：</p>\n<p>在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记的话，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br></pre></td></tr></table></figure>\n<p>Android 26 上 ContextImpl 的相关代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记就会抛异常。</p>\n<p>而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span></span><br><span class=\"line\">        &amp;&amp; options != <span class=\"keyword\">null</span> &amp;&amp; ActivityOptions.fromBundle(options).getLaunchTaskId() == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有在指定了 <code>options</code> 同时其中没有指定 LaunchTaskId 才会抛异常。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。</p>\n<p>不管如何谨慎小心，怀着诚惶诚恐的心态写作，但是毕竟作者的水平有限，如果有写的不对的地方，敬请指教，先行感谢。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><blockquote>\n<p>本文中涉及的源码分析都是基于 Android 27</p>\n</blockquote>\n<p>Context 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 <code>getResources()</code> 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图：</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/Context.png?x-oss-process=style/doc-img\" alt=\"Context\"></p>\n<p>其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ContextWrapper</span><span class=\"params\">(Context base)</span> </span>&#123;</span><br><span class=\"line\">\tmBase = base;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    mBase.startActivity(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过在构造函数中将 ContextImpl 实例赋值给 <code>mBase</code>，然后在比如 <code>startActivity</code> 等方法实现中，将调用转发给 <code>mBase</code>，至于 <code>mBase</code> 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。</p>\n<p>通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。</p>\n<h2 id=\"Context初始化\"><a href=\"#Context初始化\" class=\"headerlink\" title=\"Context初始化\"></a>Context初始化</h2><h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>在前面的 <a href=\"https://linxiaotao.github.io/2018/03/27/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EAndroid26/\">Activity 启动分析</a>中，我们知道 Activity 启动方法是 <code>ActivityThread.performLaunchActivity()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLaunchActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.packageInfo == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \tr.packageInfo = getPackageInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        appContext.setOuterContext(activity);</span><br><span class=\"line\">        activity.attach();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先获取 LoadedApk 实例，接着调用 <code>createBaseContextForActivity()</code> 创建 ContextImpl 实例，之前我们提到 ContextWrapper 是将 Context 核心功能转发给 ContextImpl 实现的，而 <code>ContextWrapper.mBase</code> 的赋值，在 Activity 启动流程中，是通过调用 <code>Activity.attach()</code> 实现，这个我们在后面的分析中可以知道。</p>\n<h4 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ComtextImpl <span class=\"title\">createBaseContextForActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> displayId;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        displayId = ActivityManager.getService().getActivityDisplayId(r.token);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ContextImpl appContext = ContextImpl.createActivityContext();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createActivityContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Activity Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ResourcesManager resourcesManager = ResourcesManager.getInstance();</span><br><span class=\"line\">    context.setResources(resourcesManager.createBaseActivityResources(activityToken,</span><br><span class=\"line\">                packageInfo.getResDir(),</span><br><span class=\"line\">                splitDirs,</span><br><span class=\"line\">                packageInfo.getOverlayDirs(),</span><br><span class=\"line\">                packageInfo.getApplicationInfo().sharedLibraryFiles,</span><br><span class=\"line\">                displayId,</span><br><span class=\"line\">                overrideConfiguration,</span><br><span class=\"line\">                compatInfo,</span><br><span class=\"line\">                classLoader));</span><br><span class=\"line\">    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,</span><br><span class=\"line\">                context.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach\"><a href=\"#attach\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">attachBaseContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.attachBaseContext(newBase);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个步骤比较简单，最终也是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h3><p>Service 的创建是在 <code>ActivityThread.handleCreateService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化 LoadedApk</span></span><br><span class=\"line\">LoadedApk packageInfo = getPackageInfoNoCheck();</span><br><span class=\"line\"></span><br><span class=\"line\">Service service = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class=\"line\">    <span class=\"comment\">// 通过反射实例化 Service</span></span><br><span class=\"line\">    service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ContextImpl context = ContextImpl.createAppContext(<span class=\"keyword\">this</span>, packageInfo);</span><br><span class=\"line\">    context.setOuterContext(service);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Application app = packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">    service.attach();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 Context 初始化流程和 Activity 是差不多，相同的 LoadedApk -&gt; ContextImpl -&gt; attach</p>\n<h4 id=\"create-1\"><a href=\"#create-1\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    <span class=\"comment\">// Service 的 Resources 相对于 Activity 是比较简单的</span></span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-1\"><a href=\"#attach-1\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 的 attach 和 Activity 相同，都是调用 <code>ContextWrapper.attachBaseContext()</code></p>\n<h3 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h3><p>Application 的创建是在 <code>LoadedApk.makeApplication()</code> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Application <span class=\"title\">makeApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保持单例</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> mApplication;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Application app = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    String appClass = mApplicationInfo.className;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forceDefaultAppClass || (appClass == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果强制使用默认 Application，或者没有实现自定义 Application</span></span><br><span class=\"line\">    \tappClass = <span class=\"string\">\"android.app.Application\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mPackageName.equals(<span class=\"string\">\"android\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 包名不是 \"android\"，即非系统进程</span></span><br><span class=\"line\">        \tinitializeJavaContextClassLoader();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 ContextImpl 实例</span></span><br><span class=\"line\">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建 Application 实例</span></span><br><span class=\"line\">    \tapp = mActivityThread.mInstrumentation.newApplication(</span><br><span class=\"line\">                    cl, appClass, appContext);</span><br><span class=\"line\">    \tappContext.setOuterContext(app);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>咋一看好像 Application 的流程和其他两个不太相同，其实 Application 的 attach 是在 <code>Instrumentation.newApplication()</code></p>\n<h4 id=\"create-2\"><a href=\"#create-2\" class=\"headerlink\" title=\"create\"></a>create</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ContextImpl <span class=\"title\">createAppContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ContextImpl context = <span class=\"keyword\">new</span> ContextImpl();</span><br><span class=\"line\">    context.setResources(packageInfo.getResources());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"attach-2\"><a href=\"#attach-2\" class=\"headerlink\" title=\"attach\"></a>attach</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Application <span class=\"title\">newApplication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 反射获取实例</span></span><br><span class=\"line\">    Application app = (Application)clazz.newInstance();</span><br><span class=\"line\">    app.attach(context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    attachBaseContext(context);</span><br><span class=\"line\">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p> Activity、Service、Application 的 Context 初始化流程大致是这样，首先创建 ContextImpl 实例，接着调用 <code>ContextWrapper.attachBaseContext()</code> 赋值给 <code>mBase</code>，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过对实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。</p>\n<h3 id=\"View-Context\"><a href=\"#View-Context\" class=\"headerlink\" title=\"View Context\"></a>View Context</h3><h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>我们知道可以通过调用 <code>View.getContext()</code> 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>首先我们对 View 的 <code>mContext</code> 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。</p>\n<p>如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater layoutInflater = LayoutInflater.from(context);</span><br><span class=\"line\">View view = layoutInflater.inflate(R.layout.xxx,<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>首先我们看下 <code>LayoutInflater.from()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LayoutInflater <span class=\"title\">from</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">LayoutInflater LayoutInflater =\t\t  (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LayoutInflater == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"LayoutInflater not found.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> LayoutInflater;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在前面，我们提到 Context 的核心方法都转发给 <code>mBase</code> 即 ContextImpl 实例，所以看下 ContextImpl 类的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SystemServiceRegistry.getSystemService(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class=\"line\">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetcher != <span class=\"keyword\">null</span> ? fetcher.getService(ctx) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到最终的调用都转发给了 ServiceFetcher，而 <code>SYSTEM_SERVICE_FETCHERS</code> 则是存储着各个类型的 Fetcher 的实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name-&gt;Fetcher</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 存储 Class-&gt;Name</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">registerService</span><span class=\"params\">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class=\"line\">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class=\"line\">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SYSTEM_SERVICE_FETCHERS</code> 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 <code>registerService()</code>，这里我们只关心 LayoutInflater 的注册：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;                  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>                                                         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutInflater <span class=\"title\">createService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());        </span><br><span class=\"line\">    &#125;&#125;);</span><br></pre></td></tr></table></figure>\n<p>LayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 只是简单的继承 LayoutInflater，核心代码都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 <code>CachedServiceFetcher.getService()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> T <span class=\"title\">getService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] cache = ctx.mServiceCache;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (cache) &#123;</span><br><span class=\"line\">        Object service = cache[mCacheIndex];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                service = createService(ctx);</span><br><span class=\"line\">                cache[mCacheIndex] = service;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ServiceNotFoundException e) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意到，Service 的缓存是存储在 <code>ContextImpl.mServiceCache</code> 并且该字段不是静态的，即<strong>Service 的缓存是针对于相同的 Context 实例的</strong>，如果不存在缓存，那么调用 <code>createService()</code>，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Application</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br></pre></td></tr></table></figure>\n<p>而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">LayoutInflater</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到</span></span><br><span class=\"line\">    mContext = context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们看下 <code>inflate()</code> 源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> resource, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Resources res = getContext().getResources();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inflate(parser, root, attachToRoot);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        parser.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">inflate</span><span class=\"params\">(XmlPullParser parser, @Nullable ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mConstructorArgs) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Context inflaterContext = mContext;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class=\"line\">    \tContext lastContext = (Context) mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = inflaterContext;</span><br><span class=\"line\">        View result = root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 解析 xml 中的节点</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>inflater()</code> 就是对 xml 布局进行解析，接着实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 <code>createViewFromTag()</code> 它是根据标签名称去实例化具体的 View 实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">View <span class=\"title\">createViewFromTag</span><span class=\"params\">(View parent, String name, Context context, AttributeSet attrs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name.equals(<span class=\"string\">\"view\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果我们使用 view 标签则从 class 属性中获取具体类名称</span></span><br><span class=\"line\">        name = attrs.getAttributeValue(<span class=\"keyword\">null</span>, <span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ignoreThemeAttr) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取设置的 theme 属性值</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> themeResId = ta.getResourceId(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (themeResId != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了，则将 context 包装成 ContextThemeWrapper</span></span><br><span class=\"line\">            <span class=\"comment\">// 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性</span></span><br><span class=\"line\">            context = <span class=\"keyword\">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ta.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        View view;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFactory2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            view = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span> &amp;&amp; mPrivateFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tview = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = context;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == name.indexOf(<span class=\"string\">'.'</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 系统控件</span></span><br><span class=\"line\">                    view = onCreateView(parent, name, attrs);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 自定义控件</span></span><br><span class=\"line\">                    view = createView(name, <span class=\"keyword\">null</span>, attrs);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 <code>createView()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> View <span class=\"title\">createView</span><span class=\"params\">(String name, String prefix, AttributeSet attrs)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存构造函数</span></span><br><span class=\"line\">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class=\"line\">    <span class=\"comment\">// 检查构造函数类加载器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (constructor != <span class=\"keyword\">null</span> &amp;&amp; !verifyClassLoader(constructor))&#123;</span><br><span class=\"line\">        constructor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        sConstructorMap.remove(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Class&lt;? extends View&gt; clazz = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取 View 构造函数实例，并处理过滤情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (constructor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \tclazz = mContext.getClassLoader().loadClass(</span><br><span class=\"line\">                        prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span> &amp;&amp; clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 检查是否过滤</span></span><br><span class=\"line\">        \t<span class=\"keyword\">boolean</span> allowed = mFilter.onLoadClass(clazz);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class=\"line\">            constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            sConstructorMap.put(name, constructor);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFilter != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 存在过滤器</span></span><br><span class=\"line\">                Boolean allowedState = mFilterMap.get(name);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (allowedState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 没有缓存过滤结果，新的类</span></span><br><span class=\"line\">                    clazz = mContext.getClassLoader().loadClass(                            </span><br><span class=\"line\">                    prefix != <span class=\"keyword\">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class=\"line\">                \t<span class=\"keyword\">boolean</span> allowed = clazz != <span class=\"keyword\">null</span> &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class=\"line\">                \tmFilterMap.put(name, allowed);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!allowed) &#123;</span><br><span class=\"line\">                    \tfailNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (allowedState.equals(Boolean.FALSE)) &#123;</span><br><span class=\"line\">                    failNotAllowed(name, prefix, attrs);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Object lastContext = mConstructorArgs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mConstructorArgs[<span class=\"number\">0</span>] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果还没设置 context 参数</span></span><br><span class=\"line\">            mConstructorArgs[<span class=\"number\">0</span>] = mContext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object[] args = mConstructorArgs;</span><br><span class=\"line\">        args[<span class=\"number\">1</span>] = attrs;</span><br><span class=\"line\">        <span class=\"comment\">// 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View view = constructor.newInstance(args); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view <span class=\"keyword\">instanceof</span> ViewStub) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用相同的 Context 处理 ViewStub</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> ViewStub viewStub = (ViewStub) view;</span><br><span class=\"line\">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mConstructorArgs[<span class=\"number\">0</span>] = lastContext;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125; catech () &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同的地方，我们先通过一个例子来看下效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用两种 Context 创建两个 EditText</span></span><br><span class=\"line\">    addEditText(<span class=\"keyword\">this</span>);                   </span><br><span class=\"line\">\taddEditText(getApplicationContext());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addEditText</span><span class=\"params\">(@Nullable Context context)</span> </span>&#123; </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mRootLayout == <span class=\"keyword\">null</span>) &#123;                        </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;                            </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;                                       </span><br><span class=\"line\">    &#125;                                                 </span><br><span class=\"line\">                                                                                                       </span><br><span class=\"line\">    EditText editText = <span class=\"keyword\">new</span> EditText(context);        </span><br><span class=\"line\">    mRootLayout.addView(editText);                    </span><br><span class=\"line\">    editText.setText(context.toString());                                                               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Applicatin</span> </span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/AppTheme\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Applicatin</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>@color/colorAccent<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">color</span> <span class=\"attr\">name</span>=<span class=\"string\">\"colorAccent\"</span>&gt;</span>#FF4081<span class=\"tag\">&lt;/<span class=\"name\">color</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/ActivityContextEditText.png?x-oss-process=style/doc-img\" alt=\"ActivityContextEditText\"></p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/ApplicationContextEditText.png?x-oss-process=style/doc-img\" alt=\"ApplicationContextEditText\"></p>\n<p>我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Resources.<span class=\"function\">Theme <span class=\"title\">getTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTheme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThemeResource == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mThemeResource = R.style.Theme_AppCompat_Light;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    initializeTheme();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mTheme;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initializeTheme</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> first = mTheme == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first) &#123;</span><br><span class=\"line\">        mTheme = getResources().newTheme();</span><br><span class=\"line\">        Resources.Theme theme = getBaseContext().getTheme();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (theme != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mTheme.setTo(theme);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    onApplyThemeResource(mTheme, mThemeResource, first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplyThemeResource</span><span class=\"params\">(Resources.Theme theme, <span class=\"keyword\">int</span> resid, <span class=\"keyword\">boolean</span> first)</span> </span>&#123;</span><br><span class=\"line\">    theme.applyStyle(resid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mTheme</code> 和 <code>mThemeResource</code> 都可以通过构造方法和 set 方法进行赋值，假设没有给 <code>mTheme</code> 赋值，只给 <code>mThemeResource</code> 赋值，那么上面的代码将 <code>mThemeSource</code> 应用到 <code>ContextWrapper.getTheme()</code> 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 <code>ActivityThread.performLaunchActivity()</code> 中，其中涉及 Theme 的赋值是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (theme != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    activity.setTheme(theme);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过上面的源码分析，我们可以知道：</p>\n<ol>\n<li>当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 <code>View(Context,AttributeSet)</code> 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。</li>\n<li>Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。</li>\n</ol>\n<h3 id=\"getApplication-和getApplicatinContext\"><a href=\"#getApplication-和getApplicatinContext\" class=\"headerlink\" title=\"getApplication()和getApplicatinContext()\"></a>getApplication()和getApplicatinContext()</h3><p><strong>接下来的分析参考于 <a href=\"http://gityuan.com/2017/04/09/android_context/\" target=\"_blank\" rel=\"noopener\">android-context</a></strong></p>\n<p>绝大数情况下，这两个方法的返回值是一样。</p>\n<p><code>getApplicationContext()</code> 的存在是 Android 历史原因，<code>getApplication()</code> 这个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 <code>getApplicationContext()</code>。</p>\n<p>两者对比：</p>\n<ol>\n<li>对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过</li>\n<li>BroadcastReceiver 只能通过 <code>getApplicationContext()</code> 获取 Application 实例</li>\n<li>ContentProvider 也只能通过 <code>getApplicationContext()</code> 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 <code>getApplicationContext()</code> 则会返回空。</li>\n</ol>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>绝大数情况下，<code>getApplication()</code> 和 <code>getApplicationContext()</code> 返回是一样的，但如果不是特别熟悉，最好对 <code>getApplicationContext()</code> 进行空值判断。</p>\n<h3 id=\"Dialog-Context\"><a href=\"#Dialog-Context\" class=\"headerlink\" title=\"Dialog Context\"></a>Dialog Context</h3><p>我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?</span><br></pre></td></tr></table></figure>\n<h3 id=\"start-Activity\"><a href=\"#start-Activity\" class=\"headerlink\" title=\"start Activity\"></a>start Activity</h3><p>通过调用 <code>startActivity()</code> 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 <code>startActivity()</code> 即实现是委托给 ContextImpl 的。这里有个需要注意的地方：</p>\n<p>在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记的话，则会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br></pre></td></tr></table></figure>\n<p>Android 26 上 ContextImpl 的相关代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要没有添加 <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> 标记就会抛异常。</p>\n<p>而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span></span><br><span class=\"line\">        &amp;&amp; options != <span class=\"keyword\">null</span> &amp;&amp; ActivityOptions.fromBundle(options).getLaunchTaskId() == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AndroidRuntimeException(</span><br><span class=\"line\">                    <span class=\"string\">\"Calling startActivity() from outside of an Activity \"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"</span></span><br><span class=\"line\">                    + <span class=\"string\">\" Is this really what you want?\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有在指定了 <code>options</code> 同时其中没有指定 LaunchTaskId 才会抛异常。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。</p>\n<p>不管如何谨慎小心，怀着诚惶诚恐的心态写作，但是毕竟作者的水平有限，如果有写的不对的地方，敬请指教，先行感谢。</p>\n"},{"title":"触摸事件实践之路","date":"2018-04-03T01:17:20.000Z","_content":"\n## 前言\n\n最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。\n\n## 触摸事件简单回顾\n\n我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。\n\n![TouchEvent](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/TouchEvent.png?x-oss-process=style/doc-img)\n\n上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 `dispatchTouchEvent` 开始分发，先判断 ViewGroup 的 `onInterceptTouchEvent` 是否拦截，同时这里也可以调用 ViewGroup 的 `requestDisallowInterceptTouchEvent` 让 ViewGroup 不调用 `onInterceptTouchEvent`，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 `dispatchTouchEvent`，反之，则调用子视图的 `dispatchTouchEvent`，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 `dispatchTouchEvent`。\n\n最终都会调用到 View 的 `onTouchEvent` 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。\n\n## 手势判定\n\n上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。\n\n当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：\n\nScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 `onInterceptTouchEvent`\n\n> 因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。\n>\n> 源码部分基于 Android 26\n\n### onInterceptTouchEvent\n\n``` java\nif ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {\n    return true;\n}\n```\n\n用 `mIsBeingDragged` 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 `ACTION_MOVE`，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。\n\n#### TOUCH_DOWN\n\n``` java\nif (!inChild((int) ev.getX(), (int) y)) {\n    mIsBeingDragged = false;\n    recycleVelocityTracker();\n    break;\n}\n```\n\n这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。\n\n``` java\nmLastMotionY = y;\nmActivePointerId = ev.getPointerId(0);\ninitOrResetVelocityTracker();\nmVelocityTracker.addMovement(ev);\n\nmScroller.computeScrollOffset();\nmIsBeingDragged = !mScroller.isFinished();\n\nstartNestedScroll(SCROLL_AXIS_VERTICAL);\n```\n\n这段代码主要是用于初始化判定之前的资源，比如 `mLastMotionY` 记录按下时的坐标信息，`mActivePointerId` 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，`initOrResetVelocityTracker` 初始化速度跟踪器，同时使用 `addMovement` 记录当前触摸事件信息，`mScroller` 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，`startNestedScroll` 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。\n\n#### TOUCH_MOVE\n\n```java\nfinal int activePointerId = mActivePointerId;\nif (activePointerId == INVALID_POINTER) {\n    break;\n}\nfinal int pointerIndex = ev.findPointerIndex(activePointerId);\nif (pointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(pointerIndex);\nfinal int yDiff = Math.abs(y - mLastMotionY);\nif (yDiff > mTouchSlop && (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {\n    mIsBeingDragged = true;\n    mLastMotionY = y;\n    initVelocityTrackerIfNotExists();\n    mVelocityTracker.addMovement(ev);\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n```\n\n这段代码先使用我们在 `TOUCH_DOWN` 中记录的  `mActivePointerId` 进行是否为有效的判断，如果有效，则通过 `findPointerIndex` 获取作用手指 id 的下标，记录为  `pointerIndex` ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。`yDiff` 是滑动的距离，`mTouchSlop` 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 `getScaledTouchSlop` 获取，如果大于这个值，我们可以认为开始了拖动的手势。 `getNestedScrollAxes` 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，`mIsBeingDragged` 标记为 `true`，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 `requestDisallowInterceptTouchEvent`，防止父视图拦截了事件，即 `onInterceptTouchEvent`\n\n#### TOUCH_CANCEL && TOUCH_UP\n\n``` java\nmIsBeingDragged = false;\nmActivePointerId = INVALID_POINTER;\nrecycleVelocityTracker();\nstopNestedScroll();\n```\n\n一般我们都会在 `TOUCH_CANCEL` 和 `TOUCH_UP` 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 `mIsBeingDragged` 设置为 `false`，释放速度跟踪器等等 \n\n> `TOUCH_UP` 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 `TOUCH_CANCEL` 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 `TOUCH_DOWN`，即在这个事件分发时，向父视图传递了 `true` 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 `ACTION_MOVE` 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 `onInterceptTouch` 中返回了 `true`，那么在 ViewGroup 的 `dispatchTouchEvent` 中会给已经确认消费事件的子视图分发一个 `TOUCH_CANCEL` 的事件，具体可以阅读源码。\n\n#### ACTION_POINTER_UP\n\n这个为多指触摸时，某个手指抬起时分发的事件。\n\n``` java\nfinal int pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >>\n                MotionEvent.ACTION_POINTER_INDEX_SHIFT;\nfinal int pointerId = ev.getPointerId(pointerIndex);\nif (pointerId == mActivePointerId) {\n    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n    mLastMotionY = (int) ev.getY(newPointerIndex);\n    mActivePointerId = ev.getPointerId(newPointerIndex);\n    if (mVelocityTracker != null) {\n        mVelocityTracker.clear();\n    }\n}\n```\n\n这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源\n\n#### 小结\n\n我们可以简单总结下，`onInterceptTouchEvent` 所进行的处理，即在 `TOUCH_DOWN` 资源初始化，`TOUCH_MOVE` 判断是否开始拖动手势，`TOUCH_CANCEL` && `TOUCH_UP` 中进行资源释放。这里涉及了多指触摸的处理。\n\n### onTouchEvent\n\n`onTouchEvent` 要比 `onInterceptTouch` 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。\n\n#### TOUCH_DOWN\n\n``` java\nif (getChildCount() == 0) {\n    return false;\n}\nif ((mIsBeingDragged = !mScroller.isFinished())) {\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n\nif (!mScroller.isFinished()) {\n    mScroller.abortAnimation();\n}\n\nmLastMotionY = (int) ev.getY();\nmActivePointerId = ev.getPointerId(0);\n```\n\n同样的，`onTouchEvent` 在 `TOUCH_DOWN` 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 `abortAnimation`，如果 Scroller 还没结束 fling 计算，则中止处理。\n\n#### TOUCH_MOVE\n\n``` java\nfinal int activePointerIndex = ev.findPointerIndex(mActivePointerId);\nif (activePointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(activePointerIndex);\nint deltaY = mLastMotionY - y;\nif (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {\n    // 嵌套滚动处理\n    deltaY -= mScrollConsumed[1];\n    vtev.offsetLocation(0, mScrollOffset[1]);\n    mNestedYOffset += mScrollOffset[1];\n}\n    if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {\n        final ViewParent parent = getParent();\n        if (parent != null) {\n            parent.requestDisallowInterceptTouchEvent(true);\n        }\n        mIsBeingDragged = true;\n        if (deltaY > 0) {\n            deltaY -= mTouchSlop;\n        } else {\n            deltaY += mTouchSlop;\n        }\n    }\n    \n    if (mIsBeingDragged) {\n        /// 业务逻辑\n    }\n```\n\n这段代码同样会进行多指处理，获取指定手指的触摸事件信息。`mIsBeingDragged` 为 `false`，同时会再进行一次拖动手势的判定，判定逻辑和 `onInterceptTouchEvent` 中类似，如果 `mIsBeingDragged` 为 `true`，则开始进行真正的逻辑处理。\n\n> EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码\n\n#### TOUCH_UP\n\n``` java\nif (mIsBeingDragged) {\n    final VelocityTracker velocityTracker = mVelocityTracker;\n\tvelocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n    int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);\n    \n    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {\n    \tflingWithNestedDispatch(-initialVelocity);\n    }\n    \n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 `getYVelocity` 获取速度，在判断是否可以作为 fling 手势处理，`mMaximumVelocity` 是处理的最大速度，`mMinimumVelocity` 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 `getScaledMaximumFlingVelocity` 和 `getScaledMinimumFlingVelocity` 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：\n\n``` java\nint height = getHeight() - mPaddingBottom - mPaddingTop;\nint bottom = getChildAt(0).getHeight();\n\nmScroller.fling(mScrollX, mScrollY, 0, velocityY, 0, 0, 0,\n                    Math.max(0, bottom - height), 0, height/2);\n\npostInvalidateOnAnimation();\n```\n\n通过传递当前拖动手势速度值来调用 `fling` 进行处理，然后在 `computeScrollOffset` 方法中，进行真正的滚动处理：\n\n``` java\npublic void computeScroll() {\n    if (mScroller.computeScrollOffset()) {\n      \t// 逻辑处理\n        int x = mScroller.getCurrX();\n        int y = mScroller.getCurrY();\n        postInvalidateOnAnimation();\n    }\n}\n```\n\n首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 `computeScrollOffset` 进行计算，如果返回 `true`，表示计算还没结束，然后通过 `getCurrX` 或 `getCurrY` 获取计算后的值，最后进行真正的滚动处理，比如调用 `scrollTo` 等等，这里需要注意的是，需要调用 `invalidate` 来确保进行下一次的 `computeScroll` 调用，这里使用的 `postInvalidateOnAnimation` 其作用是类似的。\n\n#### TOUCH_CANCEL\n\n``` java\nif (mIsBeingDragged && getChildCount() > 0) {\n    if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {\n        postInvalidateOnAnimation();\n    }\n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n同样的，一般我们都会在 `TOUCH_CANCEL` 中释放资源。\n\n#### ACTION_POINTER_DOWN\n\n当有新的手指按下时分发的事件\n\n``` java\nfinal int index = ev.getActionIndex();\nmLastMotionY = (int) ev.getY(index);\nmActivePointerId = ev.getPointerId(index);\n```\n\n以新按下的手指的信息重新计算\n\n#### ACTION_POINTER_UP\n\n这里的处理和 `onInterceptTouch` 一致\n\n#### 小结\n\n`onTouchEvent` 和 `onInterceptTouchEvent` 处理有些相似，主要是在 `TOUCH_MOVE` 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 `TOUCH_UP` 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。\n\n### 总结\n\n在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 `NestedScrollView`、`RecyclerView`  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 `ViewDragHelper` ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。\n\n## 实战\n\n理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：\n\n![WheelView](https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim)\n\n![TapeView](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/more.gif?x-oss-process=style/doc-img)\n\n详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是[滚轮控件](https://github.com/LinXiaoTao/WheelView)，第二个是之前参加活动的仿薄荷健康的[卷尺控件](https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md)。在这里我们只分析部分代码：\n\n### 滚轮控件\n\n在前面手势判定中的分析中，我们提到在 `onTouchEvent` 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：\n\n``` java\nif (mIsBeingDragged) {\n    mDistanceY += mLastY - moveY;\n    postInvalidateOnAnimation();\n}\n```\n\n在每次 `TOUCH_MOVE` 事件分发时，计算与 `TOUCH_DOWN` 时记录的位置信息的差值，保存为 `mDistanceY`，并且在 `onDraw` 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。\n\n### 卷尺控件\n\n拖动距离的计算与滚轮控件一样，只是记录为 `mOffsetLeft` 而已，同时两个控件都有在 `onTouchEvent` 的 `ACTION_UP` 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。\n\n## 结语\n\n文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。\n\n但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：\n\n* 最基本的拖动手势处理\n* fling 效果实现\n* 如果可以，再实现边缘效果\n\n感谢大家的阅读。\n\n\n\n","source":"_posts/触摸事件实践之路.md","raw":"---\ntitle: 触摸事件实践之路\ndate: 2018-04-03 09:17:20\ncategories: Android Application\ntags: \n---\n\n## 前言\n\n最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。\n\n## 触摸事件简单回顾\n\n我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。\n\n![TouchEvent](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/TouchEvent.png?x-oss-process=style/doc-img)\n\n上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 `dispatchTouchEvent` 开始分发，先判断 ViewGroup 的 `onInterceptTouchEvent` 是否拦截，同时这里也可以调用 ViewGroup 的 `requestDisallowInterceptTouchEvent` 让 ViewGroup 不调用 `onInterceptTouchEvent`，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 `dispatchTouchEvent`，反之，则调用子视图的 `dispatchTouchEvent`，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 `dispatchTouchEvent`。\n\n最终都会调用到 View 的 `onTouchEvent` 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。\n\n## 手势判定\n\n上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。\n\n当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：\n\nScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 `onInterceptTouchEvent`\n\n> 因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。\n>\n> 源码部分基于 Android 26\n\n### onInterceptTouchEvent\n\n``` java\nif ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {\n    return true;\n}\n```\n\n用 `mIsBeingDragged` 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 `ACTION_MOVE`，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。\n\n#### TOUCH_DOWN\n\n``` java\nif (!inChild((int) ev.getX(), (int) y)) {\n    mIsBeingDragged = false;\n    recycleVelocityTracker();\n    break;\n}\n```\n\n这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。\n\n``` java\nmLastMotionY = y;\nmActivePointerId = ev.getPointerId(0);\ninitOrResetVelocityTracker();\nmVelocityTracker.addMovement(ev);\n\nmScroller.computeScrollOffset();\nmIsBeingDragged = !mScroller.isFinished();\n\nstartNestedScroll(SCROLL_AXIS_VERTICAL);\n```\n\n这段代码主要是用于初始化判定之前的资源，比如 `mLastMotionY` 记录按下时的坐标信息，`mActivePointerId` 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，`initOrResetVelocityTracker` 初始化速度跟踪器，同时使用 `addMovement` 记录当前触摸事件信息，`mScroller` 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，`startNestedScroll` 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。\n\n#### TOUCH_MOVE\n\n```java\nfinal int activePointerId = mActivePointerId;\nif (activePointerId == INVALID_POINTER) {\n    break;\n}\nfinal int pointerIndex = ev.findPointerIndex(activePointerId);\nif (pointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(pointerIndex);\nfinal int yDiff = Math.abs(y - mLastMotionY);\nif (yDiff > mTouchSlop && (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {\n    mIsBeingDragged = true;\n    mLastMotionY = y;\n    initVelocityTrackerIfNotExists();\n    mVelocityTracker.addMovement(ev);\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n```\n\n这段代码先使用我们在 `TOUCH_DOWN` 中记录的  `mActivePointerId` 进行是否为有效的判断，如果有效，则通过 `findPointerIndex` 获取作用手指 id 的下标，记录为  `pointerIndex` ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。`yDiff` 是滑动的距离，`mTouchSlop` 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 `getScaledTouchSlop` 获取，如果大于这个值，我们可以认为开始了拖动的手势。 `getNestedScrollAxes` 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，`mIsBeingDragged` 标记为 `true`，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 `requestDisallowInterceptTouchEvent`，防止父视图拦截了事件，即 `onInterceptTouchEvent`\n\n#### TOUCH_CANCEL && TOUCH_UP\n\n``` java\nmIsBeingDragged = false;\nmActivePointerId = INVALID_POINTER;\nrecycleVelocityTracker();\nstopNestedScroll();\n```\n\n一般我们都会在 `TOUCH_CANCEL` 和 `TOUCH_UP` 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 `mIsBeingDragged` 设置为 `false`，释放速度跟踪器等等 \n\n> `TOUCH_UP` 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 `TOUCH_CANCEL` 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 `TOUCH_DOWN`，即在这个事件分发时，向父视图传递了 `true` 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 `ACTION_MOVE` 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 `onInterceptTouch` 中返回了 `true`，那么在 ViewGroup 的 `dispatchTouchEvent` 中会给已经确认消费事件的子视图分发一个 `TOUCH_CANCEL` 的事件，具体可以阅读源码。\n\n#### ACTION_POINTER_UP\n\n这个为多指触摸时，某个手指抬起时分发的事件。\n\n``` java\nfinal int pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >>\n                MotionEvent.ACTION_POINTER_INDEX_SHIFT;\nfinal int pointerId = ev.getPointerId(pointerIndex);\nif (pointerId == mActivePointerId) {\n    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n    mLastMotionY = (int) ev.getY(newPointerIndex);\n    mActivePointerId = ev.getPointerId(newPointerIndex);\n    if (mVelocityTracker != null) {\n        mVelocityTracker.clear();\n    }\n}\n```\n\n这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源\n\n#### 小结\n\n我们可以简单总结下，`onInterceptTouchEvent` 所进行的处理，即在 `TOUCH_DOWN` 资源初始化，`TOUCH_MOVE` 判断是否开始拖动手势，`TOUCH_CANCEL` && `TOUCH_UP` 中进行资源释放。这里涉及了多指触摸的处理。\n\n### onTouchEvent\n\n`onTouchEvent` 要比 `onInterceptTouch` 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。\n\n#### TOUCH_DOWN\n\n``` java\nif (getChildCount() == 0) {\n    return false;\n}\nif ((mIsBeingDragged = !mScroller.isFinished())) {\n    final ViewParent parent = getParent();\n    if (parent != null) {\n        parent.requestDisallowInterceptTouchEvent(true);\n    }\n}\n\nif (!mScroller.isFinished()) {\n    mScroller.abortAnimation();\n}\n\nmLastMotionY = (int) ev.getY();\nmActivePointerId = ev.getPointerId(0);\n```\n\n同样的，`onTouchEvent` 在 `TOUCH_DOWN` 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 `abortAnimation`，如果 Scroller 还没结束 fling 计算，则中止处理。\n\n#### TOUCH_MOVE\n\n``` java\nfinal int activePointerIndex = ev.findPointerIndex(mActivePointerId);\nif (activePointerIndex == -1) {\n    break;\n}\nfinal int y = (int) ev.getY(activePointerIndex);\nint deltaY = mLastMotionY - y;\nif (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {\n    // 嵌套滚动处理\n    deltaY -= mScrollConsumed[1];\n    vtev.offsetLocation(0, mScrollOffset[1]);\n    mNestedYOffset += mScrollOffset[1];\n}\n    if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {\n        final ViewParent parent = getParent();\n        if (parent != null) {\n            parent.requestDisallowInterceptTouchEvent(true);\n        }\n        mIsBeingDragged = true;\n        if (deltaY > 0) {\n            deltaY -= mTouchSlop;\n        } else {\n            deltaY += mTouchSlop;\n        }\n    }\n    \n    if (mIsBeingDragged) {\n        /// 业务逻辑\n    }\n```\n\n这段代码同样会进行多指处理，获取指定手指的触摸事件信息。`mIsBeingDragged` 为 `false`，同时会再进行一次拖动手势的判定，判定逻辑和 `onInterceptTouchEvent` 中类似，如果 `mIsBeingDragged` 为 `true`，则开始进行真正的逻辑处理。\n\n> EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码\n\n#### TOUCH_UP\n\n``` java\nif (mIsBeingDragged) {\n    final VelocityTracker velocityTracker = mVelocityTracker;\n\tvelocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n    int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);\n    \n    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {\n    \tflingWithNestedDispatch(-initialVelocity);\n    }\n    \n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 `getYVelocity` 获取速度，在判断是否可以作为 fling 手势处理，`mMaximumVelocity` 是处理的最大速度，`mMinimumVelocity` 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 `getScaledMaximumFlingVelocity` 和 `getScaledMinimumFlingVelocity` 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：\n\n``` java\nint height = getHeight() - mPaddingBottom - mPaddingTop;\nint bottom = getChildAt(0).getHeight();\n\nmScroller.fling(mScrollX, mScrollY, 0, velocityY, 0, 0, 0,\n                    Math.max(0, bottom - height), 0, height/2);\n\npostInvalidateOnAnimation();\n```\n\n通过传递当前拖动手势速度值来调用 `fling` 进行处理，然后在 `computeScrollOffset` 方法中，进行真正的滚动处理：\n\n``` java\npublic void computeScroll() {\n    if (mScroller.computeScrollOffset()) {\n      \t// 逻辑处理\n        int x = mScroller.getCurrX();\n        int y = mScroller.getCurrY();\n        postInvalidateOnAnimation();\n    }\n}\n```\n\n首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 `computeScrollOffset` 进行计算，如果返回 `true`，表示计算还没结束，然后通过 `getCurrX` 或 `getCurrY` 获取计算后的值，最后进行真正的滚动处理，比如调用 `scrollTo` 等等，这里需要注意的是，需要调用 `invalidate` 来确保进行下一次的 `computeScroll` 调用，这里使用的 `postInvalidateOnAnimation` 其作用是类似的。\n\n#### TOUCH_CANCEL\n\n``` java\nif (mIsBeingDragged && getChildCount() > 0) {\n    if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {\n        postInvalidateOnAnimation();\n    }\n    mActivePointerId = INVALID_POINTER;\n    endDrag();\n}\n```\n\n同样的，一般我们都会在 `TOUCH_CANCEL` 中释放资源。\n\n#### ACTION_POINTER_DOWN\n\n当有新的手指按下时分发的事件\n\n``` java\nfinal int index = ev.getActionIndex();\nmLastMotionY = (int) ev.getY(index);\nmActivePointerId = ev.getPointerId(index);\n```\n\n以新按下的手指的信息重新计算\n\n#### ACTION_POINTER_UP\n\n这里的处理和 `onInterceptTouch` 一致\n\n#### 小结\n\n`onTouchEvent` 和 `onInterceptTouchEvent` 处理有些相似，主要是在 `TOUCH_MOVE` 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 `TOUCH_UP` 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。\n\n### 总结\n\n在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 `NestedScrollView`、`RecyclerView`  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 `ViewDragHelper` ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。\n\n## 实战\n\n理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：\n\n![WheelView](https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim)\n\n![TapeView](https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/more.gif?x-oss-process=style/doc-img)\n\n详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是[滚轮控件](https://github.com/LinXiaoTao/WheelView)，第二个是之前参加活动的仿薄荷健康的[卷尺控件](https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md)。在这里我们只分析部分代码：\n\n### 滚轮控件\n\n在前面手势判定中的分析中，我们提到在 `onTouchEvent` 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：\n\n``` java\nif (mIsBeingDragged) {\n    mDistanceY += mLastY - moveY;\n    postInvalidateOnAnimation();\n}\n```\n\n在每次 `TOUCH_MOVE` 事件分发时，计算与 `TOUCH_DOWN` 时记录的位置信息的差值，保存为 `mDistanceY`，并且在 `onDraw` 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。\n\n### 卷尺控件\n\n拖动距离的计算与滚轮控件一样，只是记录为 `mOffsetLeft` 而已，同时两个控件都有在 `onTouchEvent` 的 `ACTION_UP` 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。\n\n## 结语\n\n文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。\n\n但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：\n\n* 最基本的拖动手势处理\n* fling 效果实现\n* 如果可以，再实现边缘效果\n\n感谢大家的阅读。\n\n\n\n","slug":"触摸事件实践之路","published":1,"updated":"2018-11-16T10:13:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs1d0018e39kmsgfii4a","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。</p>\n<h2 id=\"触摸事件简单回顾\"><a href=\"#触摸事件简单回顾\" class=\"headerlink\" title=\"触摸事件简单回顾\"></a>触摸事件简单回顾</h2><p>我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/TouchEvent.png?x-oss-process=style/doc-img\" alt=\"TouchEvent\"></p>\n<p>上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 <code>dispatchTouchEvent</code> 开始分发，先判断 ViewGroup 的 <code>onInterceptTouchEvent</code> 是否拦截，同时这里也可以调用 ViewGroup 的 <code>requestDisallowInterceptTouchEvent</code> 让 ViewGroup 不调用 <code>onInterceptTouchEvent</code>，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 <code>dispatchTouchEvent</code>，反之，则调用子视图的 <code>dispatchTouchEvent</code>，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 <code>dispatchTouchEvent</code>。</p>\n<p>最终都会调用到 View 的 <code>onTouchEvent</code> 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。</p>\n<h2 id=\"手势判定\"><a href=\"#手势判定\" class=\"headerlink\" title=\"手势判定\"></a>手势判定</h2><p>上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。</p>\n<p>当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：</p>\n<p>ScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 <code>onInterceptTouchEvent</code></p>\n<blockquote>\n<p>因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。</p>\n<p>源码部分基于 Android 26</p>\n</blockquote>\n<h3 id=\"onInterceptTouchEvent\"><a href=\"#onInterceptTouchEvent\" class=\"headerlink\" title=\"onInterceptTouchEvent\"></a>onInterceptTouchEvent</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 <code>mIsBeingDragged</code> 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 <code>ACTION_MOVE</code>，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。</p>\n<h4 id=\"TOUCH-DOWN\"><a href=\"#TOUCH-DOWN\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!inChild((<span class=\"keyword\">int</span>) ev.getX(), (<span class=\"keyword\">int</span>) y)) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    recycleVelocityTracker();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mLastMotionY = y;</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br><span class=\"line\">initOrResetVelocityTracker();</span><br><span class=\"line\">mVelocityTracker.addMovement(ev);</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.computeScrollOffset();</span><br><span class=\"line\">mIsBeingDragged = !mScroller.isFinished();</span><br><span class=\"line\"></span><br><span class=\"line\">startNestedScroll(SCROLL_AXIS_VERTICAL);</span><br></pre></td></tr></table></figure>\n<p>这段代码主要是用于初始化判定之前的资源，比如 <code>mLastMotionY</code> 记录按下时的坐标信息，<code>mActivePointerId</code> 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，<code>initOrResetVelocityTracker</code> 初始化速度跟踪器，同时使用 <code>addMovement</code> 记录当前触摸事件信息，<code>mScroller</code> 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，<code>startNestedScroll</code> 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。</p>\n<h4 id=\"TOUCH-MOVE\"><a href=\"#TOUCH-MOVE\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerId = mActivePointerId;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerId == INVALID_POINTER) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = ev.findPointerIndex(activePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> yDiff = Math.abs(y - mLastMotionY);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mLastMotionY = y;</span><br><span class=\"line\">    initVelocityTrackerIfNotExists();</span><br><span class=\"line\">    mVelocityTracker.addMovement(ev);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码先使用我们在 <code>TOUCH_DOWN</code> 中记录的  <code>mActivePointerId</code> 进行是否为有效的判断，如果有效，则通过 <code>findPointerIndex</code> 获取作用手指 id 的下标，记录为  <code>pointerIndex</code> ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。<code>yDiff</code> 是滑动的距离，<code>mTouchSlop</code> 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 <code>getScaledTouchSlop</code> 获取，如果大于这个值，我们可以认为开始了拖动的手势。 <code>getNestedScrollAxes</code> 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，<code>mIsBeingDragged</code> 标记为 <code>true</code>，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 <code>requestDisallowInterceptTouchEvent</code>，防止父视图拦截了事件，即 <code>onInterceptTouchEvent</code></p>\n<h4 id=\"TOUCH-CANCEL-amp-amp-TOUCH-UP\"><a href=\"#TOUCH-CANCEL-amp-amp-TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_CANCEL &amp;&amp; TOUCH_UP\"></a>TOUCH_CANCEL &amp;&amp; TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">recycleVelocityTracker();</span><br><span class=\"line\">stopNestedScroll();</span><br></pre></td></tr></table></figure>\n<p>一般我们都会在 <code>TOUCH_CANCEL</code> 和 <code>TOUCH_UP</code> 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 <code>mIsBeingDragged</code> 设置为 <code>false</code>，释放速度跟踪器等等 </p>\n<blockquote>\n<p><code>TOUCH_UP</code> 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 <code>TOUCH_CANCEL</code> 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 <code>TOUCH_DOWN</code>，即在这个事件分发时，向父视图传递了 <code>true</code> 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 <code>ACTION_MOVE</code> 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 <code>onInterceptTouch</code> 中返回了 <code>true</code>，那么在 ViewGroup 的 <code>dispatchTouchEvent</code> 中会给已经确认消费事件的子视图分发一个 <code>TOUCH_CANCEL</code> 的事件，具体可以阅读源码。</p>\n</blockquote>\n<h4 id=\"ACTION-POINTER-UP\"><a href=\"#ACTION-POINTER-UP\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这个为多指触摸时，某个手指抬起时分发的事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;</span><br><span class=\"line\">                MotionEvent.ACTION_POINTER_INDEX_SHIFT;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerId = ev.getPointerId(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerId == mActivePointerId) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> newPointerIndex = pointerIndex == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">    mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(newPointerIndex);</span><br><span class=\"line\">    mActivePointerId = ev.getPointerId(newPointerIndex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mVelocityTracker != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mVelocityTracker.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>我们可以简单总结下，<code>onInterceptTouchEvent</code> 所进行的处理，即在 <code>TOUCH_DOWN</code> 资源初始化，<code>TOUCH_MOVE</code> 判断是否开始拖动手势，<code>TOUCH_CANCEL</code> &amp;&amp; <code>TOUCH_UP</code> 中进行资源释放。这里涉及了多指触摸的处理。</p>\n<h3 id=\"onTouchEvent\"><a href=\"#onTouchEvent\" class=\"headerlink\" title=\"onTouchEvent\"></a>onTouchEvent</h3><p><code>onTouchEvent</code> 要比 <code>onInterceptTouch</code> 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。</p>\n<h4 id=\"TOUCH-DOWN-1\"><a href=\"#TOUCH-DOWN-1\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (getChildCount() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((mIsBeingDragged = !mScroller.isFinished())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!mScroller.isFinished()) &#123;</span><br><span class=\"line\">    mScroller.abortAnimation();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY();</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>同样的，<code>onTouchEvent</code> 在 <code>TOUCH_DOWN</code> 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 <code>abortAnimation</code>，如果 Scroller 还没结束 fling 计算，则中止处理。</p>\n<h4 id=\"TOUCH-MOVE-1\"><a href=\"#TOUCH-MOVE-1\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerIndex = ev.findPointerIndex(mActivePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(activePointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">int</span> deltaY = mLastMotionY - y;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (dispatchNestedPreScroll(<span class=\"number\">0</span>, deltaY, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 嵌套滚动处理</span></span><br><span class=\"line\">    deltaY -= mScrollConsumed[<span class=\"number\">1</span>];</span><br><span class=\"line\">    vtev.offsetLocation(<span class=\"number\">0</span>, mScrollOffset[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    mNestedYOffset += mScrollOffset[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mIsBeingDragged &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (deltaY &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            deltaY -= mTouchSlop;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            deltaY += mTouchSlop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码同样会进行多指处理，获取指定手指的触摸事件信息。<code>mIsBeingDragged</code> 为 <code>false</code>，同时会再进行一次拖动手势的判定，判定逻辑和 <code>onInterceptTouchEvent</code> 中类似，如果 <code>mIsBeingDragged</code> 为 <code>true</code>，则开始进行真正的逻辑处理。</p>\n<blockquote>\n<p>EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码</p>\n</blockquote>\n<h4 id=\"TOUCH-UP\"><a href=\"#TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_UP\"></a>TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> VelocityTracker velocityTracker = mVelocityTracker;</span><br><span class=\"line\">\tvelocityTracker.computeCurrentVelocity(<span class=\"number\">1000</span>, mMaximumVelocity);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> initialVelocity = (<span class=\"keyword\">int</span>) velocityTracker.getYVelocity(mActivePointerId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((Math.abs(initialVelocity) &gt; mMinimumVelocity)) &#123;</span><br><span class=\"line\">    \tflingWithNestedDispatch(-initialVelocity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 <code>getYVelocity</code> 获取速度，在判断是否可以作为 fling 手势处理，<code>mMaximumVelocity</code> 是处理的最大速度，<code>mMinimumVelocity</code> 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 <code>getScaledMaximumFlingVelocity</code> 和 <code>getScaledMinimumFlingVelocity</code> 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> height = getHeight() - mPaddingBottom - mPaddingTop;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bottom = getChildAt(<span class=\"number\">0</span>).getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.fling(mScrollX, mScrollY, <span class=\"number\">0</span>, velocityY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                    Math.max(<span class=\"number\">0</span>, bottom - height), <span class=\"number\">0</span>, height/<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">postInvalidateOnAnimation();</span><br></pre></td></tr></table></figure>\n<p>通过传递当前拖动手势速度值来调用 <code>fling</code> 进行处理，然后在 <code>computeScrollOffset</code> 方法中，进行真正的滚动处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 逻辑处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = mScroller.getCurrX();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = mScroller.getCurrY();</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 <code>computeScrollOffset</code> 进行计算，如果返回 <code>true</code>，表示计算还没结束，然后通过 <code>getCurrX</code> 或 <code>getCurrY</code> 获取计算后的值，最后进行真正的滚动处理，比如调用 <code>scrollTo</code> 等等，这里需要注意的是，需要调用 <code>invalidate</code> 来确保进行下一次的 <code>computeScroll</code> 调用，这里使用的 <code>postInvalidateOnAnimation</code> 其作用是类似的。</p>\n<h4 id=\"TOUCH-CANCEL\"><a href=\"#TOUCH-CANCEL\" class=\"headerlink\" title=\"TOUCH_CANCEL\"></a>TOUCH_CANCEL</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged &amp;&amp; getChildCount() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.springBack(mScrollX, mScrollY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, getScrollRange())) &#123;</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的，一般我们都会在 <code>TOUCH_CANCEL</code> 中释放资源。</p>\n<h4 id=\"ACTION-POINTER-DOWN\"><a href=\"#ACTION-POINTER-DOWN\" class=\"headerlink\" title=\"ACTION_POINTER_DOWN\"></a>ACTION_POINTER_DOWN</h4><p>当有新的手指按下时分发的事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = ev.getActionIndex();</span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(index);</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(index);</span><br></pre></td></tr></table></figure>\n<p>以新按下的手指的信息重新计算</p>\n<h4 id=\"ACTION-POINTER-UP-1\"><a href=\"#ACTION-POINTER-UP-1\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这里的处理和 <code>onInterceptTouch</code> 一致</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><code>onTouchEvent</code> 和 <code>onInterceptTouchEvent</code> 处理有些相似，主要是在 <code>TOUCH_MOVE</code> 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 <code>TOUCH_UP</code> 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 <code>NestedScrollView</code>、<code>RecyclerView</code>  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 <code>ViewDragHelper</code> ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim\" alt=\"WheelView\"></p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/more.gif?x-oss-process=style/doc-img\" alt=\"TapeView\"></p>\n<p>详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是<a href=\"https://github.com/LinXiaoTao/WheelView\" target=\"_blank\" rel=\"noopener\">滚轮控件</a>，第二个是之前参加活动的仿薄荷健康的<a href=\"https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md\" target=\"_blank\" rel=\"noopener\">卷尺控件</a>。在这里我们只分析部分代码：</p>\n<h3 id=\"滚轮控件\"><a href=\"#滚轮控件\" class=\"headerlink\" title=\"滚轮控件\"></a>滚轮控件</h3><p>在前面手势判定中的分析中，我们提到在 <code>onTouchEvent</code> 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    mDistanceY += mLastY - moveY;</span><br><span class=\"line\">    postInvalidateOnAnimation();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在每次 <code>TOUCH_MOVE</code> 事件分发时，计算与 <code>TOUCH_DOWN</code> 时记录的位置信息的差值，保存为 <code>mDistanceY</code>，并且在 <code>onDraw</code> 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。</p>\n<h3 id=\"卷尺控件\"><a href=\"#卷尺控件\" class=\"headerlink\" title=\"卷尺控件\"></a>卷尺控件</h3><p>拖动距离的计算与滚轮控件一样，只是记录为 <code>mOffsetLeft</code> 而已，同时两个控件都有在 <code>onTouchEvent</code> 的 <code>ACTION_UP</code> 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。</p>\n<p>但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：</p>\n<ul>\n<li>最基本的拖动手势处理</li>\n<li>fling 效果实现</li>\n<li>如果可以，再实现边缘效果</li>\n</ul>\n<p>感谢大家的阅读。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。</p>\n<h2 id=\"触摸事件简单回顾\"><a href=\"#触摸事件简单回顾\" class=\"headerlink\" title=\"触摸事件简单回顾\"></a>触摸事件简单回顾</h2><p>我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。</p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/TouchEvent.png?x-oss-process=style/doc-img\" alt=\"TouchEvent\"></p>\n<p>上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 <code>dispatchTouchEvent</code> 开始分发，先判断 ViewGroup 的 <code>onInterceptTouchEvent</code> 是否拦截，同时这里也可以调用 ViewGroup 的 <code>requestDisallowInterceptTouchEvent</code> 让 ViewGroup 不调用 <code>onInterceptTouchEvent</code>，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 <code>dispatchTouchEvent</code>，反之，则调用子视图的 <code>dispatchTouchEvent</code>，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 <code>dispatchTouchEvent</code>。</p>\n<p>最终都会调用到 View 的 <code>onTouchEvent</code> 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。</p>\n<h2 id=\"手势判定\"><a href=\"#手势判定\" class=\"headerlink\" title=\"手势判定\"></a>手势判定</h2><p>上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。</p>\n<p>当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下：</p>\n<p>ScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 <code>onInterceptTouchEvent</code></p>\n<blockquote>\n<p>因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。</p>\n<p>源码部分基于 Android 26</p>\n</blockquote>\n<h3 id=\"onInterceptTouchEvent\"><a href=\"#onInterceptTouchEvent\" class=\"headerlink\" title=\"onInterceptTouchEvent\"></a>onInterceptTouchEvent</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 <code>mIsBeingDragged</code> 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 <code>ACTION_MOVE</code>，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。</p>\n<h4 id=\"TOUCH-DOWN\"><a href=\"#TOUCH-DOWN\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!inChild((<span class=\"keyword\">int</span>) ev.getX(), (<span class=\"keyword\">int</span>) y)) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    recycleVelocityTracker();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mLastMotionY = y;</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br><span class=\"line\">initOrResetVelocityTracker();</span><br><span class=\"line\">mVelocityTracker.addMovement(ev);</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.computeScrollOffset();</span><br><span class=\"line\">mIsBeingDragged = !mScroller.isFinished();</span><br><span class=\"line\"></span><br><span class=\"line\">startNestedScroll(SCROLL_AXIS_VERTICAL);</span><br></pre></td></tr></table></figure>\n<p>这段代码主要是用于初始化判定之前的资源，比如 <code>mLastMotionY</code> 记录按下时的坐标信息，<code>mActivePointerId</code> 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，<code>initOrResetVelocityTracker</code> 初始化速度跟踪器，同时使用 <code>addMovement</code> 记录当前触摸事件信息，<code>mScroller</code> 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，<code>startNestedScroll</code> 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。</p>\n<h4 id=\"TOUCH-MOVE\"><a href=\"#TOUCH-MOVE\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerId = mActivePointerId;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerId == INVALID_POINTER) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = ev.findPointerIndex(activePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> yDiff = Math.abs(y - mLastMotionY);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mLastMotionY = y;</span><br><span class=\"line\">    initVelocityTrackerIfNotExists();</span><br><span class=\"line\">    mVelocityTracker.addMovement(ev);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码先使用我们在 <code>TOUCH_DOWN</code> 中记录的  <code>mActivePointerId</code> 进行是否为有效的判断，如果有效，则通过 <code>findPointerIndex</code> 获取作用手指 id 的下标，记录为  <code>pointerIndex</code> ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。<code>yDiff</code> 是滑动的距离，<code>mTouchSlop</code> 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 <code>getScaledTouchSlop</code> 获取，如果大于这个值，我们可以认为开始了拖动的手势。 <code>getNestedScrollAxes</code> 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，<code>mIsBeingDragged</code> 标记为 <code>true</code>，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 <code>requestDisallowInterceptTouchEvent</code>，防止父视图拦截了事件，即 <code>onInterceptTouchEvent</code></p>\n<h4 id=\"TOUCH-CANCEL-amp-amp-TOUCH-UP\"><a href=\"#TOUCH-CANCEL-amp-amp-TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_CANCEL &amp;&amp; TOUCH_UP\"></a>TOUCH_CANCEL &amp;&amp; TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mIsBeingDragged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">recycleVelocityTracker();</span><br><span class=\"line\">stopNestedScroll();</span><br></pre></td></tr></table></figure>\n<p>一般我们都会在 <code>TOUCH_CANCEL</code> 和 <code>TOUCH_UP</code> 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 <code>mIsBeingDragged</code> 设置为 <code>false</code>，释放速度跟踪器等等 </p>\n<blockquote>\n<p><code>TOUCH_UP</code> 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 <code>TOUCH_CANCEL</code> 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 <code>TOUCH_DOWN</code>，即在这个事件分发时，向父视图传递了 <code>true</code> 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 <code>ACTION_MOVE</code> 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 <code>onInterceptTouch</code> 中返回了 <code>true</code>，那么在 ViewGroup 的 <code>dispatchTouchEvent</code> 中会给已经确认消费事件的子视图分发一个 <code>TOUCH_CANCEL</code> 的事件，具体可以阅读源码。</p>\n</blockquote>\n<h4 id=\"ACTION-POINTER-UP\"><a href=\"#ACTION-POINTER-UP\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这个为多指触摸时，某个手指抬起时分发的事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;</span><br><span class=\"line\">                MotionEvent.ACTION_POINTER_INDEX_SHIFT;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerId = ev.getPointerId(pointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointerId == mActivePointerId) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> newPointerIndex = pointerIndex == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">    mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(newPointerIndex);</span><br><span class=\"line\">    mActivePointerId = ev.getPointerId(newPointerIndex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mVelocityTracker != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mVelocityTracker.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>我们可以简单总结下，<code>onInterceptTouchEvent</code> 所进行的处理，即在 <code>TOUCH_DOWN</code> 资源初始化，<code>TOUCH_MOVE</code> 判断是否开始拖动手势，<code>TOUCH_CANCEL</code> &amp;&amp; <code>TOUCH_UP</code> 中进行资源释放。这里涉及了多指触摸的处理。</p>\n<h3 id=\"onTouchEvent\"><a href=\"#onTouchEvent\" class=\"headerlink\" title=\"onTouchEvent\"></a>onTouchEvent</h3><p><code>onTouchEvent</code> 要比 <code>onInterceptTouch</code> 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。</p>\n<h4 id=\"TOUCH-DOWN-1\"><a href=\"#TOUCH-DOWN-1\" class=\"headerlink\" title=\"TOUCH_DOWN\"></a>TOUCH_DOWN</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (getChildCount() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((mIsBeingDragged = !mScroller.isFinished())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!mScroller.isFinished()) &#123;</span><br><span class=\"line\">    mScroller.abortAnimation();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY();</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>同样的，<code>onTouchEvent</code> 在 <code>TOUCH_DOWN</code> 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 <code>abortAnimation</code>，如果 Scroller 还没结束 fling 计算，则中止处理。</p>\n<h4 id=\"TOUCH-MOVE-1\"><a href=\"#TOUCH-MOVE-1\" class=\"headerlink\" title=\"TOUCH_MOVE\"></a>TOUCH_MOVE</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> activePointerIndex = ev.findPointerIndex(mActivePointerId);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (activePointerIndex == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y = (<span class=\"keyword\">int</span>) ev.getY(activePointerIndex);</span><br><span class=\"line\"><span class=\"keyword\">int</span> deltaY = mLastMotionY - y;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (dispatchNestedPreScroll(<span class=\"number\">0</span>, deltaY, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 嵌套滚动处理</span></span><br><span class=\"line\">    deltaY -= mScrollConsumed[<span class=\"number\">1</span>];</span><br><span class=\"line\">    vtev.offsetLocation(<span class=\"number\">0</span>, mScrollOffset[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    mNestedYOffset += mScrollOffset[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mIsBeingDragged &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ViewParent parent = getParent();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mIsBeingDragged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (deltaY &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            deltaY -= mTouchSlop;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            deltaY += mTouchSlop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码同样会进行多指处理，获取指定手指的触摸事件信息。<code>mIsBeingDragged</code> 为 <code>false</code>，同时会再进行一次拖动手势的判定，判定逻辑和 <code>onInterceptTouchEvent</code> 中类似，如果 <code>mIsBeingDragged</code> 为 <code>true</code>，则开始进行真正的逻辑处理。</p>\n<blockquote>\n<p>EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码</p>\n</blockquote>\n<h4 id=\"TOUCH-UP\"><a href=\"#TOUCH-UP\" class=\"headerlink\" title=\"TOUCH_UP\"></a>TOUCH_UP</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> VelocityTracker velocityTracker = mVelocityTracker;</span><br><span class=\"line\">\tvelocityTracker.computeCurrentVelocity(<span class=\"number\">1000</span>, mMaximumVelocity);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> initialVelocity = (<span class=\"keyword\">int</span>) velocityTracker.getYVelocity(mActivePointerId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((Math.abs(initialVelocity) &gt; mMinimumVelocity)) &#123;</span><br><span class=\"line\">    \tflingWithNestedDispatch(-initialVelocity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 <code>getYVelocity</code> 获取速度，在判断是否可以作为 fling 手势处理，<code>mMaximumVelocity</code> 是处理的最大速度，<code>mMinimumVelocity</code> 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 <code>getScaledMaximumFlingVelocity</code> 和 <code>getScaledMinimumFlingVelocity</code> 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> height = getHeight() - mPaddingBottom - mPaddingTop;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bottom = getChildAt(<span class=\"number\">0</span>).getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">mScroller.fling(mScrollX, mScrollY, <span class=\"number\">0</span>, velocityY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                    Math.max(<span class=\"number\">0</span>, bottom - height), <span class=\"number\">0</span>, height/<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">postInvalidateOnAnimation();</span><br></pre></td></tr></table></figure>\n<p>通过传递当前拖动手势速度值来调用 <code>fling</code> 进行处理，然后在 <code>computeScrollOffset</code> 方法中，进行真正的滚动处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 逻辑处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = mScroller.getCurrX();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = mScroller.getCurrY();</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 <code>computeScrollOffset</code> 进行计算，如果返回 <code>true</code>，表示计算还没结束，然后通过 <code>getCurrX</code> 或 <code>getCurrY</code> 获取计算后的值，最后进行真正的滚动处理，比如调用 <code>scrollTo</code> 等等，这里需要注意的是，需要调用 <code>invalidate</code> 来确保进行下一次的 <code>computeScroll</code> 调用，这里使用的 <code>postInvalidateOnAnimation</code> 其作用是类似的。</p>\n<h4 id=\"TOUCH-CANCEL\"><a href=\"#TOUCH-CANCEL\" class=\"headerlink\" title=\"TOUCH_CANCEL\"></a>TOUCH_CANCEL</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged &amp;&amp; getChildCount() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mScroller.springBack(mScrollX, mScrollY, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, getScrollRange())) &#123;</span><br><span class=\"line\">        postInvalidateOnAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mActivePointerId = INVALID_POINTER;</span><br><span class=\"line\">    endDrag();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的，一般我们都会在 <code>TOUCH_CANCEL</code> 中释放资源。</p>\n<h4 id=\"ACTION-POINTER-DOWN\"><a href=\"#ACTION-POINTER-DOWN\" class=\"headerlink\" title=\"ACTION_POINTER_DOWN\"></a>ACTION_POINTER_DOWN</h4><p>当有新的手指按下时分发的事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = ev.getActionIndex();</span><br><span class=\"line\">mLastMotionY = (<span class=\"keyword\">int</span>) ev.getY(index);</span><br><span class=\"line\">mActivePointerId = ev.getPointerId(index);</span><br></pre></td></tr></table></figure>\n<p>以新按下的手指的信息重新计算</p>\n<h4 id=\"ACTION-POINTER-UP-1\"><a href=\"#ACTION-POINTER-UP-1\" class=\"headerlink\" title=\"ACTION_POINTER_UP\"></a>ACTION_POINTER_UP</h4><p>这里的处理和 <code>onInterceptTouch</code> 一致</p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><code>onTouchEvent</code> 和 <code>onInterceptTouchEvent</code> 处理有些相似，主要是在 <code>TOUCH_MOVE</code> 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 <code>TOUCH_UP</code> 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 <code>NestedScrollView</code>、<code>RecyclerView</code>  等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 <code>ViewDragHelper</code> ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/22/161bd1e1f4774f80?imageslim\" alt=\"WheelView\"></p>\n<p><img src=\"https://leo-doc-img.oss-cn-hangzhou.aliyuncs.com/doc-img/more.gif?x-oss-process=style/doc-img\" alt=\"TapeView\"></p>\n<p>详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是<a href=\"https://github.com/LinXiaoTao/WheelView\" target=\"_blank\" rel=\"noopener\">滚轮控件</a>，第二个是之前参加活动的仿薄荷健康的<a href=\"https://github.com/LinXiaoTao/CustomViewProject/blob/master/app/src/main/java/com/leo/customviewproject/tape/README.md\" target=\"_blank\" rel=\"noopener\">卷尺控件</a>。在这里我们只分析部分代码：</p>\n<h3 id=\"滚轮控件\"><a href=\"#滚轮控件\" class=\"headerlink\" title=\"滚轮控件\"></a>滚轮控件</h3><p>在前面手势判定中的分析中，我们提到在 <code>onTouchEvent</code> 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mIsBeingDragged) &#123;</span><br><span class=\"line\">    mDistanceY += mLastY - moveY;</span><br><span class=\"line\">    postInvalidateOnAnimation();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在每次 <code>TOUCH_MOVE</code> 事件分发时，计算与 <code>TOUCH_DOWN</code> 时记录的位置信息的差值，保存为 <code>mDistanceY</code>，并且在 <code>onDraw</code> 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。</p>\n<h3 id=\"卷尺控件\"><a href=\"#卷尺控件\" class=\"headerlink\" title=\"卷尺控件\"></a>卷尺控件</h3><p>拖动距离的计算与滚轮控件一样，只是记录为 <code>mOffsetLeft</code> 而已，同时两个控件都有在 <code>onTouchEvent</code> 的 <code>ACTION_UP</code> 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。</p>\n<p>但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果：</p>\n<ul>\n<li>最基本的拖动手势处理</li>\n<li>fling 效果实现</li>\n<li>如果可以，再实现边缘效果</li>\n</ul>\n<p>感谢大家的阅读。</p>\n"},{"title":"scoped_model源码解析","date":"2019-05-06T14:13:54.000Z","_content":"\n### 参考\n\n* [ephemeral-vs-app](https://flutter.dev/docs/development/data-and-backend/state-mgmt/ephemeral-vs-app)\n* [inheritedwidget-inheritedmodel]([http://juju.one/inheritedwidget-inheritedmodel/](http://juju.one/inheritedwidget-inheritedmodel/))\n\n\n\n[scoped_model](https://pub.dartlang.org/packages/scoped_model) 是 Google 推荐使用的应用状态管理库（Simple app state management），当然，除了它，还有其他选择，比如 Redux，Rx，hooks 等等。\n\n### 临时状态和应用状态\n\n我们说 scoped_model 用于**应用状态**管理，是因为除了**应用状态（app state）**以外，还有临时状态（ephemeral state）。\n\n#### 临时状态\n\n也可以称为 UI 状态或者本地状态，是一种可以包含在单个 widget 的状态。\n\n比如以下定义：\n\n* `PageView` 当前的页面\n* 动画当前的进度\n* `BottomNavigationBar` 当前选中项\n\n使用临时状态，我们不需要使用状态管理，只需要一个 `StatefulWidget`。\n\n#### 应用状态\n\n需要在应用中多个组件之间共享，而且在不同的用户会话之间保持，这就是应用状态，有时候也称为共享状态。\n\n比如以下定义：\n\n* 用户偏好设置\n* 登录信息\n* 通知栏功能\n* 购物车功能\n* 已读未读功能\n\n\n\n临时状态和应用状态之间没有非常明确的界限，比如你可能需要持久化保存 `BottomNavigationBar` 的选中项，那它就不是临时状态了，而是应用状态。如果你愿意，你甚至可以不用任何状态管理库，只使用 `State` 和 `setState()` 来管理应用所有的状态。\n\n### scoped_model\n\nscoped_model 由三个部分组成，`ScopedModel`、`ScopedModelDescendant` 和 `Model`。\n\n#### Model\n\n`Model` 是定义一个数据模型的基类，它继承了 `Listenable`，提供了 `notifyListeners()` 方法来通知组件需要更新。\n\n``` dart\n@protected                                                                  \nvoid notifyListeners() {                                                    \n  // We schedule a microtask to debounce multiple changes that can occur    \n  // all at once.                     \n  if (_microtaskVersion == _version) {\n    // 去抖\n    _microtaskVersion++; \n    // 安排一个 Microtask 任务\n    scheduleMicrotask(() {                                                  \n      _version++;                                                           \n      _microtaskVersion = _version;                                         \n                                                                            \n      // Convert the Set to a List before executing each listener. This     \n      // prevents errors that can arise if a listener removes itself during \n      // invocation!                                                        \n      _listeners.toList().forEach((VoidCallback listener) => listener());   \n    });                                                                     \n  }                                                                         \n}                                                                           \n```\n\n> 关于 Microtask：这涉及到 dart 的单线程模型，这里我们只需要知道，它的优先级比 event 要高，会先执行。\n>\n> 关于更多信息，可以查看 [event-loop](https://webdev.dartlang.org/articles/performance/event-loop#darts-event-loop-and-queues)\n\n#### ScopedModel\n\n在定义一个 `Model` 后，我们需要再定义一个 `ScopedModel` 作为 root widget，它有两个参数，一个是 `model` 即我们上面定义的 `Model` 实例，另外一个是 `child`，则是我们定义的 widget。`ScopedModel` 是一个 `StetelessWidget`，我们看下它的 `build()` 方法：\n\n``` dart\n@override                                                                     \nWidget build(BuildContext context) {                                          \n  return AnimatedBuilder(                                                     \n    animation: model,                                                         \n    builder: (context, _) => _InheritedModel<T>(model: model, child: child),  \n  );                                                                          \n}                                                                             \n```\n\n`AnimatedBuilder` 是一个用于构建动画的 widget，它的 `animation` 参数是一个 `Listenable` 类：\n\n``` dart\nabstract class Listenable {                                                          \n  /// Abstract const constructor. This constructor enables subclasses to provide     \n  /// const constructors so that they can be used in const expressions.              \n  const Listenable();                                                                \n                                                                                     \n  /// Return a [Listenable] that triggers when any of the given [Listenable]s        \n  /// themselves trigger.                                                            \n  ///                                                                                \n  /// The list must not be changed after this method has been called. Doing so       \n  /// will lead to memory leaks or exceptions.                                       \n  ///                                                                                \n  /// The list may contain nulls; they are ignored.                                  \n  factory Listenable.merge(List<Listenable> listenables) = _MergingListenable;       \n                                                                                     \n  /// Register a closure to be called when the object notifies its listeners.        \n  void addListener(VoidCallback listener);                                           \n                                                                                     \n  /// Remove a previously registered closure from the list of closures that the      \n  /// object notifies.                                                               \n  void removeListener(VoidCallback listener);                                        \n}                                                                                    \n```\n\n`AnimatedBuilder` 会调用 `addListener()` 方法添加一个监听者，然后调用 `setState()` 方法进行 rebuild。从上面可知，`Model` 继承 `Listenable` 类。这也是为什么在修改值后需要调用 `notifyListeners()` 的原因。\n\n再看下 `builder` 参数，它实际上返回了一个 `_InheritedModel` 实例：\n\n``` dart\nclass _InheritedModel<T extends Model> extends InheritedWidget {     \n  final T model;                                                     \n  final int version;                                                 \n                                                                     \n  _InheritedModel({Key key, Widget child, T model})                  \n      : this.model = model,                                          \n        this.version = model._version,                               \n        super(key: key, child: child);                               \n                                                                     \n  @override                                                          \n  bool updateShouldNotify(_InheritedModel<T> oldWidget) =>           \n      (oldWidget.version != version);                                \n}                                                                    \n```\n\n`InheritedWidget` 是 `scoped_model` 的核心。\n\n##### InheritedWidget\n\n`InheritedWidget` 可以在组件树中有效的传递和共享数据。将 `InheritedWidget` 作为 root widget，child widget 可以通过 `inheritFromWidgetOfExactType()` 方法返回距离它最近的 `InheritedWidget` 实例，同时也将它注册到 `InheritedWidget` 中，当 `InheritedWidget` 的数据发生变化时，child widget 也会随之 rebuild。\n\n当 `InheritedWidget` rebuild 时，会调用 `updateShouldNotify()` 方法来决定是否重建 child widget。\n\n继续看 `ScopedModel`，它使用 `version` 来判断是否需要通知 child widget 更新：\n\n``` dart\n@override                                                          \nbool updateShouldNotify(_InheritedModel<T> oldWidget) =>           \n      (oldWidget.version != version); \n```\n\n当我们调用 `Model` 的 `notifyListeners()` 方法时，`version` 就会自增。\n\n#### ScopedModelDescendant\n\n`ScopedModelDescendant` 是一个工具类，用于获取指定类型的 `Model`，当 `Model` 更新时，会重新执行 `build()` 方法：\n\n``` dart\n@override                                                            \nWidget build(BuildContext context) {                                 \n  return builder(                                                    \n    context,                                                         \n    child,                                                           \n    ScopedModel.of<T>(context, rebuildOnChange: rebuildOnChange),    \n  );                                                                 \n}\n\n\nstatic T of<T extends Model>(                       \n  BuildContext context, {                           \n  bool rebuildOnChange = false,                     \n}) {                                                \n  final Type type = _type<_InheritedModel<T>>();    \n  \n  // 最终也是使用 inheritFromWidgetOfExactType 或 ancestorWidgetOfExactType\n  Widget widget = rebuildOnChange                   \n      ? context.inheritFromWidgetOfExactType(type)  \n      : context.ancestorWidgetOfExactType(type);    \n                                                    \n  if (widget == null) {                             \n    throw new ScopedModelError();                   \n  } else {                                          \n    return (widget as _InheritedModel<T>).model;    \n  }                                                 \n}                                                   \n                                                    \nstatic Type _type<T>() => T;                        \n```\n\n注意到，在调用 `ScopedModel.of()` 方法时，有个 `rebuildOnChange` 参数，表示当 `Model` 更新时，是否需要 rebuild。当设置为 `false` 时，会使用 `ancestorWidgetOfExactType()` 方法去获取最近的 `InheritedWidget`，和 `inheritFromWidgetOfExactType()` 方法的区别是，`inheritFromWidgetOfExactType` 在获取的同时会注册到 `InheritedWidget` 上。\n\n### 总结\n\n使用 `scoped_model`，我们首先定义一个 `Model`，这里面封装了对数据的操作，需要注意，数据改变后需要调用 `notifyListeners()` 方法。接着再将 `ScopedModel` 作为 root widget，传递一个 `Model` 实例，最后我们可以使用 `ScopedModelDescendant` 来响应数据的修改，也可以手动调用 `ScopedModel.of()` 方法来获取 `Model` 实例，调用这个方法，如果参数 `rebuildOnChange` 传递为 `true`，则同时会将当前 widget 注册到 `InheritedWidget` 上，当数据改变时，当前 widget 会重新构建。","source":"_posts/scoped-model源码解析.md","raw":"---\ntitle: scoped_model源码解析\ndate: 2019-05-06 22:13:54\ncategories: Flutter\ntags:\n---\n\n### 参考\n\n* [ephemeral-vs-app](https://flutter.dev/docs/development/data-and-backend/state-mgmt/ephemeral-vs-app)\n* [inheritedwidget-inheritedmodel]([http://juju.one/inheritedwidget-inheritedmodel/](http://juju.one/inheritedwidget-inheritedmodel/))\n\n\n\n[scoped_model](https://pub.dartlang.org/packages/scoped_model) 是 Google 推荐使用的应用状态管理库（Simple app state management），当然，除了它，还有其他选择，比如 Redux，Rx，hooks 等等。\n\n### 临时状态和应用状态\n\n我们说 scoped_model 用于**应用状态**管理，是因为除了**应用状态（app state）**以外，还有临时状态（ephemeral state）。\n\n#### 临时状态\n\n也可以称为 UI 状态或者本地状态，是一种可以包含在单个 widget 的状态。\n\n比如以下定义：\n\n* `PageView` 当前的页面\n* 动画当前的进度\n* `BottomNavigationBar` 当前选中项\n\n使用临时状态，我们不需要使用状态管理，只需要一个 `StatefulWidget`。\n\n#### 应用状态\n\n需要在应用中多个组件之间共享，而且在不同的用户会话之间保持，这就是应用状态，有时候也称为共享状态。\n\n比如以下定义：\n\n* 用户偏好设置\n* 登录信息\n* 通知栏功能\n* 购物车功能\n* 已读未读功能\n\n\n\n临时状态和应用状态之间没有非常明确的界限，比如你可能需要持久化保存 `BottomNavigationBar` 的选中项，那它就不是临时状态了，而是应用状态。如果你愿意，你甚至可以不用任何状态管理库，只使用 `State` 和 `setState()` 来管理应用所有的状态。\n\n### scoped_model\n\nscoped_model 由三个部分组成，`ScopedModel`、`ScopedModelDescendant` 和 `Model`。\n\n#### Model\n\n`Model` 是定义一个数据模型的基类，它继承了 `Listenable`，提供了 `notifyListeners()` 方法来通知组件需要更新。\n\n``` dart\n@protected                                                                  \nvoid notifyListeners() {                                                    \n  // We schedule a microtask to debounce multiple changes that can occur    \n  // all at once.                     \n  if (_microtaskVersion == _version) {\n    // 去抖\n    _microtaskVersion++; \n    // 安排一个 Microtask 任务\n    scheduleMicrotask(() {                                                  \n      _version++;                                                           \n      _microtaskVersion = _version;                                         \n                                                                            \n      // Convert the Set to a List before executing each listener. This     \n      // prevents errors that can arise if a listener removes itself during \n      // invocation!                                                        \n      _listeners.toList().forEach((VoidCallback listener) => listener());   \n    });                                                                     \n  }                                                                         \n}                                                                           \n```\n\n> 关于 Microtask：这涉及到 dart 的单线程模型，这里我们只需要知道，它的优先级比 event 要高，会先执行。\n>\n> 关于更多信息，可以查看 [event-loop](https://webdev.dartlang.org/articles/performance/event-loop#darts-event-loop-and-queues)\n\n#### ScopedModel\n\n在定义一个 `Model` 后，我们需要再定义一个 `ScopedModel` 作为 root widget，它有两个参数，一个是 `model` 即我们上面定义的 `Model` 实例，另外一个是 `child`，则是我们定义的 widget。`ScopedModel` 是一个 `StetelessWidget`，我们看下它的 `build()` 方法：\n\n``` dart\n@override                                                                     \nWidget build(BuildContext context) {                                          \n  return AnimatedBuilder(                                                     \n    animation: model,                                                         \n    builder: (context, _) => _InheritedModel<T>(model: model, child: child),  \n  );                                                                          \n}                                                                             \n```\n\n`AnimatedBuilder` 是一个用于构建动画的 widget，它的 `animation` 参数是一个 `Listenable` 类：\n\n``` dart\nabstract class Listenable {                                                          \n  /// Abstract const constructor. This constructor enables subclasses to provide     \n  /// const constructors so that they can be used in const expressions.              \n  const Listenable();                                                                \n                                                                                     \n  /// Return a [Listenable] that triggers when any of the given [Listenable]s        \n  /// themselves trigger.                                                            \n  ///                                                                                \n  /// The list must not be changed after this method has been called. Doing so       \n  /// will lead to memory leaks or exceptions.                                       \n  ///                                                                                \n  /// The list may contain nulls; they are ignored.                                  \n  factory Listenable.merge(List<Listenable> listenables) = _MergingListenable;       \n                                                                                     \n  /// Register a closure to be called when the object notifies its listeners.        \n  void addListener(VoidCallback listener);                                           \n                                                                                     \n  /// Remove a previously registered closure from the list of closures that the      \n  /// object notifies.                                                               \n  void removeListener(VoidCallback listener);                                        \n}                                                                                    \n```\n\n`AnimatedBuilder` 会调用 `addListener()` 方法添加一个监听者，然后调用 `setState()` 方法进行 rebuild。从上面可知，`Model` 继承 `Listenable` 类。这也是为什么在修改值后需要调用 `notifyListeners()` 的原因。\n\n再看下 `builder` 参数，它实际上返回了一个 `_InheritedModel` 实例：\n\n``` dart\nclass _InheritedModel<T extends Model> extends InheritedWidget {     \n  final T model;                                                     \n  final int version;                                                 \n                                                                     \n  _InheritedModel({Key key, Widget child, T model})                  \n      : this.model = model,                                          \n        this.version = model._version,                               \n        super(key: key, child: child);                               \n                                                                     \n  @override                                                          \n  bool updateShouldNotify(_InheritedModel<T> oldWidget) =>           \n      (oldWidget.version != version);                                \n}                                                                    \n```\n\n`InheritedWidget` 是 `scoped_model` 的核心。\n\n##### InheritedWidget\n\n`InheritedWidget` 可以在组件树中有效的传递和共享数据。将 `InheritedWidget` 作为 root widget，child widget 可以通过 `inheritFromWidgetOfExactType()` 方法返回距离它最近的 `InheritedWidget` 实例，同时也将它注册到 `InheritedWidget` 中，当 `InheritedWidget` 的数据发生变化时，child widget 也会随之 rebuild。\n\n当 `InheritedWidget` rebuild 时，会调用 `updateShouldNotify()` 方法来决定是否重建 child widget。\n\n继续看 `ScopedModel`，它使用 `version` 来判断是否需要通知 child widget 更新：\n\n``` dart\n@override                                                          \nbool updateShouldNotify(_InheritedModel<T> oldWidget) =>           \n      (oldWidget.version != version); \n```\n\n当我们调用 `Model` 的 `notifyListeners()` 方法时，`version` 就会自增。\n\n#### ScopedModelDescendant\n\n`ScopedModelDescendant` 是一个工具类，用于获取指定类型的 `Model`，当 `Model` 更新时，会重新执行 `build()` 方法：\n\n``` dart\n@override                                                            \nWidget build(BuildContext context) {                                 \n  return builder(                                                    \n    context,                                                         \n    child,                                                           \n    ScopedModel.of<T>(context, rebuildOnChange: rebuildOnChange),    \n  );                                                                 \n}\n\n\nstatic T of<T extends Model>(                       \n  BuildContext context, {                           \n  bool rebuildOnChange = false,                     \n}) {                                                \n  final Type type = _type<_InheritedModel<T>>();    \n  \n  // 最终也是使用 inheritFromWidgetOfExactType 或 ancestorWidgetOfExactType\n  Widget widget = rebuildOnChange                   \n      ? context.inheritFromWidgetOfExactType(type)  \n      : context.ancestorWidgetOfExactType(type);    \n                                                    \n  if (widget == null) {                             \n    throw new ScopedModelError();                   \n  } else {                                          \n    return (widget as _InheritedModel<T>).model;    \n  }                                                 \n}                                                   \n                                                    \nstatic Type _type<T>() => T;                        \n```\n\n注意到，在调用 `ScopedModel.of()` 方法时，有个 `rebuildOnChange` 参数，表示当 `Model` 更新时，是否需要 rebuild。当设置为 `false` 时，会使用 `ancestorWidgetOfExactType()` 方法去获取最近的 `InheritedWidget`，和 `inheritFromWidgetOfExactType()` 方法的区别是，`inheritFromWidgetOfExactType` 在获取的同时会注册到 `InheritedWidget` 上。\n\n### 总结\n\n使用 `scoped_model`，我们首先定义一个 `Model`，这里面封装了对数据的操作，需要注意，数据改变后需要调用 `notifyListeners()` 方法。接着再将 `ScopedModel` 作为 root widget，传递一个 `Model` 实例，最后我们可以使用 `ScopedModelDescendant` 来响应数据的修改，也可以手动调用 `ScopedModel.of()` 方法来获取 `Model` 实例，调用这个方法，如果参数 `rebuildOnChange` 传递为 `true`，则同时会将当前 widget 注册到 `InheritedWidget` 上，当数据改变时，当前 widget 会重新构建。","slug":"scoped-model源码解析","published":1,"updated":"2019-05-06T14:14:57.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mqbs1n001se39kai2qs1e1","content":"<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://flutter.dev/docs/development/data-and-backend/state-mgmt/ephemeral-vs-app\" target=\"_blank\" rel=\"noopener\">ephemeral-vs-app</a></li>\n<li><a href=\"[http://juju.one/inheritedwidget-inheritedmodel/](http://juju.one/inheritedwidget-inheritedmodel/\">inheritedwidget-inheritedmodel</a>)</li>\n</ul>\n<p><a href=\"https://pub.dartlang.org/packages/scoped_model\" target=\"_blank\" rel=\"noopener\">scoped_model</a> 是 Google 推荐使用的应用状态管理库（Simple app state management），当然，除了它，还有其他选择，比如 Redux，Rx，hooks 等等。</p>\n<h3 id=\"临时状态和应用状态\"><a href=\"#临时状态和应用状态\" class=\"headerlink\" title=\"临时状态和应用状态\"></a>临时状态和应用状态</h3><p>我们说 scoped_model 用于<strong>应用状态</strong>管理，是因为除了<strong>应用状态（app state）</strong>以外，还有临时状态（ephemeral state）。</p>\n<h4 id=\"临时状态\"><a href=\"#临时状态\" class=\"headerlink\" title=\"临时状态\"></a>临时状态</h4><p>也可以称为 UI 状态或者本地状态，是一种可以包含在单个 widget 的状态。</p>\n<p>比如以下定义：</p>\n<ul>\n<li><code>PageView</code> 当前的页面</li>\n<li>动画当前的进度</li>\n<li><code>BottomNavigationBar</code> 当前选中项</li>\n</ul>\n<p>使用临时状态，我们不需要使用状态管理，只需要一个 <code>StatefulWidget</code>。</p>\n<h4 id=\"应用状态\"><a href=\"#应用状态\" class=\"headerlink\" title=\"应用状态\"></a>应用状态</h4><p>需要在应用中多个组件之间共享，而且在不同的用户会话之间保持，这就是应用状态，有时候也称为共享状态。</p>\n<p>比如以下定义：</p>\n<ul>\n<li>用户偏好设置</li>\n<li>登录信息</li>\n<li>通知栏功能</li>\n<li>购物车功能</li>\n<li>已读未读功能</li>\n</ul>\n<p>临时状态和应用状态之间没有非常明确的界限，比如你可能需要持久化保存 <code>BottomNavigationBar</code> 的选中项，那它就不是临时状态了，而是应用状态。如果你愿意，你甚至可以不用任何状态管理库，只使用 <code>State</code> 和 <code>setState()</code> 来管理应用所有的状态。</p>\n<h3 id=\"scoped-model\"><a href=\"#scoped-model\" class=\"headerlink\" title=\"scoped_model\"></a>scoped_model</h3><p>scoped_model 由三个部分组成，<code>ScopedModel</code>、<code>ScopedModelDescendant</code> 和 <code>Model</code>。</p>\n<h4 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h4><p><code>Model</code> 是定义一个数据模型的基类，它继承了 <code>Listenable</code>，提供了 <code>notifyListeners()</code> 方法来通知组件需要更新。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span>                                                                  </span><br><span class=\"line\"><span class=\"keyword\">void</span> notifyListeners() &#123;                                                    </span><br><span class=\"line\">  <span class=\"comment\">// We schedule a microtask to debounce multiple changes that can occur    </span></span><br><span class=\"line\">  <span class=\"comment\">// all at once.                     </span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_microtaskVersion == _version) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 去抖</span></span><br><span class=\"line\">    _microtaskVersion++; </span><br><span class=\"line\">    <span class=\"comment\">// 安排一个 Microtask 任务</span></span><br><span class=\"line\">    scheduleMicrotask(() &#123;                                                  </span><br><span class=\"line\">      _version++;                                                           </span><br><span class=\"line\">      _microtaskVersion = _version;                                         </span><br><span class=\"line\">                                                                            </span><br><span class=\"line\">      <span class=\"comment\">// Convert the Set to a List before executing each listener. This     </span></span><br><span class=\"line\">      <span class=\"comment\">// prevents errors that can arise if a listener removes itself during </span></span><br><span class=\"line\">      <span class=\"comment\">// invocation!                                                        </span></span><br><span class=\"line\">      _listeners.toList().forEach((VoidCallback listener) =&gt; listener());   </span><br><span class=\"line\">    &#125;);                                                                     </span><br><span class=\"line\">  &#125;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关于 Microtask：这涉及到 dart 的单线程模型，这里我们只需要知道，它的优先级比 event 要高，会先执行。</p>\n<p>关于更多信息，可以查看 <a href=\"https://webdev.dartlang.org/articles/performance/event-loop#darts-event-loop-and-queues\" target=\"_blank\" rel=\"noopener\">event-loop</a></p>\n</blockquote>\n<h4 id=\"ScopedModel\"><a href=\"#ScopedModel\" class=\"headerlink\" title=\"ScopedModel\"></a>ScopedModel</h4><p>在定义一个 <code>Model</code> 后，我们需要再定义一个 <code>ScopedModel</code> 作为 root widget，它有两个参数，一个是 <code>model</code> 即我们上面定义的 <code>Model</code> 实例，另外一个是 <code>child</code>，则是我们定义的 widget。<code>ScopedModel</code> 是一个 <code>StetelessWidget</code>，我们看下它的 <code>build()</code> 方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span>                                                                     </span><br><span class=\"line\">Widget build(BuildContext context) &#123;                                          </span><br><span class=\"line\">  <span class=\"keyword\">return</span> AnimatedBuilder(                                                     </span><br><span class=\"line\">    animation: model,                                                         </span><br><span class=\"line\">    builder: (context, _) =&gt; _InheritedModel&lt;T&gt;(model: model, child: child),  </span><br><span class=\"line\">  );                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>AnimatedBuilder</code> 是一个用于构建动画的 widget，它的 <code>animation</code> 参数是一个 <code>Listenable</code> 类：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Listenable</span> </span>&#123;                                                          </span><br><span class=\"line\">  <span class=\"comment\">/// Abstract const constructor. This constructor enables subclasses to provide     </span></span><br><span class=\"line\">  <span class=\"comment\">/// const constructors so that they can be used in const expressions.              </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Listenable();                                                                </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">  <span class=\"comment\">/// Return a [Listenable] that triggers when any of the given [Listenable]s        </span></span><br><span class=\"line\">  <span class=\"comment\">/// themselves trigger.                                                            </span></span><br><span class=\"line\">  <span class=\"comment\">///                                                                                </span></span><br><span class=\"line\">  <span class=\"comment\">/// The list must not be changed after this method has been called. Doing so       </span></span><br><span class=\"line\">  <span class=\"comment\">/// will lead to memory leaks or exceptions.                                       </span></span><br><span class=\"line\">  <span class=\"comment\">///                                                                                </span></span><br><span class=\"line\">  <span class=\"comment\">/// The list may contain nulls; they are ignored.                                  </span></span><br><span class=\"line\">  <span class=\"keyword\">factory</span> Listenable.merge(<span class=\"built_in\">List</span>&lt;Listenable&gt; listenables) = _MergingListenable;       </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">  <span class=\"comment\">/// Register a closure to be called when the object notifies its listeners.        </span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> addListener(VoidCallback listener);                                           </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">  <span class=\"comment\">/// Remove a previously registered closure from the list of closures that the      </span></span><br><span class=\"line\">  <span class=\"comment\">/// object notifies.                                                               </span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> removeListener(VoidCallback listener);                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>AnimatedBuilder</code> 会调用 <code>addListener()</code> 方法添加一个监听者，然后调用 <code>setState()</code> 方法进行 rebuild。从上面可知，<code>Model</code> 继承 <code>Listenable</code> 类。这也是为什么在修改值后需要调用 <code>notifyListeners()</code> 的原因。</p>\n<p>再看下 <code>builder</code> 参数，它实际上返回了一个 <code>_InheritedModel</code> 实例：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_InheritedModel</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Model</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">InheritedWidget</span> </span>&#123;     </span><br><span class=\"line\">  <span class=\"keyword\">final</span> T model;                                                     </span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> version;                                                 </span><br><span class=\"line\">                                                                     </span><br><span class=\"line\">  _InheritedModel(&#123;Key key, Widget child, T model&#125;)                  </span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.model = model,                                          </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.version = model._version,                               </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(key: key, child: child);                               </span><br><span class=\"line\">                                                                     </span><br><span class=\"line\">  <span class=\"meta\">@override</span>                                                          </span><br><span class=\"line\">  <span class=\"built_in\">bool</span> updateShouldNotify(_InheritedModel&lt;T&gt; oldWidget) =&gt;           </span><br><span class=\"line\">      (oldWidget.version != version);                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>InheritedWidget</code> 是 <code>scoped_model</code> 的核心。</p>\n<h5 id=\"InheritedWidget\"><a href=\"#InheritedWidget\" class=\"headerlink\" title=\"InheritedWidget\"></a>InheritedWidget</h5><p><code>InheritedWidget</code> 可以在组件树中有效的传递和共享数据。将 <code>InheritedWidget</code> 作为 root widget，child widget 可以通过 <code>inheritFromWidgetOfExactType()</code> 方法返回距离它最近的 <code>InheritedWidget</code> 实例，同时也将它注册到 <code>InheritedWidget</code> 中，当 <code>InheritedWidget</code> 的数据发生变化时，child widget 也会随之 rebuild。</p>\n<p>当 <code>InheritedWidget</code> rebuild 时，会调用 <code>updateShouldNotify()</code> 方法来决定是否重建 child widget。</p>\n<p>继续看 <code>ScopedModel</code>，它使用 <code>version</code> 来判断是否需要通知 child widget 更新：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span>                                                          </span><br><span class=\"line\"><span class=\"built_in\">bool</span> updateShouldNotify(_InheritedModel&lt;T&gt; oldWidget) =&gt;           </span><br><span class=\"line\">      (oldWidget.version != version);</span><br></pre></td></tr></table></figure>\n<p>当我们调用 <code>Model</code> 的 <code>notifyListeners()</code> 方法时，<code>version</code> 就会自增。</p>\n<h4 id=\"ScopedModelDescendant\"><a href=\"#ScopedModelDescendant\" class=\"headerlink\" title=\"ScopedModelDescendant\"></a>ScopedModelDescendant</h4><p><code>ScopedModelDescendant</code> 是一个工具类，用于获取指定类型的 <code>Model</code>，当 <code>Model</code> 更新时，会重新执行 <code>build()</code> 方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span>                                                            </span><br><span class=\"line\">Widget build(BuildContext context) &#123;                                 </span><br><span class=\"line\">  <span class=\"keyword\">return</span> builder(                                                    </span><br><span class=\"line\">    context,                                                         </span><br><span class=\"line\">    child,                                                           </span><br><span class=\"line\">    ScopedModel.of&lt;T&gt;(context, rebuildOnChange: rebuildOnChange),    </span><br><span class=\"line\">  );                                                                 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> T of&lt;T <span class=\"keyword\">extends</span> Model&gt;(                       </span><br><span class=\"line\">  BuildContext context, &#123;                           </span><br><span class=\"line\">  <span class=\"built_in\">bool</span> rebuildOnChange = <span class=\"keyword\">false</span>,                     </span><br><span class=\"line\">&#125;) &#123;                                                </span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">Type</span> type = _type&lt;_InheritedModel&lt;T&gt;&gt;();    </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 最终也是使用 inheritFromWidgetOfExactType 或 ancestorWidgetOfExactType</span></span><br><span class=\"line\">  Widget widget = rebuildOnChange                   </span><br><span class=\"line\">      ? context.inheritFromWidgetOfExactType(type)  </span><br><span class=\"line\">      : context.ancestorWidgetOfExactType(type);    </span><br><span class=\"line\">                                                    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (widget == <span class=\"keyword\">null</span>) &#123;                             </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ScopedModelError();                   </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;                                          </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (widget <span class=\"keyword\">as</span> _InheritedModel&lt;T&gt;).model;    </span><br><span class=\"line\">  &#125;                                                 </span><br><span class=\"line\">&#125;                                                   </span><br><span class=\"line\">                                                    </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">Type</span> _type&lt;T&gt;() =&gt; T;</span><br></pre></td></tr></table></figure>\n<p>注意到，在调用 <code>ScopedModel.of()</code> 方法时，有个 <code>rebuildOnChange</code> 参数，表示当 <code>Model</code> 更新时，是否需要 rebuild。当设置为 <code>false</code> 时，会使用 <code>ancestorWidgetOfExactType()</code> 方法去获取最近的 <code>InheritedWidget</code>，和 <code>inheritFromWidgetOfExactType()</code> 方法的区别是，<code>inheritFromWidgetOfExactType</code> 在获取的同时会注册到 <code>InheritedWidget</code> 上。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用 <code>scoped_model</code>，我们首先定义一个 <code>Model</code>，这里面封装了对数据的操作，需要注意，数据改变后需要调用 <code>notifyListeners()</code> 方法。接着再将 <code>ScopedModel</code> 作为 root widget，传递一个 <code>Model</code> 实例，最后我们可以使用 <code>ScopedModelDescendant</code> 来响应数据的修改，也可以手动调用 <code>ScopedModel.of()</code> 方法来获取 <code>Model</code> 实例，调用这个方法，如果参数 <code>rebuildOnChange</code> 传递为 <code>true</code>，则同时会将当前 widget 注册到 <code>InheritedWidget</code> 上，当数据改变时，当前 widget 会重新构建。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://flutter.dev/docs/development/data-and-backend/state-mgmt/ephemeral-vs-app\" target=\"_blank\" rel=\"noopener\">ephemeral-vs-app</a></li>\n<li><a href=\"[http://juju.one/inheritedwidget-inheritedmodel/](http://juju.one/inheritedwidget-inheritedmodel/\">inheritedwidget-inheritedmodel</a>)</li>\n</ul>\n<p><a href=\"https://pub.dartlang.org/packages/scoped_model\" target=\"_blank\" rel=\"noopener\">scoped_model</a> 是 Google 推荐使用的应用状态管理库（Simple app state management），当然，除了它，还有其他选择，比如 Redux，Rx，hooks 等等。</p>\n<h3 id=\"临时状态和应用状态\"><a href=\"#临时状态和应用状态\" class=\"headerlink\" title=\"临时状态和应用状态\"></a>临时状态和应用状态</h3><p>我们说 scoped_model 用于<strong>应用状态</strong>管理，是因为除了<strong>应用状态（app state）</strong>以外，还有临时状态（ephemeral state）。</p>\n<h4 id=\"临时状态\"><a href=\"#临时状态\" class=\"headerlink\" title=\"临时状态\"></a>临时状态</h4><p>也可以称为 UI 状态或者本地状态，是一种可以包含在单个 widget 的状态。</p>\n<p>比如以下定义：</p>\n<ul>\n<li><code>PageView</code> 当前的页面</li>\n<li>动画当前的进度</li>\n<li><code>BottomNavigationBar</code> 当前选中项</li>\n</ul>\n<p>使用临时状态，我们不需要使用状态管理，只需要一个 <code>StatefulWidget</code>。</p>\n<h4 id=\"应用状态\"><a href=\"#应用状态\" class=\"headerlink\" title=\"应用状态\"></a>应用状态</h4><p>需要在应用中多个组件之间共享，而且在不同的用户会话之间保持，这就是应用状态，有时候也称为共享状态。</p>\n<p>比如以下定义：</p>\n<ul>\n<li>用户偏好设置</li>\n<li>登录信息</li>\n<li>通知栏功能</li>\n<li>购物车功能</li>\n<li>已读未读功能</li>\n</ul>\n<p>临时状态和应用状态之间没有非常明确的界限，比如你可能需要持久化保存 <code>BottomNavigationBar</code> 的选中项，那它就不是临时状态了，而是应用状态。如果你愿意，你甚至可以不用任何状态管理库，只使用 <code>State</code> 和 <code>setState()</code> 来管理应用所有的状态。</p>\n<h3 id=\"scoped-model\"><a href=\"#scoped-model\" class=\"headerlink\" title=\"scoped_model\"></a>scoped_model</h3><p>scoped_model 由三个部分组成，<code>ScopedModel</code>、<code>ScopedModelDescendant</code> 和 <code>Model</code>。</p>\n<h4 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h4><p><code>Model</code> 是定义一个数据模型的基类，它继承了 <code>Listenable</code>，提供了 <code>notifyListeners()</code> 方法来通知组件需要更新。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span>                                                                  </span><br><span class=\"line\"><span class=\"keyword\">void</span> notifyListeners() &#123;                                                    </span><br><span class=\"line\">  <span class=\"comment\">// We schedule a microtask to debounce multiple changes that can occur    </span></span><br><span class=\"line\">  <span class=\"comment\">// all at once.                     </span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_microtaskVersion == _version) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 去抖</span></span><br><span class=\"line\">    _microtaskVersion++; </span><br><span class=\"line\">    <span class=\"comment\">// 安排一个 Microtask 任务</span></span><br><span class=\"line\">    scheduleMicrotask(() &#123;                                                  </span><br><span class=\"line\">      _version++;                                                           </span><br><span class=\"line\">      _microtaskVersion = _version;                                         </span><br><span class=\"line\">                                                                            </span><br><span class=\"line\">      <span class=\"comment\">// Convert the Set to a List before executing each listener. This     </span></span><br><span class=\"line\">      <span class=\"comment\">// prevents errors that can arise if a listener removes itself during </span></span><br><span class=\"line\">      <span class=\"comment\">// invocation!                                                        </span></span><br><span class=\"line\">      _listeners.toList().forEach((VoidCallback listener) =&gt; listener());   </span><br><span class=\"line\">    &#125;);                                                                     </span><br><span class=\"line\">  &#125;                                                                         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关于 Microtask：这涉及到 dart 的单线程模型，这里我们只需要知道，它的优先级比 event 要高，会先执行。</p>\n<p>关于更多信息，可以查看 <a href=\"https://webdev.dartlang.org/articles/performance/event-loop#darts-event-loop-and-queues\" target=\"_blank\" rel=\"noopener\">event-loop</a></p>\n</blockquote>\n<h4 id=\"ScopedModel\"><a href=\"#ScopedModel\" class=\"headerlink\" title=\"ScopedModel\"></a>ScopedModel</h4><p>在定义一个 <code>Model</code> 后，我们需要再定义一个 <code>ScopedModel</code> 作为 root widget，它有两个参数，一个是 <code>model</code> 即我们上面定义的 <code>Model</code> 实例，另外一个是 <code>child</code>，则是我们定义的 widget。<code>ScopedModel</code> 是一个 <code>StetelessWidget</code>，我们看下它的 <code>build()</code> 方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span>                                                                     </span><br><span class=\"line\">Widget build(BuildContext context) &#123;                                          </span><br><span class=\"line\">  <span class=\"keyword\">return</span> AnimatedBuilder(                                                     </span><br><span class=\"line\">    animation: model,                                                         </span><br><span class=\"line\">    builder: (context, _) =&gt; _InheritedModel&lt;T&gt;(model: model, child: child),  </span><br><span class=\"line\">  );                                                                          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>AnimatedBuilder</code> 是一个用于构建动画的 widget，它的 <code>animation</code> 参数是一个 <code>Listenable</code> 类：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Listenable</span> </span>&#123;                                                          </span><br><span class=\"line\">  <span class=\"comment\">/// Abstract const constructor. This constructor enables subclasses to provide     </span></span><br><span class=\"line\">  <span class=\"comment\">/// const constructors so that they can be used in const expressions.              </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Listenable();                                                                </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">  <span class=\"comment\">/// Return a [Listenable] that triggers when any of the given [Listenable]s        </span></span><br><span class=\"line\">  <span class=\"comment\">/// themselves trigger.                                                            </span></span><br><span class=\"line\">  <span class=\"comment\">///                                                                                </span></span><br><span class=\"line\">  <span class=\"comment\">/// The list must not be changed after this method has been called. Doing so       </span></span><br><span class=\"line\">  <span class=\"comment\">/// will lead to memory leaks or exceptions.                                       </span></span><br><span class=\"line\">  <span class=\"comment\">///                                                                                </span></span><br><span class=\"line\">  <span class=\"comment\">/// The list may contain nulls; they are ignored.                                  </span></span><br><span class=\"line\">  <span class=\"keyword\">factory</span> Listenable.merge(<span class=\"built_in\">List</span>&lt;Listenable&gt; listenables) = _MergingListenable;       </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">  <span class=\"comment\">/// Register a closure to be called when the object notifies its listeners.        </span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> addListener(VoidCallback listener);                                           </span><br><span class=\"line\">                                                                                     </span><br><span class=\"line\">  <span class=\"comment\">/// Remove a previously registered closure from the list of closures that the      </span></span><br><span class=\"line\">  <span class=\"comment\">/// object notifies.                                                               </span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> removeListener(VoidCallback listener);                                        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>AnimatedBuilder</code> 会调用 <code>addListener()</code> 方法添加一个监听者，然后调用 <code>setState()</code> 方法进行 rebuild。从上面可知，<code>Model</code> 继承 <code>Listenable</code> 类。这也是为什么在修改值后需要调用 <code>notifyListeners()</code> 的原因。</p>\n<p>再看下 <code>builder</code> 参数，它实际上返回了一个 <code>_InheritedModel</code> 实例：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_InheritedModel</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Model</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">InheritedWidget</span> </span>&#123;     </span><br><span class=\"line\">  <span class=\"keyword\">final</span> T model;                                                     </span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> version;                                                 </span><br><span class=\"line\">                                                                     </span><br><span class=\"line\">  _InheritedModel(&#123;Key key, Widget child, T model&#125;)                  </span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.model = model,                                          </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.version = model._version,                               </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(key: key, child: child);                               </span><br><span class=\"line\">                                                                     </span><br><span class=\"line\">  <span class=\"meta\">@override</span>                                                          </span><br><span class=\"line\">  <span class=\"built_in\">bool</span> updateShouldNotify(_InheritedModel&lt;T&gt; oldWidget) =&gt;           </span><br><span class=\"line\">      (oldWidget.version != version);                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>InheritedWidget</code> 是 <code>scoped_model</code> 的核心。</p>\n<h5 id=\"InheritedWidget\"><a href=\"#InheritedWidget\" class=\"headerlink\" title=\"InheritedWidget\"></a>InheritedWidget</h5><p><code>InheritedWidget</code> 可以在组件树中有效的传递和共享数据。将 <code>InheritedWidget</code> 作为 root widget，child widget 可以通过 <code>inheritFromWidgetOfExactType()</code> 方法返回距离它最近的 <code>InheritedWidget</code> 实例，同时也将它注册到 <code>InheritedWidget</code> 中，当 <code>InheritedWidget</code> 的数据发生变化时，child widget 也会随之 rebuild。</p>\n<p>当 <code>InheritedWidget</code> rebuild 时，会调用 <code>updateShouldNotify()</code> 方法来决定是否重建 child widget。</p>\n<p>继续看 <code>ScopedModel</code>，它使用 <code>version</code> 来判断是否需要通知 child widget 更新：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span>                                                          </span><br><span class=\"line\"><span class=\"built_in\">bool</span> updateShouldNotify(_InheritedModel&lt;T&gt; oldWidget) =&gt;           </span><br><span class=\"line\">      (oldWidget.version != version);</span><br></pre></td></tr></table></figure>\n<p>当我们调用 <code>Model</code> 的 <code>notifyListeners()</code> 方法时，<code>version</code> 就会自增。</p>\n<h4 id=\"ScopedModelDescendant\"><a href=\"#ScopedModelDescendant\" class=\"headerlink\" title=\"ScopedModelDescendant\"></a>ScopedModelDescendant</h4><p><code>ScopedModelDescendant</code> 是一个工具类，用于获取指定类型的 <code>Model</code>，当 <code>Model</code> 更新时，会重新执行 <code>build()</code> 方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span>                                                            </span><br><span class=\"line\">Widget build(BuildContext context) &#123;                                 </span><br><span class=\"line\">  <span class=\"keyword\">return</span> builder(                                                    </span><br><span class=\"line\">    context,                                                         </span><br><span class=\"line\">    child,                                                           </span><br><span class=\"line\">    ScopedModel.of&lt;T&gt;(context, rebuildOnChange: rebuildOnChange),    </span><br><span class=\"line\">  );                                                                 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> T of&lt;T <span class=\"keyword\">extends</span> Model&gt;(                       </span><br><span class=\"line\">  BuildContext context, &#123;                           </span><br><span class=\"line\">  <span class=\"built_in\">bool</span> rebuildOnChange = <span class=\"keyword\">false</span>,                     </span><br><span class=\"line\">&#125;) &#123;                                                </span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">Type</span> type = _type&lt;_InheritedModel&lt;T&gt;&gt;();    </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 最终也是使用 inheritFromWidgetOfExactType 或 ancestorWidgetOfExactType</span></span><br><span class=\"line\">  Widget widget = rebuildOnChange                   </span><br><span class=\"line\">      ? context.inheritFromWidgetOfExactType(type)  </span><br><span class=\"line\">      : context.ancestorWidgetOfExactType(type);    </span><br><span class=\"line\">                                                    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (widget == <span class=\"keyword\">null</span>) &#123;                             </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ScopedModelError();                   </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;                                          </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (widget <span class=\"keyword\">as</span> _InheritedModel&lt;T&gt;).model;    </span><br><span class=\"line\">  &#125;                                                 </span><br><span class=\"line\">&#125;                                                   </span><br><span class=\"line\">                                                    </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">Type</span> _type&lt;T&gt;() =&gt; T;</span><br></pre></td></tr></table></figure>\n<p>注意到，在调用 <code>ScopedModel.of()</code> 方法时，有个 <code>rebuildOnChange</code> 参数，表示当 <code>Model</code> 更新时，是否需要 rebuild。当设置为 <code>false</code> 时，会使用 <code>ancestorWidgetOfExactType()</code> 方法去获取最近的 <code>InheritedWidget</code>，和 <code>inheritFromWidgetOfExactType()</code> 方法的区别是，<code>inheritFromWidgetOfExactType</code> 在获取的同时会注册到 <code>InheritedWidget</code> 上。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用 <code>scoped_model</code>，我们首先定义一个 <code>Model</code>，这里面封装了对数据的操作，需要注意，数据改变后需要调用 <code>notifyListeners()</code> 方法。接着再将 <code>ScopedModel</code> 作为 root widget，传递一个 <code>Model</code> 实例，最后我们可以使用 <code>ScopedModelDescendant</code> 来响应数据的修改，也可以手动调用 <code>ScopedModel.of()</code> 方法来获取 <code>Model</code> 实例，调用这个方法，如果参数 <code>rebuildOnChange</code> 传递为 <code>true</code>，则同时会将当前 widget 注册到 <code>InheritedWidget</code> 上，当数据改变时，当前 widget 会重新构建。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck3mqbs0i0000e39kvtkx8tmd","category_id":"ck3mqbs0o0003e39kaoyythr0","_id":"ck3mqbs0v000ae39k7qtruels"},{"post_id":"ck3mqbs0m0002e39kltlfodye","category_id":"ck3mqbs0t0007e39kna9aiszu","_id":"ck3mqbs0z000ee39kw4yj0gd2"},{"post_id":"ck3mqbs0q0004e39kbm3e0d4x","category_id":"ck3mqbs0v000be39kh3ex4flk","_id":"ck3mqbs12000je39k7tuhbyws"},{"post_id":"ck3mqbs0y000de39keb5dxhq1","category_id":"ck3mqbs0t0007e39kna9aiszu","_id":"ck3mqbs13000le39kl9eniuuo"},{"post_id":"ck3mqbs0r0005e39kanl0p2kj","category_id":"ck3mqbs0v000be39kh3ex4flk","_id":"ck3mqbs14000oe39kuztqcy2j"},{"post_id":"ck3mqbs0s0006e39k9p36fwp7","category_id":"ck3mqbs12000ie39ki44a01gp","_id":"ck3mqbs17000ue39kasch5uwm"},{"post_id":"ck3mqbs15000qe39krh8adtfv","category_id":"ck3mqbs0o0003e39kaoyythr0","_id":"ck3mqbs19000xe39kd6fvcck4"},{"post_id":"ck3mqbs0t0008e39kh2xkf5xy","category_id":"ck3mqbs12000ie39ki44a01gp","_id":"ck3mqbs1a0010e39kyqm4d5bb"},{"post_id":"ck3mqbs0u0009e39kvxv17f1c","category_id":"ck3mqbs12000ie39ki44a01gp","_id":"ck3mqbs1b0013e39k3sr6ywya"},{"post_id":"ck3mqbs19000ze39kssxyvq0x","category_id":"ck3mqbs0t0007e39kna9aiszu","_id":"ck3mqbs1d0016e39kwvhqo266"},{"post_id":"ck3mqbs0w000ce39k5fgp0lso","category_id":"ck3mqbs12000ie39ki44a01gp","_id":"ck3mqbs1e0019e39kzpwlno29"},{"post_id":"ck3mqbs10000ge39k65ryytu4","category_id":"ck3mqbs12000ie39ki44a01gp","_id":"ck3mqbs1e001ae39kxzbmniq6"},{"post_id":"ck3mqbs1c0015e39khoam1zgt","category_id":"ck3mqbs0v000be39kh3ex4flk","_id":"ck3mqbs1e001ce39k3kl3laqp"},{"post_id":"ck3mqbs12000ke39khuop5os1","category_id":"ck3mqbs1d0017e39kghs1klcj","_id":"ck3mqbs1f001ee39k7kvh2f1g"},{"post_id":"ck3mqbs14000ne39kzwtccq6k","category_id":"ck3mqbs1d0017e39kghs1klcj","_id":"ck3mqbs1f001ge39k8bjj8dta"},{"post_id":"ck3mqbs16000re39kqplih8hs","category_id":"ck3mqbs1d0017e39kghs1klcj","_id":"ck3mqbs1g001ie39kjn70sgts"},{"post_id":"ck3mqbs17000ve39k1y9fineq","category_id":"ck3mqbs1d0017e39kghs1klcj","_id":"ck3mqbs1g001ke39kldq72fi7"},{"post_id":"ck3mqbs18000we39k0nf0myaa","category_id":"ck3mqbs1d0017e39kghs1klcj","_id":"ck3mqbs1g001me39kn1evsmm6"},{"post_id":"ck3mqbs1a0011e39kxudjjvtd","category_id":"ck3mqbs1d0017e39kghs1klcj","_id":"ck3mqbs1h001oe39kuj24jc6s"},{"post_id":"ck3mqbs1b0014e39kk7884ref","category_id":"ck3mqbs1d0017e39kghs1klcj","_id":"ck3mqbs1h001pe39km25rei8v"},{"post_id":"ck3mqbs1d0018e39kmsgfii4a","category_id":"ck3mqbs1d0017e39kghs1klcj","_id":"ck3mqbs1h001qe39kygct4xnq"},{"post_id":"ck3mqbs1n001se39kai2qs1e1","category_id":"ck3mqbs1o001te39kbkc4pw0p","_id":"ck3mqbs1p001ue39k1kid8iub"}],"PostTag":[{"post_id":"ck3mqbs11000he39k7tz9rihl","tag_id":"ck3mqbs13000me39k75myakb4","_id":"ck3mqbs17000se39kbxayyb1i"}],"Tag":[{"name":"JavaScript","_id":"ck3mqbs13000me39k75myakb4"}]}}