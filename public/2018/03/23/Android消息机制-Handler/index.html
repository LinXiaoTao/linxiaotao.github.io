<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Android消息机制-Handler | My World</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="参考Android消息机制1-Handler(Java层) Android消息机制2-Handler(Native层) Android应用程序消息处理机制（Looper、Handler）分析 管道(Unix)) Epoll 文件描述符 Handler 机制主要由四个部分组成：  Looper MessageQueue Message Handler  典型用法1234567891011121314">
<meta property="og:type" content="article">
<meta property="og:title" content="Android消息机制-Handler">
<meta property="og:url" content="https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/index.html">
<meta property="og:site_name" content="My World">
<meta property="og:description" content="参考Android消息机制1-Handler(Java层) Android消息机制2-Handler(Native层) Android应用程序消息处理机制（Looper、Handler）分析 管道(Unix)) Epoll 文件描述符 Handler 机制主要由四个部分组成：  Looper MessageQueue Message Handler  典型用法1234567891011121314">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://gityuan.com/images/handler/java_sendmessage.png">
<meta property="og:image" content="http://gityuan.com/images/handler/handler_java.jpg">
<meta property="og:updated_time" content="2018-03-27T01:21:48.004Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android消息机制-Handler">
<meta name="twitter:description" content="参考Android消息机制1-Handler(Java层) Android消息机制2-Handler(Native层) Android应用程序消息处理机制（Looper、Handler）分析 管道(Unix)) Epoll 文件描述符 Handler 机制主要由四个部分组成：  Looper MessageQueue Message Handler  典型用法1234567891011121314">
<meta name="twitter:image" content="http://gityuan.com/images/handler/java_sendmessage.png">
    
        <link rel="alternate" type="application/atom+xml" title="My World" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpeg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Leo</h5>
          <a href="mailto:linxiaotao1993@vip.qq.com" title="linxiaotao1993@vip.qq.com" class="mail">linxiaotao1993@vip.qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/LinXiaoTao" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/linxiaotao1993" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Android消息机制-Handler</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Android消息机制-Handler</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-03-23T12:29:21.000Z" itemprop="datePublished" class="page-time">
  2018-03-23
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android-Framework/">Android Framework</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#参考"><span class="post-toc-number">1.</span> <span class="post-toc-text">参考</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#典型用法"><span class="post-toc-number">2.</span> <span class="post-toc-text">典型用法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Looper"><span class="post-toc-number">3.</span> <span class="post-toc-text">Looper</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Handler"><span class="post-toc-number">4.</span> <span class="post-toc-text">Handler</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MessageQueue"><span class="post-toc-number">5.</span> <span class="post-toc-text">MessageQueue</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Message"><span class="post-toc-number">6.</span> <span class="post-toc-text">Message</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#总结"><span class="post-toc-number">7.</span> <span class="post-toc-text">总结</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Android消息机制-Handler"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Android消息机制-Handler</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-03-23 20:29:21" datetime="2018-03-23T12:29:21.000Z"  itemprop="datePublished">2018-03-23</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android-Framework/">Android Framework</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Android消息机制1-Handler(Java层)</a></p>
<p><a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Android消息机制2-Handler(Native层)</a></p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/6817933" target="_blank" rel="noopener">Android应用程序消息处理机制（Looper、Handler）分析</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix" target="_blank" rel="noopener">管道(Unix)</a>)</p>
<p><a href="https://zh.wikipedia.org/zh-hans/Epoll" target="_blank" rel="noopener">Epoll</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6" target="_blank" rel="noopener">文件描述符</a></p>
<p>Handler 机制主要由四个部分组成：</p>
<ul>
<li>Looper</li>
<li>MessageQueue</li>
<li>Message</li>
<li>Handler</li>
</ul>
<h3 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a>典型用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        </span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// process incoming messages here</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>不断循环执行 <code>Looper.loop</code>，按分发机制将消息分发给目标处理者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建 Looper 存储到 ThreadLocal</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sThreadLocal</code> 是一个 ThreadLocal 类型的静态变量</p>
<blockquote>
<p>ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Looper 中创建 MessageQueue</span></span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;                                                                     </span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();                                                               </span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;                                                                           </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;                                                                                           </span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;                                                       </span><br><span class="line">                                                                                                </span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,                      </span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.                                  </span></span><br><span class="line">    Binder.clearCallingIdentity();                                                              </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();                                           </span><br><span class="line">                                                                                                </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                                                                                  </span><br><span class="line">        Message msg = queue.next(); <span class="comment">// 获取下一条 Message，可能会阻塞                                              </span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;                                                                      </span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.                         </span></span><br><span class="line">            <span class="keyword">return</span>;                                                                             </span><br><span class="line">        &#125;                                                                                       </span><br><span class="line">                                                                                                </span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger                 </span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;                                                    </span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;                                                                  </span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +                        </span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);                                            </span><br><span class="line">        &#125;                                                                                       </span><br><span class="line">                                                                                                </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;                       </span><br><span class="line">                                                                                                </span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();     </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> end;                                                                         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 分发 Message</span></span><br><span class="line">            msg.target.dispatchMessage(msg);                                                    </span><br><span class="line">            end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();              </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;                                                                             </span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;                                                                </span><br><span class="line">                Trace.traceEnd(traceTag);                                                       </span><br><span class="line">            &#125;                                                                                   </span><br><span class="line">        &#125;                                                                                       </span><br><span class="line">        <span class="keyword">if</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>) &#123;                                                      </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> time = end - start;                                                      </span><br><span class="line">            <span class="keyword">if</span> (time &gt; slowDispatchThresholdMs) &#123;                                               </span><br><span class="line">                Slog.w(TAG, <span class="string">"Dispatch took "</span> + time + <span class="string">"ms on "</span>                                  </span><br><span class="line">                        + Thread.currentThread().getName() + <span class="string">", h="</span> +                           </span><br><span class="line">                        msg.target + <span class="string">" cb="</span> + msg.callback + <span class="string">" msg="</span> + msg.what);               </span><br><span class="line">            &#125;                                                                                   </span><br><span class="line">        &#125;                                                                                       </span><br><span class="line">                                                                                                </span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;                                                                  </span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);            </span><br><span class="line">        &#125;                                                                                       </span><br><span class="line">                                                                                                </span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the                                  </span></span><br><span class="line">        <span class="comment">// identity of the thread wasn't corrupted.                                             </span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();                                    </span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;                                                                </span><br><span class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span>                                      </span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span>                                        </span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span>                     </span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span>                                     </span><br><span class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);                                      </span><br><span class="line">        &#125;                                                                                       </span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 释放 Message</span></span><br><span class="line">        msg.recycleUnchecked();                                                                 </span><br><span class="line">    &#125;                                                                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Looper.quit 最终调用的都是 MessageQueue.quit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">false</span>); <span class="comment">// 移除消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">true</span>); <span class="comment">// 安全移除消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MessageQueue 在构造方法中，会调用 native 方法 <code>nativeInit</code> 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs</span></span><br><span class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :  </span><br><span class="line">    mAllowNonCallbacks(allowNonCallbacks),  </span><br><span class="line">    mResponseIndex(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 管道机制</span></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];  </span><br><span class="line">    <span class="keyword">int</span> result = pipe(wakeFds);  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];  </span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];  </span><br><span class="line">  	</span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class="line">    <span class="comment">// 分配新的 epoll 实例同时注册唤醒管道</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span>  </span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    <span class="comment">// 观察 EPOLLIN 事件</span></span><br><span class="line">    eventItem.events = EPOLLIN;  </span><br><span class="line">    eventItem.data.fd = mWakeReadPipeFd;  </span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);  </span><br><span class="line">    ......  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">    ......  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。</p>
<p>epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p>
</blockquote>
<p>pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。</p>
<p>以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;                                                  </span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;                                                                     </span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();                                          </span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;          </span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏</span></span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +      </span><br><span class="line">                klass.getCanonicalName());                                                          </span><br><span class="line">        &#125;                                                                                           </span><br><span class="line">    &#125;                                                                                               </span><br><span class="line">    <span class="comment">// 默认使用当前线程的 Looper                                                                                                </span></span><br><span class="line">    mLooper = Looper.myLooper();                                                                    </span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;                                                                          </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(                                                                 </span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);             </span><br><span class="line">    &#125;                                                                                               </span><br><span class="line">    mQueue = mLooper.mQueue;                                                                        </span><br><span class="line">    mCallback = callback;</span><br><span class="line">    <span class="comment">// 是否为异步处理</span></span><br><span class="line">    mAsynchronous = async;                                                                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Looper.loop</code> 中，当存在 Message 需要处理时，会调用 <code>dispatchMessage</code> 来进行分发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 先调用 callback</span></span><br><span class="line">        handleCallback(msg);                    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                    </span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 接着检查通过构造方法传进来的 Callback</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123; </span><br><span class="line">                <span class="keyword">return</span>;                         </span><br><span class="line">            &#125;                                   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后调用 handleMessage</span></span><br><span class="line">        handleMessage(msg);                     </span><br><span class="line">    &#125;                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 Handler 发送消息：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://gityuan.com/images/handler/java_sendmessage.png" alt="发送消息调用链" title="">
                </div>
                <div class="image-caption">发送消息调用链</div>
            </figure>
<p>最终所有的方法都会调用到 <code>MessageQueue.enqueueMessage</code></p>
<h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><blockquote>
<p>消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123; </span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    <span class="comment">// used by native code</span></span><br><span class="line">    mPtr = nativeInit();            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MessageQueue 的初始化工作主要由 native 方法来执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();  </span><br><span class="line">    <span class="keyword">if</span> (! nativeMessageQueue) &#123;  </span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量</span></span><br><span class="line">    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nativeInit</code> 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 <code>mPtr</code>，关联了 NativeMessageQueue 和 MessageQueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;                                                                              </span><br><span class="line">    <span class="comment">// messsage loop has already quit                                                              </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;                                                                    </span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;                                                                           </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;                                                                          </span><br><span class="line">    &#125;                                                                                         </span><br><span class="line">                                                                                              </span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration                       </span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;                                                            </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                                                                                </span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;                                                     </span><br><span class="line">            Binder.flushPendingCommands();                                                    </span><br><span class="line">        &#125;                                                                                     </span><br><span class="line">        <span class="comment">// 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class="line">        <span class="comment">// ptr 是在 JNI 层创建的 NativeMessageQueue</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);                                           </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前 nativePollOnce 返回后，查看消息队列中是否存在消息</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;                                                                 </span><br><span class="line">            <span class="comment">// 尝试检索下一条消息，如果找到则返回                            </span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();                                      </span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;                                                           </span><br><span class="line">            Message msg = mMessages;                                                          </span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;                                          </span><br><span class="line">                <span class="comment">// 找到下一条异步消息或者没有消息了，则退出循环</span></span><br><span class="line">                <span class="keyword">do</span> &#123;                                                                          </span><br><span class="line">                    prevMsg = msg;                                                            </span><br><span class="line">                    msg = msg.next;                                                           </span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());                               </span><br><span class="line">            &#125;                                                                                 </span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;                                                                </span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;                                                         </span><br><span class="line">                    <span class="comment">// 下一个消息还没准备好，重新设置唤醒超时时间</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                                                      </span><br><span class="line">                    <span class="comment">// 获取一条消息                                                         </span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;                                                    </span><br><span class="line">                        prevMsg.next = msg.next;                                              </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;                                                                  </span><br><span class="line">                        mMessages = msg.next;                                                 </span><br><span class="line">                    &#125;                                                                         </span><br><span class="line">                    msg.next = <span class="keyword">null</span>;                                                          </span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    <span class="comment">// 标记当前消息已使用</span></span><br><span class="line">                    msg.markInUse();                                                          </span><br><span class="line">                    <span class="keyword">return</span> msg;                                                               </span><br><span class="line">                &#125;                                                                             </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                                                          </span><br><span class="line">                <span class="comment">// 当前还没有消息，设置为 -1，无限等待中                                                     </span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;                                                   </span><br><span class="line">            &#125;                                                                                 </span><br><span class="line">                                                                                              </span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.      </span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;                                                                  </span><br><span class="line">                dispose();                                                                    </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;                                                                  </span><br><span class="line">            &#125;                                                                                 </span><br><span class="line">                                                                                              </span><br><span class="line">            <span class="comment">// queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// get pending idle handler count</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span>                                                   </span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;                         </span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();                               </span><br><span class="line">            &#125;                                                                                 </span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;                                               </span><br><span class="line">                <span class="comment">// 没有 idle handlers 需要运行，循环继续等待                        </span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;                                                              </span><br><span class="line">                <span class="keyword">continue</span>;                                                                     </span><br><span class="line">            &#125;                                                                                 </span><br><span class="line">                                                                                              </span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;                                               </span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)]; </span><br><span class="line">            &#125;                                                                                 </span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);               </span><br><span class="line">        &#125;                                                                                     </span><br><span class="line">                                                                                              </span><br><span class="line">        <span class="comment">// Run the idle handlers.                                                        </span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration                    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;                                   </span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];                                </span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>;           </span><br><span class="line">                                                                                              </span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;                                                             </span><br><span class="line">            <span class="keyword">try</span> &#123;                                                                             </span><br><span class="line">                keep = idler.queueIdle();                                                     </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;                                                           </span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);                               </span><br><span class="line">            &#125;                                                                                 </span><br><span class="line">                                                                                              </span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;                                                                      </span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);                                              </span><br><span class="line">                &#125;                                                                             </span><br><span class="line">            &#125;                                                                                 </span><br><span class="line">        &#125;                                                                                     </span><br><span class="line">                                                                                              </span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.                     </span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;                                                          </span><br><span class="line">                                                                                              </span><br><span class="line">        <span class="comment">//不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入                </span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;                                                            </span><br><span class="line">    &#125;                                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>next</code> 方法中，<code>nativePollOnce</code> 是阻塞操作，其中 <code>nextPollTimeoutMillis</code> 代表下一个消息到来之前，还需要等待的时长；<code>nextPollTimeoutMillis == -1</code> 表示当前没有更多消息。<code>nativePollOnce</code> 调用结束后，从 <code>mMessages</code> 中提取一个消息</p>
<p>当处于空闲时，执行 <code>IdleHandler</code> 中的回调方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,  </span></span></span><br><span class="line"><span class="function"><span class="params">        jint ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过前面设置的 mPrt 获取 NativeMessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr); </span><br><span class="line">    <span class="comment">// 调用 NativeMessageQueue.pollOnce 进行轮询</span></span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(timeoutMillis);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(<span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    <span class="comment">// 将调用转发给了 JNI 层的 Looper</span></span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pollOnce</code> 会调用 <code>pollnner</code> 来进一步操作，如果 <code>pollnner</code> 返回值不等于 0，则返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> result = ALOOPER_POLL_WAKE;  </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="comment">// 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis</span></span><br><span class="line">    <span class="comment">// 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件</span></span><br><span class="line">    <span class="comment">// 如果检查成功或者超时，则结束等待</span></span><br><span class="line">    <span class="comment">// 处于 Idle 状态</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">    <span class="keyword">bool</span> acquiredLock = <span class="literal">false</span>;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">    ......  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// eventCount &lt; 0 可能出错了</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;  </span><br><span class="line">            <span class="keyword">goto</span> Done;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        LOGW(<span class="string">"Poll failed with an unexpected error, errno=%d"</span>, errno);  </span><br><span class="line">        result = ALOOPER_POLL_ERROR;  </span><br><span class="line">        <span class="keyword">goto</span> Done;  </span><br><span class="line">    &#125;  </span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// eventCount == 0 超时</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">        result = ALOOPER_POLL_TIMEOUT;  </span><br><span class="line">        <span class="keyword">goto</span> Done;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOOPER_USES_EPOLL</span></span><br><span class="line">    <span class="comment">// eventCount &gt; 0 存在事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;  </span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="comment">// Looper 中使用 epoll 监听的 EPOLLIN 事件</span></span><br><span class="line">                awoken();  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                LOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            ......  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (acquiredLock) &#123;  </span><br><span class="line">        mLock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">Done: ;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">    ......  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::awoken() &#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">16</span>];  </span><br><span class="line">    <span class="keyword">ssize_t</span> nRead;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        nRead = read(mWakeReadPipeFd, buffer, <span class="keyword">sizeof</span>(buffer));  </span><br><span class="line">    &#125; <span class="keyword">while</span> ((nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class="keyword">sizeof</span>(buffer));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结上面的代码，Looper 通过 <code>loop</code> 调用 MessageQueue 的 <code>next</code>，<code>next</code> 中又会调用到 native 方法 <code>nativePollOnce</code>，在这个方法中，会调用到 NativeMessageQueue 的 <code>pollInner</code>，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 <code>awoken</code>，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;                                         </span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;                                                            </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);               </span><br><span class="line">    &#125;                                                                                    </span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;                                                                 </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);       </span><br><span class="line">    &#125;                                                                                    </span><br><span class="line">                                                                                         </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;                                                                </span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;                                                                 </span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(                         </span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);      </span><br><span class="line">            Log.w(TAG, e.getMessage(), e);                                               </span><br><span class="line">            msg.recycle();                                                               </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;                                                                </span><br><span class="line">        &#125;                                                                                </span><br><span class="line">                                                                                         </span><br><span class="line">        msg.markInUse();                                                                 </span><br><span class="line">        msg.when = when;                                                                 </span><br><span class="line">        Message p = mMessages;                                                           </span><br><span class="line">        <span class="keyword">boolean</span> needWake;                                                                </span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;                                   </span><br><span class="line">            <span class="comment">// 不存在头部消息或立即执行或执行时机快于头部消息</span></span><br><span class="line">            <span class="comment">// 将处理的消息作为新的头部消息</span></span><br><span class="line">            msg.next = p;                                                                </span><br><span class="line">            mMessages = msg;                                                             </span><br><span class="line">            needWake = mBlocked;                                                         </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                                                         </span><br><span class="line">            <span class="comment">// 将处理的消息插入到队列的尾部</span></span><br><span class="line">            <span class="comment">// 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();             </span><br><span class="line">            Message prev;                                                                </span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;                                                                   </span><br><span class="line">                prev = p;                                                                </span><br><span class="line">                p = p.next;                                                              </span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;                                        </span><br><span class="line">                    <span class="keyword">break</span>;                                                               </span><br><span class="line">                &#125;                                                                        </span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;                                    </span><br><span class="line">                    needWake = <span class="keyword">false</span>;                                                    </span><br><span class="line">                &#125;                                                                        </span><br><span class="line">            &#125;                                                                            </span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next                                   </span></span><br><span class="line">            prev.next = msg;                                                             </span><br><span class="line">        &#125;                                                                                </span><br><span class="line">                                                                                         </span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.                           </span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;                                                                  </span><br><span class="line">            nativeWake(mPtr);                                                            </span><br><span class="line">        &#125;                                                                                </span><br><span class="line">    &#125;                                                                                    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MessageQueue</code> 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。</p>
<p>如果当前线程处于空闲等待状态，那么还需要调用 <code>nativeWake</code> 来唤醒：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jobject obj, jint ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ptr 获取 NativeMessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);  </span><br><span class="line">    <span class="keyword">return</span> nativeMessageQueue-&gt;wake();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将唤醒请求转发到 Looper <code>wake</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/utils/Looper.cpp</span></span><br><span class="line"><span class="keyword">void</span> Looper::wake() &#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;  </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 先管道中写入 "W</span></span><br><span class="line">        nWrite = write(mWakeWritePipeFd, <span class="string">"W"</span>, <span class="number">1</span>);  </span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);  </span><br><span class="line">  </span><br><span class="line">    .......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 <code>polllnner</code> 中调用 <code>epoll_wait</code> 进入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;                                          </span><br><span class="line">        <span class="keyword">return</span>;                                               </span><br><span class="line">    &#125;                                                         </span><br><span class="line">                                                              </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;                                     </span><br><span class="line">        Message p = mMessages;                                </span><br><span class="line">                                                              </span><br><span class="line">        <span class="comment">// 从队列头部开始，移除连续的所有符合条件的消息                     </span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what   </span><br><span class="line">               &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;      </span><br><span class="line">            Message n = p.next;                               </span><br><span class="line">            mMessages = n;</span><br><span class="line">            <span class="comment">// 找到对应的消息，释放它</span></span><br><span class="line">            p.recycleUnchecked();                             </span><br><span class="line">            p = n;                                            </span><br><span class="line">        &#125;                                                     </span><br><span class="line">                                                              </span><br><span class="line">        <span class="comment">//  从新的队列头部开始，移除全部符合条件的消息                  </span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;                                   </span><br><span class="line">            Message n = p.next;                               </span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;                                  </span><br><span class="line">                <span class="keyword">if</span> (n.target == h &amp;&amp; n.what == what           </span><br><span class="line">                    &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123; </span><br><span class="line">                    Message nn = n.next;                      </span><br><span class="line">                    n.recycleUnchecked();                     </span><br><span class="line">                    p.next = nn;                              </span><br><span class="line">                    <span class="keyword">continue</span>;                                 </span><br><span class="line">                &#125;                                             </span><br><span class="line">            &#125;                                                 </span><br><span class="line">            p = n;                                            </span><br><span class="line">        &#125;                                                     </span><br><span class="line">    &#125;                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>postSyncBarrier</code> 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 <code>removeSyncBarrier</code></p>
<p>当 MessageQueue 退出时，需要 <code>dispose</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Disposes of the underlying message queue.                 </span></span><br><span class="line"><span class="comment">// Must only be called on the looper thread or the finalizer.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;                                     </span><br><span class="line">    <span class="keyword">if</span> (mPtr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// native 方法</span></span><br><span class="line">        nativeDestroy(mPtr);</span><br><span class="line">        <span class="comment">// mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量</span></span><br><span class="line">        mPtr = <span class="number">0</span>;                                            </span><br><span class="line">    &#125;                                                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nativeDestroy</code> 最终会调用 RefBase 的 <code>decStrong</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id); <span class="comment">//移除强引用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id); <span class="comment">// 移除弱引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;                 </span><br><span class="line">    <span class="comment">// 标记为使用状态，清除其他状态     </span></span><br><span class="line">    flags = FLAG_IN_USE;                  </span><br><span class="line">    what = <span class="number">0</span>;                             </span><br><span class="line">    arg1 = <span class="number">0</span>;                             </span><br><span class="line">    arg2 = <span class="number">0</span>;                             </span><br><span class="line">    obj = <span class="keyword">null</span>;                           </span><br><span class="line">    replyTo = <span class="keyword">null</span>;                       </span><br><span class="line">    sendingUid = -<span class="number">1</span>;                      </span><br><span class="line">    when = <span class="number">0</span>;                             </span><br><span class="line">    target = <span class="keyword">null</span>;                        </span><br><span class="line">    callback = <span class="keyword">null</span>;                      </span><br><span class="line">    data = <span class="keyword">null</span>;                          </span><br><span class="line">                                          </span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="comment">// 消息缓存</span></span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;  </span><br><span class="line">            next = sPool;                 </span><br><span class="line">            sPool = <span class="keyword">this</span>;                 </span><br><span class="line">            sPoolSize++;                  </span><br><span class="line">        &#125;                                 </span><br><span class="line">    &#125;                                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;             </span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;               </span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 从缓存中获取</span></span><br><span class="line">            Message m = sPool;               </span><br><span class="line">            sPool = m.next;                  </span><br><span class="line">            m.next = <span class="keyword">null</span>;                   </span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;                     </span><br><span class="line">            <span class="keyword">return</span> m;                        </span><br><span class="line">        &#125;                                    </span><br><span class="line">    &#125;                                        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://gityuan.com/images/handler/handler_java.jpg" alt="消息机制" title="">
                </div>
                <div class="image-caption">消息机制</div>
            </figure>
<p>Java 层：</p>
<ul>
<li>Handler 通过 <code>sendMessage</code>，将 Message 通过 <code>MessageQueue.enqueueMessage</code> 添加到队列中</li>
<li>Looper 通过 <code>loop</code> 提取需要执行的 Message，并交与 <code>Message.target</code> 的 Handler 进行 <code>dispatchMessage</code> 分发</li>
<li>将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler </li>
</ul>
<p>JNI 层：</p>
<ul>
<li>线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态</li>
<li>通过 epoll 机制监听 <code>EPOLLIN</code> 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程</li>
</ul>
<p>消息分发的优先级：</p>
<ol>
<li><code>Message.callback.run()</code></li>
<li><code>Handler.mCallback.handleMessage()</code></li>
<li><code>Handler.handleMessage()</code></li>
</ol>
<blockquote>
<p>EPOLL：Linux 内核的可扩展 I/O 事件通知机制</p>
<p>PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入</p>
<p>文件描述符(File descriptor)：用于表述指向<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">文件</a>的引用的抽象化概念</p>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-03-27T01:21:48.004Z" itemprop="dateUpdated">2018-03-27 09:21:48</time>
</span><br>


        
        欢迎探讨 <a href="mailto://linxiaotao1993@vip.qq.com" target="_blank">linxiaotao1993@vip.qq.com</a>
        
    </div>
    
    <footer>
        <a href="https://linxiaotao.github.io">
            <img src="/img/avatar.jpeg" alt="Leo">
            Leo
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/&title=《Android消息机制-Handler》 — My World&pic=https://linxiaotao.github.io/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/&title=《Android消息机制-Handler》 — My World&source=linxiaotao's blog" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android消息机制-Handler》 — My World&url=https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/&via=https://linxiaotao.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/03/27/Activity启动流程-基于Android26/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Activity启动流程(基于Android26)</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/03/17/hello-world/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Hello World</h4>
      </a>
    </div>
  
</nav>



    














</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Leo &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/&title=《Android消息机制-Handler》 — My World&pic=https://linxiaotao.github.io/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/&title=《Android消息机制-Handler》 — My World&source=linxiaotao's blog" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android消息机制-Handler》 — My World&url=https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/&via=https://linxiaotao.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://linxiaotao.github.io/2018/03/23/Android消息机制-Handler/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
