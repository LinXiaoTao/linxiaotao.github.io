[{"title":"Android消息机制-Handler","date":"2018-03-23T12:29:21.000Z","path":"2018/03/23/Android消息机制-Handler/","text":"参考Android消息机制1-Handler(Java层) Android消息机制2-Handler(Native层) Android应用程序消息处理机制（Looper、Handler）分析 管道(Unix)) Epoll 文件描述符 Handler 机制主要由四个部分组成： Looper MessageQueue Message Handler 典型用法123456789101112131415class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; Looper不断循环执行 Looper.loop，按分发机制将消息分发给目标处理者 1234567private static void prepare(boolean quitAllowed) &#123; if(sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; // 构建 Looper 存储到 ThreadLocal sThreadLocal.set(new Looper(quitAllowed));&#125; sThreadLocal 是一个 ThreadLocal 类型的静态变量 ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域 12345private Looper(boolean quitAllowed) &#123; // Looper 中创建 MessageQueue mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // 获取下一条 Message，可能会阻塞 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; //省略 final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try &#123; // 分发 Message msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time = end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, \"Dispatch took \" + time + \"ms on \" + Thread.currentThread().getName() + \", h=\" + msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what); &#125; &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; // 释放 Message msg.recycleUnchecked(); &#125; &#125; 12345678// Looper.quit 最终调用的都是 MessageQueue.quitpublic void quit() &#123; mQueue.quit(false); // 移除消息&#125;public void quitSafely() &#123; mQueue.quit(true); // 安全移除消息&#125; MessageQueue 在构造方法中，会调用 native 方法 nativeInit 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper 1234567891011121314151617181920212223242526272829303132// frameworks/base/libsLooper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mResponseIndex(0) &#123; // 管道机制 int wakeFds[2]; int result = pipe(wakeFds); ...... mWakeReadPipeFd = wakeFds[0]; mWakeWritePipeFd = wakeFds[1]; ...... #ifdef LOOPER_USES_EPOLL // 分配新的 epoll 实例同时注册唤醒管道 mEpollFd = epoll_create(EPOLL_SIZE_HINT); ...... struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union // 观察 EPOLLIN 事件 eventItem.events = EPOLLIN; eventItem.data.fd = mWakeReadPipeFd; result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem); ...... #else ...... #endif ...... &#125; 管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。 epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。 pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。 以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。 Handler123456789101112131415161718192021public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; // 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏 Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; // 默认使用当前线程的 Looper mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; // 是否为异步处理 mAsynchronous = async; &#125; 在 Looper.loop 中，当存在 Message 需要处理时，会调用 dispatchMessage 来进行分发： 123456789101112131415public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; // 先调用 callback handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; // 接着检查通过构造方法传进来的 Callback if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; // 最后调用 handleMessage handleMessage(msg); &#125; &#125; 通过 Handler 发送消息： 发送消息调用链 最终所有的方法都会调用到 MessageQueue.enqueueMessage MessageQueue 消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理 12345MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; // used by native code mPtr = nativeInit(); &#125; MessageQueue 的初始化工作主要由 native 方法来执行 123456789101112//frameworks/base/core/jni/android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) &#123; // 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层 NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (! nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return; &#125; // 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量 android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue); &#125; nativeInit 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 mPtr，关联了 NativeMessageQueue 和 MessageQueue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104Message next() &#123; // messsage loop has already quit final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回 // ptr 是在 JNI 层创建的 NativeMessageQueue nativePollOnce(ptr, nextPollTimeoutMillis); // 当前 nativePollOnce 返回后，查看消息队列中是否存在消息 synchronized (this) &#123; // 尝试检索下一条消息，如果找到则返回 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // 找到下一条异步消息或者没有消息了，则退出循环 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 下一个消息还没准备好，重新设置唤醒超时时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 获取一条消息 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); // 标记当前消息已使用 msg.markInUse(); return msg; &#125; &#125; else &#123; // 当前还没有消息，设置为 -1，无限等待中 nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // queue is empty or if the first message // get pending idle handler count if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // 没有 idle handlers 需要运行，循环继续等待 mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; //不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入 nextPollTimeoutMillis = 0; &#125; &#125; 在 next 方法中，nativePollOnce 是阻塞操作，其中 nextPollTimeoutMillis 代表下一个消息到来之前，还需要等待的时长；nextPollTimeoutMillis == -1 表示当前没有更多消息。nativePollOnce 调用结束后，从 mMessages 中提取一个消息 当处于空闲时，执行 IdleHandler 中的回调方法。 12345678// frameworks/base/core/jni/android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jint ptr, jint timeoutMillis) &#123; // 通过前面设置的 mPrt 获取 NativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); // 调用 NativeMessageQueue.pollOnce 进行轮询 nativeMessageQueue-&gt;pollOnce(timeoutMillis); &#125; 1234void NativeMessageQueue::pollOnce(int timeoutMillis) &#123; // 将调用转发给了 JNI 层的 Looper mLooper-&gt;pollOnce(timeoutMillis); &#125; pollOnce 会调用 pollnner 来进一步操作，如果 pollnner 返回值不等于 0，则返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// frameworks/base/libs/utils/Looper.cppint Looper::pollInner(int timeoutMillis) &#123; ...... int result = ALOOPER_POLL_WAKE; ...... #ifdef LOOPER_USES_EPOLL struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis // 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件 // 如果检查成功或者超时，则结束等待 // 处于 Idle 状态 int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); bool acquiredLock = false; #else ...... #endif // eventCount &lt; 0 可能出错了 if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; LOGW(\"Poll failed with an unexpected error, errno=%d\", errno); result = ALOOPER_POLL_ERROR; goto Done; &#125; // eventCount == 0 超时 if (eventCount == 0) &#123; ...... result = ALOOPER_POLL_TIMEOUT; goto Done; &#125; ...... #ifdef LOOPER_USES_EPOLL // eventCount &gt; 0 存在事件 for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeReadPipeFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; // Looper 中使用 epoll 监听的 EPOLLIN 事件 awoken(); &#125; else &#123; LOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents); &#125; &#125; else &#123; ...... &#125; &#125; if (acquiredLock) &#123; mLock.unlock(); &#125; Done: ; #else ...... #endif ...... return result; &#125; 123456789void Looper::awoken() &#123; ...... char buffer[16]; ssize_t nRead; do &#123; nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer)); &#125; while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer)); &#125; 总结上面的代码，Looper 通过 loop 调用 MessageQueue 的 next，next 中又会调用到 native 方法 nativePollOnce，在这个方法中，会调用到 NativeMessageQueue 的 pollInner，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 awoken，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 不存在头部消息或立即执行或执行时机快于头部消息 // 将处理的消息作为新的头部消息 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // 将处理的消息插入到队列的尾部 // 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; MessageQueue 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。 如果当前线程处于空闲等待状态，那么还需要调用 nativeWake 来唤醒： 123456// frameworks/base/core/jni/android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj, jint ptr) &#123; // ptr 获取 NativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); return nativeMessageQueue-&gt;wake(); &#125; 这里将唤醒请求转发到 Looper wake： 123456789101112// frameworks/base/libs/utils/Looper.cppvoid Looper::wake() &#123; ...... ssize_t nWrite; do &#123; // 先管道中写入 \"W nWrite = write(mWakeWritePipeFd, \"W\", 1); &#125; while (nWrite == -1 &amp;&amp; errno == EINTR); ....... &#125; 往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 polllnner 中调用 epoll_wait 进入 12345678910111213141516171819202122232425262728293031323334void removeMessages(Handler h, int what, Object object) &#123; if (h == null) &#123; return; &#125; synchronized (this) &#123; Message p = mMessages; // 从队列头部开始，移除连续的所有符合条件的消息 while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what &amp;&amp; (object == null || p.obj == object)) &#123; Message n = p.next; mMessages = n; // 找到对应的消息，释放它 p.recycleUnchecked(); p = n; &#125; // 从新的队列头部开始，移除全部符合条件的消息 while (p != null) &#123; Message n = p.next; if (n != null) &#123; if (n.target == h &amp;&amp; n.what == what &amp;&amp; (object == null || n.obj == object)) &#123; Message nn = n.next; n.recycleUnchecked(); p.next = nn; continue; &#125; &#125; p = n; &#125; &#125; &#125; postSyncBarrier 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 removeSyncBarrier 当 MessageQueue 退出时，需要 dispose： 12345678910// Disposes of the underlying message queue. // Must only be called on the looper thread or the finalizer.private void dispose() &#123; if (mPtr != 0) &#123; // native 方法 nativeDestroy(mPtr); // mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量 mPtr = 0; &#125; &#125; nativeDestroy 最终会调用 RefBase 的 decStrong： 12345678910111213void RefBase::decStrong(const void* id) const&#123; weakref_impl* const refs = mRefs; refs-&gt;removeStrongRef(id); //移除强引用 const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong); if (c == 1) &#123; refs-&gt;mBase-&gt;onLastStrongRef(id); if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123; delete this; &#125; &#125; refs-&gt;decWeak(id); // 移除弱引用&#125; Message1234567891011121314151617181920212223void recycleUnchecked() &#123; // 标记为使用状态，清除其他状态 flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; // 消息缓存 if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; 1234567891011121314public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; // 从缓存中获取 Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; 总结 消息机制 Java 层： Handler 通过 sendMessage，将 Message 通过 MessageQueue.enqueueMessage 添加到队列中 Looper 通过 loop 提取需要执行的 Message，并交与 Message.target 的 Handler 进行 dispatchMessage 分发 将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler JNI 层： 线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态 通过 epoll 机制监听 EPOLLIN 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程 消息分发的优先级： Message.callback.run() Handler.mCallback.handleMessage() Handler.handleMessage() EPOLL：Linux 内核的可扩展 I/O 事件通知机制 PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入 文件描述符(File descriptor)：用于表述指向文件的引用的抽象化概念","tags":[]},{"title":"Hello World","date":"2018-03-17T05:24:16.197Z","path":"2018/03/17/hello-world/","text":"面朝大海，春暖花开从明天起，做一个幸福的人 喂马、劈柴、周游世界 从明天起，关心粮食和蔬菜 我有一所房子，面朝大海，春暖花开 从明天起，和每一个亲人通信 告诉他们我的幸福 那幸福的闪电告诉我的 我将告诉每一个人 给每一条河每一座山取一个温暖的名字 陌生人，我也为你祝福 愿你有一个灿烂的前程 愿你有情人总成眷属 愿你在尘世获得幸福 我只愿面朝大海，春暖花开","tags":[]}]