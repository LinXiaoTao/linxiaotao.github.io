[{"title":"熟悉又陌生的Context","date":"2018-04-12T02:45:36.000Z","path":"2018/04/12/熟悉又陌生的Context/","text":"感谢android-context 概述 本文中涉及的源码分析都是基于 Android 27 Context 又叫上下文，用于提供应用环境的信息。常用的操作包括启动 Activity、Service，或者通过 getResources() 返回 Resources 用于获取应用的资源文件，比如字符串、Drawable 等等。对于这些用法，我们就不去一一列举了，这篇文章的最终目的是，通过对于 Context 体系的整体了解，能在平时的应用开发中，正确使用不同类型的 Context。首先我们看下 Context 的类图： Context 其中 ContextImpl 负责 Context 核心功能的实现，而我们常见的 Activity Context，Application Context 等则是继承于 ContextWrapper，从类名可以猜测，这个是 Context 的包装类。实际上也是如此： 12345678public ContextWrapper(Context base) &#123; mBase = base;&#125;@Overridepublic void startActivity(Intent intent) &#123; mBase.startActivity(intent);&#125; 通过在构造函数中将 ContextImpl 实例赋值给 mBase，然后在比如 startActivity 等方法实现中，将调用转发给 mBase，至于 mBase 是不是 ContextImpl 实例，这个在后面的源码分析中可以知道。 通过上面的类图，我们可以知道 Application、Service、Activity 都是继承于 ContextWrapper，那么接下来通过简单的源码分析下上述的三个类实例的 Context 初始化过程。 Context初始化Activity在前面的 Activity 启动分析中，我们知道最终 Activity 启动方法是 ActivityThread.performLaunchActivity() 123456789101112131415161718192021222324private void performLaunchActivity() &#123; // 初始化 LoadedApk if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(); &#125; // 创建 ContextImpl 实例 ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); &#125; catch (Exception e) &#123; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); appContext.setOuterContext(activity); activity.attach(); &#125; catch (Exception e) &#123; &#125;&#125; 首先获取 LoadedApk 实例，接着调用 createBaseContextForActivity() 创建 ContextImpl 实例，之前我们提到 ContextWraper 是将 Context 核心功能转发给 ContextImpl 实现的，在 Activity 启动流程中，是通过调用 Activity.attach() 实现，这个我们在后面的分析中可以知道。 create12345678910private ComtextImpl createBaseContextForActivity() &#123; final int displayId; try &#123; displayId = ActivityManager.getService().getActivityDisplayId(r.token); &#125; catch (RemoteException e) &#123; &#125; ContextImpl appContext = ContextImpl.createActivityContext();&#125; 1234567891011121314151617static ContextImpl createActivityContext() &#123; ContextImpl context = new ContextImpl(); // Activity Resource final ResourcesManager resourcesManager = ResourcesManager.getInstance(); context.setResources(resourcesManager.createBaseActivityResources(activityToken, packageInfo.getResDir(), splitDirs, packageInfo.getOverlayDirs(), packageInfo.getApplicationInfo().sharedLibraryFiles, displayId, overrideConfiguration, compatInfo, classLoader)); context.mDisplay = resourcesManager.getAdjustedDisplay(displayId, context.getResources());&#125; attach123final void attach() &#123; attachBaseContext(context);&#125; 123protected void attachBaseContext() &#123; super.attachBaseContext(newBase);&#125; 这个步骤比较简单，最终也是调用 ContextWrapper.attachBaseContext() ServiceService 的创建是在 ActivityThread.handleCreateService() 123456789101112131415161718192021// 初始化 LoadedApkLoadedApk packageInfo = getPackageInfoNoCheck();Service service = null;try &#123; java.lang.ClassLoader cl = packageInfo.getClassLoader(); // 通过反射实例化 Service service = (Service) cl.loadClass(data.info.name).newInstance();&#125; catch (Exception e) &#123; &#125;try &#123; ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); Application app = packageInfo.makeApplication(false, mInstrumentation); service.attach();&#125; catch (Exception e) &#123; &#125; Service 的 Context 初始化流程和 Activity 是差不多，相同的是 LoadedApk -&gt; ContextImpl -&gt; attach create123456static ContextImpl createAppContext() &#123; ContextImpl context = new ContextImpl(); // Service 的 Resources 相对于 Activity 是比较简单的 context.setResources(packageInfo.getResources()); return context;&#125; attach123public final void attach() &#123; attachBaseContext(context);&#125; Service 的 attach 和 Activity 相同，都是调用 ContextWrapper.attachBaseContext() ApplicationApplication 的创建是在 LoadedApk.makeApplication() 123456789101112131415161718192021222324252627public Application makeApplication() &#123; // 保持单例 if (mApplication != null) &#123; return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; // 如果强制使用默认 Application，或者没有实现自定义 Application appClass = \"android.app.Application\"; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(\"android\")) &#123; // 包名不是 \"android\"，即非系统进程 initializeJavaContextClassLoader(); &#125; // 创建 ContextImpl 实例 ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); // 创建 Application 实例 app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; &#125;&#125; 咋一看好像 Application 的流程和其他两个不太相同，其实不是这样的，Application 的 attach 在 Instrumentation.newApplication() create1234static ContextImpl createAppContext() &#123; ContextImpl context = new ContextImpl(); context.setResources(packageInfo.getResources());&#125; attach123456public static Application newApplication() &#123; // 反射获取实例 Application app = (Application)clazz.newInstance(); app.attach(context); return app;&#125; 1234final void attach() &#123; attachBaseContext(context); mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;&#125; 小结通过我们对 Activity、Service、Application 的 Context 初始化流程的分析，首先创建 ContextImpl 实例，接着调用 ContextWrapper.attachBaseContext() 赋值给 mBase，ContextImpl 用于实现 Context 的核心功能，而 Context 的继承类则增加差异性功能。 实践通过上面对不同类型的 Context 的初始化分析，我们对 Context 机制有个大概的认识，接下来我们通过实际场景下的不同 Context 用例进行分析，从而加深对 Context 的理解。 View Context问题我们知道可以通过调用 View.getContext() 返回当前 View 使用的 Context 实例，这个实例主要用于获取 View 所要使用的资源信息，那么这个 Context 实例是在什么时候赋值的，使用的是哪种类型的 Context，区别又是什么呢。 分析首先我们对 View 的 mContext 变量赋值进行搜索，可以知道，赋值操作是在其中一个构造函数中，同时其他构造函数都会调用这个构造函数，所以我们可以先从构造函数的调用入手。 如果我们想要动态从 xml 布局中解析得到 View，我们会通过 LayoutInflater 去实现： 12LayoutInflater mLayoutInflater = LayoutInflater.from(context);View view = mLayoutInflater.inflate(R.layout.xxx,null); 首先我们看下 LayoutInflater.from()： 1234567public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater =(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError(\"LayoutInflater not found.\"); &#125; return LayoutInflater;&#125; 在上文我们提到 Context 的核心方法都转发给 mBase 即 ContextImpl 实例 12345678public Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name);&#125;public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;&#125; 最终的调用都转发给了 ServiceFetcher，而 SYSTEM_SERVICE_FETCHERS 存储着各个类型的 Fetcher 的实例 123456789101112// SYSTEM_SERVICE_FETCHERS 是个 Map，存储 Name-&gt;Fetcherprivate static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS = new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();// 存储 Class-&gt;Nameprivate static final HashMap&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES = new HashMap&lt;Class&lt;?&gt;, String&gt;();private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass, ServiceFetcher&lt;T&gt; serviceFetcher) &#123; SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);&#125; SYSTEM_SERVICE_FETCHERS 存储着 Service 名称和 Fetcher 的映射关系，而这种关系的注册是通过 registerService()，这里我们只关心 LayoutInflater 的注册： 123456registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;); LayoutInflater 的实现类是 PhoneLayoutInflater，同时 Fetcher 的实现类是 CachedServiceFetcher，PhoneLayoutInflater 实际并没有特殊的操作，基本逻辑都在 LayoutInflater，有兴趣的同学可以去看下，所以我们就看下 CachedServiceFetcher.getService() 123456789101112131415public final T getService(ContextImpl ctx) &#123; final Object[] cache = ctx.mServiceCache; synchronized (cache) &#123; Object service = cache[mCacheIndex]; if (service == null) &#123; try &#123; service = createService(ctx); cache[mCacheIndex] = service; &#125; catch (ServiceNotFoundException e) &#123; &#125; &#125; return (T)service; &#125;&#125; 注意到，Service 的缓存是存储在 ContextImpl.mServiceCache 并且该字段不是静态的，即Service 的缓存是针对于相同的 Context 实例的，如果不存在缓存，那么调用 createService()，上文我们分析 LayoutInflater Fetcher 时知道会创建 PhoneLayoutInflater 实例： 12// 在 Context 初始化那节我们知道 outerContext 就是具体的 ContextWrapper 实现类的实例，比如 Activity、Service 或者 Applicationreturn new PhoneLayoutInflater(ctx.getOuterContext()); 而 PhoneLayoutInflater 的构造函数也是调用超类的构造函数： 1234protected LayoutInflater(Context context) &#123; // 这个 mContext 要记住他是具体 ContextWrapper 实现类的实例，比如 Activity 等，这个后面会用到 mContext = context;&#125; 接下来我们看下 inflate() 源码： 123456789public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125;&#125; 1234567891011121314151617181920212223public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; // mContext 是具体 ContextWrapper 实现类的实例，上文我们已经提到了 final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; // 解析 xml 中的节点 final View temp = createViewFromTag(root, name, inflaterContext, attrs); &#125; catch () &#123; &#125; finally &#123; mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; &#125; return result; &#125;&#125; inflater() 就是对 xml 布局进行解析，实例化 View，这里我们不去关心它的解析流程，这一块内容可以单独写成一篇文章，我们主要看的是 createViewFromTag() 它是根据标签名称是实例化具体的 View 实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; if (name.equals(\"view\")) &#123; // 如果我们使用 view 标签则从 class 属性中获取具体类名称 name = attrs.getAttributeValue(null, \"class\"); &#125; if (!ignoreThemeAttr) &#123; // 默认 ignoreThemeAttr 为 false，即不忽略 theme 属性 // 获取设置的 theme 属性值 final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; // 如果设置了，则将 context 包装成 ContextThemeWrapper // 这意味着 xml 布局中 view 设置的 theme 属性优先级要高于 context 中的 theme 属性 context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); &#125; try &#123; View view; // Factory 是用于实现兼容功能，比如 TextView 会使用兼容包的 AppCompatTextView if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf('.')) &#123; // 系统控件 view = onCreateView(parent, name, attrs); &#125; else &#123; // 自定义控件 view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; &#125; catch () &#123; &#125;&#125; 不管是系统控件或者自定义控件，最终创建 View 实例都会调用到 createView() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public final View createView(String name, String prefix, AttributeSet attrs)&#123; // 缓存构造函数 Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); // 检查构造函数类加载器 if (constructor != null &amp;&amp; !verifyClassLoader(constructor))&#123; constructor = null; sConstructorMap.remove(name); &#125; Class&lt;? extends View&gt; clazz = null; try &#123; // 获取 View 构造函数实例，并处理过滤情况 if (constructor == null) &#123; clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); if (mFilter != null &amp;&amp; clazz != null) &#123; // 检查是否过滤 boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); &#125; else &#123; if (mFilter != null) &#123; // 存在过滤器 Boolean allowedState = mFilterMap.get(name); if (allowedState == null) &#123; // 没有缓存过滤结果，新的类 clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz); mFilterMap.put(name, allowed); if (!allowed) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; else if (allowedState.equals(Boolean.FALSE)) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; &#125; Object lastContext = mConstructorArgs[0]; if (mConstructorArgs[0] == null) &#123; // 如果还没设置 context 参数 mConstructorArgs[0] = mContext; &#125; Object[] args = mConstructorArgs; args[1] = attrs; // 反射创建 View 实例，这里调用的构造函数类型为 (Context,AttributeSet)，从 args 可知 final View view = constructor.newInstance(args); if (view instanceof ViewStub) &#123; // 使用相同的 Context 处理 ViewStub final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); &#125; mConstructorArgs[0] = lastContext; return view; &#125; catech () &#123; &#125;&#125; 最后一个问题，Application Context 和 Activity Context 用在 View Context 中有什么不同地方，我们先通过一个例子来看下效果： 12345678910111213141516171819protected void onCreate(Bundle savedInstanceState) &#123; // 使用两种 Context 创建两个 EditText addEditText(this); addEditText(getApplicationContext());&#125;private void addEditText(@Nullable Context context) &#123; if (mRootLayout == null) &#123; return; &#125; if (context == null) &#123; return; &#125; EditText editText = new EditText(context); mRootLayout.addView(editText); editText.setText(context.toString()); &#125; 代码很简单，使用不同 Context 去创建 EditText 实例，同时我们在 AndroidManifest 中应用了主题 123456&lt;Applicatin android:theme=\"@style/AppTheme\"&gt;&lt;/Applicatin&gt;&lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;&lt;color name=\"colorAccent\"&gt;#FF4081&lt;/color&gt; ActivityContextEditText ApplicationContextEditText 我们发现使用 Activity Context 的 EditText 使用了 theme 中的配置，回顾我们最开始的 Context 类图，Activity 是继承于 ContextThemeWrapper，而 Application 则是继承于 ContextWrapper，那我们是不是可以猜测只有 ContextThemeWrapper 的继承类才会读取 theme 中配置信息呢？我们可以看下 ContextThemeWrapper 中跟 theme 相关的方法： 1234567891011121314151617181920212223242526public Resources.Theme getTheme() &#123; if (mTheme != null) &#123; return mTheme; &#125; if (mThemeResource == 0) &#123; mThemeResource = R.style.Theme_AppCompat_Light; &#125; initializeTheme(); return mTheme;&#125;private void initializeTheme() &#123; final boolean first = mTheme == null; if (first) &#123; mTheme = getResources().newTheme(); Resources.Theme theme = getBaseContext().getTheme(); if (theme != null) &#123; mTheme.setTo(theme); &#125; &#125; onApplyThemeResource(mTheme, mThemeResource, first);&#125;protected void onApplyThemeResource(Resources.Theme theme, int resid, boolean first) &#123; theme.applyStyle(resid, true);&#125; mTheme 和 mThemeResource 都可以通过构造方法和 set 方法进行赋值，假设没有给 mTheme 赋值，只给 mThemeResource 赋值，那么上面的代码将 mThemeSource 应用到 ContextWrapper.getTheme() 返回的 Theme 实例，从而获取新的 Theme 实例。Activity 的启动流程是在 ActivityThread.performLaunchActivity() 中，其中涉及 Theme 的赋值是： 1234int theme = r.activityInfo.getThemeResource();if (theme != 0) &#123; activity.setTheme(theme);&#125; 现在我们应该知道了为什么有时候控件的样式不跟随主题设置了。 小结通过上面的源码分析，我们可以知道： 当使用 LayoutInflater 从 xml 文件中 inflate 布局时，调用的是 View(Context,AttributeSet) 构造函数，使用的 Context 实例跟 LayoutInflater 创建时使用的 Context 一样，并且 LayoutInflater 会缓存在 Context 实例中，即相同的 Context 实例多次调用会获取一样的 LayoutInflater 实例。 Activity Context 会读取 Theme 的样式信息，而 Application Context 则不会。 getApplication()和getApplicatinContext()接下来的分析参考于 android-context 绝大数情况下，这两个方法的返回值是一样。 getApplicationContext() 的存在是 Android 历史原因，getApplication() 这两个只存在 Activity 和 Service 类中，那么对于 BroadcastReceiver 和 ContentProvider 来说，要获取 Application，就只能通过 getApplicationContext()。 两者对比： 对于 Activity/Service 来说，这两个方法没有区别，除非厂商修改过 BroadcastReceiver 只能通过 getApplicationContext() 获取 Application 实例 ContentProvider 也只能通过 getApplicationContext() 获取 Application 实例，但有可能出现空值的情况。当同个进程有多个 apk 的情况下，对于第二个 apk 是由 provider 方式拉起，而 provider 创建过程中并不会初始化 Application，此时调用 getApplicationContext() 则会返回空。 小结绝大数情况下，getApplication() 和 getApplicationContext() 返回是一样的，但如果不是特别熟悉，最好对 getApplicationContext() 进行空值判断。 Dialog Context我们都知道创建 Dialog 实例需要传递 Context 实例，但这里的 Context 必须是 Activity Context，如果传入其他类型的 Context，则会抛出以下异常： 1Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running? start Activity通过调用 startActivity() 去启动 Activity 是非常常见的操作，并且这个方法存在 Context 类中，即不仅仅是 Activity 可以调用，Application 也可以调用，而 Application 没有重写 startActivity() 即实现是委托给 ContextImpl 的。这里有个需要注意的地方： 在 Android 26 上，如果使用 Application 启动 Activity，而没有添加 Intent.FLAG_ACTIVITY_NEW_TASK 标记的话，则会抛出以下异常： 1Caused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want? Android 26 上 ContextImpl 的相关代码如下： 123456789public void startActivity(Intent intent, Bundle options) &#123; if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123; throw new AndroidRuntimeException( \"Calling startActivity() from outside of an Activity \" + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\" + \" Is this really what you want?\"); &#125;&#125; 只要没有添加 Intent.FLAG_ACTIVITY_NEW_TASK 标记就会抛异常。 而在 Android 27 上，则有些区别，同样是 ContextImpl 的源码： 123456789public void startActivity(Intent intent, Bundle options) &#123; if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; options != null &amp;&amp; ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) &#123; throw new AndroidRuntimeException( \"Calling startActivity() from outside of an Activity \" + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\" + \" Is this really what you want?\"); &#125;&#125; 只有在指定了 options 同时其中没有指定 LaunchTaskId 才会抛异常。 总结上面我们列举了不同 Context 的初始化过程，比如最常见的 Activity Context 和 Application Context，同时对不同 Context 的使用场景进行比较，相信看完文章的同学，对 Context 有了更多的理解。 不管如何谨慎小心，怀着诚惶诚恐的心态，毕竟作者的水平有限，如果有说的不对的地方，敬请指出，先行感谢。","tags":[]},{"title":"Hello World","date":"2018-04-11T14:05:30.096Z","path":"2018/04/11/hello-world/","text":"面朝大海，春暖花开从明天起，做一个幸福的人 喂马、劈柴、周游世界 从明天起，关心粮食和蔬菜 我有一所房子，面朝大海，春暖花开 从明天起，和每一个亲人通信 告诉他们我的幸福 那幸福的闪电告诉我的 我将告诉每一个人 给每一条河每一座山取一个温暖的名字 陌生人，我也为你祝福 愿你有一个灿烂的前程 愿你有情人总成眷属 愿你在尘世获得幸福 我只愿面朝大海，春暖花开","tags":[]},{"title":"触摸事件实践之路","date":"2018-04-03T01:17:20.000Z","path":"2018/04/03/触摸事件实践之路/","text":"前言最近帮公司面试 Android 岗位，面试的同学大部分具有两年以上的工作经验，但发现很多同学对触摸事件的分发都不是很熟悉，有的可能还能照本宣科地说个七七八八，有的却完全不熟悉，这让我感觉到诧异，因为我认为这 Android 中非常基础的知识，不仅要熟悉其中的分发流程，还要能实现简单的涉及手势处理的自定义控件。所以，这也是这篇文章的目的，希望能通过一些触摸事件处理的实际例子，来加深对触摸事件分发的理解，同时能实现相关需求。 触摸事件简单回顾我们都知道触摸事件的分发严格意义上讲，是从 Activity 开始进行分发，但一般我们谈论的，只从 ViewGroup 开始分发。 上面的图只是粗略地画出触摸事件的分发流程，从 ViewGroup 的 dispatchTouchEvent 开始分发，先判断 ViewGroup 的 onInterceptTouchEvent 是否拦截，同时这里也可以调用 ViewGroup 的 requestDisallowInterceptTouchEvent 让 ViewGroup 不调用 onInterceptTouchEvent，如果事件被拦截，则调用 ViewGroup 的超类即 View 的 dispatchTouchEvent，反之，则调用子视图的 dispatchTouchEvent，注意：这里我们做了简单处理，假设当前 ViewGroup 的子视图为 View，如果子视图为 ViewGroup，那么还是先执行 ViewGroup 的 dispatchTouchEvent。 最终都会调用到 View 的 onTouchEvent 中，这个方法是真正处理触摸事件的，一般如果我们需要自己处理触摸事件，也是在这个方法中处理。 手势判定上面我们简单回顾了触摸事件分发，具体细节可以看下源码。其实上面所讲的分发流程，很多同学都能说出个大概，但就是在动手写的时候，不知道如何入手。 当我们在日常开发中，如果遇到不知道怎么实现的需求时，最直接的方法就是阅读他人的源码，不管是个人的库也好，Google 提供的库也好，设计良好的源码抵过看一大堆的博客。在实现需要处理触摸事件的需求也是一个道理，Android SDK 已经提供了 ListView，RecyclerView，ScrollView 等等涉及拖动处理的系统控件，所以我们可以从阅读这类控件的源码入手，看看系统控件是如何处理触摸事件的。这里我们选择 ScrollView 来简单分析下： ScrollView 继承于 FrameLayout，属于 ViewGroup 控件，所以有 onInterceptTouchEvent 因为篇幅有限，所以我们会省略去无关紧要的代码，各位同学可以对照着源码进行分析。 源码部分基于 Android 26 onInterceptTouchEvent123if ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) &#123; return true;&#125; 用 mIsBeingDragged 变量来保存当前是否已经开始进行拖动手势，这个后面会讲到，同时当前分发事件类型为 ACTION_MOVE，那么直接返回 true，即拦截事件向子视图进行分发。这个是一个快捷的判断，省去了后面再进行一系列的判断，这个是个小技巧，我们在实现自定义控件的时候也可以用上。接下来的分析，为了更清晰，我们分为不同类型的 Touch Action 进行阅读。 TOUCH_DOWN12345if (!inChild((int) ev.getX(), (int) y)) &#123; mIsBeingDragged = false; recycleVelocityTracker(); break;&#125; 这段代码很简单，如果触摸事件没有作用于子视图范围内，那么就不处理，同时释放速度跟踪器，这个后面会讲到，一般用于 fling 手势的判定。 123456789mLastMotionY = y;mActivePointerId = ev.getPointerId(0);initOrResetVelocityTracker();mVelocityTracker.addMovement(ev);mScroller.computeScrollOffset();mIsBeingDragged = !mScroller.isFinished();startNestedScroll(SCROLL_AXIS_VERTICAL); 这段代码主要是用于初始化判定之前的资源，比如 mLastMotionY 记录按下时的坐标信息，mActivePointerId 记录当前分发触摸事件的手指 id，这个一般用于多指的处理，initOrResetVelocityTracker 初始化速度跟踪器，同时使用 addMovement 记录当前触摸事件信息，mScroller 是一般用于 fling 手势处理，这里的作用是处理上一次的 fling，startNestedScroll 则是嵌套滚动机制的知识了，嵌套滚动机制也不难理解，但这里我们先不涉及，相信理解基础的触摸事件知识后，这个只要稍微阅读下源码，就能理解的，说句题外话，虽然嵌套滚动很容易理解，作用却非常大，基本解决了大部分的滑动冲突场景。 TOUCH_MOVE1234567891011121314151617181920final int activePointerId = mActivePointerId;if (activePointerId == INVALID_POINTER) &#123; break;&#125;final int pointerIndex = ev.findPointerIndex(activePointerId);if (pointerIndex == -1) &#123; break;&#125;final int y = (int) ev.getY(pointerIndex);final int yDiff = Math.abs(y - mLastMotionY);if (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == 0) &#123; mIsBeingDragged = true; mLastMotionY = y; initVelocityTrackerIfNotExists(); mVelocityTracker.addMovement(ev); final ViewParent parent = getParent(); if (parent != null) &#123; parent.requestDisallowInterceptTouchEvent(true); &#125;&#125; 这段代码先使用我们在 TOUCH_DOWN 中记录的 mActivePointerId 进行是否为有效的判断，如果有效，则通过 findPointerIndex 获取作用手指 id 的下标，记录为 pointerIndex ，为什么要获取这个值，我们知道现在的手机屏幕都是支持多指触摸的，所以我们需要根据某个按下的手指的触摸信息来进行处理。yDiff 是滑动的距离，mTouchSlop 则是 SDK 定义的可作为判定是否开始进行拖动的距离常量，可以通过 ViewConfiguration 的 getScaledTouchSlop 获取，如果大于这个值，我们可以认为开始了拖动的手势。 getNestedScrollAxes 这个同样是用于嵌套滚动机制的，可以略过。如果开始了拖动手势，mIsBeingDragged 标记为 true，同样使用速度跟踪器记录信息，这里还会调用 ViewParent 的 requestDisallowInterceptTouchEvent，防止父视图拦截了事件，即 onInterceptTouchEvent TOUCH_CANCEL &amp;&amp; TOUCH_UP1234mIsBeingDragged = false;mActivePointerId = INVALID_POINTER;recycleVelocityTracker();stopNestedScroll(); 一般我们都会在 TOUCH_CANCEL 和 TOUCH_UP 这两个类型的触摸事件分发中，进行一些释放资源的操作，比如 mIsBeingDragged 设置为 false，释放速度跟踪器等等 TOUCH_UP 是所有的手指(多指触摸)抬起时分发的事件，这个比较好理解，而 TOUCH_CANCEL 则是触摸取消事件类型，一般什么时候会分发这个事件呢？举个例子，如果某个子视图已经消费了 TOUCH_DOWN，即在这个事件分发时，向父视图传递了 true 的返回值，那么一般情况下，父视图不会再拦截接下来的事件，比如 ACTION_MOVE 等，但是如果父视图在这种情况下，还拦截了事件传递，即在 onInterceptTouch 中返回了 true，那么在 ViewGroup 的 dispatchTouchEvent 中会给已经确认消费事件的子视图分发一个 TOUCH_CANCEL 的事件，具体可以阅读源码。 ACTION_POINTER_UP这个为多指触摸时，某个手指抬起时分发的事件。 1234567891011final int pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt; MotionEvent.ACTION_POINTER_INDEX_SHIFT;final int pointerId = ev.getPointerId(pointerIndex);if (pointerId == mActivePointerId) &#123; final int newPointerIndex = pointerIndex == 0 ? 1 : 0; mLastMotionY = (int) ev.getY(newPointerIndex); mActivePointerId = ev.getPointerId(newPointerIndex); if (mVelocityTracker != null) &#123; mVelocityTracker.clear(); &#125;&#125; 这段代码处理的是，当某个手指抬起时，而这个手指刚好是我们当前使用的，则重新初始化资源 小结我们可以简单总结下，onInterceptTouchEvent 所进行的处理，即在 TOUCH_DOWN 资源初始化，TOUCH_MOVE 判断是否开始拖动手势，TOUCH_CANCEL &amp;&amp; TOUCH_UP 中进行资源释放。这里涉及了多指触摸的处理。 onTouchEventonTouchEvent 要比 onInterceptTouch 的逻辑更复杂，因为这个方法是用于真正的消费触摸事件。同样的，我们只关心核心代码，略去无关紧要的代码片段。 TOUCH_DOWN12345678910111213141516if (getChildCount() == 0) &#123; return false;&#125;if ((mIsBeingDragged = !mScroller.isFinished())) &#123; final ViewParent parent = getParent(); if (parent != null) &#123; parent.requestDisallowInterceptTouchEvent(true); &#125;&#125;if (!mScroller.isFinished()) &#123; mScroller.abortAnimation();&#125;mLastMotionY = (int) ev.getY();mActivePointerId = ev.getPointerId(0); 同样的，onTouchEvent 在 TOUCH_DOWN 事件分发中，主要是进行资源初始化，同时也处理上一次的 fling 任务，比如调用 Scroller 的 abortAnimation，如果 Scroller 还没结束 fling 计算，则中止处理。 TOUCH_MOVE12345678910111213141516171819202122232425262728final int activePointerIndex = ev.findPointerIndex(mActivePointerId);if (activePointerIndex == -1) &#123; break;&#125;final int y = (int) ev.getY(activePointerIndex);int deltaY = mLastMotionY - y;if (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) &#123; // 嵌套滚动处理 deltaY -= mScrollConsumed[1]; vtev.offsetLocation(0, mScrollOffset[1]); mNestedYOffset += mScrollOffset[1];&#125; if (!mIsBeingDragged &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop) &#123; final ViewParent parent = getParent(); if (parent != null) &#123; parent.requestDisallowInterceptTouchEvent(true); &#125; mIsBeingDragged = true; if (deltaY &gt; 0) &#123; deltaY -= mTouchSlop; &#125; else &#123; deltaY += mTouchSlop; &#125; &#125; if (mIsBeingDragged) &#123; /// 业务逻辑 &#125; 这段代码同样会进行多指处理，获取指定手指的触摸事件信息。mIsBeingDragged 为 false，同时会再进行一次拖动手势的判定，判定逻辑和 onInterceptTouchEvent 中类似，如果 mIsBeingDragged 为 true，则开始进行真正的逻辑处理。 EdgeEffect 是用于拖动时，边缘的阴影效果，具体使用可以参考源码 TOUCH_UP123456789101112if (mIsBeingDragged) &#123; final VelocityTracker velocityTracker = mVelocityTracker; velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity); int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId); if ((Math.abs(initialVelocity) &gt; mMinimumVelocity)) &#123; flingWithNestedDispatch(-initialVelocity); &#125; mActivePointerId = INVALID_POINTER; endDrag();&#125; 当手指全部抬起时，可以使用速度跟踪器进行 fling 手势的判定，同时释放资源。通过 getYVelocity 获取速度，在判断是否可以作为 fling 手势处理，mMaximumVelocity 是处理的最大速度，mMinimumVelocity 是处理的最小速度，这两个值同样可以通过 ViewConfiguration 的 getScaledMaximumFlingVelocity 和 getScaledMinimumFlingVelocity 获取。一般情况对 fling 的处理是通过 Scroller 进行处理的，因为这里涉及复杂的数学知识，而 Scroller 可以帮我们简化这里的操作，使用如下： 1234567int height = getHeight() - mPaddingBottom - mPaddingTop;int bottom = getChildAt(0).getHeight();mScroller.fling(mScrollX, mScrollY, 0, velocityY, 0, 0, 0, Math.max(0, bottom - height), 0, height/2);postInvalidateOnAnimation(); 通过传递当前拖动手势速度值来调用 fling 进行处理，然后在 computeScrollOffset 方法中，进行真正的滚动处理： 12345678public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; // 逻辑处理 int x = mScroller.getCurrX(); int y = mScroller.getCurrY(); postInvalidateOnAnimation(); &#125;&#125; 首先我们要知道 Scroller 并不会为我们进行滚动处理，它只是提供了计算的模型，通过调用 computeScrollOffset 进行计算，如果返回 true，表示计算还没结束，然后通过 getCurrX 或 getCurrY 获取计算后的值，最后进行真正的滚动处理，比如调用 scrollTo 等等，这里需要注意的是，需要调用 invalidate 来确保进行下一次的 computeScroll 调用，这里使用的 postInvalidateOnAnimation 其作用是类似的。 TOUCH_CANCEL1234567if (mIsBeingDragged &amp;&amp; getChildCount() &gt; 0) &#123; if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) &#123; postInvalidateOnAnimation(); &#125; mActivePointerId = INVALID_POINTER; endDrag();&#125; 同样的，一般我们都会在 TOUCH_CANCEL 中释放资源。 ACTION_POINTER_DOWN当有新的手指按下时分发的事件 123final int index = ev.getActionIndex();mLastMotionY = (int) ev.getY(index);mActivePointerId = ev.getPointerId(index); 以新按下的手指的信息重新计算 ACTION_POINTER_UP这里的处理和 onInterceptTouch 一致 小结onTouchEvent 和 onInterceptTouchEvent 处理有些相似，主要是在 TOUCH_MOVE 中在判定为拖动手势后进行真正的业务逻辑处理，同时在 TOUCH_UP 中根据速度跟踪器的获取的速度，判定是否符合 fling 手势，如果符合，则使用 Scroller 进行计算。 总结在分析完 ScrollView 的触摸事件处理，我们应该对事件处理有个基本理解，可以按照这个思路去分析其他的类似的系统控件，比如 NestedScrollView、RecyclerView 等等，我们可以发现处理的思路基本一致，那我们是不是可以将这些判定逻辑封装下呢？是的，并且系统已经提供 GestureDetector 来进行手势的判定，我们只需要在相应的手势回调方法中进行我们的业务逻辑即可。还有更强大的 ViewDragHelper ，但不管怎样，只要能理解好触摸事件分发，对工具类的熟练使用就不在话下。 实战理论说的再多，也是纸上谈兵，只有真正去实践，才能熟练掌握。因为业务需求或者兴趣爱好，我写了以下两个自定义控件，正好一个是纵向滑动和一个是横向滑动，效果如下： 详细的代码分析我们就不进行了，因为阅读源码是最快的方式，第一个是滚轮控件，第二个是之前参加活动的仿薄荷健康的卷尺控件。在这里我们只分析部分代码： 滚轮控件在前面手势判定中的分析中，我们提到在 onTouchEvent 判定拖动手势成功后，进行真正的业务逻辑处理，在这个控件中也是一样的： 1234if (mIsBeingDragged) &#123; mDistanceY += mLastY - moveY; postInvalidateOnAnimation();&#125; 在每次 TOUCH_MOVE 事件分发时，计算与 TOUCH_DOWN 时记录的位置信息的差值，保存为 mDistanceY，并且在 onDraw 中使用这个值对 Canvas 进行位移，绘制新位置的 UI。 卷尺控件拖动距离的计算与滚轮控件一样，只是记录为 mOffsetLeft 而已，同时两个控件都有在 onTouchEvent 的 ACTION_UP 事件分发中，处理 fling 手势。不过卷尺控件有使用 EdgeEffect 处理边缘效果，有兴趣的同学可以看下。 结语文章的主要目的并不在于教会怎么去处理触摸事件的分发，只是希望通过这个例子，大家能养成阅读源码的习惯，不管是系统 SDK 也好，第三方库也好，只要把核心知识掌握，就能熟练使用各种现成的工具库，并且达到举一反三的效果。 但是理论知识再多也是纸上谈兵，最重要的是实践，具体实践可以这样做：先理解好触摸事件分发流程，然后选择一个控件，可以是系统控件，也可以是其他控件，只要涉及触摸事件处理就行，进行阅读，然后手动实现一个相反方向滚动的控件，比如，你阅读的是纵向滑动的控件，那么就实现一个横向滑动的控件。这个自定义控件需要实现以下效果： 最基本的拖动手势处理 fling 效果实现 如果可以，再实现边缘效果 感谢大家的阅读。","tags":[]},{"title":"Activity启动流程(基于Android26)","date":"2018-03-27T01:54:17.000Z","path":"2018/03/27/Activity启动流程-基于Android26/","text":"基于 Android 26，分析 Android Activity 启动流程 参考startActivity启动过程分析 源码源码篇幅可能过长，所以会省略一下不必要的代码和注释 Activity12345678910111213@Override public void startActivity() &#123; this.startActivity(intent, null); &#125;@Override public void startActivity() &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; startActivityForResult(intent, -1); &#125; &#125; 最终都会调用到 startActivityForResult： 1234567891011121314public void startActivityForResult() &#123; if (mParent == null) &#123; // 转场动画的处理 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(); if (ar != null) &#123; mMainThread.sendActivityResult(); &#125; if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; &#125; else &#123; // 如果存在 Parent Activity 则交由它处理 &#125; &#125; 可以知道 Activity 启动委托给了 Instrumentation 进行实现 Instrumentation1234567891011121314151617181920212223242526272829303132333435363738public ActivityResult execStartActivity() &#123; // 由 ActivityThread.getApplicationThread 提供的 ApplicationThread IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) &#123; // true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 result = am.onStartActivity(intent); &#125; if (result != null) &#123; am.mHits++; return result; &#125; else if (am.match(who, null, intent)) &#123; // match 使用 IntentFilter 和 类名 进行匹配 am.mHits++; if (am.isBlocking()) &#123; // 当前监视器阻止 Activity 启动 return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; // 委托为 ActivityManagerService(AMS) 去处理 int result = ActivityManager.getService().startActivity(); // 检查 AMS 的处理结果 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null; &#125; 可以通过最后的调用委托给了ActivityManager.getService，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现 相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC 12345678910111213public static IActivityManager getService() &#123; return IActivityManagerSingleton.get(); &#125;private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; ActivityManagerService123456789@Override public final int startActivity() &#123; return startActivityAsUser(); &#125;@Override public final int startActivityAsUser() &#123; return mActivityStarter.startActivityMayWait(); &#125; 这里将启动请求又委托给了 ActivityStarter ActivityStarter1234567891011final int startActivityMayWait() &#123; // Intent 的响应 ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId); // Intent 的 Activity 信息 ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); final ActivityRecord[] outRecord = new ActivityRecord[1]; // 调用 startActivityLocked int res = startActivityLocked(outRecord); return res; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116private int startActivity() &#123; // 源 Activity 记录，即在哪个 Activity 进行 startActivity ActivityRecord sourceRecord = null; // 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity ActivityRecord resultRecord = null; if (resultTo != null) &#123; // 获取 Activity Stack 中已经存在的源 Activity 记录 sourceRecord = mSupervisor.isInAnyStackLocked(resultTo); if (sourceRecord != null) &#123; if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; // requestCode &gt;= 0，源 Activity 同时为 结果 Activity resultRecord = sourceRecord; &#125; &#125; &#125; final int launchFlags = intent.getFlags(); if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123; // 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity // 比如：A -&gt; B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A if (requestCode &gt;= 0) &#123; // 不允许有 requestCode ActivityOptions.abort(options); return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT; &#125; // 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity resultRecord = sourceRecord.resultTo; if (resultRecord != null &amp;&amp; !resultRecord.isInStackLocked()) &#123; resultRecord = null; &#125; // requestCode 处理 resultWho = sourceRecord.resultWho; requestCode = sourceRecord.requestCode; sourceRecord.resultTo = null; if (resultRecord != null) &#123; // 删除源 Activity 记录 resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode); &#125; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123; // component 找不到 err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123; // ActivityInfo 找不到 err = ActivityManager.START_CLASS_NOT_FOUND; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null &amp;&amp; sourceRecord.getTask().voiceSession != null) &#123; // 语音启动 Activity，检查是否符合 &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) &#123; // 启动语音会话 &#125; final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack(); if (err != START_SUCCESS) &#123; // 启动 Activity 失败 if (resultRecord != null) &#123; // 发送取消通知 resultStack.sendActivityResultLocked( -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return err; &#125; // 进行一些权限检查，判断是否终止 if (abort) &#123; // 如果需要终止 Activity if (resultRecord != null) &#123; resultStack.sendActivityResultLocked(); &#125; // 返回启动成功，实际终止 ActivityOptions.abort(options); return START_SUCCESS; &#125; // 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent // 处理 ephemeral app // 构造一个 ActivityRecord ActivityRecord r = new ActivityRecord(); final ActivityStack stack = mSupervisor.mFocusedStack; if (voiceSession == null &amp;&amp; (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123; // 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换 if (!mService.checkAppSwitchAllowedLocked() &#123; PendingActivityLaunch pal = new PendingActivityLaunch(); mPendingActivityLaunches.add(pal); ActivityOptions.abort(options); // 切换 app 失败 return ActivityManager.START_SWITCHES_CANCELED; &#125; &#125; if (mService.mDidAppSwitch) &#123; // 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0 mService.mAppSwitchesAllowedTime = 0; &#125; else &#123; mService.mDidAppSwitch = true; &#125; // 执行因为不允许 app 切换，而加到等待启动的 Activity doPendingActivityLaunchesLocked(false); return startActivity(); &#125; 12345678910111213141516171819private int startActivity() &#123; int result = START_CANCELED; try &#123; mService.mWindowManager.deferSurfaceLayout(); // 下一步流程 result = startActivityUnchecked(); &#125; finally &#123; // 如果启动 Activity 没有成功， 从 task 中移除 Activity if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; mStartActivity.getTask() != null) &#123; mStartActivity.getTask().removeActivity(mStartActivity); &#125; mService.mWindowManager.continueSurfaceLayout(); &#125; postStartActivityProcessing(); return result; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141private int startActivityUnchecked() &#123; // 设置一些初始化状态 setInitialState(); // 计算 launch flags computeLaunchingTaskFlags(); // 计算源 Task，源 Task 是否存在等 computeSourceStack(); // 获取是否存在可以复用的 Activity，根据 flags 和 launchMode ActivityRecord reusedActivity = getReusableIntentActivity(); if (reusedActivity != null) &#123; // 存在可复用的 Activity，复用它 // 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置 &#125; if (mStartActivity.packageName == null) &#123; return START_CLASS_NOT_FOUND; &#125; // 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity final boolean dontStart = top != null &amp;&amp; mStartActivity.resultTo == null &amp;&amp; top.realActivity.equals(mStartActivity.realActivity) &amp;&amp; top.userId == mStartActivity.userId &amp;&amp; top.app != null &amp;&amp; top.app.thread != null &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop || mLaunchSingleTask); if(dontStart)&#123; // 传递一个新的 Intent 到 onNewIntent top.deliverNewIntentLocked(); return START_DELIVERED_TO_TOP; &#125; // 获取 mTargetStack if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; newTask = true; // 需要创建新的 Task result = setTaskFromReuseOrCreateNewTask(); &#125; else if (mSourceRecord != null) &#123; // 从源 Activity 中获取 Task result = setTaskFromSourceRecord(); &#125; else if (mInTask != null) &#123; // 从 InTask 中获取 Task result = setTaskFromInTask(); &#125; else &#123; // 可能创建新的 Task 或使用当前 Task，一般不会发生 setTaskToCurrentTopOrCreateNewTask(); &#125; // 使用 mTargetStack 启动 Activity mTargetStack.startActivityLocked(); if (mDoResume) &#123; if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; // 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity // 那么我们不恢复目标 Task，只需要确保它可见即可 mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); &#125; &#125; else &#123; if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123; // 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台 mTargetStack.moveToFront(\"startActivityUnchecked\"); &#125; // 恢复目标 Task mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); &#125; else &#123; // 如果不需要恢复，那么加到\"最近活动\"中 mTargetStack.addRecentActivityLocked(mStartActivity); &#125; return START_SUCCESS;&#125;private void setInitialState()&#123; // 获取 DisplayId mSourceDisplayId = getSourceDisplayId(); // 获取用于启动 Activity 的范围，Rect mLaunchBounds = getOerrideBounds(); // launchMode mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP; mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE; mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK; // Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主 // 如果 requestCode &gt;= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity sendNewTaskResultRequestIfNeeded();&#125;private void computeLaunchingTaskFlags()&#123; if (mSourceRecord == null &amp;&amp; mInTask != null &amp;&amp; mInTask.getStack() != null)&#123; // 如果不存在源 Activity final Intent baseIntent = mInTask.getBaseIntent(); final ActivityRecord root = mInTask.getRootActivity(); if (baseIntent == null)&#123; throw new IllegalArgumentException(); &#125; if (mLaunchSingleInstance || mLaunchSingleTask) &#123; // 如果设置了 SingleInstacne 或 SingleTask if (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent()))&#123; // Task 不符合 throw new IllegalArgumentException(); &#125; if(root != null)&#123; // 已经存在 Task 根 Activity throw new IllegalArgumentException(); &#125; &#125; if (root == null) &#123; // 如果不存在根 Activity，重新设置 launch flags mAddingToTask = true; &#125;else if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; mAddingToTask = false; &#125;else &#123; mAddingToTask = true; &#125; &#125;else &#123; if ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) &amp;&amp; mSourceRecord != null &amp;&amp; mSourceRecord.isFreeform()) &#123; // 如果使用 ResolverActivity 启动或者 noDisplay mAddingToTask = true; &#125; &#125; if(mInTask == null)&#123; if (mSourceRecord == null) &#123; if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; mInTask == null) &#123; // 不存在 Task，并且不存在源 Activity mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK; &#125; &#125;else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123; // 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK; &#125;else if (mLaunchSingleInstance || mLaunchSingleTask) &#123; // 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK; &#125; &#125; &#125; ActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity ActivityStack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172final void startActivityLocked()&#123; if(!newTask) &#123; // 如果从已存在的 Task 中启动 Activity boolean startIt = true; for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; task = mTaskHistory.get(taskNdx); if (task.getTopActivity() == null)&#123; // 如果 task 不存在 Activity continue; &#125; if (task == rTask) &#123; // 找到对应的 task if (!startIt) &#123; // 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动 r.createWindowContainer(); ActivityOptions.abort(options); return; &#125; &#125; else if (task.numFullscreen &gt; 0) &#123; startIt = false; &#125; &#125; &#125; // 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调 if (task == activityTask &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) &#123; mStackSupervisor.mUserLeaving = false; &#125; if (!isHomeOrRecentsStack() || numActivities() &gt; 0) &#123; // 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0 // 处理 动画 if (newTask) &#123; if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123; // 如果设置了重置的标记 resetTaskIfNeededLocked(r, r); doShow = topRunningNonDelayedActivityLocked(null) == r; &#125; else if (options != null &amp;&amp; options.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123; // 需要进行转场动画 doShow = false; &#125; &#125; if (r.mLaunchTaskBehind) &#123; // 如果为 true，那么不开启 window，但要确保 Activity 是可见的 r.setVisibility(true); ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); &#125; else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123; TaskRecord prevTask = r.getTask(); ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked(); if (prev != null) &#123; // 以下两种情况不展示之前的 Activity 预览 if (prev.getTask() != prevTask) &#123; // 之前的 Activity 在不同的 Task prev = null; &#125; else if (prev.nowVisible) &#123; // 现在可见 prev = null; &#125; &#125; // 显示启动 Activity 的 Window r.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity)); &#125; else &#123; // 当前为栈顶 Activity ActivityOptions.abort(options); &#125; &#125; ActivityStack.startActivityLocked 主要是创建 WindowContainer，同时显示 Window ActivityStackSupervisor1234567891011121314boolean resumeFocusedStackTopActivityLocked()&#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; // 存在 targetStack return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; // 恢复聚焦 task mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; else if (r.state == RESUMED) &#123; // 执行应用转场动画 mFocusedStack.executeAppTransition(targetOptions); &#125;&#125; ActivityStack123456789101112131415boolean resumeTopActivityUncheckedLocked() &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // 防止递归 return false; &#125; try &#123; // 设置恢复标记 mStackSupervisor.inResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; // 在恢复过程中，确保必要的暂停逻辑 mStackSupervisor.checkReadyForSleepLocked();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184private boolean resumeTopActivityInnerLocked() &#123; // 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦 final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */); final boolean hasRunningActivity = next != null; final ActivityRecord parent = mActivityContainer.mParentActivity; final boolean isParentNotResumed = parent != null &amp;&amp; parent.state != ActivityState.RESUMED; if (hasRunningActivity &amp;&amp; (isParentNotResumed || !mActivityContainer.isAttachedLocked())) &#123; // 如果父 Activity 不是恢复状态，则不恢复当前 Activity return false; &#125; if (!hasRunningActivity) &#123; // 当前 Task 没有需要恢复的 Activity return resumeTopActivityInNextFocusableStack(prev, options, \"noMoreActivities\"); &#125; if (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123; // 如果 Activity 已经是恢复状态 // 确保已经执行了所有等待的转场 executeAppTransition(options); return false; &#125; if (mService.isSleepingOrShuttingDownLocked() &amp;&amp; mLastPausedActivity == next &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123; // 如果系统处于休眠状态，当前 Activity 处于暂停状态 // 确保转场执行 executeAppTransition(options); return false; &#125; if (!mService.mUserController.hasStartedUserState(next.userId)) &#123; // 如果拥有该 Activity 的用户没有启动 return false; &#125; if (!mStackSupervisor.allPausedActivitiesComplete()) &#123; // 如果存在暂停 Activity 的操作未完成 return false; &#125; boolean lastResumedCanPip = false; final ActivityStack lastFocusedStack = mStackSupervisor.getLastStack(); if (lastFocusedStack != null &amp;&amp; lastFocusedStack != this) &#123; final ActivityRecord lastResumed = lastFocusedStack.mResumedActivity; // 最后一个恢复的 Activity 是否可以 画中画 lastResumedCanPip = lastResumed != null &amp;&amp; lastResumed.checkEnterPictureInPictureState( \"resumeTopActivity\", true /* noThrow */, userLeaving /* beforeStopping */); &#125; // 是否需要可以在上一个 Activity 暂停时进行恢复 final boolean resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != 0 &amp;&amp; !lastResumedCanPip; // 是否暂停了回退的 task boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false); if (mResumedActivity != null) &#123; // 暂停上一个恢复状态的 Activity pausing |= startPausingLocked(userLeaving, false, next, false); &#125; if (pausing &amp;&amp; !resumeWhilePausing) &#123; // 之前的 Activity 已经暂停，但不能进行恢复当前 Activity if (next.app != null &amp;&amp; next.app.thread != null) &#123; // hosting application，一般不执行 // 让当前 Activity 放在 Lru 的顶部，避免早早杀死 mService.updateLruProcessLocked(next.app, true, null); &#125; return true; &#125; else if (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123; // 当前需要恢复的 Activity 已经是恢复状态 // 确保执行转场 executeAppTransition(options); return true; &#125; if (mService.isSleepingLocked() &amp;&amp; mLastNoHistoryActivity != null &amp;&amp; !mLastNoHistoryActivity.finishing) &#123; // 结束因为系统休眠而还没结束的 Activity requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED, null, \"resume-no-history\", false); mLastNoHistoryActivity = null; &#125; if (prev != null &amp;&amp; prev != next) &#123; if (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev) &amp;&amp; next != null &amp;&amp; !next.nowVisible) &#123; mStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev); &#125; else &#123; // 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity if (prev.finishing) &#123; prev.setVisibility(false); &#125; else &#123; &#125; &#125; &#125; // Activity 转场处理 ActivityStack lastStack = mStackSupervisor.getLastStack(); if (next.app != null &amp;&amp; next.app.thread != null) &#123; // 上一个 Activity 是否为透明 final boolean lastActivityTranslucent = lastStack != null &amp;&amp; (!lastStack.mFullscreen || (lastStack.mLastPausedActivity != null &amp;&amp; !lastStack.mLastPausedActivity.fullscreen)); if (!next.visible || next.stopped || lastActivityTranslucent) &#123; // 前一个 Activity 为透明，并且当前 Activity 还没显示 // 设置为显示状态 next.setVisibility(true); &#125; // 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向 boolean notUpdated = true; if (mStackSupervisor.isFocusedStack(this)) &#123; final Configuration config = mWindowManager.updateOrientationFromAppTokens( mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId), next.mayFreezeScreenLocked(next.app) ? next.appToken : null, mDisplayId); if (config != null) &#123; next.frozenBeforeDestroy = true; &#125; notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next, false /* deferResume */, mDisplayId); &#125; if (notUpdated) &#123; // 配置发生更新无法保持已经存在的 Activity 实例 // 重新获取需要恢复的 Activity ActivityRecord nextNext = topRunningActivityLocked(); // 确保 Activity 仍然保持在栈顶，同时安排另外一次执行 if (nextNext != next) &#123; mStackSupervisor.scheduleResumeTopActivities(); &#125; if (!next.visible || next.stopped) &#123; next.setVisibility(true); &#125; next.completeResumeLocked(); return true; &#125; try &#123; // 传递所有等待的结果 if (next.newIntents != null)&#123; next.app.thread.scheduleNewIntent( next.newIntents, next.appToken, false /* andPause */); &#125; next.notifyAppResumed(next.stopped); // 准备恢复 Activity next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState, mService.isNextTransitionForward(), resumeAnimOptions); &#125; catch (Exception e)&#123; // 发生异常，重新启动 Activity mStackSupervisor.startSpecificActivityLocked(next, true, false); return true; &#125; try &#123; next.completeResumeLocked(); &#125; catch(Exception e)&#123; // 发生异常，结束 Activity requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null, \"resume-exception\", true); return true; &#125; &#125; else &#123; // 需要启动 Activity mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; return true;&#125; 如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程： ActivityStackSupervisor12345678910111213141516171819void startSpecificActivityLocked() &#123; // 获取应用进程信息 ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); if (app != null &amp;&amp; app.thread != null) &#123; // 如果进程已经启动 try &#123; realStartActivityLocked(r, app, andResume, checkConfig); return; &#125;catch (RemoteException e)&#123; &#125; &#125; // 启动应用进程 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true);&#125; 123456789101112131415161718192021222324final boolean realStartActivityLocked() &#123; // 冻结屏幕 r.startFreezingScreenLocked(app, 0); if (checkConfig) &#123; // 根据新的 Activity 顺序重新评估屏幕的方向 &#125; int idx = app.activities.indexOf(r); if (idx &lt; 0) &#123; // 将 Activity 添加到应用进程中 app.activities.add(r); &#125; try &#123; app.thread.scheduleLaunchActivity(); &#125;catch(RemoteException e)&#123; // 发生异常，结束 Activity stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null, \"2nd-crash\", false); return false; &#125; return true;&#125; 启动流程最后还是回到了 ApplicationThread ApplicationThread1234public final void scheduleLaunchActivity() &#123; // 通过 Handler 发送 LAUNCH_ACTIVITY sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 我们单独把 LAUNCH_ACTIVITY 的处理拿出来： 1234final ActivityClientRecord r = (ActivityClientRecord) msg.obj;r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo);handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); ActivityThread1234567891011private void handleLaunchActivity() &#123; // 执行启动 Activity Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; // resume activity handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); &#125; else &#123; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private performLaunchActivity() &#123; // Activity 信息初始化 // 创建 context ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); // 构建 Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); &#125;catch(Exception e)&#123; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if(activity != null)&#123; activity.attach(); // 通过 Instrumentation 执行 Activity onCreate if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125;else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!r.activity.mFinished) &#123; // Activity onStart activity.performStart(); &#125; // 通过 Instrumentation 执行 Activity onRestoreInstanceState if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; // 通过 Instrumentation 执行 Activity onPostCreeate if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125;else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; &#125; &#125; return activity; &#125; 12345678910111213141516171819final void handleResumeActivity() &#123; r = performResumeActivity(); if(r != null) &#123; final Activity a = r.activity; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; // window wm.addView(decor, l); &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718public final ActivityClientRecord performResumeActivity() &#123; if (r != null &amp;&amp; !r.activity.mFinished) &#123; try &#123; // 处理等待的 Intent if (r.pendingIntents != null) &#123; deliverNewIntents(r, r.pendingIntents); r.pendingIntents = null; &#125; // 处理等待的 result if (r.pendingResults != null) &#123; deliverResults(r, r.pendingResults); r.pendingResults = null; &#125; // 执行 resume r.activity.performResume(); &#125; &#125;&#125; Instrumentation123public Activity newActivity()&#123; return (Activity)cl.loadClass(className).newInstance();&#125; 12345private void callActivityOnCreate()&#123; prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity);&#125; Activity1234567final void performCreate() &#123; restoreHasCurrentPermissionRequest(icicle); // 调用 onCreate onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon();&#125; 12345final void performStart() &#123; mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); mInstrumentation.callActivityOnStart(this); mActivityTransitionState.enterReady(this);&#125; 12345final void performResume() &#123; // 执行 restart performRestart(); mInstrumentation.callActivityOnResume(this);&#125; 12345678final void performRestart() &#123; if (mStopped) &#123; mStopped = false; mInstrumentation.callActivityOnRestart(this); // 执行 start performStart(); &#125;&#125; Instrumentation123public void callActivityOnStart() &#123; activity.onStart();&#125; 1234public void callActivityOnResume() &#123; activity.mResumed = true; activity.onResume();&#125; 123public void callActivityOnRestart() &#123; activity.onRestart();&#125; 总结简单总结下 Activity 的启动流程： 从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信 ActivityManagerService 用于管理所有的 Activity 活动 当接受到启动 Activity 的调用时，使用 resolveActivity ，查询系统中符合要求的 Activity 创建使用合适的 ActivityStack 和 launch flags 来启动 Activity 如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity 如果不存在应用进程，先创建应用进程 最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行 使用 Instrumentation 去通过反射构建 Activity 实例 使用 Handler 机制调用 Activity 的生命周期 下面的图例来自博客： 时序图","tags":[]},{"title":"Android消息机制-Handler","date":"2018-03-23T12:29:21.000Z","path":"2018/03/23/Android消息机制-Handler/","text":"参考Android消息机制1-Handler(Java层) Android消息机制2-Handler(Native层) Android应用程序消息处理机制（Looper、Handler）分析 管道(Unix)) Epoll 文件描述符 Handler 机制主要由四个部分组成： Looper MessageQueue Message Handler 典型用法123456789101112131415class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; Looper不断循环执行 Looper.loop，按分发机制将消息分发给目标处理者 1234567private static void prepare(boolean quitAllowed) &#123; if(sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; // 构建 Looper 存储到 ThreadLocal sThreadLocal.set(new Looper(quitAllowed));&#125; sThreadLocal 是一个 ThreadLocal 类型的静态变量 ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域 12345private Looper(boolean quitAllowed) &#123; // Looper 中创建 MessageQueue mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // 获取下一条 Message，可能会阻塞 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; //省略 final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try &#123; // 分发 Message msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time = end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, \"Dispatch took \" + time + \"ms on \" + Thread.currentThread().getName() + \", h=\" + msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what); &#125; &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; // 释放 Message msg.recycleUnchecked(); &#125; &#125; 12345678// Looper.quit 最终调用的都是 MessageQueue.quitpublic void quit() &#123; mQueue.quit(false); // 移除消息&#125;public void quitSafely() &#123; mQueue.quit(true); // 安全移除消息&#125; MessageQueue 在构造方法中，会调用 native 方法 nativeInit 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper 1234567891011121314151617181920212223242526272829303132// frameworks/base/libsLooper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mResponseIndex(0) &#123; // 管道机制 int wakeFds[2]; int result = pipe(wakeFds); ...... mWakeReadPipeFd = wakeFds[0]; mWakeWritePipeFd = wakeFds[1]; ...... #ifdef LOOPER_USES_EPOLL // 分配新的 epoll 实例同时注册唤醒管道 mEpollFd = epoll_create(EPOLL_SIZE_HINT); ...... struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union // 观察 EPOLLIN 事件 eventItem.events = EPOLLIN; eventItem.data.fd = mWakeReadPipeFd; result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem); ...... #else ...... #endif ...... &#125; 管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。 epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。 pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。 以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。 Handler123456789101112131415161718192021public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; // 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏 Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; // 默认使用当前线程的 Looper mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; // 是否为异步处理 mAsynchronous = async; &#125; 在 Looper.loop 中，当存在 Message 需要处理时，会调用 dispatchMessage 来进行分发： 123456789101112131415public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; // 先调用 callback handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; // 接着检查通过构造方法传进来的 Callback if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; // 最后调用 handleMessage handleMessage(msg); &#125; &#125; 通过 Handler 发送消息： 最终所有的方法都会调用到 MessageQueue.enqueueMessage MessageQueue 消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理 12345MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; // used by native code mPtr = nativeInit(); &#125; MessageQueue 的初始化工作主要由 native 方法来执行 123456789101112//frameworks/base/core/jni/android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) &#123; // 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层 NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (! nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return; &#125; // 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量 android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue); &#125; nativeInit 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 mPtr，关联了 NativeMessageQueue 和 MessageQueue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104Message next() &#123; // messsage loop has already quit final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回 // ptr 是在 JNI 层创建的 NativeMessageQueue nativePollOnce(ptr, nextPollTimeoutMillis); // 当前 nativePollOnce 返回后，查看消息队列中是否存在消息 synchronized (this) &#123; // 尝试检索下一条消息，如果找到则返回 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // 找到下一条异步消息或者没有消息了，则退出循环 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 下一个消息还没准备好，重新设置唤醒超时时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 获取一条消息 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); // 标记当前消息已使用 msg.markInUse(); return msg; &#125; &#125; else &#123; // 当前还没有消息，设置为 -1，无限等待中 nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // queue is empty or if the first message // get pending idle handler count if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // 没有 idle handlers 需要运行，循环继续等待 mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; //不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入 nextPollTimeoutMillis = 0; &#125; &#125; 在 next 方法中，nativePollOnce 是阻塞操作，其中 nextPollTimeoutMillis 代表下一个消息到来之前，还需要等待的时长；nextPollTimeoutMillis == -1 表示当前没有更多消息。nativePollOnce 调用结束后，从 mMessages 中提取一个消息 当处于空闲时，执行 IdleHandler 中的回调方法。 12345678// frameworks/base/core/jni/android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jint ptr, jint timeoutMillis) &#123; // 通过前面设置的 mPrt 获取 NativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); // 调用 NativeMessageQueue.pollOnce 进行轮询 nativeMessageQueue-&gt;pollOnce(timeoutMillis); &#125; 1234void NativeMessageQueue::pollOnce(int timeoutMillis) &#123; // 将调用转发给了 JNI 层的 Looper mLooper-&gt;pollOnce(timeoutMillis); &#125; pollOnce 会调用 pollnner 来进一步操作，如果 pollnner 返回值不等于 0，则返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// frameworks/base/libs/utils/Looper.cppint Looper::pollInner(int timeoutMillis) &#123; ...... int result = ALOOPER_POLL_WAKE; ...... #ifdef LOOPER_USES_EPOLL struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis // 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件 // 如果检查成功或者超时，则结束等待 // 处于 Idle 状态 int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); bool acquiredLock = false; #else ...... #endif // eventCount &lt; 0 可能出错了 if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; LOGW(\"Poll failed with an unexpected error, errno=%d\", errno); result = ALOOPER_POLL_ERROR; goto Done; &#125; // eventCount == 0 超时 if (eventCount == 0) &#123; ...... result = ALOOPER_POLL_TIMEOUT; goto Done; &#125; ...... #ifdef LOOPER_USES_EPOLL // eventCount &gt; 0 存在事件 for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeReadPipeFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; // Looper 中使用 epoll 监听的 EPOLLIN 事件 awoken(); &#125; else &#123; LOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents); &#125; &#125; else &#123; ...... &#125; &#125; if (acquiredLock) &#123; mLock.unlock(); &#125; Done: ; #else ...... #endif ...... return result; &#125; 123456789void Looper::awoken() &#123; ...... char buffer[16]; ssize_t nRead; do &#123; nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer)); &#125; while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer)); &#125; 总结上面的代码，Looper 通过 loop 调用 MessageQueue 的 next，next 中又会调用到 native 方法 nativePollOnce，在这个方法中，会调用到 NativeMessageQueue 的 pollInner，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 awoken，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 不存在头部消息或立即执行或执行时机快于头部消息 // 将处理的消息作为新的头部消息 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // 将处理的消息插入到队列的尾部 // 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; MessageQueue 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。 如果当前线程处于空闲等待状态，那么还需要调用 nativeWake 来唤醒： 123456// frameworks/base/core/jni/android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj, jint ptr) &#123; // ptr 获取 NativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); return nativeMessageQueue-&gt;wake(); &#125; 这里将唤醒请求转发到 Looper wake： 123456789101112// frameworks/base/libs/utils/Looper.cppvoid Looper::wake() &#123; ...... ssize_t nWrite; do &#123; // 先管道中写入 \"W nWrite = write(mWakeWritePipeFd, \"W\", 1); &#125; while (nWrite == -1 &amp;&amp; errno == EINTR); ....... &#125; 往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 polllnner 中调用 epoll_wait 进入 12345678910111213141516171819202122232425262728293031323334void removeMessages(Handler h, int what, Object object) &#123; if (h == null) &#123; return; &#125; synchronized (this) &#123; Message p = mMessages; // 从队列头部开始，移除连续的所有符合条件的消息 while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what &amp;&amp; (object == null || p.obj == object)) &#123; Message n = p.next; mMessages = n; // 找到对应的消息，释放它 p.recycleUnchecked(); p = n; &#125; // 从新的队列头部开始，移除全部符合条件的消息 while (p != null) &#123; Message n = p.next; if (n != null) &#123; if (n.target == h &amp;&amp; n.what == what &amp;&amp; (object == null || n.obj == object)) &#123; Message nn = n.next; n.recycleUnchecked(); p.next = nn; continue; &#125; &#125; p = n; &#125; &#125; &#125; postSyncBarrier 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 removeSyncBarrier 当 MessageQueue 退出时，需要 dispose： 12345678910// Disposes of the underlying message queue. // Must only be called on the looper thread or the finalizer.private void dispose() &#123; if (mPtr != 0) &#123; // native 方法 nativeDestroy(mPtr); // mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量 mPtr = 0; &#125; &#125; nativeDestroy 最终会调用 RefBase 的 decStrong： 12345678910111213void RefBase::decStrong(const void* id) const&#123; weakref_impl* const refs = mRefs; refs-&gt;removeStrongRef(id); //移除强引用 const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong); if (c == 1) &#123; refs-&gt;mBase-&gt;onLastStrongRef(id); if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123; delete this; &#125; &#125; refs-&gt;decWeak(id); // 移除弱引用&#125; Message1234567891011121314151617181920212223void recycleUnchecked() &#123; // 标记为使用状态，清除其他状态 flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; // 消息缓存 if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; 1234567891011121314public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; // 从缓存中获取 Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; 总结 Java 层： Handler 通过 sendMessage，将 Message 通过 MessageQueue.enqueueMessage 添加到队列中 Looper 通过 loop 提取需要执行的 Message，并交与 Message.target 的 Handler 进行 dispatchMessage 分发 将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler JNI 层： 线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态 通过 epoll 机制监听 EPOLLIN 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程 消息分发的优先级： Message.callback.run() Handler.mCallback.handleMessage() Handler.handleMessage() EPOLL：Linux 内核的可扩展 I/O 事件通知机制 PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入 文件描述符(File descriptor)：用于表述指向文件的引用的抽象化概念","tags":[]}]