[{"title":"Activity启动流程(基于Android26)","date":"2018-03-27T01:54:17.000Z","path":"2018/03/27/Activity启动流程-基于Android26/","text":"基于 Android 26，分析 Android Activity 启动流程 参考startActivity启动过程分析 源码源码篇幅可能过长，所以会省略一下不必要的代码和注释 Activity12345678910111213@Override public void startActivity() &#123; this.startActivity(intent, null); &#125;@Override public void startActivity() &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; startActivityForResult(intent, -1); &#125; &#125; 最终都会调用到 startActivityForResult： 1234567891011121314public void startActivityForResult() &#123; if (mParent == null) &#123; // 转场动画的处理 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(); if (ar != null) &#123; mMainThread.sendActivityResult(); &#125; if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; &#125; else &#123; // 如果存在 Parent Activity 则交由它处理 &#125; &#125; 可以知道 Activity 启动委托给了 Instrumentation 进行实现 Instrumentation1234567891011121314151617181920212223242526272829303132333435363738public ActivityResult execStartActivity() &#123; // 由 ActivityThread.getApplicationThread 提供的 ApplicationThread IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) &#123; // true 表示这个监视器被用于使用 onStartActivity 拦截所有 Activity 启动 result = am.onStartActivity(intent); &#125; if (result != null) &#123; am.mHits++; return result; &#125; else if (am.match(who, null, intent)) &#123; // match 使用 IntentFilter 和 类名 进行匹配 am.mHits++; if (am.isBlocking()) &#123; // 当前监视器阻止 Activity 启动 return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; // 委托为 ActivityManagerService(AMS) 去处理 int result = ActivityManager.getService().startActivity(); // 检查 AMS 的处理结果 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null; &#125; 可以通过最后的调用委托给了ActivityManager.getService，实际上就是 ActivityManagerService(AMS) 的 Binder 代理类实现 相对于之前的版本，比如 Android 23，现在已经没有了 ActivityManagerProxy 和 ActivityManagerNative，将直接与 system_server 进程上的 AMS 进行 IPC 12345678910111213public static IActivityManager getService() &#123; return IActivityManagerSingleton.get(); &#125;private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; ActivityManagerService123456789@Override public final int startActivity() &#123; return startActivityAsUser(); &#125;@Override public final int startActivityAsUser() &#123; return mActivityStarter.startActivityMayWait(); &#125; 这里将启动请求又委托给了 ActivityStarter ActivityStarter1234567891011final int startActivityMayWait() &#123; // Intent 的响应 ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId); // Intent 的 Activity 信息 ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); final ActivityRecord[] outRecord = new ActivityRecord[1]; // 调用 startActivityLocked int res = startActivityLocked(outRecord); return res; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116private int startActivity() &#123; // 源 Activity 记录，即在哪个 Activity 进行 startActivity ActivityRecord sourceRecord = null; // 如果使用 startActivityForResult，result 返回的 Activity 称为结果 Activity ActivityRecord resultRecord = null; if (resultTo != null) &#123; // 获取 Activity Stack 中已经存在的源 Activity 记录 sourceRecord = mSupervisor.isInAnyStackLocked(resultTo); if (sourceRecord != null) &#123; if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; // requestCode &gt;= 0，源 Activity 同时为 结果 Activity resultRecord = sourceRecord; &#125; &#125; &#125; final int launchFlags = intent.getFlags(); if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123; // 使用 FLAG_ACTIVITY_FORWARD_RESULT，可以将返回结果的源 Activity 转移为当前正在新启动的 Activity // 比如：A -&gt; B,B - C 使用了 FLAG_ACTIVITY_FORWARD_RESULT,那么 C 的 setResult 会返回给 A if (requestCode &gt;= 0) &#123; // 不允许有 requestCode ActivityOptions.abort(options); return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT; &#125; // 将源 Activity 的结果 Activity 设置为新 Activity 的结果 Activity resultRecord = sourceRecord.resultTo; if (resultRecord != null &amp;&amp; !resultRecord.isInStackLocked()) &#123; resultRecord = null; &#125; // requestCode 处理 resultWho = sourceRecord.resultWho; requestCode = sourceRecord.requestCode; sourceRecord.resultTo = null; if (resultRecord != null) &#123; // 删除源 Activity 记录 resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode); &#125; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123; // component 找不到 err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123; // ActivityInfo 找不到 err = ActivityManager.START_CLASS_NOT_FOUND; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null &amp;&amp; sourceRecord.getTask().voiceSession != null) &#123; // 语音启动 Activity，检查是否符合 &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) &#123; // 启动语音会话 &#125; final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack(); if (err != START_SUCCESS) &#123; // 启动 Activity 失败 if (resultRecord != null) &#123; // 发送取消通知 resultStack.sendActivityResultLocked( -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return err; &#125; // 进行一些权限检查，判断是否终止 if (abort) &#123; // 如果需要终止 Activity if (resultRecord != null) &#123; resultStack.sendActivityResultLocked(); &#125; // 返回启动成功，实际终止 ActivityOptions.abort(options); return START_SUCCESS; &#125; // 如果权限检查是否在启动 Activity 之前，那么先启动权限检查的 Intent // 处理 ephemeral app // 构造一个 ActivityRecord ActivityRecord r = new ActivityRecord(); final ActivityStack stack = mSupervisor.mFocusedStack; if (voiceSession == null &amp;&amp; (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123; // 前台 stack 还没 resume 状态的 Activity，检查是否允许 app 切换 if (!mService.checkAppSwitchAllowedLocked() &#123; PendingActivityLaunch pal = new PendingActivityLaunch(); mPendingActivityLaunches.add(pal); ActivityOptions.abort(options); // 切换 app 失败 return ActivityManager.START_SWITCHES_CANCELED; &#125; &#125; if (mService.mDidAppSwitch) &#123; // 从上次禁止 app 切换以来，这是第二次，允许 app 切换，并将切换时间设置为 0 mService.mAppSwitchesAllowedTime = 0; &#125; else &#123; mService.mDidAppSwitch = true; &#125; // 执行因为不允许 app 切换，而加到等待启动的 Activity doPendingActivityLaunchesLocked(false); return startActivity(); &#125; 12345678910111213141516171819private int startActivity() &#123; int result = START_CANCELED; try &#123; mService.mWindowManager.deferSurfaceLayout(); // 下一步流程 result = startActivityUnchecked(); &#125; finally &#123; // 如果启动 Activity 没有成功， 从 task 中移除 Activity if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; mStartActivity.getTask() != null) &#123; mStartActivity.getTask().removeActivity(mStartActivity); &#125; mService.mWindowManager.continueSurfaceLayout(); &#125; postStartActivityProcessing(); return result; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141private int startActivityUnchecked() &#123; // 设置一些初始化状态 setInitialState(); // 计算 launch flags computeLaunchingTaskFlags(); // 计算源 Task，源 Task 是否存在等 computeSourceStack(); // 获取是否存在可以复用的 Activity，根据 flags 和 launchMode ActivityRecord reusedActivity = getReusableIntentActivity(); if (reusedActivity != null) &#123; // 存在可复用的 Activity，复用它 // 可能需要清除 Task 中其他 Activity，并将启动的 Activity 前置 &#125; if (mStartActivity.packageName == null) &#123; return START_CLASS_NOT_FOUND; &#125; // 如果启动的 Activity 与当前 Task 顶部的 Activity 相同，判断是否需要继续启动新的 Activity final boolean dontStart = top != null &amp;&amp; mStartActivity.resultTo == null &amp;&amp; top.realActivity.equals(mStartActivity.realActivity) &amp;&amp; top.userId == mStartActivity.userId &amp;&amp; top.app != null &amp;&amp; top.app.thread != null &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop || mLaunchSingleTask); if(dontStart)&#123; // 传递一个新的 Intent 到 onNewIntent top.deliverNewIntentLocked(); return START_DELIVERED_TO_TOP; &#125; // 获取 mTargetStack if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; newTask = true; // 需要创建新的 Task result = setTaskFromReuseOrCreateNewTask(); &#125; else if (mSourceRecord != null) &#123; // 从源 Activity 中获取 Task result = setTaskFromSourceRecord(); &#125; else if (mInTask != null) &#123; // 从 InTask 中获取 Task result = setTaskFromInTask(); &#125; else &#123; // 可能创建新的 Task 或使用当前 Task，一般不会发生 setTaskToCurrentTopOrCreateNewTask(); &#125; // 使用 mTargetStack 启动 Activity mTargetStack.startActivityLocked(); if (mDoResume) &#123; if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; // 目标 Task 不可聚焦 ，或者源 Task 栈顶 Activity 总是在其他 Activity 之上，并且不为源 Activity // 那么我们不恢复目标 Task，只需要确保它可见即可 mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); &#125; &#125; else &#123; if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123; // 如果目标 Task 之前不是可聚焦，但是现在为可聚焦，那么移动到前台 mTargetStack.moveToFront(\"startActivityUnchecked\"); &#125; // 恢复目标 Task mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); &#125; else &#123; // 如果不需要恢复，那么加到\"最近活动\"中 mTargetStack.addRecentActivityLocked(mStartActivity); &#125; return START_SUCCESS;&#125;private void setInitialState()&#123; // 获取 DisplayId mSourceDisplayId = getSourceDisplayId(); // 获取用于启动 Activity 的范围，Rect mLaunchBounds = getOerrideBounds(); // launchMode mLaunchSingleTop = r.launchmode == LAUNCH_SINGLE_TOP; mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE; mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK; // Intent flags 的处理，如果和 Manifest 存在冲突，以 Manifest 为主 // 如果 requestCode &gt;= 0，同时启动的 Activity 位于新的 Task，发送取消的结果给源 Activity sendNewTaskResultRequestIfNeeded();&#125;private void computeLaunchingTaskFlags()&#123; if (mSourceRecord == null &amp;&amp; mInTask != null &amp;&amp; mInTask.getStack() != null)&#123; // 如果不存在源 Activity final Intent baseIntent = mInTask.getBaseIntent(); final ActivityRecord root = mInTask.getRootActivity(); if (baseIntent == null)&#123; throw new IllegalArgumentException(); &#125; if (mLaunchSingleInstance || mLaunchSingleTask) &#123; // 如果设置了 SingleInstacne 或 SingleTask if (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent()))&#123; // Task 不符合 throw new IllegalArgumentException(); &#125; if(root != null)&#123; // 已经存在 Task 根 Activity throw new IllegalArgumentException(); &#125; &#125; if (root == null) &#123; // 如果不存在根 Activity，重新设置 launch flags mAddingToTask = true; &#125;else if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; mAddingToTask = false; &#125;else &#123; mAddingToTask = true; &#125; &#125;else &#123; if ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) &amp;&amp; mSourceRecord != null &amp;&amp; mSourceRecord.isFreeform()) &#123; // 如果使用 ResolverActivity 启动或者 noDisplay mAddingToTask = true; &#125; &#125; if(mInTask == null)&#123; if (mSourceRecord == null) &#123; if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; mInTask == null) &#123; // 不存在 Task，并且不存在源 Activity mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK; &#125; &#125;else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123; // 如果源 Activity 的 launchMode 是 SingleInstance，要设置 NEW_TASK flag mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK; &#125;else if (mLaunchSingleInstance || mLaunchSingleTask) &#123; // 如果启动 Activity 的 launchMode 是 SingleInstance 或 SingleTask，需要设置 NEW_TASK flag mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK; &#125; &#125; &#125; ActivityStarter 主要的作用是，计算 launch flags，创建或者复用合适的 Task，即 ActivityStack，从而启动 Activity ActivityStack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172final void startActivityLocked()&#123; if(!newTask) &#123; // 如果从已存在的 Task 中启动 Activity boolean startIt = true; for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; task = mTaskHistory.get(taskNdx); if (task.getTopActivity() == null)&#123; // 如果 task 不存在 Activity continue; &#125; if (task == rTask) &#123; // 找到对应的 task if (!startIt) &#123; // 如果当前对于用户还不可见，那么只是添加它，而不启动它，它将在用户导航回来时启动 r.createWindowContainer(); ActivityOptions.abort(options); return; &#125; &#125; else if (task.numFullscreen &gt; 0) &#123; startIt = false; &#125; &#125; &#125; // 如果当前 task 为活动 task，那么不需要传递 onuserLeaving 回调 if (task == activityTask &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) &#123; mStackSupervisor.mUserLeaving = false; &#125; if (!isHomeOrRecentsStack() || numActivities() &gt; 0) &#123; // 如果当前不是 Home 或 Recent Task,或者活动 Activity 数量大于 0 // 处理 动画 if (newTask) &#123; if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123; // 如果设置了重置的标记 resetTaskIfNeededLocked(r, r); doShow = topRunningNonDelayedActivityLocked(null) == r; &#125; else if (options != null &amp;&amp; options.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123; // 需要进行转场动画 doShow = false; &#125; &#125; if (r.mLaunchTaskBehind) &#123; // 如果为 true，那么不开启 window，但要确保 Activity 是可见的 r.setVisibility(true); ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); &#125; else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123; TaskRecord prevTask = r.getTask(); ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked(); if (prev != null) &#123; // 以下两种情况不展示之前的 Activity 预览 if (prev.getTask() != prevTask) &#123; // 之前的 Activity 在不同的 Task prev = null; &#125; else if (prev.nowVisible) &#123; // 现在可见 prev = null; &#125; &#125; // 显示启动 Activity 的 Window r.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity)); &#125; else &#123; // 当前为栈顶 Activity ActivityOptions.abort(options); &#125; &#125; ActivityStack.startActivityLocked 主要是创建 WindowContainer，同时显示 Window ActivityStackSupervisor1234567891011121314boolean resumeFocusedStackTopActivityLocked()&#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; // 存在 targetStack return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; // 恢复聚焦 task mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; else if (r.state == RESUMED) &#123; // 执行应用转场动画 mFocusedStack.executeAppTransition(targetOptions); &#125;&#125; ActivityStack123456789101112131415boolean resumeTopActivityUncheckedLocked() &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // 防止递归 return false; &#125; try &#123; // 设置恢复标记 mStackSupervisor.inResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; // 在恢复过程中，确保必要的暂停逻辑 mStackSupervisor.checkReadyForSleepLocked();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184private boolean resumeTopActivityInnerLocked() &#123; // 寻找需要恢复的栈顶 Activity，它必须是未结束并且聚焦 final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */); final boolean hasRunningActivity = next != null; final ActivityRecord parent = mActivityContainer.mParentActivity; final boolean isParentNotResumed = parent != null &amp;&amp; parent.state != ActivityState.RESUMED; if (hasRunningActivity &amp;&amp; (isParentNotResumed || !mActivityContainer.isAttachedLocked())) &#123; // 如果父 Activity 不是恢复状态，则不恢复当前 Activity return false; &#125; if (!hasRunningActivity) &#123; // 当前 Task 没有需要恢复的 Activity return resumeTopActivityInNextFocusableStack(prev, options, \"noMoreActivities\"); &#125; if (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123; // 如果 Activity 已经是恢复状态 // 确保已经执行了所有等待的转场 executeAppTransition(options); return false; &#125; if (mService.isSleepingOrShuttingDownLocked() &amp;&amp; mLastPausedActivity == next &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123; // 如果系统处于休眠状态，当前 Activity 处于暂停状态 // 确保转场执行 executeAppTransition(options); return false; &#125; if (!mService.mUserController.hasStartedUserState(next.userId)) &#123; // 如果拥有该 Activity 的用户没有启动 return false; &#125; if (!mStackSupervisor.allPausedActivitiesComplete()) &#123; // 如果存在暂停 Activity 的操作未完成 return false; &#125; boolean lastResumedCanPip = false; final ActivityStack lastFocusedStack = mStackSupervisor.getLastStack(); if (lastFocusedStack != null &amp;&amp; lastFocusedStack != this) &#123; final ActivityRecord lastResumed = lastFocusedStack.mResumedActivity; // 最后一个恢复的 Activity 是否可以 画中画 lastResumedCanPip = lastResumed != null &amp;&amp; lastResumed.checkEnterPictureInPictureState( \"resumeTopActivity\", true /* noThrow */, userLeaving /* beforeStopping */); &#125; // 是否需要可以在上一个 Activity 暂停时进行恢复 final boolean resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != 0 &amp;&amp; !lastResumedCanPip; // 是否暂停了回退的 task boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false); if (mResumedActivity != null) &#123; // 暂停上一个恢复状态的 Activity pausing |= startPausingLocked(userLeaving, false, next, false); &#125; if (pausing &amp;&amp; !resumeWhilePausing) &#123; // 之前的 Activity 已经暂停，但不能进行恢复当前 Activity if (next.app != null &amp;&amp; next.app.thread != null) &#123; // hosting application，一般不执行 // 让当前 Activity 放在 Lru 的顶部，避免早早杀死 mService.updateLruProcessLocked(next.app, true, null); &#125; return true; &#125; else if (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123; // 当前需要恢复的 Activity 已经是恢复状态 // 确保执行转场 executeAppTransition(options); return true; &#125; if (mService.isSleepingLocked() &amp;&amp; mLastNoHistoryActivity != null &amp;&amp; !mLastNoHistoryActivity.finishing) &#123; // 结束因为系统休眠而还没结束的 Activity requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED, null, \"resume-no-history\", false); mLastNoHistoryActivity = null; &#125; if (prev != null &amp;&amp; prev != next) &#123; if (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev) &amp;&amp; next != null &amp;&amp; !next.nowVisible) &#123; mStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev); &#125; else &#123; // 如果当前需要恢复的 Activity 已经可见，所有隐藏上一个 Activity if (prev.finishing) &#123; prev.setVisibility(false); &#125; else &#123; &#125; &#125; &#125; // Activity 转场处理 ActivityStack lastStack = mStackSupervisor.getLastStack(); if (next.app != null &amp;&amp; next.app.thread != null) &#123; // 上一个 Activity 是否为透明 final boolean lastActivityTranslucent = lastStack != null &amp;&amp; (!lastStack.mFullscreen || (lastStack.mLastPausedActivity != null &amp;&amp; !lastStack.mLastPausedActivity.fullscreen)); if (!next.visible || next.stopped || lastActivityTranslucent) &#123; // 前一个 Activity 为透明，并且当前 Activity 还没显示 // 设置为显示状态 next.setVisibility(true); &#125; // 让窗口管理器重新基于新的 Activity 顺序评估屏幕的方向 boolean notUpdated = true; if (mStackSupervisor.isFocusedStack(this)) &#123; final Configuration config = mWindowManager.updateOrientationFromAppTokens( mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId), next.mayFreezeScreenLocked(next.app) ? next.appToken : null, mDisplayId); if (config != null) &#123; next.frozenBeforeDestroy = true; &#125; notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next, false /* deferResume */, mDisplayId); &#125; if (notUpdated) &#123; // 配置发生更新无法保持已经存在的 Activity 实例 // 重新获取需要恢复的 Activity ActivityRecord nextNext = topRunningActivityLocked(); // 确保 Activity 仍然保持在栈顶，同时安排另外一次执行 if (nextNext != next) &#123; mStackSupervisor.scheduleResumeTopActivities(); &#125; if (!next.visible || next.stopped) &#123; next.setVisibility(true); &#125; next.completeResumeLocked(); return true; &#125; try &#123; // 传递所有等待的结果 if (next.newIntents != null)&#123; next.app.thread.scheduleNewIntent( next.newIntents, next.appToken, false /* andPause */); &#125; next.notifyAppResumed(next.stopped); // 准备恢复 Activity next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState, mService.isNextTransitionForward(), resumeAnimOptions); &#125; catch (Exception e)&#123; // 发生异常，重新启动 Activity mStackSupervisor.startSpecificActivityLocked(next, true, false); return true; &#125; try &#123; next.completeResumeLocked(); &#125; catch(Exception e)&#123; // 发生异常，结束 Activity requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null, \"resume-exception\", true); return true; &#125; &#125; else &#123; // 需要启动 Activity mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; return true;&#125; 如果可以不需要重新启动 Activity，则直接恢复 Activity 即可，否则进行重新启动流程： ActivityStackSupervisor12345678910111213141516171819void startSpecificActivityLocked() &#123; // 获取应用进程信息 ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); if (app != null &amp;&amp; app.thread != null) &#123; // 如果进程已经启动 try &#123; realStartActivityLocked(r, app, andResume, checkConfig); return; &#125;catch (RemoteException e)&#123; &#125; &#125; // 启动应用进程 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true);&#125; 123456789101112131415161718192021222324final boolean realStartActivityLocked() &#123; // 冻结屏幕 r.startFreezingScreenLocked(app, 0); if (checkConfig) &#123; // 根据新的 Activity 顺序重新评估屏幕的方向 &#125; int idx = app.activities.indexOf(r); if (idx &lt; 0) &#123; // 将 Activity 添加到应用进程中 app.activities.add(r); &#125; try &#123; app.thread.scheduleLaunchActivity(); &#125;catch(RemoteException e)&#123; // 发生异常，结束 Activity stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null, \"2nd-crash\", false); return false; &#125; return true;&#125; 启动流程最后还是回到了 ApplicationThread ApplicationThread1234public final void scheduleLaunchActivity() &#123; // 通过 Handler 发送 LAUNCH_ACTIVITY sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 我们单独把 LAUNCH_ACTIVITY 的处理拿出来： 1234final ActivityClientRecord r = (ActivityClientRecord) msg.obj;r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo);handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); ActivityThread1234567891011private void handleLaunchActivity() &#123; // 执行启动 Activity Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; // resume activity handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); &#125; else &#123; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private performLaunchActivity() &#123; // Activity 信息初始化 // 创建 context ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); // 构建 Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); &#125;catch(Exception e)&#123; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if(activity != null)&#123; activity.attach(); // 通过 Instrumentation 执行 Activity onCreate if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125;else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!r.activity.mFinished) &#123; // Activity onStart activity.performStart(); &#125; // 通过 Instrumentation 执行 Activity onRestoreInstanceState if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; // 通过 Instrumentation 执行 Activity onPostCreeate if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125;else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; &#125; &#125; return activity; &#125; 12345678910111213141516171819final void handleResumeActivity() &#123; r = performResumeActivity(); if(r != null) &#123; final Activity a = r.activity; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; // window wm.addView(decor, l); &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718public final ActivityClientRecord performResumeActivity() &#123; if (r != null &amp;&amp; !r.activity.mFinished) &#123; try &#123; // 处理等待的 Intent if (r.pendingIntents != null) &#123; deliverNewIntents(r, r.pendingIntents); r.pendingIntents = null; &#125; // 处理等待的 result if (r.pendingResults != null) &#123; deliverResults(r, r.pendingResults); r.pendingResults = null; &#125; // 执行 resume r.activity.performResume(); &#125; &#125;&#125; Instrumentation123public Activity newActivity()&#123; return (Activity)cl.loadClass(className).newInstance();&#125; 12345private void callActivityOnCreate()&#123; prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity);&#125; Activity1234567final void performCreate() &#123; restoreHasCurrentPermissionRequest(icicle); // 调用 onCreate onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon();&#125; 12345final void performStart() &#123; mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); mInstrumentation.callActivityOnStart(this); mActivityTransitionState.enterReady(this);&#125; 12345final void performResume() &#123; // 执行 restart performRestart(); mInstrumentation.callActivityOnResume(this);&#125; 12345678final void performRestart() &#123; if (mStopped) &#123; mStopped = false; mInstrumentation.callActivityOnRestart(this); // 执行 start performStart(); &#125;&#125; Instrumentation123public void callActivityOnStart() &#123; activity.onStart();&#125; 1234public void callActivityOnResume() &#123; activity.mResumed = true; activity.onResume();&#125; 123public void callActivityOnRestart() &#123; activity.onRestart();&#125; 总结简单总结下 Activity 的启动流程： 从用户应用进程开始启动，如果从桌面启动，则为 launcher 进程，用户进程通过 Binder 机制与 system_server 进程进行通信 ActivityManagerService 用于管理所有的 Activity 活动 当接受到启动 Activity 的调用时，使用 resolveActivity ，查询系统中符合要求的 Activity 创建使用合适的 ActivityStack 和 launch flags 来启动 Activity 如果存在可以直接恢复 Activity，则恢复，否则重新启动 Activity 如果不存在应用进程，先创建应用进程 最终启动流程又会通过 Binder 调用回应用进程，使用 ActivityThread 去执行 使用 Instrumentation 去通过反射构建 Activity 实例 使用 Handler 机制调用 Activity 的生命周期 下面的图例来自博客： 启动流程","tags":[]},{"title":"Android消息机制-Handler","date":"2018-03-23T12:29:21.000Z","path":"2018/03/23/Android消息机制-Handler/","text":"参考Android消息机制1-Handler(Java层) Android消息机制2-Handler(Native层) Android应用程序消息处理机制（Looper、Handler）分析 管道(Unix)) Epoll 文件描述符 Handler 机制主要由四个部分组成： Looper MessageQueue Message Handler 典型用法123456789101112131415class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; Looper不断循环执行 Looper.loop，按分发机制将消息分发给目标处理者 1234567private static void prepare(boolean quitAllowed) &#123; if(sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; // 构建 Looper 存储到 ThreadLocal sThreadLocal.set(new Looper(quitAllowed));&#125; sThreadLocal 是一个 ThreadLocal 类型的静态变量 ThreadLocal：线程本地存储区（Thread Local Storage），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域 12345private Looper(boolean quitAllowed) &#123; // Looper 中创建 MessageQueue mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // 获取下一条 Message，可能会阻塞 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; //省略 final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try &#123; // 分发 Message msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time = end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, \"Dispatch took \" + time + \"ms on \" + Thread.currentThread().getName() + \", h=\" + msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what); &#125; &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; // 释放 Message msg.recycleUnchecked(); &#125; &#125; 12345678// Looper.quit 最终调用的都是 MessageQueue.quitpublic void quit() &#123; mQueue.quit(false); // 移除消息&#125;public void quitSafely() &#123; mQueue.quit(true); // 安全移除消息&#125; MessageQueue 在构造方法中，会调用 native 方法 nativeInit 方法，在 NativeMessageQueue 的构造方法中，会构造一个 JNI 层的 Looper 1234567891011121314151617181920212223242526272829303132// frameworks/base/libsLooper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mResponseIndex(0) &#123; // 管道机制 int wakeFds[2]; int result = pipe(wakeFds); ...... mWakeReadPipeFd = wakeFds[0]; mWakeWritePipeFd = wakeFds[1]; ...... #ifdef LOOPER_USES_EPOLL // 分配新的 epoll 实例同时注册唤醒管道 mEpollFd = epoll_create(EPOLL_SIZE_HINT); ...... struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union // 观察 EPOLLIN 事件 eventItem.events = EPOLLIN; eventItem.data.fd = mWakeReadPipeFd; result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem); ...... #else ...... #endif ...... &#125; 管道：Linux 系统中的一种进程间通信机制。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件的文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。 epoll：Linux 系统中的 epoll 机制为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。 pipe 是 Linux 系统中的管道机制，用于 IPC，在管道机制的实现中，又使用 epoll 机制来监听读写事件。 以上在 Android 上的应用为，当 Java 层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当 Java 层的消息队列中来了新的消息后，就唤醒 Android 应用程序的主线程来处理这个消息。 Handler123456789101112131415161718192021public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; // 匿名类、内部类或本地类都必须申明为 static，否则会警告出现内存泄漏 Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; // 默认使用当前线程的 Looper mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; // 是否为异步处理 mAsynchronous = async; &#125; 在 Looper.loop 中，当存在 Message 需要处理时，会调用 dispatchMessage 来进行分发： 123456789101112131415public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; // 先调用 callback handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; // 接着检查通过构造方法传进来的 Callback if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; // 最后调用 handleMessage handleMessage(msg); &#125; &#125; 通过 Handler 发送消息： 发送消息调用链 最终所有的方法都会调用到 MessageQueue.enqueueMessage MessageQueue 消息机制中 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理 12345MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; // used by native code mPtr = nativeInit(); &#125; MessageQueue 的初始化工作主要由 native 方法来执行 123456789101112//frameworks/base/core/jni/android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) &#123; // 构建一个 NativeMessageQueue，在它的构造方法中，也会创建一个 Looper，不过这个 Looper 对象实现是在 JNI 层 NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (! nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return; &#125; // 在这里，会 NativeMessageQueue 保存到 Java 层 MessageQueue 的 mPtr 变量中，这里保存的是一个偏移量 android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue); &#125; nativeInit 中主要是在 JNI 层创建一个 NativeMessageQueue 并将偏移量保存在 MessageQueue 中的 mPtr，关联了 NativeMessageQueue 和 MessageQueue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104Message next() &#123; // messsage loop has already quit final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回 // ptr 是在 JNI 层创建的 NativeMessageQueue nativePollOnce(ptr, nextPollTimeoutMillis); // 当前 nativePollOnce 返回后，查看消息队列中是否存在消息 synchronized (this) &#123; // 尝试检索下一条消息，如果找到则返回 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // 找到下一条异步消息或者没有消息了，则退出循环 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 下一个消息还没准备好，重新设置唤醒超时时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 获取一条消息 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); // 标记当前消息已使用 msg.markInUse(); return msg; &#125; &#125; else &#123; // 当前还没有消息，设置为 -1，无限等待中 nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // queue is empty or if the first message // get pending idle handler count if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // 没有 idle handlers 需要运行，循环继续等待 mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; //不设置超时时间,因为可能在处理 IdleHandler 时可能有新的消息加入 nextPollTimeoutMillis = 0; &#125; &#125; 在 next 方法中，nativePollOnce 是阻塞操作，其中 nextPollTimeoutMillis 代表下一个消息到来之前，还需要等待的时长；nextPollTimeoutMillis == -1 表示当前没有更多消息。nativePollOnce 调用结束后，从 mMessages 中提取一个消息 当处于空闲时，执行 IdleHandler 中的回调方法。 12345678// frameworks/base/core/jni/android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jint ptr, jint timeoutMillis) &#123; // 通过前面设置的 mPrt 获取 NativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); // 调用 NativeMessageQueue.pollOnce 进行轮询 nativeMessageQueue-&gt;pollOnce(timeoutMillis); &#125; 1234void NativeMessageQueue::pollOnce(int timeoutMillis) &#123; // 将调用转发给了 JNI 层的 Looper mLooper-&gt;pollOnce(timeoutMillis); &#125; pollOnce 会调用 pollnner 来进一步操作，如果 pollnner 返回值不等于 0，则返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// frameworks/base/libs/utils/Looper.cppint Looper::pollInner(int timeoutMillis) &#123; ...... int result = ALOOPER_POLL_WAKE; ...... #ifdef LOOPER_USES_EPOLL struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // 调用 epoll_wait 检查 epoll 专用文件描述符 mEpollFd 所监控的文件描述符是否有 IO 事件,超时时间为 timeoutMillis // 在 JNI 层的 Looper 构造函数中，设置了要监控 mWakeReadPipeFd 文件描述符的 EPOLLIN 事件 // 如果检查成功或者超时，则结束等待 // 处于 Idle 状态 int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); bool acquiredLock = false; #else ...... #endif // eventCount &lt; 0 可能出错了 if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; LOGW(\"Poll failed with an unexpected error, errno=%d\", errno); result = ALOOPER_POLL_ERROR; goto Done; &#125; // eventCount == 0 超时 if (eventCount == 0) &#123; ...... result = ALOOPER_POLL_TIMEOUT; goto Done; &#125; ...... #ifdef LOOPER_USES_EPOLL // eventCount &gt; 0 存在事件 for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeReadPipeFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; // Looper 中使用 epoll 监听的 EPOLLIN 事件 awoken(); &#125; else &#123; LOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents); &#125; &#125; else &#123; ...... &#125; &#125; if (acquiredLock) &#123; mLock.unlock(); &#125; Done: ; #else ...... #endif ...... return result; &#125; 123456789void Looper::awoken() &#123; ...... char buffer[16]; ssize_t nRead; do &#123; nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer)); &#125; while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer)); &#125; 总结上面的代码，Looper 通过 loop 调用 MessageQueue 的 next，next 中又会调用到 native 方法 nativePollOnce，在这个方法中，会调用到 NativeMessageQueue 的 pollInner，这里会通过在 JNI 层 Looper 的构造方法中，使用 epoll 监听管道 EPOLLIN 事件，如果存在调用 awoken，清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 不存在头部消息或立即执行或执行时机快于头部消息 // 将处理的消息作为新的头部消息 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // 将处理的消息插入到队列的尾部 // 一般不需要唤醒事件队列，除非消息头存在 barrier，并且当前处理的消息是队列中最早的异步消息 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; MessageQueue 是按照消息触发时间的先后顺序排列的，队列头部的消息是最早触发的。当有消息加入，会从队列头部开始遍历，插入到合适的位置，以保证所有消息的时间顺序。 如果当前线程处于空闲等待状态，那么还需要调用 nativeWake 来唤醒： 123456// frameworks/base/core/jni/android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj, jint ptr) &#123; // ptr 获取 NativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); return nativeMessageQueue-&gt;wake(); &#125; 这里将唤醒请求转发到 Looper wake： 123456789101112// frameworks/base/libs/utils/Looper.cppvoid Looper::wake() &#123; ...... ssize_t nWrite; do &#123; // 先管道中写入 \"W nWrite = write(mWakeWritePipeFd, \"W\", 1); &#125; while (nWrite == -1 &amp;&amp; errno == EINTR); ....... &#125; 往管道写入内容，从而唤醒线程，因为当消息队列中没有消息处理时，线程会进入空闲等待状态，具体是通过 Looper 的 polllnner 中调用 epoll_wait 进入 12345678910111213141516171819202122232425262728293031323334void removeMessages(Handler h, int what, Object object) &#123; if (h == null) &#123; return; &#125; synchronized (this) &#123; Message p = mMessages; // 从队列头部开始，移除连续的所有符合条件的消息 while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what &amp;&amp; (object == null || p.obj == object)) &#123; Message n = p.next; mMessages = n; // 找到对应的消息，释放它 p.recycleUnchecked(); p = n; &#125; // 从新的队列头部开始，移除全部符合条件的消息 while (p != null) &#123; Message n = p.next; if (n != null) &#123; if (n.target == h &amp;&amp; n.what == what &amp;&amp; (object == null || n.obj == object)) &#123; Message nn = n.next; n.recycleUnchecked(); p.next = nn; continue; &#125; &#125; p = n; &#125; &#125; &#125; postSyncBarrier 提交一个同步屏障，这将会阻止队列中消息的执行，直到手动调用 removeSyncBarrier 当 MessageQueue 退出时，需要 dispose： 12345678910// Disposes of the underlying message queue. // Must only be called on the looper thread or the finalizer.private void dispose() &#123; if (mPtr != 0) &#123; // native 方法 nativeDestroy(mPtr); // mPtr 是记录 JNI 层的 NativeMessageQueue 的偏移量 mPtr = 0; &#125; &#125; nativeDestroy 最终会调用 RefBase 的 decStrong： 12345678910111213void RefBase::decStrong(const void* id) const&#123; weakref_impl* const refs = mRefs; refs-&gt;removeStrongRef(id); //移除强引用 const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong); if (c == 1) &#123; refs-&gt;mBase-&gt;onLastStrongRef(id); if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123; delete this; &#125; &#125; refs-&gt;decWeak(id); // 移除弱引用&#125; Message1234567891011121314151617181920212223void recycleUnchecked() &#123; // 标记为使用状态，清除其他状态 flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; // 消息缓存 if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; 1234567891011121314public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; // 从缓存中获取 Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; 总结 消息机制 Java 层： Handler 通过 sendMessage，将 Message 通过 MessageQueue.enqueueMessage 添加到队列中 Looper 通过 loop 提取需要执行的 Message，并交与 Message.target 的 Handler 进行 dispatchMessage 分发 将 Message 添加到 MessageQueue 时，会唤醒 Looper 线程；如果 MessageQueue 中没有 Message 时，并处于 Idle 状态，则会执行 IdelHandler JNI 层： 线程在进入循环之前，会在 JNI 创建管道(Pipe) ，当消息队列为空时，线程处于空闲等待状态 通过 epoll 机制监听 EPOLLIN 事件，当有新事件进入消息队列时，并且当前线程处于空闲状态，通过向管道写入数据，来唤醒线程 消息分发的优先级： Message.callback.run() Handler.mCallback.handleMessage() Handler.handleMessage() EPOLL：Linux 内核的可扩展 I/O 事件通知机制 PIPE：管道是一系列将标准输入输出链接起来的进程，其中每个进程的输出被直接作为下一个进程的输入 文件描述符(File descriptor)：用于表述指向文件的引用的抽象化概念","tags":[]},{"title":"Hello World","date":"2018-03-17T05:24:16.197Z","path":"2018/03/17/hello-world/","text":"面朝大海，春暖花开从明天起，做一个幸福的人 喂马、劈柴、周游世界 从明天起，关心粮食和蔬菜 我有一所房子，面朝大海，春暖花开 从明天起，和每一个亲人通信 告诉他们我的幸福 那幸福的闪电告诉我的 我将告诉每一个人 给每一条河每一座山取一个温暖的名字 陌生人，我也为你祝福 愿你有一个灿烂的前程 愿你有情人总成眷属 愿你在尘世获得幸福 我只愿面朝大海，春暖花开","tags":[]}]